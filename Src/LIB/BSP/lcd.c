/**
* @file        lcd.c
*
* @brief       API display LCD 2x20 / 4x 40 - Implementation -
*
* @author      Nick
*
* @riskClass   C
*
* @moduleID
*
* @vcsInfo
*     $Id: lcd.c 694 2025-02-18 14:06:30Z stefano $
*
*     $Revision: 694 $
*
*     $Author: stefano $
*
*     $Date: 2025-02-18 15:06:30 +0100 (mar, 18 feb 2025) $
*
*
* @copyright
*       Copyright (C) 2017 SCAME S.p.A. All rights reserved.
*       This file is copyrighted and the property of Aesys S.p.A.. It contains confidential and proprietary
*       information. Any copies of this file (in whole or in part) made by any method must also include a copy of this
*       legend.
*       Developed by:  SCAME S.p.A.
***********************************************************************************************************************/

/************************************************************
 * Include
 ************************************************************/
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include "cmsis_os.h"
#include "displayPin.h"
#include "wrapper.h"
#include "LcdMng.h"
#include "inputsMng.h"
#include "evsMng.h"
#include "EnergyMng.h"
#include "eeprom.h"
#include "lcd.h"

/*
*********************************** SCAME ************************************
**                                                                          **
**           LOCAL MACROS, TYPEDEF, STRUCTURE, ENUM                         **
**                                                                          **
******************************************************************************
*/

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Local Variables                               **
**                                                                          **
******************************************************************************
*/

static DAC_HandleTypeDef      DacHandle;
static DAC_ChannelConfTypeDef sConfig;

static char                 lcd_locline[2][LCD_CHAR_NUM];
static upgLcd_e             upgradeLcd;
static uint16_t             lcdHwMng;
static uint8_t              timeOnLcdFlag;
__no_init presenceLcd_e     lcdPresent;

lcdCntt_e                   cnttChange;
uint16_t                    minTimeEnVal;

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Global Variables                              **
**                                                                          **
******************************************************************************
*/
/*  Input manager queue  declaration */
xQueueHandle      lowLevelLcdMngQueue = NULL;

lowLevelLcd_st    lowLevelLcd;
uint32_t          lcdTimeTick;



/*
*********************************** SCAME ************************************
**                                                                          **
**                            External Variables                            **
**                                                                          **
******************************************************************************
*/


/*
*********************************** SCAME ************************************
**                                                                          **
**                            External Function                             **
**                                                                          **
******************************************************************************
*/
extern void setSysTickStatus(uint16_t status);

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Internal Function prototype                   **
**                                                                          **
******************************************************************************
*/
void    Write_LcdData   (uint8_t val);
uint8_t Read_LcdData    (void);
void    Lcd_Enable      (uint8_t stato);
void    Lcd_Rw          (uint8_t stato);
void    Lcd_Rs          (uint8_t stato);
void    gotoxy          (uint8_t x, uint8_t y);
void    set_cursor      (uint8_t x, uint8_t y, uint8_t cursore);
void    LcdCmd          (uint8_t Data);
void    LcdData         (uint8_t Data);
uint8_t LcdWaitBusy     (void);
void    LcdContrastInit (void);

static void     contrastConfigDAC   (void);
static uint8_t  LcdReadBusyFlag     (void);
static uint8_t  LcdRead             (void);
static uint32_t lowLevelLcdManager  (lowLevelLcdMsg_st *pMsg);

void   Lcd2x20FastInit     (void);

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Function Definition                           **
**                                                                          **
******************************************************************************
*/

/*
*********************************** SCAME ************************************
**                                                                          **
**           LOCAL MACROS, TYPEDEF, STRUCTURE, ENUM                         **
**                                                                          **
******************************************************************************
*/
#define   MIN_TIME_EN_VAL       ((uint16_t)30)   /* era 300 */
#define   MIN_HOLD_EN_VAL       ((uint16_t)10)

#define   MAX_COL           ((uint8_t)192)
#define   MAX_ROW           ((uint8_t)32)
#define   COUNTRY_COL       ((uint8_t)32)
/** data offset in the PORT DB0=GPIOE.3 ... DB3=GPIOE.6 --> 3 Only 4 bit are used    */
#define   DATA_OFFSET       ((uint8_t)3)
#define   DATA_IN_MASK      ((uint32_t)0x0000000F)
#define   DATA_OUT_MASK     ((uint32_t)0x00000078)
#define   MODE_MASK         ((uint32_t)0x00003FC0)
#define   MODE_OUT_MASK     ((uint32_t)0x00001540)
#define   OTYPE_OUT_MASK    ((uint32_t)0x00000078)

#define   WriteIns(a)       LcdCmd(a)

#define   LOCATION_LITTLEMAN  ((uint8_t)1)
#define   ADDR_CGRAM          ((uint8_t)0x40)
#define   ADDR_LITTLEMAN      (ADDR_CGRAM + LOCATION_LITTLEMAN * (uint8_t)8)
#define   MIDDLE_CHAR_POS     ((uint8_t)10)
#define   ADDR_CHECK_CHAR     (POS_RIGA_1)

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Local Variables                               **
**                                                                          **
******************************************************************************
*/

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Local Const                                  **
**                                                                          **
******************************************************************************
*/
static const uint8_t littleMan[] = {0x0E, 0x0E, 0x04, 0x1F, 0x04, 0x04,0x0A, 0x0A};
static const char    strDwnl[] = "  UPLOADING...      ";

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Global Variables                              **
**                                                                          **
******************************************************************************
*/
GPIO_TypeDef* LCD_PORT[LCDn] = {DB0_GPIO_PORT,
                                DB1_GPIO_PORT,
                                DB2_GPIO_PORT,
                                DB3_GPIO_PORT,
                                RW_GPIO_PORT,
                                RS_GPIO_PORT,
                                CS_GPIO_PORT
                               };

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Global Const                                  **
**                                                                          **
******************************************************************************
*/
const uint16_t LCD_PIN[LCDn] = {DB0_PIN,
                                DB1_PIN,
                                DB2_PIN,
                                DB3_PIN,
                                RW_PIN,
                                RS_PIN,
                                CS_PIN
                               };

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD */
unsigned const char italiaPic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x1F, 0x00, 0x00,
  0x00, 0x71, 0xC0, 0x00,
  0x03, 0xC0, 0x20, 0x00,
  0x1C, 0x00, 0x20, 0x00,
  0x10, 0x00, 0xE0, 0x00,
  0x10, 0x01, 0x07, 0x7C,
  0x10, 0x01, 0x02, 0x10,
  0x10, 0x01, 0x02, 0x10,
  0x19, 0xC1, 0x02, 0x10,
  0x0E, 0x60, 0x82, 0x10,
  0x00, 0x20, 0x42, 0x10,
  0x00, 0x20, 0x47, 0x10,
  0x00, 0x18, 0x20, 0x00,
  0x00, 0x08, 0x10, 0x00,
  0x00, 0x04, 0x08, 0x00,
  0x00, 0x02, 0x06, 0x00,
  0x00, 0x01, 0x01, 0x00,
  0x01, 0x80, 0xC0, 0x80,
  0x06, 0x40, 0x20, 0x70,
  0x06, 0x40, 0x18, 0x08,
  0x02, 0x40, 0x04, 0x04,
  0x02, 0x40, 0x02, 0x74,
  0x02, 0x40, 0x01, 0x4C,
  0x04, 0x40, 0x01, 0x20,
  0x07, 0x80, 0x00, 0xA0,
  0x00, 0x00, 0x00, 0xA0,
  0x00, 0x01, 0x81, 0x40,
  0x00, 0x02, 0x7E, 0x80,
  0x00, 0x02, 0x02, 0x00,
  0x00, 0x01, 0xC1, 0x00,
  0x00, 0x00, 0x71, 0x00,
  0x00, 0x00, 0x0E, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD */
unsigned const char franciaPic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0xC0, 0x00,
  0x00, 0x01, 0x60, 0x00, 
  0x00, 0x03, 0x38, 0x00, 
  0x00, 0x06, 0x0C, 0x00, 
  0x00, 0x0C, 0x03, 0x80,
  0x00, 0xF8, 0x00, 0xF0, 
  0x0E, 0x80, 0x00, 0x18, 
  0x11, 0x80, 0x00, 0x10, 
  0x10, 0x00, 0x00, 0x10,
  0x0C, 0x07, 0xBC, 0x30, 
  0x07, 0x04, 0x24, 0x60, 
  0x01, 0x04, 0x24, 0x40, 
  0x01, 0x87, 0x3C, 0xC0,
  0x00, 0x84, 0x30, 0x80, 
  0x00, 0x44, 0x28, 0xE0, 
  0x00, 0x44, 0x24, 0x20, 
  0x00, 0x20, 0x00, 0x20,
  0x00, 0x40, 0x00, 0x20, 
  0x00, 0x40, 0x00, 0x20, 
  0x00, 0x40, 0x00, 0x30, 
  0x00, 0x80, 0x00, 0x10,
  0x01, 0x00, 0x00, 0x30, 
  0x00, 0x80, 0x1F, 0x60, 
  0x00, 0xE0, 0x20, 0x88, 
  0x00, 0x3E, 0x40, 0x38,
  0x00, 0x01, 0x80, 0x68, 
  0x00, 0x00, 0x00, 0x28, 
  0x00, 0x00, 0x00, 0x18, 
  0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD */
unsigned const char ukPic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x00,
  0x00, 0x01, 0x88, 0xA2,
  0x00, 0x07, 0x08, 0xA4,
  0x00, 0x3B, 0x08, 0xA8,
  0x00, 0x22, 0x08, 0xB0,
  0x00, 0x33, 0xC8, 0xA8,
  0x00, 0x10, 0x48, 0xA4,
  0x00, 0x30, 0x8F, 0xA2,
  0x00, 0x11, 0x00, 0x00,
  0x00, 0x19, 0xC0, 0x00,
  0x00, 0x0C, 0x60, 0x00,
  0x00, 0x64, 0x20, 0x00,
  0x01, 0xA7, 0x30, 0x00,
  0x01, 0x11, 0x18, 0x00,
  0x00, 0xD1, 0x88, 0x00,
  0x00, 0x20, 0x8C, 0x00,
  0x00, 0x07, 0x85, 0x00,
  0x00, 0x06, 0x02, 0x80,
  0x00, 0x02, 0x00, 0xC0,
  0x00, 0x02, 0x00, 0x80,
  0x00, 0x0C, 0x01, 0x00,
  0x00, 0x0F, 0x81, 0x80,
  0x00, 0x01, 0x81, 0x80,
  0x00, 0x02, 0x1F, 0x00,
  0x00, 0x0C, 0xF0, 0x00,
  0x00, 0x1B, 0x00, 0x00,
  0x00, 0x0C, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD */
unsigned const char pulsante1Pic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x01, 0xFF, 0xFC, 0x00,
  0x02, 0x00, 0x0C, 0x00,
  0x04, 0x00, 0x14, 0x00,
  0x08, 0x00, 0x24, 0x00,
  0x10, 0x00, 0x44, 0x00,
  0x1F, 0xFF, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x11, 0x08, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x80,
  0x10, 0xE0, 0x91, 0x00,
  0x11, 0x10, 0xAB, 0xFE,
  0x11, 0x10, 0x91, 0x00,
  0x11, 0x10, 0x80, 0x80,
  0x10, 0xE0, 0xA0, 0x00,
  0x10, 0x00, 0xC0, 0x00,
  0x1F, 0xFF, 0x80, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD */
unsigned const char pulsante2Pic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x01, 0xFF, 0xFC, 0x00,
  0x02, 0x00, 0x0C, 0x00,
  0x04, 0x00, 0x14, 0x00,
  0x08, 0x00, 0x24, 0x00,
  0x10, 0x00, 0x44, 0x00,
  0x1F, 0xFF, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x11, 0x08, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x10,
  0x10, 0xE0, 0x90, 0x20,
  0x11, 0x10, 0xA8, 0x7E,
  0x11, 0x10, 0x90, 0x20,
  0x11, 0x10, 0x80, 0x10,
  0x10, 0xE0, 0xA0, 0x00,
  0x10, 0x00, 0xC0, 0x00,
  0x1F, 0xFF, 0x80, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD Arabia Saudita */
unsigned const char asPic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x03, 0xE0, 0x00, 0x00,
  0x02, 0x38, 0x00, 0x00,
  0x02, 0x0C, 0x00, 0x00,
  0x02, 0x06, 0x00, 0x00,
  0x0C, 0x03, 0xE0, 0x00,
  0x18, 0x00, 0x38, 0x00,
  0x10, 0x00, 0x0C, 0x00,
  0x08, 0x00, 0x04, 0x00,
  0x08, 0x00, 0x06, 0x00,
  0x0C, 0x00, 0x02, 0x00,
  0x06, 0x00, 0x03, 0x00,
  0x02, 0x00, 0x01, 0x00,
  0x01, 0x00, 0x00, 0x80,
  0x01, 0x80, 0x00, 0x40,
  0x00, 0x80, 0x00, 0x38,
  0x00, 0x80, 0x00, 0x08,
  0x00, 0x80, 0x00, 0x08,
  0x00, 0x40, 0x00, 0x18,
  0x00, 0x20, 0x00, 0xF0,
  0x00, 0x10, 0x0F, 0x80,
  0x00, 0x10, 0x18, 0x00,
  0x00, 0x17, 0xF0, 0x00,
  0x00, 0x1C, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di dito 1 */
unsigned const char dito1[MAX_ROW][COUNTRY_COL / 8] = {
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x01, 0xFF, 0xFC, 0x00,
    0x02, 0x00, 0x0C, 0x00,
    0x04, 0x00, 0x14, 0x00,
    0x08, 0x00, 0x24, 0x00,
    0x10, 0x00, 0x44, 0x00,
    0x1F, 0xFF, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x11, 0xF8, 0x84, 0x00,
    0x11, 0x08, 0x84, 0x00,
    0x11, 0xF8, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0xE0, 0x90, 0x00,
    0x11, 0x10, 0xAB, 0xFE,
    0x11, 0x10, 0x93, 0xFE,
    0x11, 0x10, 0x80, 0xFE,
    0x10, 0xE0, 0xA0, 0x00,
    0x10, 0x00, 0xC0, 0x00,
    0x1F, 0xFF, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00 
};

unsigned const char dito2[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x01, 0xFF, 0xFC, 0x00,
  0x02, 0x00, 0x0C, 0x00,
  0x04, 0x00, 0x14, 0x00,
  0x08, 0x00, 0x24, 0x00,
  0x10, 0x00, 0x44, 0x00,
  0x1F, 0xFF, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x11, 0x08, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0xE0, 0x90, 0x00,
  0x11, 0x10, 0xA8, 0xFE,
  0x11, 0x10, 0x90, 0xFE,
  0x11, 0x10, 0x80, 0x3E,
  0x10, 0xE0, 0xA0, 0x00,
  0x10, 0x00, 0xC0, 0x00,
  0x1F, 0xFF, 0x80, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00 
};


//winstar logo
const uint8_t  pic[MAX_ROW][MAX_COL / 8] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0F, 0xF8, 0x01, 0xFF, 0x80, 0x3F,
  0xF0, 0x00, 0x1C, 0x71, 0xDD, 0xC7, 0x3F, 0xFF,
  0xC1, 0x81, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1F, 0xFC, 0x03, 0xFF, 0xC0, 0x7F,
  0xF8, 0x00, 0x1C, 0x71, 0xDD, 0xC7, 0x7F, 0xFF,
  0xC3, 0xC1, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1F, 0xFE, 0x03, 0xFF, 0xC0, 0x7F,
  0xFC, 0x00, 0x1C, 0x71, 0xDD, 0xE7, 0x70, 0x0E,
  0x07, 0xE1, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1F, 0xFE, 0x01, 0xFF, 0xE0, 0x3F,
  0xFC, 0x00, 0x0E, 0xFB, 0x9D, 0xE7, 0x70, 0x0E,
  0x06, 0x61, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0F, 0xFF, 0x01, 0xFF, 0xE0, 0x3F,
  0xFE, 0x00, 0x0E, 0xFB, 0x9D, 0xF7, 0x7F, 0x8E,
  0x0E, 0x71, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0F, 0xFF, 0x01, 0xFF, 0xF0, 0x1F,
  0xFE, 0x00, 0x0E, 0xFF, 0x1D, 0xFF, 0x3F, 0xCE,
  0x0C, 0x31, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x07, 0xFF, 0x80, 0xFF, 0xF0, 0x1F,
  0xFF, 0x00, 0x07, 0xDF, 0x1D, 0xDF, 0x00, 0xCE,
  0x0F, 0xF1, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x07, 0xFF, 0x80, 0xFF, 0xF8, 0x0F,
  0xFF, 0x00, 0x07, 0xDF, 0x1D, 0xCF, 0x61, 0xCE,
  0x1F, 0xF9, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0xFF, 0xC0, 0x7F, 0xF8, 0x07,
  0xFF, 0x00, 0x03, 0x8E, 0x1D, 0xC7, 0x7F, 0xCE,
  0x1C, 0x39, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0xFF, 0xC0, 0xFF, 0xF0, 0x0F,
  0xFE, 0x00, 0x03, 0x8E, 0x1D, 0xC7, 0x7F, 0x8E,
  0x38, 0x1D, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0x80, 0xE0, 0x00, 0x1C,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x30,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x7F, 0xE0, 0x0F, 0xFC, 0x00,
  0x00, 0x00, 0x1C, 0x63, 0x87, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0xF0, 0x1F, 0xFE, 0x00,
  0x00, 0x00, 0x1C, 0x63, 0x9F, 0xE0, 0x63, 0xE0,
  0xE1, 0xF0, 0x70, 0x3E, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0xF0, 0x1F, 0xFE, 0x00,
  0x00, 0x00, 0x0C, 0xF3, 0x18, 0x60, 0xE7, 0xF1,
  0xF3, 0xF8, 0xF8, 0x7F, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0xF8, 0x0F, 0xFF, 0x00,
  0x00, 0x00, 0x0C, 0xF3, 0x30, 0x71, 0xE6, 0x33,
  0x1B, 0x19, 0x8C, 0xE3, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x7F, 0xF8, 0x0F, 0xFF, 0x00,
  0x00, 0x00, 0x0E, 0xF3, 0x30, 0x00, 0x66, 0x33,
  0x1B, 0x19, 0x8C, 0xC1, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x7F, 0xFC, 0x07, 0xFF, 0x80,
  0x00, 0x00, 0x06, 0xF6, 0x31, 0xF0, 0x67, 0xF0,
  0x38, 0x70, 0x1C, 0xC0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x3F, 0xFC, 0x07, 0xFF, 0x80,
  0x00, 0x00, 0x06, 0x96, 0x31, 0xF0, 0x63, 0xF0,
  0x70, 0x78, 0x38, 0xC0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x3F, 0xFE, 0x03, 0xFF, 0xC0,
  0x00, 0x00, 0x07, 0x9E, 0x30, 0x30, 0x60, 0x30,
  0xE0, 0x18, 0x70, 0xC1, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1F, 0xFE, 0x03, 0xFF, 0xC0,
  0x00, 0x00, 0x03, 0x9E, 0x18, 0x70, 0x66, 0x71,
  0x83, 0x18, 0xC0, 0xE3, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x0F, 0xFC, 0x00, 0xFF, 0x80,
  0x00, 0x00, 0x03, 0x9C, 0x1F, 0xF0, 0x67, 0xE3,
  0xFB, 0xF9, 0xFC, 0x7F, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x0C, 0x0F, 0xD0, 0x63, 0xC3,
  0xF9, 0xF1, 0xFC, 0x3E, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//winstar logo
const uint8_t  araboWelcome[MAX_ROW][MAX_COL / 8] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xE0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFE, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0xFF, 0x00,
  0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0xFC, 0x00,
  0x02, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0C, 0x00, 0x00, 0x3E, 0x00, 0x70, 0x18, 0x60, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x80,
  0x02, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0C, 0x00, 0x00, 0x38, 0x01, 0xF0, 0x38, 0x70, 0x00, 0x00, 0x00, 0x1F, 0xFE, 0x00,
  0x02, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1C, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x18, 0x70, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0x80,
  0x0C, 0x03, 0xE0, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x07, 0x0C, 0x00, 0x00, 0x06, 0x00, 0x00, 0x18, 0x70, 0x00, 0x00, 0x00, 0x3F, 0xFE, 0x80,
  0x18, 0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x03, 0x0C, 0x00, 0x00, 0x06, 0x00, 0xF0, 0x18, 0x30, 0x00, 0x00, 0x00, 0x15, 0xFA, 0x00,
  0x10, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0C, 0x00, 0x00, 0x0E, 0x00, 0xF0, 0x1C, 0x30, 0x00, 0x00, 0x00, 0x15, 0xDA, 0x00,
  0x08, 0x00, 0x04, 0x00, 0x00, 0xC0, 0x01, 0xC7, 0xC0, 0x03, 0x0C, 0x00, 0x00, 0x3E, 0x01, 0xF8, 0x1C, 0x30, 0x00, 0x18, 0x00, 0x10, 0xC0, 0x00,
  0x08, 0x00, 0x06, 0x00, 0x00, 0xDE, 0x00, 0xCF, 0xE0, 0x03, 0x0E, 0x00, 0x00, 0x77, 0x00, 0xF8, 0x1C, 0x37, 0xC0, 0x1C, 0x00, 0x00, 0xC0, 0x00,
  0x0C, 0x00, 0x02, 0x00, 0x18, 0xFF, 0x00, 0xE3, 0xC0, 0x03, 0x8E, 0x00, 0x00, 0x7F, 0x00, 0x18, 0x1C, 0x3F, 0xE0, 0x1C, 0x00, 0x00, 0xC0, 0x00,
  0x06, 0x00, 0x03, 0x00, 0x18, 0xF7, 0x00, 0x63, 0x80, 0x01, 0x8E, 0x00, 0x00, 0x03, 0x00, 0x18, 0x1C, 0x38, 0xE0, 0x0C, 0x00, 0x00, 0x40, 0x00,
  0x02, 0x00, 0x01, 0x00, 0x18, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x03, 0xFF, 0xF8, 0x0F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x40, 0x00,
  0x01, 0x00, 0x00, 0x80, 0x18, 0xFF, 0x00, 0xFE, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x03, 0xFF, 0xF8, 0x0F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x60, 0x00,
  0x01, 0x80, 0x00, 0x40, 0x38, 0xC0, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
  0x00, 0x80, 0x00, 0x38, 0x39, 0xC0, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x40, 0x00,
  0x00, 0x80, 0x00, 0x08, 0x1F, 0xC0, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0xC0, 0x40, 0x60,
  0x00, 0x80, 0x00, 0x08, 0x1F, 0x80, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFA, 0xDB, 0xFC,
  0x00, 0x40, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1F, 0xFF, 0x03,
  0x00, 0x20, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0C, 0x00,
  0x00, 0x10, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xB8, 0x00,
  0x00, 0x10, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF0, 0x00,
  0x00, 0x17, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00,
  0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xF4, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xB8, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1C, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xAE, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x07, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00 
};

const uint8_t  showCardUK[MAX_ROW][MAX_COL / 8] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x88, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x08, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3B, 0x08, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x22, 0x08, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x33, 0xC8, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x48, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x8F, 0xA2, 0x00, 0x00, 0x00, 0x0F, 0x98, 0xCF, 0x98, 0xC0, 0x3E, 0x1C, 0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x58, 0xD8, 0xD8, 0xC0, 0x61, 0x36, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x19, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0xD8, 0xD8, 0xC0, 0x60, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x60, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0xD8, 0xD8, 0xC0, 0x60, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x64, 0x20, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x9F, 0xD8, 0xD8, 0xC0, 0x60, 0x63, 0x7E, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0xA7, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0xD8, 0xD8, 0xC0, 0x60, 0x7F, 0x78, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x11, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0xD8, 0xDA, 0xC0, 0x60, 0x63, 0x6C, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xD1, 0x88, 0x00, 0x00, 0x00, 0x00, 0x10, 0xD8, 0xD8, 0xDA, 0xC0, 0x61, 0x63, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x98, 0xCF, 0x8D, 0x80, 0x3E, 0x63, 0x63, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x06, 0x02, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0F, 0x81, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x81, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

const uint8_t  showCardIT[MAX_ROW][MAX_COL / 8] =
{
    0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x71, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0xC0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1C, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x01, 0x07, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x19, 0xC1, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x60, 0x82, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x42, 0x10, 0x01, 0xF9, 0xF9, 0xFC, 0xF9, 0xFD, 0x8C, 0xFC, 0x71, 0xF9, 0xFC, 0x03, 0xE1, 0xC7, 0xE3, 0xF1, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x47, 0x10, 0x01, 0x8D, 0x8D, 0x81, 0x85, 0x81, 0xCC, 0x30, 0xD9, 0x8D, 0x80, 0x06, 0x13, 0x66, 0x30, 0xC3, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x20, 0x00, 0x01, 0x8D, 0x8D, 0x81, 0x81, 0x81, 0xEC, 0x31, 0x8D, 0x8D, 0x80, 0x06, 0x06, 0x36, 0x30, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x08, 0x10, 0x00, 0x01, 0x8D, 0x8D, 0x81, 0x81, 0x81, 0xBC, 0x31, 0x8D, 0x8D, 0x80, 0x06, 0x06, 0x36, 0x30, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x04, 0x08, 0x00, 0x01, 0xF9, 0xF9, 0xE0, 0xF9, 0xE1, 0x9C, 0x31, 0x8D, 0xF9, 0xE0, 0x06, 0x06, 0x37, 0xE0, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x06, 0x00, 0x01, 0x81, 0xE1, 0x80, 0x0D, 0x81, 0x8C, 0x31, 0xFD, 0xE1, 0x80, 0x06, 0x07, 0xF7, 0x80, 0xC7, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x01, 0x00, 0x01, 0x81, 0xB1, 0x80, 0x0D, 0x81, 0x8C, 0x31, 0x8D, 0xB1, 0x80, 0x06, 0x06, 0x36, 0xC0, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x01, 0x80, 0xC0, 0x80, 0x01, 0x81, 0x99, 0x81, 0x0D, 0x81, 0x8C, 0x31, 0x8D, 0x99, 0x80, 0x06, 0x16, 0x36, 0x60, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x06, 0x40, 0x20, 0x70, 0x01, 0x81, 0x8D, 0xFC, 0xF9, 0xFD, 0x8C, 0x31, 0x8D, 0x8D, 0xFC, 0x03, 0xE6, 0x36, 0x30, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x06, 0x40, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x40, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x40, 0x02, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x40, 0x01, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x40, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x80, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x81, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x7E, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

/**   Francese: PRESENTER CARTE  */
const uint8_t  showCardFR[MAX_ROW][MAX_COL / 8] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x03, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xF8, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x80, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x10, 0x03, 0xF3, 0xF3, 0xF9, 0xF3, 0xFB, 0x19, 0xFB, 0xFB, 0xF0, 0x0F, 0x87, 0x1F, 0x8F, 0xDF, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0x07, 0xBC, 0x30, 0x03, 0x1B, 0x1B, 0x03, 0x0B, 0x03, 0x98, 0x63, 0x03, 0x18, 0x18, 0x4D, 0x98, 0xC3, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x04, 0x24, 0x60, 0x03, 0x1B, 0x1B, 0x03, 0x03, 0x03, 0xD8, 0x63, 0x03, 0x18, 0x18, 0x18, 0xD8, 0xC3, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x04, 0x24, 0x40, 0x03, 0x1B, 0x1B, 0x03, 0x03, 0x03, 0x78, 0x63, 0x03, 0x18, 0x18, 0x18, 0xD8, 0xC3, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x87, 0x3C, 0xC0, 0x03, 0xF3, 0xF3, 0xC1, 0xF3, 0xC3, 0x38, 0x63, 0xC3, 0xF0, 0x18, 0x18, 0xDF, 0x83, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x84, 0x30, 0x80, 0x03, 0x03, 0xC3, 0x00, 0x1B, 0x03, 0x18, 0x63, 0x03, 0xC0, 0x18, 0x1F, 0xDE, 0x03, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x44, 0x28, 0xE0, 0x03, 0x03, 0x63, 0x00, 0x1B, 0x03, 0x18, 0x63, 0x03, 0x60, 0x18, 0x18, 0xDB, 0x03, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x44, 0x24, 0x20, 0x03, 0x03, 0x33, 0x02, 0x1B, 0x03, 0x18, 0x63, 0x03, 0x30, 0x18, 0x58, 0xD9, 0x83, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x00, 0x20, 0x03, 0x03, 0x1B, 0xF9, 0xF3, 0xFB, 0x18, 0x63, 0xFB, 0x18, 0x0F, 0x98, 0xD8, 0xC3, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0x1F, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xE0, 0x20, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x40, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x80, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

#ifdef CZ_NO_TIME
/**   Ceko: PREDLOŽTE KARTU  */
const uint8_t  showCardCZ[MAX_ROW][MAX_COL / 8] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0xC1, 0xC0, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x30, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1C, 0x00, 0x16, 0x00, 0x07, 0xE3, 0xE7, 0xF7, 0xE6, 0x03, 0xE7, 0xF3, 0xF7, 0xF0, 0x31, 0x8E, 0x3F, 0x1F, 0xB1, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x00, 0x15, 0x00, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x30, 0xC6, 0x00, 0x33, 0x1B, 0x31, 0x86, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x08, 0x80, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x30, 0xC6, 0x00, 0x36, 0x31, 0xB1, 0x86, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x10, 0xF3, 0xE0, 0x70, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x60, 0xC6, 0x00, 0x3C, 0x31, 0xB1, 0x86, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x98, 0x60, 0x08, 0x07, 0xE7, 0xE7, 0x86, 0x36, 0x06, 0x30, 0xC0, 0xC7, 0x80, 0x38, 0x31, 0xBF, 0x06, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x81, 0xC0, 0x04, 0x06, 0x07, 0x86, 0x06, 0x36, 0x06, 0x31, 0x80, 0xC6, 0x00, 0x3C, 0x3F, 0xBC, 0x06, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x9B, 0x00, 0x0C, 0x06, 0x06, 0xC6, 0x06, 0x36, 0x06, 0x33, 0x00, 0xC6, 0x00, 0x36, 0x31, 0xB6, 0x06, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0xF3, 0xE0, 0x10, 0x06, 0x06, 0x66, 0x06, 0x36, 0x06, 0x36, 0x00, 0xC6, 0x00, 0x33, 0x31, 0xB3, 0x06, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x20, 0x06, 0x06, 0x37, 0xF7, 0xE7, 0xF3, 0xE7, 0xF0, 0xC7, 0xF0, 0x31, 0xB1, 0xB1, 0x86, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x07, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x84, 0xDB, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x58, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};
#else
/**   Ceko: PREDLOŽTE KARTU  */
const uint8_t  showCardCZ[MAX_ROW][MAX_COL / 8] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x01, 0xC1, 0xC0, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x03, 0x00, 0x30, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3C, 0x1F, 0x83, 0xF3,
    0x1C, 0x00, 0x16, 0x00, 0x07, 0xE3, 0xE7, 0xF7, 0xE6, 0x03, 0xE7, 0xF3, 0xF7, 0xF0, 0x31, 0x8E, 0x3F, 0x1F, 0xB1, 0x82, 0x3B, 0xC9, 0x79, 0xE3,
    0x60, 0xF7, 0xD5, 0x00, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x30, 0xC6, 0x00, 0x33, 0x1B, 0x31, 0x86, 0x31, 0x83, 0x3F, 0xC9, 0xF9, 0xC3,
    0x21, 0x00, 0x48, 0x80, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x30, 0xC6, 0x00, 0x36, 0x31, 0xB1, 0x86, 0x31, 0x83, 0x3F, 0x9F, 0xF9, 0x93,
    0x11, 0x00, 0x80, 0x70, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x60, 0xC6, 0x00, 0x3C, 0x31, 0xB1, 0x86, 0x31, 0x83, 0x3F, 0x3F, 0xE3, 0x33,
    0x11, 0x01, 0x00, 0x08, 0x07, 0xE7, 0xE7, 0x86, 0x36, 0x06, 0x30, 0xC0, 0xC7, 0x80, 0x38, 0x31, 0xBF, 0x06, 0x31, 0x83, 0x3E, 0x7F, 0xF9, 0x73,
    0x11, 0x02, 0x00, 0x04, 0x06, 0x07, 0x86, 0x06, 0x36, 0x06, 0x31, 0x80, 0xC6, 0x00, 0x3C, 0x3F, 0xBC, 0x06, 0x31, 0x83, 0x3C, 0xF9, 0xF9, 0x01,
    0x11, 0x04, 0x00, 0x0C, 0x06, 0x06, 0xC6, 0x06, 0x36, 0x06, 0x33, 0x00, 0xC6, 0x00, 0x36, 0x31, 0xB6, 0x06, 0x31, 0x83, 0x39, 0xF9, 0x79, 0xF3,
    0x0C, 0xF7, 0xC0, 0x10, 0x06, 0x06, 0x66, 0x06, 0x36, 0x06, 0x36, 0x00, 0xC6, 0x00, 0x33, 0x31, 0xB3, 0x06, 0x31, 0x83, 0x38, 0x0F, 0x83, 0xF3,
    0x06, 0x00, 0x00, 0x20, 0x06, 0x06, 0x37, 0xF7, 0xE7, 0xF3, 0xE7, 0xF0, 0xC7, 0xF0, 0x31, 0xB1, 0xB1, 0x86, 0x1F, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x01, 0x07, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x84, 0xDB, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x58, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF 
};
#endif

#ifdef NO_RCBO_TEXT
/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di RCBO1 */
unsigned const char rcbo1Pic[MAX_ROW][COUNTRY_COL / 8] = {
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x03, 0xFF, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x10, 0x80, 0x00,
    0x02, 0x28, 0x80, 0x00,
    0x02, 0x10, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x03, 0xFF, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00 
};
#else
/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di RCBO1 */
unsigned const char rcbo1Pic[MAX_ROW][MAX_COL / 8] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x3F, 0x07, 0xC3, 0xF0, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x31, 0x8C, 0x23, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x31, 0x8C, 0x03, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x31, 0x8C, 0x03, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x3F, 0x0C, 0x03, 0xF0, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x3C, 0x0C, 0x03, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x36, 0x0C, 0x03, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x33, 0x0C, 0x23, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x31, 0x87, 0xC3, 0xF0, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x28, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};
#endif

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di RCBO2 */
unsigned const char rcbo2Pic[MAX_ROW][COUNTRY_COL / 8] = {
    0x00, 0x00, 0x00, 0x00,
    0x07, 0xFE, 0x00, 0x00,
    0x04, 0x03, 0xFE, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x42, 0x00,
    0x04, 0x02, 0xA2, 0x00,
    0x04, 0x02, 0x42, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x03, 0xFE, 0x00,
    0x07, 0xFE, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di RCBO3 */
unsigned const char rcbo3Pic[MAX_ROW][COUNTRY_COL / 8] = {
    0x00, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0xFF, 0xE0,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x7F, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x88, 0x20,
    0x04, 0x40, 0x9C, 0x20,
    0x04, 0x40, 0xBE, 0x20,
    0x04, 0x5E, 0x88, 0x20,
    0x04, 0x5E, 0x88, 0x20,
    0x04, 0x40, 0x88, 0x20,
    0x04, 0x40, 0x88, 0x20,
    0x04, 0x40, 0x88, 0x20,
    0x04, 0x7F, 0x80, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x07, 0xFF, 0xFF, 0xE0,
    0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di RCBO4 */
unsigned const char rcbo4Pic[MAX_ROW][COUNTRY_COL / 8] = {
   0x00, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0xFF, 0xE0,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x7F, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x5E, 0x80, 0x20,
    0x04, 0x5E, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x7F, 0x80, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x07, 0xFF, 0xFF, 0xE0,
    0x00, 0x00, 0x00, 0x00 
};

/****************** LOCAL VARIABLES ***********************************************************************************/
/* TIM handler declaration */
static TIM_HandleTypeDef  htim;



/*
*********************************** SE ***************************************
**                                                                          **
**                            Internal Function prototype                   **
**                                                                          **
******************************************************************************
*/
static void lcd4X20_Handler     (void);
static void show_pic            (uint8_t arr[][MAX_COL / 8]);
static void show_picCountry     (uint8_t arr[][COUNTRY_COL / 8]);
static void createCustomChar    (uint8_t* pattern, uint8_t location);

/**
  * @brief  Configures LCD  GPIO.
  * @retval None
  */
void LCD_IO_Init(LcdInitState State)
{
  uint8_t i;
  GPIO_InitTypeDef  GPIO_InitStruct;

  if (lcdHwMng == LCD_MODE_OPEN_DRAIN)
  {
    for (i = 0; i < LCDn; i++)
    {
      /* Enable the GPIO_LED clock */
      LCDx_GPIO_CLK_ENABLE(i);

      HAL_GPIO_WritePin(LCD_PORT[i], LCD_PIN[i], GPIO_PIN_RESET);

      /* Configure the GPIO_LED pin in open drain mode (pull-up to 5V is external)*/
      GPIO_InitStruct.Pin = LCD_PIN[i];
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;

      HAL_GPIO_Init(LCD_PORT[i], &GPIO_InitStruct);

    }
  }
  else
  {
    for (i = 0; i < LCDn; i++)
    {
      /* Enable the GPIO_LED clock */
      LCDx_GPIO_CLK_ENABLE(i);

      HAL_GPIO_WritePin(LCD_PORT[i], LCD_PIN[i], GPIO_PIN_RESET);

      /* Configure the GPIO_LED pin in open drain mode (pull-up to 5V is external)*/
      GPIO_InitStruct.Pin = LCD_PIN[i];
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;

      HAL_GPIO_Init(LCD_PORT[i], &GPIO_InitStruct);
    }
  }

  /* Check in which state the init is called  */
  if (State == AS_STANDARD_MODE)
  {
    /* in this hardware a power switch on LCD supply is present */
    lcdPwrOnSequence();
  
    /* Configure the PWM GPIO_LED pin for brightness level Default = 100%  */
    PWM_LCD_GPIO_CLK_ENABLE();
    GPIO_InitStruct.Pin = PWM_LCD_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
  
    HAL_GPIO_Init(PWM_LCD_GPIO_PORT, &GPIO_InitStruct);
  
    HAL_GPIO_WritePin(PWM_LCD_GPIO_PORT, PWM_LCD_PIN, GPIO_PIN_SET);
  
    contrastConfigDAC();
  }
  
  upgradeLcd = UPG_LCD_ENABLED;

}

/**
  * @brief  Configures LCD  DB0...3 in input mode
  * @retval None
  */
void LCD_DB_Input(void)
{
  if (lcdHwMng == LCD_MODE_OPEN_DRAIN)
  {
#ifndef LCD_FAST_PROTECT
    GPIOE->MODER &= (~MODE_MASK);   // fast execution 18/07/2021 Nick (1)
#else
    GPIO_InitTypeDef  GPIO_InitStruct;

    /* we use open drain output with external pull-up at 5V, so internal pull-up isn't necessary */
    /* Configure the data bus in input mode   */
    GPIO_InitStruct.Pin = LCD_PIN[LCD_DB0] | LCD_PIN[LCD_DB1] | LCD_PIN[LCD_DB2] | LCD_PIN[LCD_DB3];
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_PORT[LCD_DB0], &GPIO_InitStruct);
#endif
  }
  else
  {
    GPIOE->MODER &= (~MODE_MASK);   // fast execution 18/07/2021 Nick (1)
  }
}

/**
  * @brief  Configures LCD  DB0...3 in output  mode
  * @retval None
  */
void LCD_DB_Output(void)
{
  if (lcdHwMng == LCD_MODE_OPEN_DRAIN)
  {
#ifndef LCD_FAST_PROTECT
    GPIOE->MODER |= MODE_OUT_MASK;     // fast execution 18/07/2021 Nick (2)
    GPIOE->OTYPER |= OTYPE_OUT_MASK;
    GPIOE->ODR &= (~DATA_OUT_MASK);
#else
    GPIO_InitTypeDef  GPIO_InitStruct;

    /* Configure the GPIO_LCD pin in open drain mode (pull-up to 5V is external)*/
    GPIO_InitStruct.Pin = LCD_PIN[LCD_DB0] | LCD_PIN[LCD_DB1] | LCD_PIN[LCD_DB2] | LCD_PIN[LCD_DB3];
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_PORT[LCD_DB0], &GPIO_InitStruct);
#endif
  }
  else
  {
    uint32_t  tmpGpio;

    tmpGpio = GPIOE->MODER; 
    GPIOE->MODER = ((tmpGpio & (~MODE_MASK)) | MODE_OUT_MASK);  // output mode for LCD0..4 
    GPIOE->OTYPER &= (~OTYPE_OUT_MASK);                         // push pull
  }
}

/**
  * @brief  set/reset  LCD  RS PIN .
  * @retval None
  */
void Lcd_Rs(uint8_t stato)
{
#ifndef LCD_FAST_PROTECT
  if (stato == OFF)                 // fast execution 18/07/2021 Nick (3)
  {
    GPIOE->ODR &= (~RS_PIN);
  }
  else
  {
    GPIOE->ODR |= (RS_PIN);
  }
#else
  if (stato == OFF)
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_RS], LCD_PIN[LCD_RS], GPIO_PIN_RESET);
  }
  else
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_RS], LCD_PIN[LCD_RS], GPIO_PIN_SET);
  }
#endif
}

/**
  * @brief  set/reset  LCD  RW PIN .
  * @retval None
  */
void Lcd_Rw(uint8_t stato)
{
#ifndef LCD_FAST_PROTECT
  if (stato == OFF)             // fast execution 18/07/2021 Nick (3)
  {
    GPIOE->ODR &= (~RW_PIN);
  }
  else
  {
    GPIOE->ODR |= (RW_PIN);
  }
#else
  if (stato == OFF)
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_RW], LCD_PIN[LCD_RW], GPIO_PIN_RESET);
  }
  else
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_RW], LCD_PIN[LCD_RW], GPIO_PIN_SET);
  }
#endif
}

/**
  * @brief  set/reset  LCD  ENABLE  PIN .
  * @retval None
  */
void Lcd_Enable(uint8_t stato)
{
#ifndef LCD_FAST_PROTECT
  if (stato == OFF)             // fast execution 18/07/2021 Nick (4)
  {
    GPIOE->ODR &= (~CS_PIN);
  }
  else
  {
    GPIOE->ODR |= (CS_PIN);
  }
#else
  if (stato == OFF)
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_CS], LCD_PIN[LCD_CS], GPIO_PIN_RESET);
  }
  else
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_CS], LCD_PIN[LCD_CS], GPIO_PIN_SET);
  }
#endif
}

/**
  * @brief  Read 4 bit data bus in low nibble .
  * @retval nibble read
  */
uint8_t Read_LcdData (void)
{
#ifndef LCD_FAST_PROTECT
  uint8_t val;

  val = (uint8_t)((GPIOE->IDR >> DATA_OFFSET) & DATA_IN_MASK); // fast execution 18/07/2021 Nick (5)
#else
  uint8_t i, mask, val;

  for (i = 0, mask = 0x01, val = 0; i <= LCD_DB3; i++, mask = mask << 1)
    //for (i = 0, mask = 0x08, val = 0; i <= LCD_DB3; i++, mask = mask >> 1)
  {
    if (GPIO_PIN_SET == HAL_GPIO_ReadPin(LCD_PORT[i], LCD_PIN[i]))
    {
      val |= mask;
    }
  }
#endif
  return (val);
}

/**
  * @brief  write 4 bit data bus taken it from low nibble .
  * @retval nibble read
  */
void Write_LcdData (uint8_t val)
{
#ifdef GRAPHICS_LCD_FAST
  uint32_t outVal;

  outVal = ((uint32_t)GPIOE->ODR && DATA_OUT_MASK);
  outVal |= (((uint32_t)val << DATA_OFFSET) & DATA_OUT_MASK);
  GPIOE->ODR = outVal;
#else
#ifndef LCD_FAST_PROTECT
  uint32_t outVal;

  outVal = (uint32_t)GPIOE->ODR;
  outVal &= (~DATA_OUT_MASK);
  outVal |= ((uint32_t)val << DATA_OFFSET);  // fast execution 18/07/2021 Nick (6)
  GPIOE->ODR = outVal;
#else
  uint8_t i, mask;

  for (i = 0, mask = 0x01; i <= LCD_DB3; i++, mask = mask << 1)
    //for (i = 0, mask = 0x08; i <= LCD_DB3; i++, mask = mask >> 1)
  {
    if ((val & mask) == mask)
    {
      HAL_GPIO_WritePin(LCD_PORT[i], LCD_PIN[i], GPIO_PIN_SET);
    }
    else
    {
      HAL_GPIO_WritePin(LCD_PORT[i], LCD_PIN[i], GPIO_PIN_RESET);
    }
  }
#endif
#endif
}

/**          code for graphic display 192x32 pixel WG19232C5-TMI-V#T  *****/

/**
*
* @brief        Init the pointer in display area
*
* @param [in]   int8_t: row index (0..31)
* @param [in]   int8_t: coloum  index (0..191)
*
* @retval       none
*
***********************************************************************************************************************/
static void graphic_address(char x, char y)
{
  WriteIns(0x80 | x);
  WriteIns(0x80 | y);
}


/**
*
* @brief        show a stored picture
*
* @param [in]   uint8_t*: pointer to the picture array
*
* @retval       none
*
***********************************************************************************************************************/
static void show_pic(uint8_t arr[][MAX_COL / 8])
{
  uint8_t   i, j;

  WriteIns(0x2e);       // extended instruction ON

  for(j = 0; j < MAX_ROW; j++)
  {
    graphic_address(j, 0x00);

    for(i = 0; i < MAX_COL / 8; i++)
    {
      LcdData(arr[j][i]);   // WriteData(arr[j][i]);
    }
  }
}

/**
*
* @brief        show a stored picture
*
* @param [in]   uint8_t*: pointer to the picture array
*
* @retval       none
*
***********************************************************************************************************************/
static void show_picCountry(uint8_t arr[][COUNTRY_COL / 8])
{
  uint8_t   i, j;

  WriteIns(0x2e);       // extended instruction ON

  for(j = 0; j < MAX_ROW; j++)
  {
    graphic_address(j, 0x00);

    for(i = 0; i < COUNTRY_COL / 8; i++)
    {
      LcdData(arr[j][i]);   // WriteData(arr[j][i]);
    }
  }
}

/**
*
* @brief        Try to show a picture for test
*
* @param [in]   none
*
* @retval       none
*
***********************************************************************************************************************/
void test_pic(uint8_t picIx)
{
  taskENTER_CRITICAL();
  if (picIx < (uint8_t)NUM_COUNTRY)
  {
    switch (picIx)
    {
      case IT:
        show_pic((uint8_t (*)[MAX_COL / 8])showCardIT);
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])italiaPic);
        break;

      case FR:
        show_pic((uint8_t (*)[MAX_COL / 8])showCardFR);
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])franciaPic);
        break;

      case UK:
        show_pic((uint8_t (*)[MAX_COL / 8])showCardUK);
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])ukPic);
        break;

      case AS:
        show_pic((uint8_t (*)[MAX_COL / 8])araboWelcome);
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])asPic);
        break;

      case CZ:
        show_pic((uint8_t (*)[MAX_COL / 8])showCardCZ);
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])asPic);
        break;

      case PULS1:
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])pulsante1Pic);
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])dito1);
        break;

      case PULS2:
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])pulsante2Pic);
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])dito2);
        break;

      case RCBO1:
#ifdef NO_RCBO_TEXT
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])rcbo1Pic);
#else
        show_pic((uint8_t (*)[MAX_COL / 8])rcbo1Pic);
#endif
        break;

      case RCBO2:
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])rcbo2Pic);
        break;

      case RCBO3:
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])rcbo3Pic);
        break;

      case RCBO4:
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])rcbo4Pic);
        break;

      default:
        break;
    }
  }
  else
  {
    if (picIx == (uint8_t)10)
    {
      show_pic((uint8_t (*)[MAX_COL / 8])pic);
    }
  }
  taskEXIT_CRITICAL();
}


// Ex lcddrv.c
/*************************************************************************************************

  Funzione:     clear

  Descrizione:     Cancellazione display

*************************************************************************************************/
void clear(void)
{
  LcdCmd(CLEAR_DISPLAY);
}

/*************************************************************************************************

  Funzione:
    gotoxy

  Descrizione:
    Posizionamento cursore

  Parametri in ingresso:
    x = coordinata x (1..20)
    y = coordinata y (1..4)

*************************************************************************************************/
void gotoxy(uint8_t x, uint8_t y)
{
  uint8_t cmd;

  switch (y)
  {
    default:
    case 1: cmd = POS_RIGA_1;   break;

    case 2: cmd = POS_RIGA_2; break;

    case 3: cmd = POS_RIGA_3; break;

    case 4: cmd = POS_RIGA_4; break;
  }

  LcdCmd(cmd + x - 1);
}

/*************************************************************************************************

  Funzione:
    set_cursor

  Descrizione:
    Programmazione cursore

  Parametri in ingresso:
    x    = coordinata x (1..20)
    y    = coordinata y (1..4)
    tipo = tipo cursore

*************************************************************************************************/
void set_cursor(uint8_t x, uint8_t y, uint8_t cursore)
{
  uint8_t cmd;

  gotoxy(x, y);

  switch (cursore)
  {
    default:
    case NO_CURSOR:
      cmd = CURSOR_OFF;
      break;

    case CURSOR_UNDERSCORE:
      cmd = CURSOR_ON_NO_BLINK;
      break;

    case CURSOR_BLINK:
      cmd = CURSOR_ON_BLINK;
      break;
  }

  LcdCmd(cmd);
}

/*************************************************************************************************

  Funzione:
    putcxy

  Descrizione:
    Visualizzazione di un carattere (DATA)

  Parametri in ingresso:
    x = coordinata x (1..20)
    y = coordinata y (1..4)
    c = carattere da visualizzare

*************************************************************************************************/
void putcxy(uint8_t x, uint8_t y, char c)
{
  gotoxy(x, y);
  LcdData(c);
}

/*************************************************************************************************

  Funzione:
    putsxy_c

  Descrizione:
    Visualizzazione di una stringa (CODE)

  Parametri in ingresso:
    x  = coordinata x (1..20)
    y  = coordinata y (1..4)
    *s = puntatore alla stringa

*************************************************************************************************/
void putsxy_c(uint8_t x, uint8_t y, char const *s)
{
  char    *pLcdStr;
  uint8_t  RetVal, RetVal2;
  uint8_t  numChar, checkPos;

  pLcdStr = (char*)s;
  if ((lcdPresent == LCD_PRESENT) && ((lowLevelLcd.state == LCD_STATE_OPERATIVE) || lowLevelLcd.state == LCD_STATE_HOLD_ON_FAIL))
  {
    if (y == 1)
    {
      if (evs_state_get() == EVSTATE_SOCKET_AVAILABLE) 
      {
        if (timeOnLcdFlag != (uint8_t)0)
        {
          /*      destination      source       length */
          memcpy((void*)&pLcdStr[15], (void*)getTimePtr(), (size_t)5);
        }
      }
    }
    
    /* Check if a LCD init procedure is required */
    switch (cnttChange)
    {
      case CNNT_CHANGE_ONGOING:                        /* LCD init procedure will be started */
        cnttChange = CNNT_CHANGE_LCD_INIT_START;            
      break;
      
      case CNNT_CHANGE_LCD_INIT_FINISHED:              /* LCD init procedure is finished */
        lcd_locline[0][0] = lcd_locline[1][0] = '\0';  /* Force the refresh of the two rows */        
        cnttChange = CNNT_CHANGE_OFF;                  /* Block the procedure  */
      break;
      
      default:
      break;
    }

    if (((upgradeLcd == UPG_LCD_ENABLED) && (memcmp((const void*)pLcdStr, (void*)lcd_locline[y-1], (size_t)LCD_CHAR_NUM) != 0)))
    //if (upgradeLcd == UPG_LCD_ENABLED)
    {      
      
      /*           destination          source                size */
      memcpy((void*)&lcd_locline[y-1][0], (void*)pLcdStr, (size_t)LCD_CHAR_NUM);

  #ifdef LCD_PROTECT
      taskENTER_CRITICAL();
  #endif

      /* disable sysTick so FreeRTOS cannot switch task  */
      setSysTickStatus(TRUE);

      gotoxy(x, y);

      for (numChar = 0, checkPos = x - 1; *pLcdStr != TERMINATORE && x < NUM_CAR_DISP + 1; pLcdStr++, x++, numChar++)
      {
        if(*pLcdStr == 'Õ')
          LcdData(0x7F);    // Modifica x visualizzare car. Greco Delta (caratteri Ascii minimi)
        else
          LcdData(*pLcdStr);
      }

      if (lcdHwMng == LCD_MODE_FULL_BIDIR)
      {
        LcdCmd(ADDR_CHECK_CHAR + (y - 1) * 0x40 + checkPos);   // set address in DDRAM to check first char 
        RetVal = LcdRead();
        LcdCmd(ADDR_CHECK_CHAR + (y - 1) * 0x40 + checkPos + numChar/2);   // set address in DDRAM to check middlechar 
        RetVal2 = LcdRead();
        if ((RetVal != s[0]) || (RetVal2 != s[numChar/2]))
        {
          upgradeLcd = UPG_LCD_DISABLED;
          tPrintf("DisplayError!\n\r");
          lcd_locline[0][0] = lcd_locline[1][0] = '\0';
          sendMessageToLcd(LCD_FAIL_CHECK);
        }
      }
      /* enable sysTick */
      setSysTickStatus(FALSE);

  #ifdef LCD_FAST_PROTECT
      taskEXIT_CRITICAL();
  #endif
    }
  }
}

/**
*
* @brief       LCD reprogramming on contactor change status 
*              flag
*
* @param [in]  none
*
* @retval      none
*
****************************************************************/
void cnttStatusChange (void)
{
  cnttChange = CNNT_CHANGE_ONGOING;
}

// Fine lcddrv.c
#if 0
// =============================================
void WaitLcdBus (uint32_t Time)
{
  uint32_t Idx;

  for (Idx = 0; Idx < Time; Idx++);
}
#endif

// =============================================
void ResetLcdBus ()
{
  LcdRw(OFF);
  LcdSetWriteDir();
  LcdRs(OFF);
  LcdEnable(OFF);
}


// =============================================
void LcdWrite (uint8_t Data, uint8_t Reg, uint8_t Nibble)
{
  if (!Nibble)
  {
    if (LcdWaitBusy() == FALSE)        // Wait abilitazione LCD
    {
      if (lcdPresent != LCD_NOT_PRESENT)
        sendMessageToLcd(LCD_FAIL_CHECK);
      lcdPresent = LCD_NOT_PRESENT;
      return;
    }
  }


  if (Reg == REGDR)
  {
    LcdRs(ON);
  }
  LcdRw(OFF);  /* RW = 0 for Write */

  LcdEnable(ON);
  //uSecWwaitTime(MIN_TIME_EN_VAL);
  WriteLcdData((Data >> 4) & 0x0F); // Output Data
  uSecWwaitTime(minTimeEnVal);
  LcdEnable(OFF);

  if (!Nibble)
  {
    uSecWwaitTime(MIN_HOLD_EN_VAL);
    LcdEnable(ON);
    //uSecWwaitTime(MIN_TIME_EN_VAL);
    WriteLcdData(Data & 0x0F);
    uSecWwaitTime(minTimeEnVal);
    LcdEnable(OFF);
  }

  uSecWwaitTime(MIN_HOLD_EN_VAL);

  if (Reg == REGDR)
    LcdRs(OFF);

  GPIOE->ODR &= (uint32_t)(0x0000FB74);

}

// =============================================
static uint8_t LcdReadBusyFlag ()
{
  uint8_t TmpVal;
  uint8_t ReadVal;

  LcdSetReadDir();

  LcdRw(ON);
  LcdRs(OFF);
  uSecWwaitTime(minTimeEnVal);
  LcdEnable(ON);      // Set CS
  uSecWwaitTime(minTimeEnVal);
  ReadLcdData(TmpVal);  // Read Data  Read_LcdData
  //uSecWwaitTime(MIN_TIME_EN_VAL);
  LcdEnable(OFF);     // Reset CS
  uSecWwaitTime(MIN_HOLD_EN_VAL);
  if (lcdHwMng == LCD_MODE_OPEN_DRAIN)
  {
    TmpVal = 0;
  }
  ReadVal = ((TmpVal << 4) & 0xF0);

  // Lettura 4LSbit
  LcdEnable(ON);      // Set CS
  uSecWwaitTime(minTimeEnVal);
  ReadLcdData(TmpVal);  // Read Data
  //uSecWwaitTime(MIN_TIME_EN_VAL);
  LcdEnable(OFF);     // Reset CS
  ReadVal |= (TmpVal & 0x0F);

  ResetLcdBus();

  return ReadVal;
}

// =============================================
static uint8_t LcdRead ()
{
  uint8_t TmpVal;
  uint8_t ReadVal;                                      
                                                        
  LcdSetReadDir();                                      
                                                        
  LcdRw(ON);                                            
  LcdRs(ON);                                          
  uSecWwaitTime(minTimeEnVal);                        
  LcdEnable(ON);      // Set CS                         
  uSecWwaitTime(minTimeEnVal);                          
  ReadLcdData(TmpVal);  // Read Data                    
  //uSecWwaitTime(MIN_TIME_EN_VAL);                     
  LcdEnable(OFF);     // Reset CS                       
  uSecWwaitTime(MIN_HOLD_EN_VAL);                       
  ReadVal = ((TmpVal << 4) & 0xF0);                     
                                                        
  // Lettura 4LSbit                                     
  LcdEnable(ON);      // Set CS                         
  uSecWwaitTime(minTimeEnVal);                          
  ReadLcdData(TmpVal);  // Read Data                    
  //uSecWwaitTime(MIN_TIME_EN_VAL);                     
  LcdEnable(OFF);     // Reset CS                       
  ReadVal |= (TmpVal & 0x0F);                           
                                                        
  ResetLcdBus();                                        
                                                        
  return ReadVal;                                       
}                                                       

/**
*
* @brief       Check the busy flag status
*
* @param [in]  none
*
* @retval      uint8_t: TRUE if the LCD is free within timeout
*
****************************************************************/
uint8_t LcdWaitBusy ()
{
  uint8_t RetVal;
  uint16_t  Cnt;

  if (lcdPresent == LCD_PRESENT)
  {
    for (Cnt = 0; Cnt < MAX_BUSYFLAG_WAIT; Cnt++)
    {
      RetVal = LcdReadBusyFlag();

      if ((RetVal & 0x80) == 0)
        return TRUE;
    }
  }
  
  if (lcdPresent != LCD_NOT_PRESENT) 
    sendMessageToLcd(LCD_FAIL_CHECK);
  
  lcdPresent = LCD_NOT_PRESENT;
  
  return FALSE;
}

// =============================================
void Lcd2x20Init(uint8_t fullInit, LcdInitState State)
{
  lcdType_e lcdType;

  /* Wait while the eeprom data are ready to use */ 
  while (osSemaphoreAcquire (EEprom_semaphore, osWaitForever) != osOK);
  
  osSemaphoreRelease (EEprom_semaphore);

  minTimeEnVal = MIN_TIME_EN_INI_VAL;
  /* get lcd type  from LCD_TYPE_EADD   */
  // xx eeprom_param_get(LCD_TYPE_EADD, (uint8_t *)&lcdType, 1);
  lcdType = infoStation.LcdType;
  lcdType &= (LCD_TYPE_MASK);

  lcdPresent = LCD_NOT_PRESENT;

  lcdHwMng = getLcdHwMng();
  /* init hw pins and ADC */
  LCD_IO_Init(State);

  if (lcdType != LCD_TYPE_NULL)
  {
    lcdPresent = LCD_PRESENT;

    ResetLcdBus();

    // Total wait = 45ms
    HAL_Delay(45);
    //WaitLcdBus(0x1D00);   // Wait 15ms

    LcdCmdNibbleNW(0x30);
    HAL_Delay(5);
    //WaitLcdBus(0x800);    // Wait 4.1ms

    LcdCmdNibbleNW(0x30);
    HAL_Delay(2);
    //WaitLcdBus(0x30);   // Wait 100uS

    LcdCmdNibbleNW(0x30);
    LcdWaitBusy();


    LcdCmdNibbleNW(0x20);
    LcdWaitBusy();

#ifdef REDUCE_CLOCK
    HAL_Delay(10);
    LcdCmd(0x28);   // Set 4bit bus, 2 linee, 5x7 dots
    HAL_Delay(10);
    LcdCmd(0x08);   // Display, cursor, blink all off
    HAL_Delay(10);
    LcdCmd(0x01);   // Clear Display
    HAL_Delay(10);
    LcdCmd(0x06);   // Cursor move to right, no shift
    HAL_Delay(10);
    LcdCmd(0x0C);   // Display On, cursor and blink off
    HAL_Delay(10);

    createCustomChar((uint8_t*)littleMan, 1);  // create a char in second position inside CGRAM 

    minTimeEnVal = MIN_TIME_EN_VAL;

    LcdContrastInit();
#else
    LcdCmd(0x28);   // Set 4bit bus, 2 linee, 5x7 dots
    if (lcdPresent == LCD_PRESENT) LcdCmd(0x08);   // Display, cursor, blink all off
    if (lcdPresent == LCD_PRESENT) LcdCmd(0x01);   // Clear Display
    //HAL_Delay(10);
    if (lcdPresent == LCD_PRESENT) LcdCmd(0x06);   // Cursor move to right, no shift
    if (lcdPresent == LCD_PRESENT) LcdCmd(0x0C);   // Display On, cursor and blink off

    if (lcdPresent == LCD_PRESENT)
    {
      createCustomChar((uint8_t*)littleMan, 1);  // create a char in second position inside CGRAM 

      minTimeEnVal = MIN_TIME_EN_VAL;

      LcdContrastInit();
    }
#endif
  }


#ifdef PWM_ACTIVE    // check the status in IAR preprocessor option     
  /* start task del PWM */
  setPWMlcd2x20();
  
#endif

  timeOnLcd(DISABLED);  
  
}

// =============================================
void LcdData(uint8_t Data)
{
  LcdWrite(Data, REGDR, FALSE);
}

// =============================================
void LcdCmd(uint8_t Data)
{
  LcdWrite(Data, REGIR, FALSE);
}

// =============================================
void LcdContrastInit (void)
{
#ifdef RESTORE_FROM_EEPROM
  uint16_t  percent;
  uint8_t ContrastLevel = 1;

  ContrastLevel = leggi_eeprom(ADDR_EEP(contrasto));

  percent = (uint16_t) ((uint16_t) ContrastLevel * 100) / MAX_CONTRAST_LEV;
  setContrastPWMlcd4x20((uint8_t)percent); // new function
#else
  LcdUpDownContrast((uint32_t)300);
#endif
}

// =============================================
// In setting.c viene passato il nuovo valore di
// contrasto
// =============================================
void LcdUpDownContrast (uint32_t ContrastLevel)
{

  if ((ContrastLevel > MAX_CONTRAST_LEV) || (ContrastLevel < MIN_CONTRAST_LEV))
    return;

  /*  Set DAC channel1 DHR12RD register ################################################*/
  if (HAL_DAC_SetValue(&DacHandle, DACx_CHANNEL, DAC_ALIGN_12B_R, ContrastLevel) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

}

/**
*
* @brief        programmazione PWM hardware
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void setPWMlcd2x20 (void)
{
  GPIO_InitTypeDef    GPIO_InitStruct;
  uint32_t            uwPrescalerValue = 0;
  /* Timer Output Compare Configuration Structure declaration */
  TIM_OC_InitTypeDef  sConfig;

  /* TIM1 clock enable */
  TIMLCD4X20_CLK_ENABLE();

  /* Enable the GPIO used for LCD4X20 PWM clock */
  PWMLCD4X20_GPIO_CLK_ENABLE();

  /* GPIOx Configuration: TIM5 CH2 (PH11)  */
  GPIO_InitStruct.Pin       = PWMLCD4X20_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = PWMLCD4X20_AF;

  HAL_GPIO_Init(PWMLCD4X20_GPIO_PORT, &GPIO_InitStruct);

  /*##-1- Configure the TIM peripheral #######################################*/
  /* -----------------------------------------------------------------------
    In this example TIM5 input clock (TIM5CLK) is set to 2 * APB1 clock (PCLK1),
    since APB1 prescaler is different from 1.
      TIM5CLK = 2 * PCLK1
      PCLK1 = HCLK / 4
      => TIM5CLK = HCLK / 2 = SystemCoreClock / 2
    To get TIM5 counter clock at 1KHz, the Prescaler is computed as following:
    Prescaler = (TIM5CLK / TIM5 counter clock) - 1
    Prescaler = ((SystemCoreClock / 2 ) /1 KHz) - 1



    Note:
     SystemCoreClock variable holds HCLK frequency and is defined in system_stm32f4xx.c file.
     Each time the core clock (HCLK) changes, user had to update SystemCoreClock
     variable value. Otherwise, any configuration based on this variable will be incorrect.
     This variable is updated in three ways:
      1) by calling CMSIS function SystemCoreClockUpdate()
      2) by calling HAL API function HAL_RCC_GetSysClockFreq()
      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency
  ----------------------------------------------------------------------- */

  /* Compute the prescaler value to have TIM5 counter clock equal to 10MHz */
  uwPrescalerValue = ((SystemCoreClock) / 10000000) - 1;

  /* Set TIMPWMLCD4X20 instance */
  htim.Instance = TIMLCD4X20;

  /* Initialize TIM5 peripheral as follows:
       + Period = 100000 - 1
       + Prescaler = ((SystemCoreClock/2)/100000) - 1
       + ClockDivision = 0
       + Counter direction = Up
  */
  htim.Init.Prescaler     = uwPrescalerValue;
  htim.Init.Period        = PWMLCD4X20_PERIOD_VALUE;  // now 100/10000 KHz = 0,01msec (100KHz)
  htim.Init.ClockDivision = 0;                        // quindi prendiamo un campione ogni 10msec
  htim.Init.CounterMode = TIM_COUNTERMODE_UP;

  if(HAL_TIM_PWM_Init(&htim) != HAL_OK)
  {
    /* Initialization Error */
    lcd4X20_Handler();
  }

  /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_PWM1;
  sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCNPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCFastMode = TIM_OCFAST_DISABLE;

  /* Set the pulse value for channel 4 */
  sConfig.Pulse = PWMLCD4X20_MIN_DC;

  if(HAL_TIM_PWM_ConfigChannel(&htim, &sConfig, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  if(HAL_TIM_OC_Stop_IT(&htim, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* Interrupt not necessaryr */
    lcd4X20_Handler();
  }

  /* TIM1  enable for PWM on PE14 on channel 4 */
  /* on channel 4 */
  if(HAL_TIM_PWM_Start(&htim, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }

}


/**
*
* @brief        Stop PWM
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void stopPWMlcd2x20 (void)
{
  GPIO_InitTypeDef  GPIO_InitStruct;

  /* TIM1  enable for PWM on PE14 on channel 4 */
  /* on channel 4 */
  if(HAL_TIM_PWM_Stop(&htim, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }

  /* Configure the GPIO_LED pin in push-pull output mode */
  GPIO_InitStruct.Pin = PWMLCD4X20_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;

  HAL_GPIO_Init(PWMLCD4X20_GPIO_PORT, &GPIO_InitStruct);

  HAL_GPIO_WritePin(PWMLCD4X20_GPIO_PORT, PWMLCD4X20_PIN, GPIO_PIN_RESET);

}

/**
*
* @brief        Stop PWM
*
* @param [in ]  ledIdx_e: led id to stop
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
static void stopPWM_LEDx (ledIdx_e led)
{
  GPIO_InitTypeDef    GPIO_InitStruct;
  uint32_t            GPIO_PinId;

  if ((led != LED_A_BLU) && (led != LED_B_GREEN) && (led != LED_C_RED))
  {
    return;
  }

  /* GPIOx Configuration: TIM1 CHx (PEx)  */
  switch (led)
  {
    case LED_A_BLU:
      GPIO_PinId       = PWMLED_A_PIN;
      break;

    case LED_B_GREEN:
      GPIO_PinId       = PWMLED_B_PIN;
      break;

    case LED_C_RED:
      GPIO_PinId       = PWMLED_C_PIN;
      break;

    default:
      break;
  }

  /* PWM LED use all the same port */
  HAL_GPIO_DeInit(PWMLED_A_GPIO_PORT, GPIO_PinId);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(PWMLED_A_GPIO_PORT, GPIO_PinId, GPIO_PIN_RESET);
  /* GPIOx Configuration: Output to 0   */
  GPIO_InitStruct.Pin       = GPIO_PinId;
  GPIO_InitStruct.Mode      = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = (uint32_t)0;

  HAL_GPIO_Init(PWMLED_A_GPIO_PORT, &GPIO_InitStruct);
}


/**
*
* @brief        Restart PWM
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void restartPWMlcd2x20 (void)
{
  /* TIM1  enable for PWM on PE14 on channel 4 */
  /* on channel 4 */
  if(HAL_TIM_PWM_Start(&htim, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }
}


/**
*
* @brief        backlight level setting
*
* @param [in ]  uint8_t - new value for contrast level
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void setBacklightPWMlcd4x20 (uint8_t percentValue)
{
  TIM_OC_InitTypeDef  sConfig;

  if (percentValue > (uint8_t)100)
  {
    return;
  }

  if (percentValue == (uint8_t)0)
  {
    stopPWMlcd2x20();
    return;
  }


  /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_PWM1;;
  sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCFastMode = TIM_OCFAST_DISABLE;

  /* Set the pulse value for channel 2 */
  sConfig.Pulse = (uint32_t)percentValue;

  if(HAL_TIM_PWM_ChangeDutyChannel(&htim, &sConfig, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }
}

/**
*
* @brief        backlight level setting
*
* @param [in ]  uint8_t - new value for contrast level
* @param [in ]  ledIdx_e: led id to restart
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void setPWM_Ledx (ledIdx_e led, uint8_t percentValue)
{
#ifndef COLLAUDO_PEN
  TIM_OC_InitTypeDef  sConfig;
  GPIO_InitTypeDef    GPIO_InitStruct;
  uint32_t            GPIO_PinId, TimCh;
#else
  uint32_t            GPIO_PinId;
  uint8_t             relayIdx;
#endif
  uint32_t            uwPrescalerValue;

  
  if ((led != LED_A_BLU) && (led != LED_B_GREEN) && (led != LED_C_RED))
  {
    return;
  }

  if (percentValue > (uint8_t)100)
  {
    return;
  }

  if (htim.Instance == NULL)
  {
    /* Compute the prescaler value to have TIM5 counter clock equal to 10MHz */
    uwPrescalerValue = ((SystemCoreClock) / 10000000) - 1;

      /* Set TIMPWMLCD4X20 instance */
    htim.Instance = TIMLCD4X20;

    /* Initialize TIM5 peripheral as follows:
         + Period = 100000 - 1
         + Prescaler = ((SystemCoreClock/2)/100000) - 1
         + ClockDivision = 0
         + Counter direction = Up
    */
    htim.Init.Prescaler     = uwPrescalerValue;
    htim.Init.Period        = PWMLCD4X20_PERIOD_VALUE;  // now 100/10000 KHz = 0,01msec (100KHz)
    htim.Init.ClockDivision = 0;                        // quindi prendiamo un campione ogni 10msec
    htim.Init.CounterMode = TIM_COUNTERMODE_UP;

    if(HAL_TIM_PWM_Init(&htim) != HAL_OK)
    {
      /* Initialization Error */
      lcd4X20_Handler();
    }
  }

#ifdef COLLAUDO_PEN
  /* nel colllaudo PEN li tratto come I/O e non come PWM   */
  switch (led)
  {
    case LED_A_BLU:
      GPIO_PinId       = PWMLED_A_PIN;
      relayIdx = 3;
      break;

    case LED_B_GREEN:
      GPIO_PinId       = PWMLED_B_PIN;
      relayIdx = 4;
      break;

    case LED_C_RED:
      GPIO_PinId       = PWMLED_C_PIN;
      relayIdx = 5;
      break;

    default:
      break;
  }
  if (percentValue <= (uint8_t)10)
  {
    /* stato off --> metto il pin a 0 */
    HAL_GPIO_WritePin(GPIOE, GPIO_PinId, GPIO_PIN_RESET);
    tPrintf("Disattivazione relè R%d\n\r", relayIdx);
  }
  else
  {
    /* stato off --> metto il pin a 1 */
    HAL_GPIO_WritePin(GPIOE, GPIO_PinId, GPIO_PIN_SET);
    tPrintf("Attivazione relè R%d\n\r", relayIdx);
  }
  return;
#else

  if (percentValue == (uint8_t)0)
  {
    stopPWM_LEDx(led);
    return;
  }

  /* GPIOx Configuration: TIM1 CHx (PEx)  */
  switch (led)
  {
    case LED_A_BLU:
      GPIO_PinId       = PWMLED_A_PIN;
      TimCh            = PWMLED_A_TIM_CHx;
      break;

    case LED_B_GREEN:
      GPIO_PinId       = PWMLED_B_PIN;
      TimCh            = PWMLED_B_TIM_CHx;
      break;

    case LED_C_RED:
      GPIO_PinId       = PWMLED_C_PIN;
      TimCh            = PWMLED_C_TIM_CHx;
      break;

    default:
      break;
  }

  /* GPIOx Configuration: TIM1 CHx (PEx)  */
  GPIO_InitStruct.Pin       = GPIO_PinId;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = PWMLED_A_AF;

  HAL_GPIO_Init(PWMLED_A_GPIO_PORT, &GPIO_InitStruct);

  /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_PWM1;;
  sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCFastMode = TIM_OCFAST_DISABLE;
  /* Set the pulse value for channel x */
  sConfig.Pulse = (uint32_t)percentValue;

  if(HAL_TIM_PWM_ChangeDutyChannel(&htim, &sConfig, TimCh) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  if(HAL_TIM_OC_Stop_IT(&htim, TimCh) != HAL_OK)
  {
    /* Interrupt not necessary */
    lcd4X20_Handler();
  }

  /* TIM1  enable for PWM on PEx on channel x */
  if(HAL_TIM_PWM_Start(&htim, TimCh) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }
#endif
}


/*
  * @brief  Generate msec delay .
  * @retval uint16_t: msec to delay
  */
void waitTime(uint16_t msDelay)
{
  HAL_Delay((uint32_t)msDelay);
}

/*
  * @brief  Generate usec  delay Based on SysTick->VAL (decrement in the time).
  * @retval uint16_t: usec to delay
  */
void uSecWwaitTime (uint16_t usDelay)
{
  uint32_t  toSysTick;
  
  /* if in Backup condition, skip delays in us */
  if (SystemCoreClock == BACKUP_SYSCLOCK_VALUE) return;
  
  uint8_t SysCoreClockRef = SystemCoreClock / 1000000;
    
  /* here we suppose up at maximum speed: 216MHz */
  if (SysTick->VAL > (SysCoreClockRef * usDelay))
  {
    /* remember: sysTick is a timer with decrement */
    toSysTick = SysTick->VAL - (SysCoreClockRef * usDelay);
  }
  else
  {
    toSysTick = (SysCoreClockRef * 1000) - ((SysCoreClockRef * usDelay) - SysTick->VAL);

    while (((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != SysTick_CTRL_COUNTFLAG_Msk))
    {
      ;
    }
  }

  while (SysTick->VAL > toSysTick  )
  {
    ;
  }
}

/**
  * @brief  Change the TIM PWM  channels duty Cycle according to the specified
  *         parameters in the TIM_OC_InitTypeDef.
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @param  sConfig: TIM PWM configuration structure
  * @param  Channel: TIM Channels to be enabled.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ChangeDutyChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
{

  __HAL_LOCK(htim);

  /* Check the parameters */
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
  assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
  assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  htim->State = HAL_TIM_STATE_BUSY;

  switch (Channel)
  {
    case TIM_CHANNEL_1:
      {
        assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
        /* Set the Capture Compare Register value */
        htim->Instance->CCR1 = sConfig->Pulse;
      }
      break;

    case TIM_CHANNEL_2:
      {
        assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
        /* Set the Capture Compare Register value */
        htim->Instance->CCR2 = sConfig->Pulse;
      }
      break;

    case TIM_CHANNEL_3:
      {
        assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
        /* Set the Capture Compare Register value */
        htim->Instance->CCR3 = sConfig->Pulse;
      }
      break;

    case TIM_CHANNEL_4:
      {
        assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
        /* Set the Capture Compare Register value */
        htim->Instance->CCR4 = sConfig->Pulse;
      }
      break;

    default:
      break;
  }

  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);

  return HAL_OK;
}

static void contrastConfigDAC(void)
{
  /*##-1- Configure the DAC peripheral #######################################*/
  DacHandle.Instance = DACx;

  /*##-2- Initialize the DAC peripheral ######################################*/
  if (HAL_DAC_Init(&DacHandle) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  /*##-3- DAC channel1 Configuration #########################################*/
  sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
  sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;

  if (HAL_DAC_ConfigChannel(&DacHandle, &sConfig, DACx_CHANNEL) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  /*##-4- Enable DAC Channel2 ################################################*/
  if (HAL_DAC_Start(&DacHandle, DACx_CHANNEL) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  /*##-5- Set DAC channel1 DHR12RD register ################################################*/
  if (HAL_DAC_SetValue(&DacHandle, DACx_CHANNEL, DAC_ALIGN_12B_R, 0x300) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

}


/**
*
* @brief        set flag LCD upgrade 
*
* @param [in ]  uint8_t - status
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void setUpgradeLcd (upgLcd_e status)
{
  upgradeLcd = status;
}


/**
*
* @brief        get flag LCD upgrade 
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       upgLcd_e: 
*
***********************************************************************************************************************/
upgLcd_e getUpgradeLcd (void)
{
  return(upgradeLcd);
}

/**
*
* @brief        set flag LCD presence 
*
* @param [in ]  uint8_t - status
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void setLcdPresence (presenceLcd_e status)
{
  lcdPresent = status;
}

/**
*
* @brief        get flag LCD presence 
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       presenceLcd_e: 
*
***********************************************************************************************************************/
presenceLcd_e getLcdPresence (void)
{
  return(lcdPresent);
}




/**
*
* @brief        fast init after every contactor change status  
*
* @param [in ]  none 
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void Lcd2x20FastInit(void)
{

  LcdSetWriteDir();

  LcdCmdNibbleNW(0x30);
  HAL_Delay(5);
  //WaitLcdBus(0x800);    // Wait 4.1ms

  LcdCmdNibbleNW(0x30);
  HAL_Delay(2);
  //WaitLcdBus(0x30);   // Wait 100uS

  LcdCmdNibbleNW(0x30);
  LcdWaitBusy();

  LcdCmdNibbleNW(0x20);
  LcdWaitBusy();

  LcdCmd(0x28);   // Set 4bit bus, 2 linee, 5x7 dots  
  LcdCmd(0x08);   // Display, cursor, blink all off
  LcdCmd(0x01);   // Clear Display
  LcdCmd(0x06);   // Cursor move to right, no shift
  LcdCmd(0x0C);   // Display On, cursor and blink off

}

/**
*
* @brief        Put a new char in CGRAM  
*
* @param [in ]  uint8_t*: pointer to char definition  
* @param [in ]  uint8_t:  location in CGRAM where store the char  
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
static void createCustomChar    (uint8_t* pattern, uint8_t location)
{
  uint8_t   i;

  if (location < 8)
  {
    LcdCmd((uint8_t)0x40 + location * 8);   // set address in CGRAM
    for (i = 0; i < 8; i++)
    {
      LcdData(pattern[i]);  // the pattern char is passed to CGRAM
    }
  }

}

/**
*
* @brief        Put the contrast when in emergency condition   
*
* @param [in ]  none   
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void LcdPwrDwnContrast (void)
{
  contrastConfigDAC();
  LcdUpDownContrast((uint32_t)300);
}

/*************************************************************************************************

  Funzione:
    putsxy_c

  Descrizione:
    Visualizzazione di una stringa (CODE)

  Parametri in ingresso:
    x  = coordinata x (1..20)
    y  = coordinata y (1..4)
    n  = block downloaded 
    *s = puntatore alla stringa

*************************************************************************************************/
void putsxyDwnl_c(uint8_t x, uint8_t y, uint8_t n)
{
  char  *s;
  uint8_t i;

  gotoxy(x, y);

  if (y == 1) s = (char*)strDwnl;
  else
  {
    for (i = 0; i < NUM_CAR_DISP; i++)
    {
       if (i < n) lcd_locline[1][i] = '.'; else lcd_locline[1][i] = ' ';
    }
    s = (char*)&lcd_locline[1][0];
  }

  for (; *s != TERMINATORE && x < NUM_CAR_DISP + 1; s++, x++)
  {
    LcdData((uint8_t)*s);
  }
}


/**
*
* @brief        Power on sequence for  LCD 
*
* @param [in ]  none   
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void lcdPwrOnSequence(void)
{ 
    
  GPIO_InitTypeDef  GPIO_InitStruct;

  /* Configure the LCD_PWR_Pin as input to put LCD in power off  (pull-up to 5V is external)*/
  GPIO_InitStruct.Pin = LCD_PWR_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(LCD_PWR_GPIO_Port, &GPIO_InitStruct);

  HAL_Delay(200);

  /* Configure the LCD_PWR_Pin as output LOW to put LCD in power on  (pull-up to 5V is external)*/
  HAL_GPIO_WritePin(LCD_PWR_GPIO_Port, LCD_PWR_Pin, GPIO_PIN_RESET);

  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;

  HAL_GPIO_Init(LCD_PWR_GPIO_Port, &GPIO_InitStruct);

  HAL_Delay(200);
    
}

/**
*
* @brief     Check if status bar related to the backup is displayed on the second row  
*
* @param [in ]  none  
*
* @param  
*
* @retval       TRUE if displayed - FALSE if NOT displayed
*
***********************************************************************************************************************/

uint8_t LCD_Check_StatusBar_Presence(void)
{
  uint8_t  Data;
  
  LcdCmd(ADDR_CHECK_CHAR + 0x40);   // set address in DDRAM to check first char 
  Data = LcdRead();
  if (Data == 'ÿ')
      return TRUE;
  return FALSE;
  
}

/**
*
* @brief        Control to enable / disable time print on LCD 
*
* @param [in ]  uint8_t: status ENABLED = 1 or DISABLED = 0   
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void timeOnLcd (uint8_t lcdTime)
{
  timeOnLcdFlag = lcdTime;
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
static void lcd4X20_Handler(void)
{
  while(1)
  {
  }
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------- //
//  FUNCTION NAME:  lowLevelLcdMngTask
//
//  DESCRIPTION:    gestione hardware display lcd 20x2
//
//  INPUT:          -
//
//  OUTPUT:         none
// ------------------------------------------------------------------------------------------------------------------------------------------------------------------- //
void lowLevelLcdMngTask(void *pvParameters)
{
  lowLevelLcdMsg_st localLowLevelLcdMsg;

  /* init task */

  /*-------- Creates an empty mailbox for LcdMngTask messages --------------------------*/
  lowLevelLcdMngQueue = xQueueCreate(4, sizeof(lowLevelLcdMsg_st));
  configASSERT(lowLevelLcdMngQueue != NULL);

  lowLevelLcd.state = LCD_STATE_IDLE;
  lcdTimeTick = pdMS_TO_TICKS(TIMER_TICK_TO_INIT); // tipical  time before init : 100ms

  /* start task */
  for (;;)
  {
    /* Wait for some event from SW */
    if (xQueueReceive(lowLevelLcdMngQueue, (void *)&localLowLevelLcdMsg, lcdTimeTick) == pdPASS)
    {
      lcdTimeTick = lowLevelLcdManager(&localLowLevelLcdMsg);
    }
    else
    {
      /* Wait for possible handled timeout */
      localLowLevelLcdMsg.lowLevelEvent = LCD_TIMEOUT;
      lcdTimeTick = lowLevelLcdManager(&localLowLevelLcdMsg);
    }
  }
}

/**
*
* @brief       Init timer structure used for PWM led management 
*
* @param [in]  none
*  
* @retval      none 
*  
****************************************************************/

void TIM_Pwm_LED_Init (void)
{
 
  uint32_t uwPrescalerValue = 0;
  TIM_OC_InitTypeDef  sConfig;

  /* TIM1 clock enable */
  __HAL_RCC_TIM1_CLK_ENABLE();

  /*##-1- Configure the TIM peripheral #######################################*/

  /* Compute the prescaler value to have TIM1 counter clock equal to 10MHz */
  uwPrescalerValue = ((SystemCoreClock) / 10000000) - 1;

  /* Set timer instance */
  htim.Instance = TIM1;

  /* Initialize TIM1 peripheral as follows:
       + Period = 100 - 1
       + Prescaler = (SystemCoreClock/100000) - 1
       + ClockDivision = 0
       + Counter direction = Up
  */
  htim.Init.Prescaler     = uwPrescalerValue;
  htim.Init.Period        = 100;    // now 100/10000 KHz = 0,01msec (100KHz)
  htim.Init.ClockDivision = 0;      
  htim.Init.CounterMode = TIM_COUNTERMODE_UP;

  if(HAL_TIM_PWM_Init(&htim) != HAL_OK)
  {
    /* Initialization Error */
   Error_Handler();
  }

    /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_PWM1;
  sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCNPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCFastMode = TIM_OCFAST_DISABLE;

  /* Set the pulse value for channel 4 */
  sConfig.Pulse = PWMLCD4X20_MIN_DC;

  if(HAL_TIM_PWM_ConfigChannel(&htim, &sConfig, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* Configuration Error */
   Error_Handler();
  }

}

/**
*
* @brief       Gestione hardware del display LCD 2x20 
*
* @param [in]  PACKET_MS*: puntatore al messaggio ricevuto  
*  
* @retval      none 
*  
****************************************************************/
static uint32_t lowLevelLcdManager(lowLevelLcdMsg_st *pMsg)
{
  uint32_t    timeTk;

  timeTk = portMAX_DELAY;

  switch (lowLevelLcd.state)
  {
    case LCD_STATE_IDLE:
      switch (pMsg->lowLevelEvent)
      {
        case LCD_TIMEOUT:
          
          Lcd2x20Init((uint8_t)TRUE, AS_STANDARD_MODE);
          putsxy_c(1, 1, " Scame Control Unit");
          putsxy_c(8, 2, FW_VERSION);
          lowLevelLcd.state = LCD_STATE_OPERATIVE;
          /* Start PWM for RGB leds*/
          setPWMlcd2x20();
          
          break;

        default:
          break;
      }
      break;

    case LCD_STATE_OPERATIVE:
      switch (pMsg->lowLevelEvent)
      {
        case LCD_FAIL_CHECK:
          Lcd2x20Init((uint8_t)FALSE, AS_STANDARD_MODE);
          timeTk = TIMER_TICK_TO_HOLD;
          lowLevelLcd.state = LCD_STATE_HOLD_ON_FAIL;
          break;

        default:
          break;
      }
      break;

    case LCD_STATE_HOLD_ON_FAIL:
      switch (pMsg->lowLevelEvent)
      {
        case LCD_FAIL_CHECK:
          timeTk = pdMS_TO_TICKS(TIMER_TICK_TO_HOLD);
          lowLevelLcd.state = LCD_STATE_FAIL;
          break;

        case LCD_TIMEOUT:
          lowLevelLcd.state = LCD_STATE_OPERATIVE;
          break;

        default:
          break;
      }
      break;

    case LCD_STATE_FAIL:
      switch (pMsg->lowLevelEvent)
      {
        case LCD_TIMEOUT:
          Lcd2x20Init((uint8_t)FALSE, AS_STANDARD_MODE);
          timeTk = pdMS_TO_TICKS(TIMER_TICK_TO_HOLD);
          lowLevelLcd.state = LCD_STATE_HOLD_ON_FAIL;
          break;

        case LCD_FAIL_CHECK:
          timeTk = pdMS_TO_TICKS(TIMER_TICK_TO_HOLD);
          break;

        default:
          break;
      }
      break;

    default:
      break;
  }

  return (timeTk);
}

/**
*
* @brief        Send a message to manage a LCD alarm
*
* @param [in]   lowLevelEvent_en: alarm type  
*  
* @param [out]  none
*
* @retval       none
*
*******************************************************************************/
void sendMessageToLcd(lowLevelEvent_en alarmLcd)
{
  lowLevelLcdMsg_st tempMsg;

  tempMsg.lowLevelEvent = alarmLcd;

  /**** genera un messaggio verso il task   */
  configASSERT(xQueueSendToBack(lowLevelLcdMngQueue, (void *)&tempMsg, portMAX_DELAY) == pdPASS);
}

// ------------------------------------------------------------------------------------------------------------------------------------------------------------------- //



