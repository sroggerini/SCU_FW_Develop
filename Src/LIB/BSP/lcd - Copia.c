/**
* @file        lcd.c
*
* @brief       API display LCD 2x20 / 4x 40 - Implementation -
*
* @author      Nick
*
* @riskClass   C
*
* @moduleID
*
* @vcsInfo
*     $Id: lcd - Copia.c 76 2022-06-20 09:46:05Z npiergi $
*
*     $Revision: 76 $
*
*     $Author: npiergi $
*
*     $Date: 2022-06-20 11:46:05 +0200 (lun, 20 giu 2022) $
*
*
* @copyright
*       Copyright (C) 2017 SCAME S.p.A. All rights reserved.
*       This file is copyrighted and the property of Aesys S.p.A.. It contains confidential and proprietary
*       information. Any copies of this file (in whole or in part) made by any method must also include a copy of this
*       legend.
*       Developed by:  SCAME S.p.A.
***********************************************************************************************************************/

/************************************************************
 * Include
 ************************************************************/
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include "displayPin.h"
#include "wrapper.h"
#include "LcdMng.h"
#include "inputsMng.h"
#include "evsMng.h"

/*
*********************************** SCAME ************************************
**                                                                          **
**           LOCAL MACROS, TYPEDEF, STRUCTURE, ENUM                         **
**                                                                          **
******************************************************************************
*/

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Local Variables                               **
**                                                                          **
******************************************************************************
*/

static DAC_HandleTypeDef      DacHandle;
static DAC_ChannelConfTypeDef sConfig;

static char                lcd_locline[2][LCD_CHAR_NUM];
static upgLcd_e            upgradeLcd;
static lcdCntt_e           cnttChange;
static uint16_t            minTimeEnVal;
static uint16_t            lcdHwMng;

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Global Variables                              **
**                                                                          **
******************************************************************************
*/


/*
*********************************** SCAME ************************************
**                                                                          **
**                            External Variables                            **
**                                                                          **
******************************************************************************
*/


/*
*********************************** SCAME ************************************
**                                                                          **
**                            External Function                             **
**                                                                          **
******************************************************************************
*/
extern void setSysTickStatus(uint16_t status);

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Internal Function prototype                   **
**                                                                          **
******************************************************************************
*/
void    Write_LcdData   (uint8_t val);
uint8_t Read_LcdData    (void);
void    Lcd_Enable      (uint8_t stato);
void    Lcd_Rw          (uint8_t stato);
void    Lcd_Rs          (uint8_t stato);
void    gotoxy          (uint8_t x, uint8_t y);
void    set_cursor      (uint8_t x, uint8_t y, uint8_t cursore);
void    LcdCmd          (uint8_t Data);
void    LcdData         (uint8_t Data);
uint8_t LcdWaitBusy     (void);
void    LcdContrastInit (void);

static void     contrastConfigDAC   (void);
static void     Lcd2x20FastInit     (void);
static uint8_t  LcdReadBusyFlag     (void);
static uint8_t  LcdRead             (void);

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Function Definition                           **
**                                                                          **
******************************************************************************
*/

/*
*********************************** SCAME ************************************
**                                                                          **
**           LOCAL MACROS, TYPEDEF, STRUCTURE, ENUM                         **
**                                                                          **
******************************************************************************
*/
#ifdef GRAPHICS_LCD
#define   MIN_TIME_EN_VAL       ((uint16_t)50)
#define   MIN_HOLD_EN_VAL       ((uint16_t)10)
#else
#define   MIN_TIME_EN_INI_VAL   ((uint16_t)300)   
#define   MIN_TIME_EN_VAL       ((uint16_t)30)   /* era 300 */
#define   MIN_HOLD_EN_VAL       ((uint16_t)10)
#endif

#define   MAX_COL           ((uint8_t)192)
#define   MAX_ROW           ((uint8_t)32)
#define   COUNTRY_COL       ((uint8_t)32)
/** data offset in the PORT DB0=GPIOE.3 ... DB3=GPIOE.6 --> 3 Only 4 bit are used    */
#define   DATA_OFFSET       ((uint8_t)3)
#define   DATA_IN_MASK      ((uint32_t)0x0000000F)
#define   DATA_OUT_MASK     ((uint32_t)0x00000078)
#define   MODE_MASK         ((uint32_t)0x00003FC0)
#define   MODE_OUT_MASK     ((uint32_t)0x00001540)
#define   OTYPE_OUT_MASK    ((uint32_t)0x00000078)

#define   WriteIns(a)       LcdCmd(a)

#define   LOCATION_LITTLEMAN  ((uint8_t)1)
#define   ADDR_CGRAM          ((uint8_t)0x40)
#define   ADDR_LITTLEMAN      (ADDR_CGRAM + LOCATION_LITTLEMAN * (uint8_t)8)

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Local Variables                               **
**                                                                          **
******************************************************************************
*/

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Local Const                                  **
**                                                                          **
******************************************************************************
*/
static const uint8_t littleMan[] = {0x0E, 0x0E, 0x04, 0x1F, 0x04, 0x04,0x0A, 0x0A};
static const char    strDwnl[] = "  UPLOADING...      ";

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Global Variables                              **
**                                                                          **
******************************************************************************
*/
GPIO_TypeDef* LCD_PORT[LCDn] = {DB0_GPIO_PORT,
                                DB1_GPIO_PORT,
                                DB2_GPIO_PORT,
                                DB3_GPIO_PORT,
                                RW_GPIO_PORT,
                                RS_GPIO_PORT,
                                CS_GPIO_PORT
                               };

/*
*********************************** SCAME ************************************
**                                                                          **
**                            Global Const                                  **
**                                                                          **
******************************************************************************
*/
const uint16_t LCD_PIN[LCDn] = {DB0_PIN,
                                DB1_PIN,
                                DB2_PIN,
                                DB3_PIN,
                                RW_PIN,
                                RS_PIN,
                                CS_PIN
                               };

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD */
unsigned char italiaPic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x1F, 0x00, 0x00,
  0x00, 0x71, 0xC0, 0x00,
  0x03, 0xC0, 0x20, 0x00,
  0x1C, 0x00, 0x20, 0x00,
  0x10, 0x00, 0xE0, 0x00,
  0x10, 0x01, 0x07, 0x7C,
  0x10, 0x01, 0x02, 0x10,
  0x10, 0x01, 0x02, 0x10,
  0x19, 0xC1, 0x02, 0x10,
  0x0E, 0x60, 0x82, 0x10,
  0x00, 0x20, 0x42, 0x10,
  0x00, 0x20, 0x47, 0x10,
  0x00, 0x18, 0x20, 0x00,
  0x00, 0x08, 0x10, 0x00,
  0x00, 0x04, 0x08, 0x00,
  0x00, 0x02, 0x06, 0x00,
  0x00, 0x01, 0x01, 0x00,
  0x01, 0x80, 0xC0, 0x80,
  0x06, 0x40, 0x20, 0x70,
  0x06, 0x40, 0x18, 0x08,
  0x02, 0x40, 0x04, 0x04,
  0x02, 0x40, 0x02, 0x74,
  0x02, 0x40, 0x01, 0x4C,
  0x04, 0x40, 0x01, 0x20,
  0x07, 0x80, 0x00, 0xA0,
  0x00, 0x00, 0x00, 0xA0,
  0x00, 0x01, 0x81, 0x40,
  0x00, 0x02, 0x7E, 0x80,
  0x00, 0x02, 0x02, 0x00,
  0x00, 0x01, 0xC1, 0x00,
  0x00, 0x00, 0x71, 0x00,
  0x00, 0x00, 0x0E, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD */
unsigned char franciaPic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0xC0, 0x00,
  0x00, 0x01, 0x60, 0x00, 
  0x00, 0x03, 0x38, 0x00, 
  0x00, 0x06, 0x0C, 0x00, 
  0x00, 0x0C, 0x03, 0x80,
  0x00, 0xF8, 0x00, 0xF0, 
  0x0E, 0x80, 0x00, 0x18, 
  0x11, 0x80, 0x00, 0x10, 
  0x10, 0x00, 0x00, 0x10,
  0x0C, 0x07, 0xBC, 0x30, 
  0x07, 0x04, 0x24, 0x60, 
  0x01, 0x04, 0x24, 0x40, 
  0x01, 0x87, 0x3C, 0xC0,
  0x00, 0x84, 0x30, 0x80, 
  0x00, 0x44, 0x28, 0xE0, 
  0x00, 0x44, 0x24, 0x20, 
  0x00, 0x20, 0x00, 0x20,
  0x00, 0x40, 0x00, 0x20, 
  0x00, 0x40, 0x00, 0x20, 
  0x00, 0x40, 0x00, 0x30, 
  0x00, 0x80, 0x00, 0x10,
  0x01, 0x00, 0x00, 0x30, 
  0x00, 0x80, 0x1F, 0x60, 
  0x00, 0xE0, 0x20, 0x88, 
  0x00, 0x3E, 0x40, 0x38,
  0x00, 0x01, 0x80, 0x68, 
  0x00, 0x00, 0x00, 0x28, 
  0x00, 0x00, 0x00, 0x18, 
  0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD */
unsigned char ukPic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x00,
  0x00, 0x01, 0x88, 0xA2,
  0x00, 0x07, 0x08, 0xA4,
  0x00, 0x3B, 0x08, 0xA8,
  0x00, 0x22, 0x08, 0xB0,
  0x00, 0x33, 0xC8, 0xA8,
  0x00, 0x10, 0x48, 0xA4,
  0x00, 0x30, 0x8F, 0xA2,
  0x00, 0x11, 0x00, 0x00,
  0x00, 0x19, 0xC0, 0x00,
  0x00, 0x0C, 0x60, 0x00,
  0x00, 0x64, 0x20, 0x00,
  0x01, 0xA7, 0x30, 0x00,
  0x01, 0x11, 0x18, 0x00,
  0x00, 0xD1, 0x88, 0x00,
  0x00, 0x20, 0x8C, 0x00,
  0x00, 0x07, 0x85, 0x00,
  0x00, 0x06, 0x02, 0x80,
  0x00, 0x02, 0x00, 0xC0,
  0x00, 0x02, 0x00, 0x80,
  0x00, 0x0C, 0x01, 0x00,
  0x00, 0x0F, 0x81, 0x80,
  0x00, 0x01, 0x81, 0x80,
  0x00, 0x02, 0x1F, 0x00,
  0x00, 0x0C, 0xF0, 0x00,
  0x00, 0x1B, 0x00, 0x00,
  0x00, 0x0C, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD */
unsigned char pulsante1Pic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x01, 0xFF, 0xFC, 0x00,
  0x02, 0x00, 0x0C, 0x00,
  0x04, 0x00, 0x14, 0x00,
  0x08, 0x00, 0x24, 0x00,
  0x10, 0x00, 0x44, 0x00,
  0x1F, 0xFF, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x11, 0x08, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x80,
  0x10, 0xE0, 0x91, 0x00,
  0x11, 0x10, 0xAB, 0xFE,
  0x11, 0x10, 0x91, 0x00,
  0x11, 0x10, 0x80, 0x80,
  0x10, 0xE0, 0xA0, 0x00,
  0x10, 0x00, 0xC0, 0x00,
  0x1F, 0xFF, 0x80, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD */
unsigned char pulsante2Pic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x01, 0xFF, 0xFC, 0x00,
  0x02, 0x00, 0x0C, 0x00,
  0x04, 0x00, 0x14, 0x00,
  0x08, 0x00, 0x24, 0x00,
  0x10, 0x00, 0x44, 0x00,
  0x1F, 0xFF, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x11, 0x08, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x10,
  0x10, 0xE0, 0x90, 0x20,
  0x11, 0x10, 0xA8, 0x7E,
  0x11, 0x10, 0x90, 0x20,
  0x11, 0x10, 0x80, 0x10,
  0x10, 0xE0, 0xA0, 0x00,
  0x10, 0x00, 0xC0, 0x00,
  0x1F, 0xFF, 0x80, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di LCD Arabia Saudita */
unsigned char asPic[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x03, 0xE0, 0x00, 0x00,
  0x02, 0x38, 0x00, 0x00,
  0x02, 0x0C, 0x00, 0x00,
  0x02, 0x06, 0x00, 0x00,
  0x0C, 0x03, 0xE0, 0x00,
  0x18, 0x00, 0x38, 0x00,
  0x10, 0x00, 0x0C, 0x00,
  0x08, 0x00, 0x04, 0x00,
  0x08, 0x00, 0x06, 0x00,
  0x0C, 0x00, 0x02, 0x00,
  0x06, 0x00, 0x03, 0x00,
  0x02, 0x00, 0x01, 0x00,
  0x01, 0x00, 0x00, 0x80,
  0x01, 0x80, 0x00, 0x40,
  0x00, 0x80, 0x00, 0x38,
  0x00, 0x80, 0x00, 0x08,
  0x00, 0x80, 0x00, 0x08,
  0x00, 0x40, 0x00, 0x18,
  0x00, 0x20, 0x00, 0xF0,
  0x00, 0x10, 0x0F, 0x80,
  0x00, 0x10, 0x18, 0x00,
  0x00, 0x17, 0xF0, 0x00,
  0x00, 0x1C, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di dito 1 */
unsigned char dito1[MAX_ROW][COUNTRY_COL / 8] = {
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x01, 0xFF, 0xFC, 0x00,
    0x02, 0x00, 0x0C, 0x00,
    0x04, 0x00, 0x14, 0x00,
    0x08, 0x00, 0x24, 0x00,
    0x10, 0x00, 0x44, 0x00,
    0x1F, 0xFF, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x11, 0xF8, 0x84, 0x00,
    0x11, 0x08, 0x84, 0x00,
    0x11, 0xF8, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0x00, 0x84, 0x00,
    0x10, 0xE0, 0x90, 0x00,
    0x11, 0x10, 0xAB, 0xFE,
    0x11, 0x10, 0x93, 0xFE,
    0x11, 0x10, 0x80, 0xFE,
    0x10, 0xE0, 0xA0, 0x00,
    0x10, 0x00, 0xC0, 0x00,
    0x1F, 0xFF, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00 
};

unsigned char dito2[MAX_ROW][COUNTRY_COL / 8] = {
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x01, 0xFF, 0xFC, 0x00,
  0x02, 0x00, 0x0C, 0x00,
  0x04, 0x00, 0x14, 0x00,
  0x08, 0x00, 0x24, 0x00,
  0x10, 0x00, 0x44, 0x00,
  0x1F, 0xFF, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x11, 0x08, 0x84, 0x00,
  0x11, 0xF8, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0x00, 0x84, 0x00,
  0x10, 0xE0, 0x90, 0x00,
  0x11, 0x10, 0xA8, 0xFE,
  0x11, 0x10, 0x90, 0xFE,
  0x11, 0x10, 0x80, 0x3E,
  0x10, 0xE0, 0xA0, 0x00,
  0x10, 0x00, 0xC0, 0x00,
  0x1F, 0xFF, 0x80, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00 
};


//winstar logo
const uint8_t  pic[MAX_ROW][MAX_COL / 8] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0F, 0xF8, 0x01, 0xFF, 0x80, 0x3F,
  0xF0, 0x00, 0x1C, 0x71, 0xDD, 0xC7, 0x3F, 0xFF,
  0xC1, 0x81, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1F, 0xFC, 0x03, 0xFF, 0xC0, 0x7F,
  0xF8, 0x00, 0x1C, 0x71, 0xDD, 0xC7, 0x7F, 0xFF,
  0xC3, 0xC1, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1F, 0xFE, 0x03, 0xFF, 0xC0, 0x7F,
  0xFC, 0x00, 0x1C, 0x71, 0xDD, 0xE7, 0x70, 0x0E,
  0x07, 0xE1, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1F, 0xFE, 0x01, 0xFF, 0xE0, 0x3F,
  0xFC, 0x00, 0x0E, 0xFB, 0x9D, 0xE7, 0x70, 0x0E,
  0x06, 0x61, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0F, 0xFF, 0x01, 0xFF, 0xE0, 0x3F,
  0xFE, 0x00, 0x0E, 0xFB, 0x9D, 0xF7, 0x7F, 0x8E,
  0x0E, 0x71, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0F, 0xFF, 0x01, 0xFF, 0xF0, 0x1F,
  0xFE, 0x00, 0x0E, 0xFF, 0x1D, 0xFF, 0x3F, 0xCE,
  0x0C, 0x31, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x07, 0xFF, 0x80, 0xFF, 0xF0, 0x1F,
  0xFF, 0x00, 0x07, 0xDF, 0x1D, 0xDF, 0x00, 0xCE,
  0x0F, 0xF1, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x07, 0xFF, 0x80, 0xFF, 0xF8, 0x0F,
  0xFF, 0x00, 0x07, 0xDF, 0x1D, 0xCF, 0x61, 0xCE,
  0x1F, 0xF9, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0xFF, 0xC0, 0x7F, 0xF8, 0x07,
  0xFF, 0x00, 0x03, 0x8E, 0x1D, 0xC7, 0x7F, 0xCE,
  0x1C, 0x39, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0xFF, 0xC0, 0xFF, 0xF0, 0x0F,
  0xFE, 0x00, 0x03, 0x8E, 0x1D, 0xC7, 0x7F, 0x8E,
  0x38, 0x1D, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0x80, 0xE0, 0x00, 0x1C,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x30,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x7F, 0xE0, 0x0F, 0xFC, 0x00,
  0x00, 0x00, 0x1C, 0x63, 0x87, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0xF0, 0x1F, 0xFE, 0x00,
  0x00, 0x00, 0x1C, 0x63, 0x9F, 0xE0, 0x63, 0xE0,
  0xE1, 0xF0, 0x70, 0x3E, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0xF0, 0x1F, 0xFE, 0x00,
  0x00, 0x00, 0x0C, 0xF3, 0x18, 0x60, 0xE7, 0xF1,
  0xF3, 0xF8, 0xF8, 0x7F, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0xF8, 0x0F, 0xFF, 0x00,
  0x00, 0x00, 0x0C, 0xF3, 0x30, 0x71, 0xE6, 0x33,
  0x1B, 0x19, 0x8C, 0xE3, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x7F, 0xF8, 0x0F, 0xFF, 0x00,
  0x00, 0x00, 0x0E, 0xF3, 0x30, 0x00, 0x66, 0x33,
  0x1B, 0x19, 0x8C, 0xC1, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x7F, 0xFC, 0x07, 0xFF, 0x80,
  0x00, 0x00, 0x06, 0xF6, 0x31, 0xF0, 0x67, 0xF0,
  0x38, 0x70, 0x1C, 0xC0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x3F, 0xFC, 0x07, 0xFF, 0x80,
  0x00, 0x00, 0x06, 0x96, 0x31, 0xF0, 0x63, 0xF0,
  0x70, 0x78, 0x38, 0xC0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x3F, 0xFE, 0x03, 0xFF, 0xC0,
  0x00, 0x00, 0x07, 0x9E, 0x30, 0x30, 0x60, 0x30,
  0xE0, 0x18, 0x70, 0xC1, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1F, 0xFE, 0x03, 0xFF, 0xC0,
  0x00, 0x00, 0x03, 0x9E, 0x18, 0x70, 0x66, 0x71,
  0x83, 0x18, 0xC0, 0xE3, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x0F, 0xFC, 0x00, 0xFF, 0x80,
  0x00, 0x00, 0x03, 0x9C, 0x1F, 0xF0, 0x67, 0xE3,
  0xFB, 0xF9, 0xFC, 0x7F, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x03, 0x0C, 0x0F, 0xD0, 0x63, 0xC3,
  0xF9, 0xF1, 0xFC, 0x3E, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//winstar logo
const uint8_t  araboWelcome[MAX_ROW][MAX_COL / 8] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xE0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFE, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0xFF, 0x00,
  0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0xFC, 0x00,
  0x02, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0C, 0x00, 0x00, 0x3E, 0x00, 0x70, 0x18, 0x60, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x80,
  0x02, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0C, 0x00, 0x00, 0x38, 0x01, 0xF0, 0x38, 0x70, 0x00, 0x00, 0x00, 0x1F, 0xFE, 0x00,
  0x02, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1C, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x18, 0x70, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0x80,
  0x0C, 0x03, 0xE0, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x07, 0x0C, 0x00, 0x00, 0x06, 0x00, 0x00, 0x18, 0x70, 0x00, 0x00, 0x00, 0x3F, 0xFE, 0x80,
  0x18, 0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x03, 0x0C, 0x00, 0x00, 0x06, 0x00, 0xF0, 0x18, 0x30, 0x00, 0x00, 0x00, 0x15, 0xFA, 0x00,
  0x10, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0C, 0x00, 0x00, 0x0E, 0x00, 0xF0, 0x1C, 0x30, 0x00, 0x00, 0x00, 0x15, 0xDA, 0x00,
  0x08, 0x00, 0x04, 0x00, 0x00, 0xC0, 0x01, 0xC7, 0xC0, 0x03, 0x0C, 0x00, 0x00, 0x3E, 0x01, 0xF8, 0x1C, 0x30, 0x00, 0x18, 0x00, 0x10, 0xC0, 0x00,
  0x08, 0x00, 0x06, 0x00, 0x00, 0xDE, 0x00, 0xCF, 0xE0, 0x03, 0x0E, 0x00, 0x00, 0x77, 0x00, 0xF8, 0x1C, 0x37, 0xC0, 0x1C, 0x00, 0x00, 0xC0, 0x00,
  0x0C, 0x00, 0x02, 0x00, 0x18, 0xFF, 0x00, 0xE3, 0xC0, 0x03, 0x8E, 0x00, 0x00, 0x7F, 0x00, 0x18, 0x1C, 0x3F, 0xE0, 0x1C, 0x00, 0x00, 0xC0, 0x00,
  0x06, 0x00, 0x03, 0x00, 0x18, 0xF7, 0x00, 0x63, 0x80, 0x01, 0x8E, 0x00, 0x00, 0x03, 0x00, 0x18, 0x1C, 0x38, 0xE0, 0x0C, 0x00, 0x00, 0x40, 0x00,
  0x02, 0x00, 0x01, 0x00, 0x18, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x03, 0xFF, 0xF8, 0x0F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x40, 0x00,
  0x01, 0x00, 0x00, 0x80, 0x18, 0xFF, 0x00, 0xFE, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x03, 0xFF, 0xF8, 0x0F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x60, 0x00,
  0x01, 0x80, 0x00, 0x40, 0x38, 0xC0, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00,
  0x00, 0x80, 0x00, 0x38, 0x39, 0xC0, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x40, 0x00,
  0x00, 0x80, 0x00, 0x08, 0x1F, 0xC0, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0xC0, 0x40, 0x60,
  0x00, 0x80, 0x00, 0x08, 0x1F, 0x80, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFA, 0xDB, 0xFC,
  0x00, 0x40, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1F, 0xFF, 0x03,
  0x00, 0x20, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0C, 0x00,
  0x00, 0x10, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xB8, 0x00,
  0x00, 0x10, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF0, 0x00,
  0x00, 0x17, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00,
  0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0xF4, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xB8, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1C, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xAE, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x07, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x03, 0x00 
};

const uint8_t  showCardUK[MAX_ROW][MAX_COL / 8] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x88, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x08, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3B, 0x08, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x22, 0x08, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x33, 0xC8, 0xA8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x48, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x8F, 0xA2, 0x00, 0x00, 0x00, 0x0F, 0x98, 0xCF, 0x98, 0xC0, 0x3E, 0x1C, 0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x58, 0xD8, 0xD8, 0xC0, 0x61, 0x36, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x19, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0xD8, 0xD8, 0xC0, 0x60, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x60, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0xD8, 0xD8, 0xC0, 0x60, 0x63, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x64, 0x20, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x9F, 0xD8, 0xD8, 0xC0, 0x60, 0x63, 0x7E, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0xA7, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0xD8, 0xD8, 0xC0, 0x60, 0x7F, 0x78, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x11, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0xD8, 0xDA, 0xC0, 0x60, 0x63, 0x6C, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xD1, 0x88, 0x00, 0x00, 0x00, 0x00, 0x10, 0xD8, 0xD8, 0xDA, 0xC0, 0x61, 0x63, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x98, 0xCF, 0x8D, 0x80, 0x3E, 0x63, 0x63, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x06, 0x02, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0F, 0x81, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x81, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

const uint8_t  showCardIT[MAX_ROW][MAX_COL / 8] =
{
    0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x71, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0xC0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1C, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x01, 0x07, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x19, 0xC1, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x60, 0x82, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x42, 0x10, 0x01, 0xF9, 0xF9, 0xFC, 0xF9, 0xFD, 0x8C, 0xFC, 0x71, 0xF9, 0xFC, 0x03, 0xE1, 0xC7, 0xE3, 0xF1, 0xC0, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x47, 0x10, 0x01, 0x8D, 0x8D, 0x81, 0x85, 0x81, 0xCC, 0x30, 0xD9, 0x8D, 0x80, 0x06, 0x13, 0x66, 0x30, 0xC3, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x20, 0x00, 0x01, 0x8D, 0x8D, 0x81, 0x81, 0x81, 0xEC, 0x31, 0x8D, 0x8D, 0x80, 0x06, 0x06, 0x36, 0x30, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x08, 0x10, 0x00, 0x01, 0x8D, 0x8D, 0x81, 0x81, 0x81, 0xBC, 0x31, 0x8D, 0x8D, 0x80, 0x06, 0x06, 0x36, 0x30, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x04, 0x08, 0x00, 0x01, 0xF9, 0xF9, 0xE0, 0xF9, 0xE1, 0x9C, 0x31, 0x8D, 0xF9, 0xE0, 0x06, 0x06, 0x37, 0xE0, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x06, 0x00, 0x01, 0x81, 0xE1, 0x80, 0x0D, 0x81, 0x8C, 0x31, 0xFD, 0xE1, 0x80, 0x06, 0x07, 0xF7, 0x80, 0xC7, 0xF0, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x01, 0x00, 0x01, 0x81, 0xB1, 0x80, 0x0D, 0x81, 0x8C, 0x31, 0x8D, 0xB1, 0x80, 0x06, 0x06, 0x36, 0xC0, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x01, 0x80, 0xC0, 0x80, 0x01, 0x81, 0x99, 0x81, 0x0D, 0x81, 0x8C, 0x31, 0x8D, 0x99, 0x80, 0x06, 0x16, 0x36, 0x60, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x06, 0x40, 0x20, 0x70, 0x01, 0x81, 0x8D, 0xFC, 0xF9, 0xFD, 0x8C, 0x31, 0x8D, 0x8D, 0xFC, 0x03, 0xE6, 0x36, 0x30, 0xC6, 0x30, 0x00, 0x00, 0x00,
    0x06, 0x40, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x40, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x40, 0x02, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x40, 0x01, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x40, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x80, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x81, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x7E, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

/**   Francese: PRESENTER CARTE  */
const uint8_t  showCardFR[MAX_ROW][MAX_COL / 8] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x03, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xF8, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x80, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x10, 0x03, 0xF3, 0xF3, 0xF9, 0xF3, 0xFB, 0x19, 0xFB, 0xFB, 0xF0, 0x0F, 0x87, 0x1F, 0x8F, 0xDF, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0x07, 0xBC, 0x30, 0x03, 0x1B, 0x1B, 0x03, 0x0B, 0x03, 0x98, 0x63, 0x03, 0x18, 0x18, 0x4D, 0x98, 0xC3, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x04, 0x24, 0x60, 0x03, 0x1B, 0x1B, 0x03, 0x03, 0x03, 0xD8, 0x63, 0x03, 0x18, 0x18, 0x18, 0xD8, 0xC3, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x04, 0x24, 0x40, 0x03, 0x1B, 0x1B, 0x03, 0x03, 0x03, 0x78, 0x63, 0x03, 0x18, 0x18, 0x18, 0xD8, 0xC3, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x87, 0x3C, 0xC0, 0x03, 0xF3, 0xF3, 0xC1, 0xF3, 0xC3, 0x38, 0x63, 0xC3, 0xF0, 0x18, 0x18, 0xDF, 0x83, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x84, 0x30, 0x80, 0x03, 0x03, 0xC3, 0x00, 0x1B, 0x03, 0x18, 0x63, 0x03, 0xC0, 0x18, 0x1F, 0xDE, 0x03, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x44, 0x28, 0xE0, 0x03, 0x03, 0x63, 0x00, 0x1B, 0x03, 0x18, 0x63, 0x03, 0x60, 0x18, 0x18, 0xDB, 0x03, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x44, 0x24, 0x20, 0x03, 0x03, 0x33, 0x02, 0x1B, 0x03, 0x18, 0x63, 0x03, 0x30, 0x18, 0x58, 0xD9, 0x83, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x00, 0x20, 0x03, 0x03, 0x1B, 0xF9, 0xF3, 0xFB, 0x18, 0x63, 0xFB, 0x18, 0x0F, 0x98, 0xD8, 0xC3, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0x1F, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xE0, 0x20, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x40, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x80, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

#ifdef CZ_NO_TIME
/**   Ceko: PREDLOŽTE KARTU  */
const uint8_t  showCardCZ[MAX_ROW][MAX_COL / 8] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0xC1, 0xC0, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x30, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1C, 0x00, 0x16, 0x00, 0x07, 0xE3, 0xE7, 0xF7, 0xE6, 0x03, 0xE7, 0xF3, 0xF7, 0xF0, 0x31, 0x8E, 0x3F, 0x1F, 0xB1, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x00, 0x15, 0x00, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x30, 0xC6, 0x00, 0x33, 0x1B, 0x31, 0x86, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x08, 0x80, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x30, 0xC6, 0x00, 0x36, 0x31, 0xB1, 0x86, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x10, 0xF3, 0xE0, 0x70, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x60, 0xC6, 0x00, 0x3C, 0x31, 0xB1, 0x86, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x98, 0x60, 0x08, 0x07, 0xE7, 0xE7, 0x86, 0x36, 0x06, 0x30, 0xC0, 0xC7, 0x80, 0x38, 0x31, 0xBF, 0x06, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x81, 0xC0, 0x04, 0x06, 0x07, 0x86, 0x06, 0x36, 0x06, 0x31, 0x80, 0xC6, 0x00, 0x3C, 0x3F, 0xBC, 0x06, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x9B, 0x00, 0x0C, 0x06, 0x06, 0xC6, 0x06, 0x36, 0x06, 0x33, 0x00, 0xC6, 0x00, 0x36, 0x31, 0xB6, 0x06, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0xF3, 0xE0, 0x10, 0x06, 0x06, 0x66, 0x06, 0x36, 0x06, 0x36, 0x00, 0xC6, 0x00, 0x33, 0x31, 0xB3, 0x06, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x20, 0x06, 0x06, 0x37, 0xF7, 0xE7, 0xF3, 0xE7, 0xF0, 0xC7, 0xF0, 0x31, 0xB1, 0xB1, 0x86, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x07, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x84, 0xDB, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x58, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};
#else
/**   Ceko: PREDLOŽTE KARTU  */
const uint8_t  showCardCZ[MAX_ROW][MAX_COL / 8] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x01, 0xC1, 0xC0, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x03, 0x00, 0x30, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3C, 0x1F, 0x83, 0xF3,
    0x1C, 0x00, 0x16, 0x00, 0x07, 0xE3, 0xE7, 0xF7, 0xE6, 0x03, 0xE7, 0xF3, 0xF7, 0xF0, 0x31, 0x8E, 0x3F, 0x1F, 0xB1, 0x82, 0x3B, 0xC9, 0x79, 0xE3,
    0x60, 0xF7, 0xD5, 0x00, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x30, 0xC6, 0x00, 0x33, 0x1B, 0x31, 0x86, 0x31, 0x83, 0x3F, 0xC9, 0xF9, 0xC3,
    0x21, 0x00, 0x48, 0x80, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x30, 0xC6, 0x00, 0x36, 0x31, 0xB1, 0x86, 0x31, 0x83, 0x3F, 0x9F, 0xF9, 0x93,
    0x11, 0x00, 0x80, 0x70, 0x06, 0x36, 0x36, 0x06, 0x36, 0x06, 0x30, 0x60, 0xC6, 0x00, 0x3C, 0x31, 0xB1, 0x86, 0x31, 0x83, 0x3F, 0x3F, 0xE3, 0x33,
    0x11, 0x01, 0x00, 0x08, 0x07, 0xE7, 0xE7, 0x86, 0x36, 0x06, 0x30, 0xC0, 0xC7, 0x80, 0x38, 0x31, 0xBF, 0x06, 0x31, 0x83, 0x3E, 0x7F, 0xF9, 0x73,
    0x11, 0x02, 0x00, 0x04, 0x06, 0x07, 0x86, 0x06, 0x36, 0x06, 0x31, 0x80, 0xC6, 0x00, 0x3C, 0x3F, 0xBC, 0x06, 0x31, 0x83, 0x3C, 0xF9, 0xF9, 0x01,
    0x11, 0x04, 0x00, 0x0C, 0x06, 0x06, 0xC6, 0x06, 0x36, 0x06, 0x33, 0x00, 0xC6, 0x00, 0x36, 0x31, 0xB6, 0x06, 0x31, 0x83, 0x39, 0xF9, 0x79, 0xF3,
    0x0C, 0xF7, 0xC0, 0x10, 0x06, 0x06, 0x66, 0x06, 0x36, 0x06, 0x36, 0x00, 0xC6, 0x00, 0x33, 0x31, 0xB3, 0x06, 0x31, 0x83, 0x38, 0x0F, 0x83, 0xF3,
    0x06, 0x00, 0x00, 0x20, 0x06, 0x06, 0x37, 0xF7, 0xE7, 0xF3, 0xE7, 0xF0, 0xC7, 0xF0, 0x31, 0xB1, 0xB1, 0x86, 0x1F, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x01, 0x07, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x84, 0xDB, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x58, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF 
};
#endif

#ifdef NO_RCBO_TEXT
/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di RCBO1 */
unsigned char rcbo1Pic[MAX_ROW][COUNTRY_COL / 8] = {
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x03, 0xFF, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x02, 0x10, 0x80, 0x00,
    0x02, 0x28, 0x80, 0x00,
    0x02, 0x10, 0x80, 0x00,
    0x02, 0x00, 0x80, 0x00,
    0x03, 0xFF, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00 
};
#else
/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di RCBO1 */
unsigned char rcbo1Pic[MAX_ROW][MAX_COL / 8] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x3F, 0x07, 0xC3, 0xF0, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x31, 0x8C, 0x23, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x31, 0x8C, 0x03, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x31, 0x8C, 0x03, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x3F, 0x0C, 0x03, 0xF0, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x3C, 0x0C, 0x03, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x36, 0x0C, 0x03, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x33, 0x0C, 0x23, 0x18, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x31, 0x87, 0xC3, 0xF0, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x28, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x10, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};
#endif

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di RCBO2 */
unsigned char rcbo2Pic[MAX_ROW][COUNTRY_COL / 8] = {
    0x00, 0x00, 0x00, 0x00,
    0x07, 0xFE, 0x00, 0x00,
    0x04, 0x03, 0xFE, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x02, 0x42, 0x00,
    0x04, 0x02, 0xA2, 0x00,
    0x04, 0x02, 0x42, 0x00,
    0x04, 0x02, 0x02, 0x00,
    0x04, 0x03, 0xFE, 0x00,
    0x07, 0xFE, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di RCBO3 */
unsigned char rcbo3Pic[MAX_ROW][COUNTRY_COL / 8] = {
    0x00, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0xFF, 0xE0,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x7F, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x88, 0x20,
    0x04, 0x40, 0x9C, 0x20,
    0x04, 0x40, 0xBE, 0x20,
    0x04, 0x5E, 0x88, 0x20,
    0x04, 0x5E, 0x88, 0x20,
    0x04, 0x40, 0x88, 0x20,
    0x04, 0x40, 0x88, 0x20,
    0x04, 0x40, 0x88, 0x20,
    0x04, 0x7F, 0x80, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x07, 0xFF, 0xFF, 0xE0,
    0x00, 0x00, 0x00, 0x00 
};

/*** 4 byte per riga = 4 * 8 = 32 pixel = una riga di RCBO4 */
unsigned char rcbo4Pic[MAX_ROW][COUNTRY_COL / 8] = {
   0x00, 0x00, 0x00, 0x00,
    0x07, 0xFF, 0xFF, 0xE0,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x7F, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x5E, 0x80, 0x20,
    0x04, 0x5E, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x40, 0x80, 0x20,
    0x04, 0x7F, 0x80, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x04, 0x00, 0x00, 0x20,
    0x07, 0xFF, 0xFF, 0xE0,
    0x00, 0x00, 0x00, 0x00 
};

/****************** LOCAL VARIABLES ***********************************************************************************/
/* TIM handler declaration */
static TIM_HandleTypeDef  htim;



/*
*********************************** SE ***************************************
**                                                                          **
**                            Internal Function prototype                   **
**                                                                          **
******************************************************************************
*/
static void lcd4X20_Handler     (void);
static void stopPWM_LEDx        (ledIdx_e led);
static void setPWM_LEDB         (void);
static void setPWM_LEDA         (void);
static void show_pic            (uint8_t arr[][MAX_COL / 8]);
static void show_picCountry     (uint8_t arr[][COUNTRY_COL / 8]);
static void createCustomChar    (uint8_t* pattern, uint8_t location);

/**
  * @brief  Configures LCD  GPIO.
  * @retval None
  */
void LCD_IO_Init(void)
{
  uint8_t i;
  GPIO_InitTypeDef  GPIO_InitStruct;

  if (lcdHwMng == LCD_MODE_OPEN_DRAIN)
  {
    for (i = 0; i < LCDn; i++)
    {
      /* Enable the GPIO_LED clock */
      LCDx_GPIO_CLK_ENABLE(i);

      /* Configure the GPIO_LED pin in open drain mode (pull-up to 5V is external)*/
      GPIO_InitStruct.Pin = LCD_PIN[i];
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;

      HAL_GPIO_Init(LCD_PORT[i], &GPIO_InitStruct);

      HAL_GPIO_WritePin(LCD_PORT[i], LCD_PIN[i], GPIO_PIN_RESET);
    }
  }
  else
  {
    for (i = 0; i < LCDn; i++)
    {
      /* Enable the GPIO_LED clock */
      LCDx_GPIO_CLK_ENABLE(i);

      /* Configure the GPIO_LED pin in open drain mode (pull-up to 5V is external)*/
      GPIO_InitStruct.Pin = LCD_PIN[i];
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;

      HAL_GPIO_Init(LCD_PORT[i], &GPIO_InitStruct);

      HAL_GPIO_WritePin(LCD_PORT[i], LCD_PIN[i], GPIO_PIN_RESET);
    }
  }
  /* Configure the PWM GPIO_LED pin for brightness level Default = 100%  */
  PWM_LCD_GPIO_CLK_ENABLE();
  GPIO_InitStruct.Pin = PWM_LCD_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;

  HAL_GPIO_Init(PWM_LCD_GPIO_PORT, &GPIO_InitStruct);

  HAL_GPIO_WritePin(PWM_LCD_GPIO_PORT, PWM_LCD_PIN, GPIO_PIN_SET);

  contrastConfigDAC();

  upgradeLcd = UPG_LCD_ENABLED;

}

/**
  * @brief  Configures LCD  DB0...3 in input mode
  * @retval None
  */
void LCD_DB_Input(void)
{
  if (lcdHwMng == LCD_MODE_OPEN_DRAIN)
  {
#ifdef GRAPHICS_LCD
    GPIOE->MODER &= (~MODE_MASK);
#else
#ifndef LCD_FAST_PROTECT
    GPIOE->MODER &= (~MODE_MASK);   // fast execution 18/07/2021 Nick (1)
#else
    GPIO_InitTypeDef  GPIO_InitStruct;

    /* we use open drain output with external pull-up at 5V, so internal pull-up isn't necessary */
    /* Configure the data bus in input mode   */
    GPIO_InitStruct.Pin = LCD_PIN[LCD_DB0] | LCD_PIN[LCD_DB1] | LCD_PIN[LCD_DB2] | LCD_PIN[LCD_DB3];
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_PORT[LCD_DB0], &GPIO_InitStruct);
#endif
#endif
  }
  else
  {
    GPIOE->MODER &= (~MODE_MASK);   // fast execution 18/07/2021 Nick (1)
  }
}

/**
  * @brief  Configures LCD  DB0...3 in output  mode
  * @retval None
  */
void LCD_DB_Output(void)
{
  if (lcdHwMng == LCD_MODE_OPEN_DRAIN)
  {
#ifdef GRAPHICS_LCD
    GPIOE->MODER |= MODE_OUT_MASK;
    GPIOE->OTYPER |= OTYPE_OUT_MASK;
#else
#ifndef LCD_FAST_PROTECT
    GPIOE->MODER |= MODE_OUT_MASK;     // fast execution 18/07/2021 Nick (2)
    GPIOE->OTYPER |= OTYPE_OUT_MASK;
    GPIOE->ODR &= (~DATA_OUT_MASK);
#else
    GPIO_InitTypeDef  GPIO_InitStruct;

    /* Configure the GPIO_LCD pin in open drain mode (pull-up to 5V is external)*/
    GPIO_InitStruct.Pin = LCD_PIN[LCD_DB0] | LCD_PIN[LCD_DB1] | LCD_PIN[LCD_DB2] | LCD_PIN[LCD_DB3];
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_PORT[LCD_DB0], &GPIO_InitStruct);
#endif
#endif
  }
  else
  {
    uint32_t  tmpGpio;

    tmpGpio = GPIOE->MODER; 
    GPIOE->MODER = ((tmpGpio & (~MODE_MASK)) | MODE_OUT_MASK);  // output mode for LCD0..4 
    GPIOE->OTYPER &= (~OTYPE_OUT_MASK);                         // push pull
  }
}

/**
  * @brief  set/reset  LCD  RS PIN .
  * @retval None
  */
void Lcd_Rs(uint8_t stato)
{
#ifdef GRAPHICS_LCD

  if (stato == OFF)
  {
    GPIOE->ODR &= (~RS_PIN);
  }
  else
  {
    GPIOE->ODR |= (RS_PIN);
  }

#else
#ifndef LCD_FAST_PROTECT
  if (stato == OFF)                 // fast execution 18/07/2021 Nick (3)
  {
    GPIOE->ODR &= (~RS_PIN);
  }
  else
  {
    GPIOE->ODR |= (RS_PIN);
  }
#else
  if (stato == OFF)
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_RS], LCD_PIN[LCD_RS], GPIO_PIN_RESET);
  }
  else
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_RS], LCD_PIN[LCD_RS], GPIO_PIN_SET);
  }
#endif
#endif
}

/**
  * @brief  set/reset  LCD  RW PIN .
  * @retval None
  */
void Lcd_Rw(uint8_t stato)
{
#ifdef GRAPHICS_LCD

  if (stato == OFF)
  {
    GPIOE->ODR &= (~RW_PIN);
  }
  else
  {
    GPIOE->ODR |= (RW_PIN);
  }

#else
#ifndef LCD_FAST_PROTECT
  if (stato == OFF)             // fast execution 18/07/2021 Nick (3)
  {
    GPIOE->ODR &= (~RW_PIN);
  }
  else
  {
    GPIOE->ODR |= (RW_PIN);
  }
#else
  if (stato == OFF)
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_RW], LCD_PIN[LCD_RW], GPIO_PIN_RESET);
  }
  else
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_RW], LCD_PIN[LCD_RW], GPIO_PIN_SET);
  }
#endif
#endif
}

/**
  * @brief  set/reset  LCD  ENABLE  PIN .
  * @retval None
  */
void Lcd_Enable(uint8_t stato)
{
#ifdef GRAPHICS_LCD

  if (stato == OFF)
  {
    GPIOE->ODR &= (~CS_PIN);
  }
  else
  {
    GPIOE->ODR |= (CS_PIN);
  }

#else
#ifndef LCD_FAST_PROTECT
  if (stato == OFF)             // fast execution 18/07/2021 Nick (4)
  {
    GPIOE->ODR &= (~CS_PIN);
  }
  else
  {
    GPIOE->ODR |= (CS_PIN);
  }
#else
  if (stato == OFF)
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_CS], LCD_PIN[LCD_CS], GPIO_PIN_RESET);
  }
  else
  {
    HAL_GPIO_WritePin(LCD_PORT[LCD_CS], LCD_PIN[LCD_CS], GPIO_PIN_SET);
  }
#endif
#endif
}

/**
  * @brief  Read 4 bit data bus in low nibble .
  * @retval nibble read
  */
uint8_t Read_LcdData (void)
{
#ifdef GRAPHICS_LCD
  uint8_t val;

  val = (uint8_t)((GPIOE->IDR >> DATA_OFFSET) & DATA_IN_MASK);
#else
#ifndef LCD_FAST_PROTECT
  uint8_t val;

  val = (uint8_t)((GPIOE->IDR >> DATA_OFFSET) & DATA_IN_MASK); // fast execution 18/07/2021 Nick (5)
#else
  uint8_t i, mask, val;

  for (i = 0, mask = 0x01, val = 0; i <= LCD_DB3; i++, mask = mask << 1)
    //for (i = 0, mask = 0x08, val = 0; i <= LCD_DB3; i++, mask = mask >> 1)
  {
    if (GPIO_PIN_SET == HAL_GPIO_ReadPin(LCD_PORT[i], LCD_PIN[i]))
    {
      val |= mask;
    }
  }
#endif
#endif
  return (val);
}

/**
  * @brief  write 4 bit data bus taken it from low nibble .
  * @retval nibble read
  */
void Write_LcdData (uint8_t val)
{
#ifdef GRAPHICS_LCD_FAST
  uint32_t outVal;

  outVal = ((uint32_t)GPIOE->ODR && DATA_OUT_MASK);
  outVal |= (((uint32_t)val << DATA_OFFSET) & DATA_OUT_MASK);
  GPIOE->ODR = outVal;
#else
#ifndef LCD_FAST_PROTECT
  uint32_t outVal;

  outVal = (uint32_t)GPIOE->ODR;
  outVal &= (~DATA_OUT_MASK);
  outVal |= ((uint32_t)val << DATA_OFFSET);  // fast execution 18/07/2021 Nick (6)
  GPIOE->ODR = outVal;
#else
  uint8_t i, mask;

  for (i = 0, mask = 0x01; i <= LCD_DB3; i++, mask = mask << 1)
    //for (i = 0, mask = 0x08; i <= LCD_DB3; i++, mask = mask >> 1)
  {
    if ((val & mask) == mask)
    {
      HAL_GPIO_WritePin(LCD_PORT[i], LCD_PIN[i], GPIO_PIN_SET);
    }
    else
    {
      HAL_GPIO_WritePin(LCD_PORT[i], LCD_PIN[i], GPIO_PIN_RESET);
    }
  }
#endif
#endif
}

/**          code for graphic display 192x32 pixel WG19232C5-TMI-V#T  *****/

/**
*
* @brief        Init the pointer in display area
*
* @param [in]   int8_t: row index (0..31)
* @param [in]   int8_t: coloum  index (0..191)
*
* @retval       none
*
***********************************************************************************************************************/
static void graphic_address(char x, char y)
{
  WriteIns(0x80 | x);
  WriteIns(0x80 | y);
}


/**
*
* @brief        show a stored picture
*
* @param [in]   uint8_t*: pointer to the picture array
*
* @retval       none
*
***********************************************************************************************************************/
static void show_pic(uint8_t arr[][MAX_COL / 8])
{
  uint8_t   i, j;

  WriteIns(0x2e);       // extended instruction ON

  for(j = 0; j < MAX_ROW; j++)
  {
    graphic_address(j, 0x00);

    for(i = 0; i < MAX_COL / 8; i++)
    {
      LcdData(arr[j][i]);   // WriteData(arr[j][i]);
    }
  }
}

/**
*
* @brief        show a stored picture
*
* @param [in]   uint8_t*: pointer to the picture array
*
* @retval       none
*
***********************************************************************************************************************/
static void show_picCountry(uint8_t arr[][COUNTRY_COL / 8])
{
  uint8_t   i, j;

  WriteIns(0x2e);       // extended instruction ON

  for(j = 0; j < MAX_ROW; j++)
  {
    graphic_address(j, 0x00);

    for(i = 0; i < COUNTRY_COL / 8; i++)
    {
      LcdData(arr[j][i]);   // WriteData(arr[j][i]);
    }
  }
}

/**
*
* @brief        Try to show a picture for test
*
* @param [in]   none
*
* @retval       none
*
***********************************************************************************************************************/
void test_pic(uint8_t picIx)
{
  taskENTER_CRITICAL();
  if (picIx < (uint8_t)NUM_COUNTRY)
  {
    switch (picIx)
    {
      case IT:
        show_pic((uint8_t (*)[MAX_COL / 8])showCardIT);
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])italiaPic);
        break;

      case FR:
        show_pic((uint8_t (*)[MAX_COL / 8])showCardFR);
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])franciaPic);
        break;

      case UK:
        show_pic((uint8_t (*)[MAX_COL / 8])showCardUK);
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])ukPic);
        break;

      case AS:
        show_pic((uint8_t (*)[MAX_COL / 8])araboWelcome);
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])asPic);
        break;

      case CZ:
        show_pic((uint8_t (*)[MAX_COL / 8])showCardCZ);
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])asPic);
        break;

      case PULS1:
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])pulsante1Pic);
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])dito1);
        break;

      case PULS2:
        //show_picCountry((uint8_t (*)[COUNTRY_COL / 8])pulsante2Pic);
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])dito2);
        break;

      case RCBO1:
#ifdef NO_RCBO_TEXT
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])rcbo1Pic);
#else
        show_pic((uint8_t (*)[MAX_COL / 8])rcbo1Pic);
#endif
        break;

      case RCBO2:
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])rcbo2Pic);
        break;

      case RCBO3:
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])rcbo3Pic);
        break;

      case RCBO4:
        show_picCountry((uint8_t (*)[COUNTRY_COL / 8])rcbo4Pic);
        break;

      default:
        break;
    }
  }
  else
  {
    if (picIx == (uint8_t)10)
    {
      show_pic((uint8_t (*)[MAX_COL / 8])pic);
    }
  }
  taskEXIT_CRITICAL();
}


// Ex lcddrv.c
/*************************************************************************************************

  Funzione:     clear

  Descrizione:     Cancellazione display

*************************************************************************************************/
void clear(void)
{
  LcdCmd(CLEAR_DISPLAY);
}

/*************************************************************************************************

  Funzione:
    gotoxy

  Descrizione:
    Posizionamento cursore

  Parametri in ingresso:
    x = coordinata x (1..20)
    y = coordinata y (1..4)

*************************************************************************************************/
void gotoxy(uint8_t x, uint8_t y)
{
  uint8_t cmd;

  switch (y)
  {
    default:
    case 1: cmd = POS_RIGA_1;   break;

    case 2: cmd = POS_RIGA_2; break;

    case 3: cmd = POS_RIGA_3; break;

    case 4: cmd = POS_RIGA_4; break;
  }

  LcdCmd(cmd + x - 1);
}

/*************************************************************************************************

  Funzione:
    set_cursor

  Descrizione:
    Programmazione cursore

  Parametri in ingresso:
    x    = coordinata x (1..20)
    y    = coordinata y (1..4)
    tipo = tipo cursore

*************************************************************************************************/
void set_cursor(uint8_t x, uint8_t y, uint8_t cursore)
{
  uint8_t cmd;

  gotoxy(x, y);

  switch (cursore)
  {
    default:
    case NO_CURSOR:
      cmd = CURSOR_OFF;
      break;

    case CURSOR_UNDERSCORE:
      cmd = CURSOR_ON_NO_BLINK;
      break;

    case CURSOR_BLINK:
      cmd = CURSOR_ON_BLINK;
      break;
  }

  LcdCmd(cmd);
}

/*************************************************************************************************

  Funzione:
    putcxy

  Descrizione:
    Visualizzazione di un carattere (DATA)

  Parametri in ingresso:
    x = coordinata x (1..20)
    y = coordinata y (1..4)
    c = carattere da visualizzare

*************************************************************************************************/
void putcxy(uint8_t x, uint8_t y, char c)
{
  gotoxy(x, y);
  LcdData(c);
}

/*************************************************************************************************

  Funzione:
    putsxy_c

  Descrizione:
    Visualizzazione di una stringa (CODE)

  Parametri in ingresso:
    x  = coordinata x (1..20)
    y  = coordinata y (1..4)
    *s = puntatore alla stringa

*************************************************************************************************/
void putsxy_c(uint8_t x, uint8_t y, char const *s)
{
  uint8_t  result;
  char    *pLcdStr;
  uint8_t  RetVal;

  do 
  {
    result = (uint8_t)TRUE;
    pLcdStr = (char*)s;
#ifndef GRAPHICS_LCD
    if (y == 1)
    {
      if (evs_state_get() == EVSTATE_SOCKET_AVAILABLE)
      {
        /*      destination      source       length */
        memcpy((void*)&pLcdStr[15], (void*)getTimePtr(), (size_t)5);
      }
    }
    if ((upgradeLcd == UPG_LCD_ENABLED) && (memcmp((const void*)pLcdStr, (void*)lcd_locline[y-1], (size_t)LCD_CHAR_NUM) != 0))
    //if (upgradeLcd == UPG_LCD_ENABLED)
    {
      if (cnttChange == CNNT_CHANGE_ONGOING)
      {
        cnttChange = CNNT_CHANGE_OFF;
        osDelay(50);
        Lcd2x20FastInit();
      }
      /*           destination          source                size */
      memcpy((void*)&lcd_locline[y-1][0], (void*)pLcdStr, (size_t)LCD_CHAR_NUM);

#ifdef LCD_PROTECT
      taskENTER_CRITICAL();
#endif

      /* disable sysTick so FreeRTOS cannot switch task  */
      setSysTickStatus(TRUE);

      gotoxy(x, y);

      for (; *pLcdStr != TERMINATORE && x < NUM_CAR_DISP + 1; pLcdStr++, x++)
      {
        if(*pLcdStr == 'Õ')
          LcdData(0x7F);    // Modifica x visualizzare car. Greco Delta (caratteri Ascii minimi)
        else
          LcdData(*pLcdStr);
      }

      if (lcdHwMng == LCD_MODE_FULL_BIDIR)
      {
        LcdCmd(ADDR_LITTLEMAN);   // set address in CGRAM
        RetVal = LcdRead();
        if (RetVal != littleMan[0])
        {
          result = FALSE;
          lcd_locline[0][0] = lcd_locline[1][0] = '\0';
          /* we try to re-init the LCD */
          Lcd2x20FastInit();
        }
      }
      /* enable sysTick */
      setSysTickStatus(FALSE);

#ifdef LCD_FAST_PROTECT
      taskEXIT_CRITICAL();
#endif
    }
#endif
  }while (result == FALSE);
}

/**
*
* @brief       LCD reprogramming on contactor change status 
*              flag
*
* @param [in]  none
*
* @retval      none
*
****************************************************************/
void cnttStatusChange (void)
{
  cnttChange = CNNT_CHANGE_ONGOING;
}

// Fine lcddrv.c
#if 0
// =============================================
void WaitLcdBus (uint32_t Time)
{
  uint32_t Idx;

  for (Idx = 0; Idx < Time; Idx++);
}
#endif

// =============================================
void ResetLcdBus ()
{
  LcdRw(OFF);
  LcdSetWriteDir();
  LcdRs(OFF);
  LcdEnable(OFF);
}


// =============================================
void LcdWrite (uint8_t Data, uint8_t Reg, uint8_t Nibble)
{
  if (!Nibble)
    LcdWaitBusy();        // Wait abilitazione LCD


  if (Reg == REGDR)
    LcdRs(ON);

  LcdEnable(ON);
  //uSecWwaitTime(MIN_TIME_EN_VAL);
  WriteLcdData((Data >> 4) & 0x0F); // Output Data
  uSecWwaitTime(minTimeEnVal);
  LcdEnable(OFF);

  if (!Nibble)
  {
    uSecWwaitTime(MIN_HOLD_EN_VAL);
    LcdEnable(ON);
    //uSecWwaitTime(MIN_TIME_EN_VAL);
    WriteLcdData(Data & 0x0F);
    uSecWwaitTime(minTimeEnVal);
    LcdEnable(OFF);
  }

  uSecWwaitTime(MIN_HOLD_EN_VAL);

  if (Reg == REGDR)
    LcdRs(OFF);

  GPIOE->ODR &= (uint32_t)(0x0000FB74);

}

// =============================================
static uint8_t LcdReadBusyFlag ()
{
  uint8_t TmpVal;
  uint8_t ReadVal;

  LcdSetReadDir();

  LcdRw(ON);
  LcdRs(OFF);
  uSecWwaitTime(minTimeEnVal);
  LcdEnable(ON);      // Set CS
  uSecWwaitTime(minTimeEnVal);
  ReadLcdData(TmpVal);  // Read Data  Read_LcdData
  //uSecWwaitTime(MIN_TIME_EN_VAL);
  LcdEnable(OFF);     // Reset CS
  uSecWwaitTime(MIN_HOLD_EN_VAL);
  if (lcdHwMng == LCD_MODE_OPEN_DRAIN)
  {
    TmpVal = 0;
  }
  ReadVal = ((TmpVal << 4) & 0xF0);

  // Lettura 4LSbit
  LcdEnable(ON);      // Set CS
  uSecWwaitTime(minTimeEnVal);
  ReadLcdData(TmpVal);  // Read Data
  //uSecWwaitTime(MIN_TIME_EN_VAL);
  LcdEnable(OFF);     // Reset CS
  ReadVal |= (TmpVal & 0x0F);

  ResetLcdBus();

  return ReadVal;
}

// =============================================
static uint8_t LcdRead ()
{
  uint8_t TmpVal;
  uint8_t ReadVal;                                      
                                                        
  LcdSetReadDir();                                      
                                                        
  LcdRw(ON);                                            
  LcdRs(ON);                                          
  uSecWwaitTime(minTimeEnVal);                        
  LcdEnable(ON);      // Set CS                         
  uSecWwaitTime(minTimeEnVal);                          
  ReadLcdData(TmpVal);  // Read Data                    
  //uSecWwaitTime(MIN_TIME_EN_VAL);                     
  LcdEnable(OFF);     // Reset CS                       
  uSecWwaitTime(MIN_HOLD_EN_VAL);                       
  ReadVal = ((TmpVal << 4) & 0xF0);                     
                                                        
  // Lettura 4LSbit                                     
  LcdEnable(ON);      // Set CS                         
  uSecWwaitTime(minTimeEnVal);                          
  ReadLcdData(TmpVal);  // Read Data                    
  //uSecWwaitTime(MIN_TIME_EN_VAL);                     
  LcdEnable(OFF);     // Reset CS                       
  ReadVal |= (TmpVal & 0x0F);                           
                                                        
  ResetLcdBus();                                        
                                                        
  return ReadVal;                                       
}                                                       

/**
*
* @brief       Check the busy flag status
*
* @param [in]  none
*
* @retval      uint8_t: TRUE if the LCD is free within timeout
*
****************************************************************/
uint8_t LcdWaitBusy ()
{
  uint8_t RetVal;
  uint16_t  Cnt;

  for (Cnt = 0; Cnt < MAX_BUSYFLAG_WAIT; Cnt++)
  {
    RetVal = LcdReadBusyFlag();

    if ((RetVal & 0x80) == 0)
      return TRUE;
  }

  return FALSE;
}

// =============================================
void Lcd2x20Init(void)
{
  minTimeEnVal = MIN_TIME_EN_INI_VAL;

  lcdHwMng = getLcdHwMng();
  /* init hw pins */
  LCD_IO_Init();

  ResetLcdBus();

  // Total wait = 45ms
  HAL_Delay(45);
  //WaitLcdBus(0x1D00);   // Wait 15ms

  LcdCmdNibbleNW(0x30);
  HAL_Delay(5);
  //WaitLcdBus(0x800);    // Wait 4.1ms

  LcdCmdNibbleNW(0x30);
  HAL_Delay(2);
  //WaitLcdBus(0x30);   // Wait 100uS

  LcdCmdNibbleNW(0x30);
  LcdWaitBusy();


  LcdCmdNibbleNW(0x20);
  LcdWaitBusy();

#ifdef GRAPHICS_LCD
  LcdCmd(0x20);   // Set 4bit bus, basic instruction
  LcdCmd(0x0C);   // Display control Display shift right by 1, cursor also follows the to shift
  LcdCmd(0x06);   // Cursor move to right, no shift
  LcdCmd(0x02);   // set DDRAM counter (AC) to 0
  LcdCmd(0x01);   // Clear Display
#else
#ifdef REDUCE_CLOCK
  HAL_Delay(10);
  LcdCmd(0x28);   // Set 4bit bus, 2 linee, 5x7 dots
  HAL_Delay(10);
  LcdCmd(0x08);   // Display, cursor, blink all off
  HAL_Delay(10);
  LcdCmd(0x01);   // Clear Display
  HAL_Delay(10);
  LcdCmd(0x06);   // Cursor move to right, no shift
  HAL_Delay(10);
  LcdCmd(0x0C);   // Display On, cursor and blink off
  HAL_Delay(10);
#else
  LcdCmd(0x28);   // Set 4bit bus, 2 linee, 5x7 dots
  LcdCmd(0x08);   // Display, cursor, blink all off
  LcdCmd(0x01);   // Clear Display
  //HAL_Delay(10);
  LcdCmd(0x06);   // Cursor move to right, no shift
  LcdCmd(0x0C);   // Display On, cursor and blink off
#endif
#endif

  createCustomChar((uint8_t*)littleMan, 1);  // create a char in second position inside CGRAM 

  minTimeEnVal = MIN_TIME_EN_VAL;

  LcdContrastInit();

#if PWM_ACTIVE==1    // check the status in IAR preprocessor option 
  /* start task del PWM */
  setPWMlcd2x20();
  /* start also PWM for led RGB */
  setPWM_LEDA();   // led Blue
  setPWM_LEDB();   // led Green
  setPWM_LEDC();   // led Red
#endif
}

// =============================================
void LcdData(uint8_t Data)
{
  LcdWrite(Data, REGDR, FALSE);
}

// =============================================
void LcdCmd(uint8_t Data)
{
  LcdWrite(Data, REGIR, FALSE);
}

// =============================================
void LcdContrastInit (void)
{
#ifdef RESTORE_FROM_EEPROM
  uint16_t  percent;
  uint8_t ContrastLevel = 1;

  ContrastLevel = leggi_eeprom(ADDR_EEP(contrasto));

  percent = (uint16_t) ((uint16_t) ContrastLevel * 100) / MAX_CONTRAST_LEV;
  setContrastPWMlcd4x20((uint8_t)percent); // new function
#else
  LcdUpDownContrast((uint32_t)300);
#endif
}

// =============================================
// In setting.c viene passato il nuovo valore di
// contrasto
// =============================================
void LcdUpDownContrast (uint32_t ContrastLevel)
{

  if ((ContrastLevel > MAX_CONTRAST_LEV) || (ContrastLevel < MIN_CONTRAST_LEV))
    return;

  /*  Set DAC channel1 DHR12RD register ################################################*/
  if (HAL_DAC_SetValue(&DacHandle, DACx_CHANNEL, DAC_ALIGN_12B_R, ContrastLevel) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

}

/**
*
* @brief        programmazione PWM hardware
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void setPWMlcd2x20 (void)
{
  GPIO_InitTypeDef    GPIO_InitStruct;
  uint32_t            uwPrescalerValue = 0;
  /* Timer Output Compare Configuration Structure declaration */
  TIM_OC_InitTypeDef  sConfig;

  /* TIM1 clock enable */
  TIMLCD4X20_CLK_ENABLE();

  /* Enable the GPIO used for LCD4X20 PWM clock */
  PWMLCD4X20_GPIO_CLK_ENABLE();

  /* GPIOx Configuration: TIM5 CH2 (PH11)  */
  GPIO_InitStruct.Pin       = PWMLCD4X20_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = PWMLCD4X20_AF;

  HAL_GPIO_Init(PWMLCD4X20_GPIO_PORT, &GPIO_InitStruct);

  /*##-1- Configure the TIM peripheral #######################################*/
  /* -----------------------------------------------------------------------
    In this example TIM5 input clock (TIM5CLK) is set to 2 * APB1 clock (PCLK1),
    since APB1 prescaler is different from 1.
      TIM5CLK = 2 * PCLK1
      PCLK1 = HCLK / 4
      => TIM5CLK = HCLK / 2 = SystemCoreClock / 2
    To get TIM5 counter clock at 1KHz, the Prescaler is computed as following:
    Prescaler = (TIM5CLK / TIM5 counter clock) - 1
    Prescaler = ((SystemCoreClock / 2 ) /1 KHz) - 1



    Note:
     SystemCoreClock variable holds HCLK frequency and is defined in system_stm32f4xx.c file.
     Each time the core clock (HCLK) changes, user had to update SystemCoreClock
     variable value. Otherwise, any configuration based on this variable will be incorrect.
     This variable is updated in three ways:
      1) by calling CMSIS function SystemCoreClockUpdate()
      2) by calling HAL API function HAL_RCC_GetSysClockFreq()
      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency
  ----------------------------------------------------------------------- */

  /* Compute the prescaler value to have TIM5 counter clock equal to 10MHz */
  uwPrescalerValue = ((SystemCoreClock) / 10000000) - 1;

  /* Set TIMPWMLCD4X20 instance */
  htim.Instance = TIMLCD4X20;

  /* Initialize TIM5 peripheral as follows:
       + Period = 100000 - 1
       + Prescaler = ((SystemCoreClock/2)/100000) - 1
       + ClockDivision = 0
       + Counter direction = Up
  */
  htim.Init.Prescaler     = uwPrescalerValue;
  htim.Init.Period        = PWMLCD4X20_PERIOD_VALUE;  // now 100/10000 KHz = 0,01msec (100KHz)
  htim.Init.ClockDivision = 0;                        // quindi prendiamo un campione ogni 10msec
  htim.Init.CounterMode = TIM_COUNTERMODE_UP;

  if(HAL_TIM_PWM_Init(&htim) != HAL_OK)
  {
    /* Initialization Error */
    lcd4X20_Handler();
  }

  /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_PWM1;;
  sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCNPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCFastMode = TIM_OCFAST_DISABLE;

  /* Set the pulse value for channel 4 */
  sConfig.Pulse = PWMLCD4X20_MIN_DC;

  if(HAL_TIM_PWM_ConfigChannel(&htim, &sConfig, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  if(HAL_TIM_OC_Stop_IT(&htim, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* Interrupt not necessaryr */
    lcd4X20_Handler();
  }

  /* TIM1  enable for PWM on PE14 on channel 4 */
  /* on channel 4 */
  if(HAL_TIM_PWM_Start(&htim, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }

}

/**
*
* @brief        PWM LED RBG - A Blue (on the same timer TIM1 of LCD)
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
static void setPWM_LEDA (void)
{
  GPIO_InitTypeDef    GPIO_InitStruct;
  /* Timer Output Compare Configuration Structure declaration */
  TIM_OC_InitTypeDef  sConfig;

  /* TIM1 clock enable */
  TIMLED_A_CLK_ENABLE();

  /* Enable the GPIO used for LED A PWM clock */
  PWMLED_A_GPIO_CLK_ENABLE();

  /* GPIOx Configuration: TIM1 CH1 (PE9)  */
  GPIO_InitStruct.Pin       = PWMLED_A_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = PWMLED_A_AF;

  HAL_GPIO_Init(PWMLED_A_GPIO_PORT, &GPIO_InitStruct);

  /*##-1- Configure the TIM peripheral #######################################*/

  /* Remember: tick TIM 1 is 10MHz */
  /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_PWM1;;
  sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCNPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCFastMode = TIM_OCFAST_DISABLE;

  /* Set the pulse value for channel 1 */
  sConfig.Pulse = PWMLED_A_MIN_DC;

  if(HAL_TIM_PWM_ConfigChannel(&htim, &sConfig, PWMLED_A_TIM_CHx) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  if(HAL_TIM_OC_Stop_IT(&htim, PWMLED_A_TIM_CHx) != HAL_OK)
  {
    /* Interrupt not necessaryr */
    lcd4X20_Handler();
  }

  /* TIM1  enable for PWM on PE9 on channel 1 */
  if(HAL_TIM_PWM_Start(&htim, PWMLED_A_TIM_CHx) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }
}

/**
*
* @brief        PWM LED RBG - B Green (on the same timer TIM1 of LCD)
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
static void setPWM_LEDB (void)
{
  GPIO_InitTypeDef    GPIO_InitStruct;
  /* Timer Output Compare Configuration Structure declaration */
  TIM_OC_InitTypeDef  sConfig;

  /* TIM1 clock enable */
  TIMLED_B_CLK_ENABLE();

  /* Enable the GPIO used for LED B PWM clock */
  PWMLED_B_GPIO_CLK_ENABLE();

  /* GPIOx Configuration: TIM1 CH1 (PE11)  */
  GPIO_InitStruct.Pin       = PWMLED_B_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = PWMLED_A_AF;

  HAL_GPIO_Init(PWMLED_B_GPIO_PORT, &GPIO_InitStruct);

  /*##-1- Configure the TIM peripheral #######################################*/

  /* Remember: tick TIM 1 is 10MHz */
  /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_PWM1;;
  sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCNPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCFastMode = TIM_OCFAST_DISABLE;

  /* Set the pulse value for channel 2 */
  sConfig.Pulse = PWMLED_B_MIN_DC;

  if(HAL_TIM_PWM_ConfigChannel(&htim, &sConfig, PWMLED_B_TIM_CHx) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  if(HAL_TIM_OC_Stop_IT(&htim, PWMLED_B_TIM_CHx) != HAL_OK)
  {
    /* Interrupt not necessaryr */
    lcd4X20_Handler();
  }

  /* TIM1  enable for PWM on PE11 on channel 2 */
  if(HAL_TIM_PWM_Start(&htim, PWMLED_B_TIM_CHx) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }
}

/**
*
* @brief        PWM LED RBG - C Red (on the same timer TIM1 of LCD)
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void setPWM_LEDC (void)
{
  GPIO_InitTypeDef    GPIO_InitStruct;
  /* Timer Output Compare Configuration Structure declaration */
  TIM_OC_InitTypeDef  sConfig;

  /* TIM1 clock enable */
  TIMLED_C_CLK_ENABLE();

  /* Enable the GPIO used for LED C PWM clock */
  PWMLED_C_GPIO_CLK_ENABLE();

  /* GPIOx Configuration: TIM1 CH3 (PE13)  */
  GPIO_InitStruct.Pin       = PWMLED_C_PIN;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = PWMLED_A_AF;

  HAL_GPIO_Init(PWMLED_C_GPIO_PORT, &GPIO_InitStruct);

  /*##-1- Configure the TIM peripheral #######################################*/

  /* Remember: tick TIM 1 is 10MHz */
  /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_PWM1;;
  sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCNPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCFastMode = TIM_OCFAST_DISABLE;

  /* Set the pulse value for channel 3 */
  sConfig.Pulse = PWMLED_C_MIN_DC;

  if(HAL_TIM_PWM_ConfigChannel(&htim, &sConfig, PWMLED_C_TIM_CHx) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  if(HAL_TIM_OC_Stop_IT(&htim, PWMLED_C_TIM_CHx) != HAL_OK)
  {
    /* Interrupt not necessaryr */
    lcd4X20_Handler();
  }

  /* TIM1  enable for PWM on PE13 on channel 3 */
  if(HAL_TIM_PWM_Start(&htim, PWMLED_C_TIM_CHx) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }
}

/**
*
* @brief        Stop PWM
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void stopPWMlcd2x20 (void)
{
  GPIO_InitTypeDef  GPIO_InitStruct;

  /* TIM1  enable for PWM on PE14 on channel 4 */
  /* on channel 4 */
  if(HAL_TIM_PWM_Stop(&htim, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }

  /* Configure the GPIO_LED pin in push-pull output mode */
  GPIO_InitStruct.Pin = PWMLCD4X20_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FAST;

  HAL_GPIO_Init(PWMLCD4X20_GPIO_PORT, &GPIO_InitStruct);

  HAL_GPIO_WritePin(PWMLCD4X20_GPIO_PORT, PWMLCD4X20_PIN, GPIO_PIN_RESET);

}

/**
*
* @brief        Stop PWM
*
* @param [in ]  ledIdx_e: led id to stop
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
static void stopPWM_LEDx (ledIdx_e led)
{
  GPIO_InitTypeDef    GPIO_InitStruct;
  uint32_t            GPIO_PinId;

  if ((led != LED_A_BLU) && (led != LED_B_GREEN) && (led != LED_C_RED))
  {
    return;
  }

  /* GPIOx Configuration: TIM1 CHx (PEx)  */
  switch (led)
  {
    case LED_A_BLU:
      GPIO_PinId       = PWMLED_A_PIN;
      break;

    case LED_B_GREEN:
      GPIO_PinId       = PWMLED_B_PIN;
      break;

    case LED_C_RED:
      GPIO_PinId       = PWMLED_C_PIN;
      break;

    default:
      break;
  }

  /* PWM LED use all the same port */
  HAL_GPIO_DeInit(PWMLED_A_GPIO_PORT, GPIO_PinId);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(PWMLED_A_GPIO_PORT, GPIO_PinId, GPIO_PIN_RESET);
  /* GPIOx Configuration: Output to 0   */
  GPIO_InitStruct.Pin       = GPIO_PinId;
  GPIO_InitStruct.Mode      = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = (uint32_t)0;

  HAL_GPIO_Init(PWMLED_A_GPIO_PORT, &GPIO_InitStruct);
}


/**
*
* @brief        Restart PWM
*
* @param [in ]  none
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void restartPWMlcd2x20 (void)
{
  /* TIM1  enable for PWM on PE14 on channel 4 */
  /* on channel 4 */
  if(HAL_TIM_PWM_Start(&htim, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }
}


/**
*
* @brief        backlight level setting
*
* @param [in ]  uint8_t - new value for contrast level
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void setBacklightPWMlcd4x20 (uint8_t percentValue)
{
  TIM_OC_InitTypeDef  sConfig;

  if (percentValue > (uint8_t)100)
  {
    return;
  }

  if (percentValue == (uint8_t)0)
  {
    stopPWMlcd2x20();
    return;
  }


  /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_PWM1;;
  sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCFastMode = TIM_OCFAST_DISABLE;

  /* Set the pulse value for channel 2 */
  sConfig.Pulse = (uint32_t)percentValue;

  if(HAL_TIM_PWM_ChangeDutyChannel(&htim, &sConfig, PWMLCD4X20_TIM_CHx) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }
}

/**
*
* @brief        backlight level setting
*
* @param [in ]  uint8_t - new value for contrast level
* @param [in ]  ledIdx_e: led id to restart
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void setPWM_Ledx (ledIdx_e led, uint8_t percentValue)
{
#ifndef COLLAUDO_PEN
  TIM_OC_InitTypeDef  sConfig;
  GPIO_InitTypeDef    GPIO_InitStruct;
  uint32_t            GPIO_PinId, TimCh;
#else
  uint32_t            GPIO_PinId;
  uint8_t             relayIdx;
#endif

  if ((led != LED_A_BLU) && (led != LED_B_GREEN) && (led != LED_C_RED))
  {
    return;
  }

  if (percentValue > (uint8_t)100)
  {
    return;
  }

#ifdef COLLAUDO_PEN
  /* nel colllaudo PEN li tratto come I/O e non come PWM   */
  switch (led)
  {
    case LED_A_BLU:
      GPIO_PinId       = PWMLED_A_PIN;
      relayIdx = 3;
      break;

    case LED_B_GREEN:
      GPIO_PinId       = PWMLED_B_PIN;
      relayIdx = 4;
      break;

    case LED_C_RED:
      GPIO_PinId       = PWMLED_C_PIN;
      relayIdx = 5;
      break;

    default:
      break;
  }
  if (percentValue <= (uint8_t)10)
  {
    /* stato off --> metto il pin a 0 */
    HAL_GPIO_WritePin(GPIOE, GPIO_PinId, GPIO_PIN_RESET);
    tPrintf("Disattivazione relè R%d\n\r", relayIdx);
  }
  else
  {
    /* stato off --> metto il pin a 1 */
    HAL_GPIO_WritePin(GPIOE, GPIO_PinId, GPIO_PIN_SET);
    tPrintf("Attivazione relè R%d\n\r", relayIdx);
  }
  return;
#else

  if (percentValue == (uint8_t)0)
  {
    stopPWM_LEDx(led);
    return;
  }

  /* GPIOx Configuration: TIM1 CHx (PEx)  */
  switch (led)
  {
    case LED_A_BLU:
      GPIO_PinId       = PWMLED_A_PIN;
      TimCh            = PWMLED_A_TIM_CHx;
      break;

    case LED_B_GREEN:
      GPIO_PinId       = PWMLED_B_PIN;
      TimCh            = PWMLED_B_TIM_CHx;
      break;

    case LED_C_RED:
      GPIO_PinId       = PWMLED_C_PIN;
      TimCh            = PWMLED_C_TIM_CHx;
      break;

    default:
      break;
  }

  /* GPIOx Configuration: TIM1 CHx (PEx)  */
  GPIO_InitStruct.Pin       = GPIO_PinId;
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull      = GPIO_PULLUP;
  GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
  GPIO_InitStruct.Alternate = PWMLED_A_AF;

  HAL_GPIO_Init(PWMLED_A_GPIO_PORT, &GPIO_InitStruct);

  /* Common configuration for all channels */
  sConfig.OCMode     = TIM_OCMODE_PWM1;;
  sConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfig.OCFastMode = TIM_OCFAST_DISABLE;
  /* Set the pulse value for channel x */
  sConfig.Pulse = (uint32_t)percentValue;

  if(HAL_TIM_PWM_ChangeDutyChannel(&htim, &sConfig, TimCh) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  if(HAL_TIM_OC_Stop_IT(&htim, TimCh) != HAL_OK)
  {
    /* Interrupt not necessary */
    lcd4X20_Handler();
  }

  /* TIM1  enable for PWM on PEx on channel x */
  if(HAL_TIM_PWM_Start(&htim, TimCh) != HAL_OK)
  {
    /* PWM error  */
    lcd4X20_Handler();
  }
#endif
}


/*
  * @brief  Generate msec delay .
  * @retval uint16_t: msec to delay
  */
void waitTime(uint16_t msDelay)
{
  HAL_Delay((uint32_t)msDelay);
}

/*
  * @brief  Generate usec  delay Based on SysTick->VAL (decrement in the time).
  * @retval uint16_t: usec to delay
  */
void uSecWwaitTime (uint16_t usDelay)
{
  uint32_t  toSysTick;

  /* here we suppose up at maximum speed: 216MHz */
  if (SysTick->VAL > (216 * usDelay))
  {
    /* remember: sysTick is a timer with decrement */
    toSysTick = SysTick->VAL - (216 * usDelay);
  }
  else
  {
    toSysTick = 216000 - ((216 * usDelay) - SysTick->VAL);

    while (((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != SysTick_CTRL_COUNTFLAG_Msk))
    {
      ;
    }
  }

  while (SysTick->VAL > toSysTick  )
  {
    ;
  }
}

/**
  * @brief  Change the TIM PWM  channels duty Cycle according to the specified
  *         parameters in the TIM_OC_InitTypeDef.
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @param  sConfig: TIM PWM configuration structure
  * @param  Channel: TIM Channels to be enabled.
  *          This parameter can be one of the following values:
  *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ChangeDutyChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
{

  __HAL_LOCK(htim);

  /* Check the parameters */
  assert_param(IS_TIM_CHANNELS(Channel));
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
  assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
  assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  htim->State = HAL_TIM_STATE_BUSY;

  switch (Channel)
  {
    case TIM_CHANNEL_1:
      {
        assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
        /* Set the Capture Compare Register value */
        htim->Instance->CCR1 = sConfig->Pulse;
      }
      break;

    case TIM_CHANNEL_2:
      {
        assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
        /* Set the Capture Compare Register value */
        htim->Instance->CCR2 = sConfig->Pulse;
      }
      break;

    case TIM_CHANNEL_3:
      {
        assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
        /* Set the Capture Compare Register value */
        htim->Instance->CCR3 = sConfig->Pulse;
      }
      break;

    case TIM_CHANNEL_4:
      {
        assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
        /* Set the Capture Compare Register value */
        htim->Instance->CCR4 = sConfig->Pulse;
      }
      break;

    default:
      break;
  }

  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);

  return HAL_OK;
}

static void contrastConfigDAC(void)
{
  /*##-1- Configure the DAC peripheral #######################################*/
  DacHandle.Instance = DACx;

  /*##-2- Initialize the DAC peripheral ######################################*/
  if (HAL_DAC_Init(&DacHandle) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  /*##-3- DAC channel1 Configuration #########################################*/
  sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
  sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;

  if (HAL_DAC_ConfigChannel(&DacHandle, &sConfig, DACx_CHANNEL) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  /*##-4- Enable DAC Channel2 ################################################*/
  if (HAL_DAC_Start(&DacHandle, DACx_CHANNEL) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

  /*##-5- Set DAC channel1 DHR12RD register ################################################*/
  if (HAL_DAC_SetValue(&DacHandle, DACx_CHANNEL, DAC_ALIGN_12B_R, 0x300) != HAL_OK)
  {
    /* Configuration Error */
    lcd4X20_Handler();
  }

}


/**
*
* @brief        set flag LCD upgrade 
*
* @param [in ]  uint8_t - status
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void setUpgradeLcd (upgLcd_e status)
{
  upgradeLcd = status;
}

/**
*
* @brief        fast init after every contactor change status  
*
* @param [in ]  none 
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
static void Lcd2x20FastInit(void)
{

  LcdSetWriteDir();

  LcdCmdNibbleNW(0x30);
  HAL_Delay(5);
  //WaitLcdBus(0x800);    // Wait 4.1ms

  LcdCmdNibbleNW(0x30);
  HAL_Delay(2);
  //WaitLcdBus(0x30);   // Wait 100uS

  LcdCmdNibbleNW(0x30);
  LcdWaitBusy();

  LcdCmdNibbleNW(0x20);
  LcdWaitBusy();

#ifdef GRAPHICS_LCD
  LcdCmd(0x20);   // Set 4bit bus, basic instruction
  LcdCmd(0x0C);   // Display control Display shift right by 1, cursor also follows the to shift
  LcdCmd(0x06);   // Cursor move to right, no shift
  LcdCmd(0x02);   // set DDRAM counter (AC) to 0
  LcdCmd(0x01);   // Clear Display
#else
  LcdCmd(0x28);   // Set 4bit bus, 2 linee, 5x7 dots
#endif

}

/**
*
* @brief        Put a new char in CGRAM  
*
* @param [in ]  uint8_t*: pointer to char definition  
* @param [in ]  uint8_t:  location in CGRAM where store the char  
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
static void createCustomChar    (uint8_t* pattern, uint8_t location)
{
  uint8_t   i;

  if (location < 8)
  {
    LcdCmd((uint8_t)0x40 + location * 8);   // set address in CGRAM
    for (i = 0; i < 8; i++)
    {
      LcdData(pattern[i]);  // the pattern char is passed to CGRAM
    }
  }

}

/**
*
* @brief        Put the contrast when in emergency condition   
*
* @param [in ]  none   
*
* @param [out]  none
*
* @retval       none
*
***********************************************************************************************************************/
void LcdPwrDwnContrast (void)
{
  contrastConfigDAC();
  LcdUpDownContrast((uint32_t)300);
}

/*************************************************************************************************

  Funzione:
    putsxy_c

  Descrizione:
    Visualizzazione di una stringa (CODE)

  Parametri in ingresso:
    x  = coordinata x (1..20)
    y  = coordinata y (1..4)
    n  = block downloaded 
    *s = puntatore alla stringa

*************************************************************************************************/
void putsxyDwnl_c(uint8_t x, uint8_t y, uint8_t n)
{
  char  *s;
  uint8_t i;

  gotoxy(x, y);

  if (y == 1) s = (char*)strDwnl;
  else
  {
    for (i = 0; i < NUM_CAR_DISP; i++)
    {
       if (i < n) lcd_locline[1][i] = '.'; else lcd_locline[1][i] = ' ';
    }
    s = (char*)&lcd_locline[1][0];
  }

  for (; *s != TERMINATORE && x < NUM_CAR_DISP + 1; s++, x++)
  {
    LcdData((uint8_t)*s);
  }
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
static void lcd4X20_Handler(void)
{
  while(1)
  {
  }
}


