###############################################################################
#
# IAR ANSI C/C++ Compiler V9.60.3.422/W64 for ARM         14/Oct/2025  09:40:45
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\Src\Protocol\sbcSem.c
#    Command line                 =
#        -f
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_DBG_HW_MP28947\Obj\Protocol_16990505445836233132.dir\sbcSem.o.rsp
#        (C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\Src\Protocol\sbcSem.c
#        -D USE_HAL_DRIVER -D STM32F427xx -D PWM_ACTIVE -D RFID_PWR_AS_LOW_PWR
#        -D CLIENTS_2 -D V230_MON_ACTIVE -D GD32F4xx -D DEBUG_TRACE_PIN -D
#        USE_SLEEP_MODE_WHEN_VOLTAGE_IS_ABSENT -D HTS_IMQ -D no_NTC_GAIN_1P5 -D
#        NTC_GAIN_6 -D MODBUS_TCP_EM_LOVATO -lC
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_DBG_HW_MP28947\List\Protocol_16990505445836233132.dir
#        -o
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_DBG_HW_MP28947\Obj\Protocol_16990505445836233132.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 --no_path_in_file_macros -e --fpu=VFPv4_sp
#        --dlib_config C:\iar\ewarm-9.60.3\arm\inc\c\DLib_Config_Full.h -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Inc\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/system\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM7/r0p1\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/netif/ppp\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Drivers/CMSIS/Device/ST/STM32F7xx/Include\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/lwip\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/lwip/apps\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/lwip/priv\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/lwip/prot\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/netif\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/compat/posix\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/compat/posix/arpa\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/compat/posix/net\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/compat/posix/sys\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/compat/stdc\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/system/arch\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\LIB\uartDbg\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\protocol\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\Device\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\coreApp\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\LIB\BSP\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\LIB\ftp\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\stationMng\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\LIB\uartEm\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\LIB\rfid\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\webserver\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\webserver\httpd\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Middlewares\BlueNRG-MS\includes\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Middlewares\BlueNRG-MS\utils\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Middlewares\BlueNRG-MS\hci\hci_tl_patterns\Basic\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Src\BlueTooth\Target\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Src\BlueTooth\Application\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Src\BlueTooth\Core\Inc\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Src\BlueTooth\BSP\Nucleo\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Inc\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\protocol\modbus\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\protocol\wifi\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Middlewares\ST\STM32_Cryptographic\include\
#        -On) --dependencies=n
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_DBG_HW_MP28947\Obj\Protocol_16990505445836233132.dir\sbcSem.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_DBG_HW_MP28947\List\Protocol_16990505445836233132.dir\sbcSem.lst
#    Object file                  =
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_DBG_HW_MP28947\Obj\Protocol_16990505445836233132.dir\sbcSem.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  1
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\Src\Protocol\sbcSem.c
      1          /**
      2          * @file        sbcSEM.c
      3          *
      4          * @brief       manager upgrade notify MDB register for SEM   - Implementation -
      5          *
      6          * @author      Nick
      7          *
      8          * @riskClass   C
      9          *
     10          * @moduleID
     11          *
     12          * @vcsInfo
     13          *     $Id: scuMdb.c 334 2023-11-06 11:11:45Z luca $
     14          *
     15          *     $Revision: 334 $
     16          *
     17          *     $Author: luca $
     18          *
     19          *     $Date: 2023-11-06 12:11:45 +0100 (lun, 06 nov 2023) $
     20          *
     21          *
     22          * @copyright
     23          *       Copyright (C) 2016 SCAME S.p.A. All rights reserved.
     24          *       This file is copyrighted and the property of Aesys S.p.A.. It contains confidential and proprietary
     25          *       information. Any copies of this file (in whole or in part) made by any method must also include a copy of this
     26          *       legend.
     27          *       Developed by:  SCAME S.p.A.
     28          ***********************************************************************************************************************/
     29          
     30          /************************************************************
     31           * Include
     32           ************************************************************/
     33          //#include <main.h>
     34          #include <stddef.h>
     35          #include <string.h>
     36          #include <stdlib.h>
     37          #include <stdio.h>
     38          #include <math.h>
     39          #ifdef GD32F4xx
     40          #include "stm32f4xx_hal.h"
     41          #include "stm32f4xx_ll_rcc.h"
     42          #else
     43          #include "stm32h5xx_hal.h"
     44          #include "stm32h5xx_ll_rcc.h"
     45          #endif
     46          #include "cmsis_os.h"
     47          #include "prot_OnUsart.h"
     48          #include "wrapper.h"
     49          #include "sbcUart.h"
     50          #include "scuMdb.h"
     51          #include "eeprom.h"
     52          #include "telnet.h"
     53          #include "sbcGsy.h"
     54          #include "uart_Legacy.h"
     55          #include "inputsMng.h"
     56          #include "rtcApi.h"
     57          #include "scheduleMng.h"   
     58          #include "httpserver-socket.h"
     59          #include "ExtInpMng.h"
     60          #include "RfidMng.h"
     61          #include "scuMdb.h"
     62          #include "sbcSem.h"
     63          #include "ioExp.h"
     64          #include "PwmMng.h"
     65          #include "LcdMng.h"
     66          #include "monitorMng.h"
     67          #include "telnet.h"
     68          
     69          /*
     70          ***********************************SCAME**************************************
     71          **                                                                          **
     72          **           LOCAL MACROS, TYPEDEF, STRUCTURE, ENUM                         **
     73          **                                                                          **
     74          ******************************************************************************
     75          */
     76          
     77          #define   DEFAULT_SBCSEM_TIME             pdMS_TO_TICKS((uint16_t)1000)
     78          #define   SBCSEM_TIMER_GARD_TIME          pdMS_TO_TICKS((uint16_t)500)
     79          
     80          #define   KEY_FULL_CONFIG                 ((uint16_t)0xAA55)
     81          #define   KEY_LOCAL_CONFIG                ((uint16_t)0xBB66)
     82          #define   KEY_SCU_SLAVE_LINKED_2          ((uint16_t)0xCC72)
     83          #define   KEY_SCU_SLAVE_LINKED_4          ((uint16_t)0xCC74)
     84          #define   KEY_FULL_MASTER_P_S             ((uint16_t)0xDD88)
     85          #define   KEY_FULL_MASTER_P               ((uint16_t)0x0088)
     86          #define   KEY_FULL_MASTER_S               ((uint16_t)0xDD00)
     87          
     88          #define   FACTOR_FOR_RANDOM_DELAY         ((uint16_t)64)
     89          // --------------------------------------------------------------------------------------------------------------------------- //
     90          
     91          /*
     92          ***********************************SCAME**************************************
     93          **                                                                          **
     94          **                            Local Const                                   **
     95          **                                                                          **
     96          ****************************************************************************** 
     97          */ 
     98          

   \                                 In section .rodata, align 4
     99          static const uint32_t   sbcSemMaskBit[SCU_NUM] = {
   \                     sbcSemMaskBit:
   \        0x0   0x0000'0001        DC32 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1'024, 2'048, 4'096, 8'192
   \              0x0000'0002  
   \              0x0000'0004  
   \              0x0000'0008  
   \              0x0000'0010  
   \              0x0000'0020  
   \              0x0000'0040  
   \              0x0000'0080  
   \              0x0000'0100  
   \              0x0000'0200  
   \              0x0000'0400  
   \              0x0000'0800  
   \              0x0000'1000  
   \              0x0000'2000
   \       0x38   0x0000'4000        DC32 16'384, 32'768
   \              0x0000'8000
    100            0x0001,    0x0002,    0x0004,    0x0008,    0x0010,     0x0020,     0x0040,     0x0080, 
    101            0x0100,    0x0200,    0x0400,    0x0800,    0x1000,     0x2000,     0x4000,     0x8000
    102          };
    103          

   \                                 In section .rodata, align 4
    104          static const char AddrUidStr[]       = "UID Athorization";
   \                     AddrUidStr:
   \        0x0   0x55 0x49          DC8 "UID Athorization"
   \              0x44 0x20    
   \              0x41 0x74    
   \              0x68 0x6F    
   \              0x72 0x69    
   \              0x7A 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x00
   \       0x11                      DS8 3

   \                                 In section .rodata, align 4
    105          static const char AddrEventFlag[]    = "Event Flag";
   \                     AddrEventFlag:
   \        0x0   0x45 0x76          DC8 "Event Flag"
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x46 0x6C    
   \              0x61 0x67    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
    106          static const char AddrChargStatus[]  = "Stato->";
   \                     AddrChargStatus:
   \        0x0   0x53 0x74          DC8 "Stato->"
   \              0x61 0x74    
   \              0x6F 0x2D    
   \              0x3E 0x00

   \                                 In section .rodata, align 4
    107          static const char AddrErr1[]         = "Error1";
   \                     AddrErr1:
   \        0x0   0x45 0x72          DC8 "Error1"
   \              0x72 0x6F    
   \              0x72 0x31    
   \              0x00
   \        0x7                      DS8 1

   \                                 In section .rodata, align 4
    108          static const char AddrErr2[]         = "Error2";
   \                     AddrErr2:
   \        0x0   0x45 0x72          DC8 "Error2"
   \              0x72 0x6F    
   \              0x72 0x32    
   \              0x00
   \        0x7                      DS8 1

   \                                 In section .rodata, align 4
    109          static const char AddrConnType[]     = "Connector Type";
   \                     AddrConnType:
   \        0x0   0x43 0x6F          DC8 "Connector Type"
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x6F    
   \              0x72 0x20    
   \              0x54 0x79    
   \              0x70 0x65    
   \              0x00
   \        0xF                      DS8 1

   \                                 In section .rodata, align 4
    110          static const char AddrSessId[]       = "Session Id";
   \                     AddrSessId:
   \        0x0   0x53 0x65          DC8 "Session Id"
   \              0x73 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x49 0x64    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
    111          static const char AddrEm[]           = "Energy Meter";
   \                     AddrEm:
   \        0x0   0x45 0x6E          DC8 "Energy Meter"
   \              0x65 0x72    
   \              0x67 0x79    
   \              0x20 0x4D    
   \              0x65 0x74    
   \              0x65 0x72    
   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
    112          static const char AddrMeasure[]      = "Measure";
   \                     AddrMeasure:
   \        0x0   0x4D 0x65          DC8 "Measure"
   \              0x61 0x73    
   \              0x75 0x72    
   \              0x65 0x00

   \                                 In section .data, align 4
    113          static const char *nameState[]       = {" Initial", " Idle",        " Preparing", " Ev Connected", " Charging", " Suspended Ev", " Suspended EvSe",   " End Charge",
   \                     nameState:
   \        0x0   0x....'....        DC32 ?_0, ?_1, ?_2, ?_3, ?_4, ?_5, ?_6, ?_7, ?_8, ?_9, ?_10, ?_11, ?_12
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....
   \       0x34   0x....'....        DC32 ?_13, ?_14
   \              0x....'....
    114                                                  " Faulted", " Unavailable", " Reserved",  " Bootloader",   "Shutdown",  " Rebooting",    " Suspended NoPower"};
    115          

   \                                 In section .rodata, align 4
    116          static const socketPresence_t Default_Socket_Presence = {.chainPresence = 0, .livePresence = 0, .keyPresence = KEY_FULL_CONFIG, .activityStatus = 0, 
   \                     Default_Socket_Presence:
   \        0x0   0x0000'0000        DC32 0, 0, 43'605, 0
   \              0x0000'0000  
   \              0x0000'AA55  
   \              0x0000'0000
   \       0x10   0x01 0x02          DC8 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
   \              0x03 0x04    
   \              0x05 0x06    
   \              0x07 0x08    
   \              0x09 0x0A    
   \              0x0B 0x0C    
   \              0x0D 0x0E    
   \              0x0F 0x10    
   \              0x11 0x12    
   \              0x13
   \       0x23   0x14 0x15          DC8 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 1, 2, 3, 4, 5
   \              0x16 0x17    
   \              0x18 0x19    
   \              0x1A 0x1B    
   \              0x1C 0x1D    
   \              0x1E 0x1F    
   \              0x20 0x01    
   \              0x02 0x03    
   \              0x04 0x05
   \       0x35   0x06 0x07          DC8 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23
   \              0x08 0x09    
   \              0x0A 0x0B    
   \              0x0C 0x0D    
   \              0x0E 0x0F    
   \              0x10 0x11    
   \              0x12 0x13    
   \              0x14 0x15    
   \              0x16 0x17
   \       0x47   0x18 0x19          DC8 24, 25, 26, 27, 28, 29, 30, 31, 32
   \              0x1A 0x1B    
   \              0x1C 0x1D    
   \              0x1E 0x1F    
   \              0x20
   \       0x50   0x0000'0000        DC32 0
    117                                                                  { 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 
    118                                                                   17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32},
    119                                                                  { 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
    120                                                                   17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32}, 
    121                                                                  .assignedDeviceId = 0};
    122          #ifdef NON_SERVE
    123          /* define a fixed structure where to find the configuration parameters */
    124          static const allConfPar_st allConfParDef = {
    125            (uint16_t)0x0,
    126            {(uint32_t)START_EE_ADDRES,             (uint32_t)EEPROM_PARAM_NUM},
    127            {(uint32_t)SCU_GENERAL_INFO_EE_ADDRES,  (uint32_t)sizeof(infoStation_t)},
    128            {(uint32_t)EDATA_BKP_SCU_EE_ADDRESS,    (uint32_t)sizeof(infoStation_t)},
    129            {(uint32_t)PRD_CODE_EE_ADDRES,          (uint32_t)(END_SN_EE_ADDRES - PRD_CODE_EE_ADDRES + 1)},
    130            {(uint32_t)EDATA_DEFAULT_ID_CODES,      (uint32_t)(PRODUCT_SN_LENGTH + PRODUCT_CODE_LENGTH + FAKE_CODE_LENGTH)},
    131            (uint32_t)0
    132          };
    133          #endif                                                    
    134          
    135          /* Definitions for SCB (SEM) modbus upgrade register Task   */

   \                                 In section .rodata, align 4
    136          const osThreadAttr_t pollingSlaveTask_attributes = {
   \                     pollingSlaveTask_attributes:
   \        0x0   0x....'....        DC32 ?_15, 0, 0x0, 0, 0x0, 512, 24
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0200  
   \              0x0000'0018
   \       0x1C                      DS8 8
    137            .name = "POLLING_SLAVE",
    138            .priority = (osPriority_t) osPriorityNormal,
    139            .stack_size = configMINIMAL_STACK_SIZE * 4     // 
    140          };
    141          
    142          /* Definitions for supend / release Task Manager  remoteMngTaskHandle  */

   \                                 In section .rodata, align 4
    143          const osThreadAttr_t remoteMngTask_attributes = {
   \                     remoteMngTask_attributes:
   \        0x0   0x....'....        DC32 ?_16, 0, 0x0, 0, 0x0, 256, 24
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0100  
   \              0x0000'0018
   \       0x1C                      DS8 8
    144            .name = "SUSP_REL_TASK",
    145            .priority = (osPriority_t) osPriorityNormal,
    146            .stack_size = configMINIMAL_STACK_SIZE * 2     // 
    147          };
    148          
    149          
    150          /*
    151          ***********************************SCAME**************************************
    152          **                                                                          **
    153          **                            Local Variables                               **
    154          **                                                                          **
    155          ****************************************************************************** 
    156          */ 

   \                                 In section .bss, align 1
    157          EvsMngEvent_en    lastCommandSent;
   \                     lastCommandSent:
   \        0x0                      DS8 1
    158          
    159          /*
    160          ***********************************SCAME**************************************
    161          **                                                                          **
    162          **                            Local  Variables                              **
    163          **                                                                          **
    164          ****************************************************************************** 
    165          */ 

   \                                 In section .bss, align 4
    166          static    TimerHandle_t     xSbcSemTimers[NUM_SBCSEM_TIMER];
   \                     xSbcSemTimers:
   \        0x0                      DS8 20

   \                                 In section .bss, align 1
    167          static    uint8_t           numberOnLcd;
   \                     numberOnLcd:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
    168          static    uint16_t          prevState[SCU_NUM];
   \                     prevState:
   \        0x0                      DS8 32

   \                                 In section .bss, align 4
    169          static    uint32_t          packetStatsCounter;
   \                     packetStatsCounter:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    170          static    areaConfPar_st*   ptrAreaConfPar;
   \                     ptrAreaConfPar:
   \        0x0                      DS8 4
    171          
    172          
    173          // --------------------------------------------------------------------------------------------------------------------------- //
    174          
    175          
    176          // --------------------------------------------------------------------------------------------------------------------------- //
    177          
    178          /*
    179          ***********************************SCAME**************************************
    180          **                                                                          **
    181          **                            Internal Function prototype                   **
    182          **                                                                          **
    183          ******************************************************************************
    184          */
    185          
    186          static  uint32_t          sbcSemMsgProcess          (frameSbcSem_st* pMsg, uint32_t currTick);
    187          static  uint32_t          rs485SemMsgProcess        (frameSbcSem_st* pMsg);
    188          static  void              writeMasterModbusRegister (uint8_t* pOriginData, headerReqRWMR_st* pScuRWmR);
    189          static  uint8_t           getInfoSocket             (uint32_t presenceMask, sbcSemInfoMng_st* pInfo); 
    190          static  void              readMasterModbusRegister  (headerRHR_t* pScuRIR);
    191          static  void              semUpdateConfig           (frameSbcSem_st* pMsg); 
    192          static  bitNotifyResult_e setChangeRegisterBit      (uint16_t ixScu, frameSbcSem_st* pMsg, uint32_t mskBit, uint16_t deviceId); 
    193          static  uint8_t           resetChangeRegisterBit    (uint16_t ixScu, uint16_t regChanged, uint16_t lenRd); 
    194          static  void              sbcSemTimCallBack         (TimerHandle_t pxTimer);
    195          static  nodeMsg           extractSendFirstInList    (nodeMsg head);
    196          static  nodeMsg           addNode                   (nodeMsg head, frameSbcSem_st *pMessage);
    197          static  uint32_t          pollingSlaveProcess       (frameSbcSem_st* pMsg);
    198          static  void              pollingSlaveTask          (void * pvParameters);
    199          static  uint8_t           getSktNumInFakeCode       (void); 
    200          static  uint16_t          getTagIdFromPrdSn         (void);
    201          static  uint8_t           checkAssignNewAddress     (frameSbcSem_st* pMsg); 
    202          static  sbcSemStates_e    checkToSendReqAddress     (frameSbcSem_st* pMsg); 
    203          static  void              mngReqAddress             (frameSbcSem_st* pMsg); 
    204          static  uint32_t          remoteSuspRelProcess      (frameRemote_st* pMsg);
    205          static  void              remoteMngTask             (void * pvParameters);
    206          static  void              restartSbcSemTimer        (uint16_t timerId, uint32_t period);
    207          static  void              forceSBCreadScu           (uint32_t activityMask); 
    208          static  void              removeSocketFromList      (uint8_t skId); 
    209          static  uint8_t           getFirstFreeLogicId       (void); 
    210          static  void              resetPacketStatusNum      (void); 
    211          #ifdef TRANSLATE_ID_LOGIC
    212          static  uint8_t           setModbusAddress          (void); 
    213          #endif
    214          static  void              saveAllSlaveParameters    (void);
    215          static  void              setInfoEepromSlaveDone    (uint16_t lastDetected);
    216          static  uint8_t           sendEeepromInfoForCloning (uint8_t idLogic);
    217          
    218          // --------------------------------------------------------------------------------------------------------------------------- //
    219          
    220          /*
    221          ***********************************SCAME**************************************
    222          **                                                                          **
    223          **                            Global Variables                              **
    224          **                                                                          **
    225          ****************************************************************************** 
    226          */ 
    227          /*  queue  declaration */

   \                                 In section .bss, align 4
    228          xQueueHandle          sbcSemQueue = NULL;
   \                     sbcSemQueue:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    229          frameSbcSem_st        frameSbcSem;
   \                     frameSbcSem:
   \        0x0                      DS8 20

   \                                 In section .bss, align 4
    230          scuRoMapRegister_st*  pScuRoMapReg;
   \                     pScuRoMapReg:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    231          sbcSemInfoMng_st      sbcSemInfoMng;
   \                     sbcSemInfoMng:
   \        0x0                      DS8 44

   \                                 In section .bss, align 4
    232          tmMapRegister_st*     pScuTmMapReg;
   \                     pScuTmMapReg:
   \        0x0                      DS8 4
    233          

   \                                 In section .bss, align 4
    234          xQueueHandle          rs485SemQueue = NULL;
   \                     rs485SemQueue:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    235          frameSbcSem_st        framers485Sem;
   \                     framers485Sem:
   \        0x0                      DS8 20

   \                                 In section .bss, align 4
    236          rs485SemInfoMng_st    rs485SemInfoMng;
   \                     rs485SemInfoMng:
   \        0x0                      DS8 24

   \                                 In section .bss, align 4
    237          socketPresence_t      socketPresence;
   \                     socketPresence:
   \        0x0                      DS8 84

   \                                 In section .bss, align 4
    238          frameSbcSem_st        currFrameSbcSem;
   \                     currFrameSbcSem:
   \        0x0                      DS8 20
    239          

   \                                 In section .bss, align 4
    240          nodeMsg               headMsg;
   \                     headMsg:
   \        0x0                      DS8 4
    241          

   \                                 In section .bss, align 4
    242          osThreadId_t          pollingSlaveTaskHandle;
   \                     pollingSlaveTaskHandle:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    243          xQueueHandle          pollingSlaveQueue = NULL;
   \                     pollingSlaveQueue:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    244          pollingSlaveMng_st    pollingSlaveMng;
   \                     pollingSlaveMng:
   \        0x0                      DS8 52
    245          

   \                                 In section .bss, align 4
    246          osThreadId_t          remoteMngTaskHandle;
   \                     remoteMngTaskHandle:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    247          xQueueHandle          remoteMngQueue = NULL;
   \                     remoteMngQueue:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    248          remoteMng_st          remoteMng;
   \                     remoteMng:
   \        0x0                      DS8 4
    249          
    250          // --------------------------------------------------------------------------------------------------------------------------- //
    251          
    252          /*
    253          *********************************** SCAME ************************************
    254          **                                                                          **
    255          **                            External Variables                            **
    256          **                                                                          **
    257          ******************************************************************************
    258          */
    259          extern osThreadId_t sbcMngTaskHandle;
    260          
    261          // --------------------------------------------------------------------------------------------------------------------------- //
    262          
    263          /*
    264          ***********************************SCAME**************************************
    265          **                                                                          **
    266          **                            Function Definition                           **
    267          **                                                                          **
    268          ******************************************************************************
    269          */
    270          
    271          /**
    272          *
    273          * @brief        Check if socket presence informations are programmed in the right location
    274          *
    275          * @param [in]   none
    276          *
    277          * @retval       uint8_t: TRUE, if an answer must be sent
    278          *
    279          ***********************************************************************************************************************/
    280          

   \                                 In section .text, align 2, keep-with-next
    281          uint8_t is_socketPresence_Programmed (void)
    282          {
    283              
    284            /* Check if structure is not initialized: all values to 0xFF */
    285            if (socketPresence.keyPresence == 0xFFFFFFFF) 
   \                     is_socketPresence_Programmed: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable1
   \        0x2   0x6880             LDR      R0,[R0, #+8]
   \        0x4   0xF110 0x0F01      CMN      R0,#+1
   \        0x8   0xD101             BNE.N    ??is_socketPresence_Programmed_0
    286              /* structure NOT initialized */
    287              return FALSE;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE000             B.N      ??is_socketPresence_Programmed_1
    288            
    289            /* structure initialized */
    290            return TRUE;
   \                     ??is_socketPresence_Programmed_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \                     ??is_socketPresence_Programmed_1: (+1)
   \       0x10   0x4770             BX       LR
    291          }
    292          

   \                                 In section .text, align 2, keep-with-next
    293          void sbcSemGestTask (void * pvParameters)
    294          {
   \                     sbcSemGestTask: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x0004             MOVS     R4,R0
    295            frameSbcSem_st tmpFrameSbcSem;  
    296            uint32_t       timeTickSem;
    297            uint8_t        ix;
    298          
    299            /*-------- Creates an empty mailbox for uart  messages --------------------------*/
    300            sbcSemQueue = xQueueCreate(NUM_BUFF_SEM_SCU, sizeof(frameSbcSem_st));
   \        0x8   0x....             LDR.N    R5,??DataTable1_1
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2112             MOVS     R1,#+18
   \        0xE   0x2010             MOVS     R0,#+16
   \       0x10   0x.... 0x....      BL       xQueueGenericCreate
   \       0x14   0x6028             STR      R0,[R5, #+0]
    301            configASSERT(sbcSemQueue != NULL);
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD109             BNE.N    ??sbcSemGestTask_0
   \       0x1C   0xB672             CPSID    I
   \       0x1E   0x2050             MOVS     R0,#+80
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   \       0x2C   0xB662             CPSIE    I
   \                     ??sbcSemGestTask_1: (+1)
   \       0x2E   0xE7FE             B.N      ??sbcSemGestTask_1
    302            vQueueAddToRegistry(sbcSemQueue, "sbcSemQueue" );
   \                     ??sbcSemGestTask_0: (+1)
   \       0x30   0x....             LDR.N    R1,??DataTable1_2
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0x.... 0x....      BL       vQueueAddToRegistry
    303            
    304            /*-------- Creates all timer for the led task  --------------------------*/
    305            for (ix = (uint8_t)0; ix < (uint8_t)NUM_SBCSEM_TIMER; ix++)
   \       0x38   0x2600             MOVS     R6,#+0
   \                     ??sbcSemGestTask_2: (+1)
   \       0x3A   0x0030             MOVS     R0,R6
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x2805             CMP      R0,#+5
   \       0x40   0xDA38             BGE.N    ??sbcSemGestTask_3
    306            {
    307              if (ix == (uint8_t)TIMER_FOR_ACK)
   \       0x42   0x0030             MOVS     R0,R6
   \       0x44   0xB2C0             UXTB     R0,R0
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD110             BNE.N    ??sbcSemGestTask_4
    308              {
    309                xSbcSemTimers[ix] = xTimerCreate("TimSbcSem", TIMEOUT_ACK_RESP, pdFALSE, (void*)(ix), sbcSemTimCallBack);
   \       0x4A   0x....             LDR.N    R0,??DataTable1_3
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x0033             MOVS     R3,R6
   \       0x50   0xB2DB             UXTB     R3,R3
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0xF44F 0x71FA      MOV      R1,#+500
   \       0x58   0x....             LDR.N    R0,??DataTable1_4
   \       0x5A   0x.... 0x....      BL       xTimerCreate
   \       0x5E   0x.... 0x....      LDR.W    R1,??sbcSemMsgProcess_0
   \       0x62   0x0032             MOVS     R2,R6
   \       0x64   0xB2D2             UXTB     R2,R2
   \       0x66   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   \       0x6A   0xE00F             B.N      ??sbcSemGestTask_5
    310              }
    311              else
    312              {
    313                /* in this case we dont use the auto-reload features */
    314                xSbcSemTimers[ix] = xTimerCreate("TimSbcSem", DEFAULT_SBCSEM_TIME, pdFALSE, (void*)(ix), sbcSemTimCallBack);
   \                     ??sbcSemGestTask_4: (+1)
   \       0x6C   0x....             LDR.N    R0,??DataTable1_3
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   \       0x70   0x0033             MOVS     R3,R6
   \       0x72   0xB2DB             UXTB     R3,R3
   \       0x74   0x2200             MOVS     R2,#+0
   \       0x76   0xF44F 0x717A      MOV      R1,#+1000
   \       0x7A   0x....             LDR.N    R0,??DataTable1_4
   \       0x7C   0x.... 0x....      BL       xTimerCreate
   \       0x80   0x.... 0x....      LDR.W    R1,??sbcSemMsgProcess_0
   \       0x84   0x0032             MOVS     R2,R6
   \       0x86   0xB2D2             UXTB     R2,R2
   \       0x88   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    315              }
    316              configASSERT(xSbcSemTimers[ix] != NULL);
   \                     ??sbcSemGestTask_5: (+1)
   \       0x8C   0x.... 0x....      LDR.W    R0,??sbcSemMsgProcess_0
   \       0x90   0x0031             MOVS     R1,R6
   \       0x92   0xB2C9             UXTB     R1,R1
   \       0x94   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD109             BNE.N    ??sbcSemGestTask_6
   \       0x9C   0xB672             CPSID    I
   \       0x9E   0x2050             MOVS     R0,#+80
   \       0xA0   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xA4   0xF3BF 0x8F4F      DSB      SY
   \       0xA8   0xF3BF 0x8F6F      ISB      SY
   \       0xAC   0xB662             CPSIE    I
   \                     ??sbcSemGestTask_7: (+1)
   \       0xAE   0xE7FE             B.N      ??sbcSemGestTask_7
    317            }
   \                     ??sbcSemGestTask_6: (+1)
   \       0xB0   0x1C76             ADDS     R6,R6,#+1
   \       0xB2   0xE7C2             B.N      ??sbcSemGestTask_2
    318          
    319            /* init structure for management */
    320            sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_START;
   \                     ??sbcSemGestTask_3: (+1)
   \       0xB4   0x2008             MOVS     R0,#+8
   \       0xB6   0x.... 0x....      LDR.W    R1,??sbcSemMsgProcess_0+4
   \       0xBA   0x8008             STRH     R0,[R1, #+0]
    321          
    322            packetStatsCounter = (uint32_t)0;
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0x....             LDR.N    R1,??DataTable1_5
   \       0xC0   0x6008             STR      R0,[R1, #+0]
    323          
    324            headMsg = NULL;
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x.... 0x....      LDR.W    R1,??sbcSemMsgProcess_0+8
   \       0xC8   0x6008             STR      R0,[R1, #+0]
    325            ptrAreaConfPar = NULL;
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0x....             LDR.N    R1,??DataTable1_6
   \       0xCE   0x6008             STR      R0,[R1, #+0]
    326              
    327            timeTickSem = portMAX_DELAY;
   \       0xD0   0xF05F 0x37FF      MOVS     R7,#+4294967295
    328          
    329            for (;;)
    330            {
    331              /* Wait for some event from Rx/Tx uart SBC (typically UART5)  */
    332              if (xQueueReceive(sbcSemQueue, (void *)&frameSbcSem, timeTickSem) == pdPASS)
   \                     ??sbcSemGestTask_8: (+1)
   \       0xD4   0x.... 0x....      LDR.W    R8,??DataTable1_7
   \       0xD8   0x003A             MOVS     R2,R7
   \       0xDA   0x4641             MOV      R1,R8
   \       0xDC   0x6828             LDR      R0,[R5, #+0]
   \       0xDE   0x.... 0x....      BL       xQueueReceive
   \       0xE2   0x2801             CMP      R0,#+1
   \       0xE4   0xD105             BNE.N    ??sbcSemGestTask_9
    333              {
    334                timeTickSem = sbcSemMsgProcess(&frameSbcSem, timeTickSem);
   \       0xE6   0x0039             MOVS     R1,R7
   \       0xE8   0x4640             MOV      R0,R8
   \       0xEA   0x.... 0x....      BL       sbcSemMsgProcess
   \       0xEE   0x0007             MOVS     R7,R0
   \       0xF0   0xE7F0             B.N      ??sbcSemGestTask_8
    335              }
    336              else
    337              {
    338                tmpFrameSbcSem.sbcSemEvent = SBC_SEM_TIMEOUT;
   \                     ??sbcSemGestTask_9: (+1)
   \       0xF2   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0xF6   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    339                timeTickSem = sbcSemMsgProcess(&tmpFrameSbcSem, timeTickSem);
   \       0xFA   0x0039             MOVS     R1,R7
   \       0xFC   0xA801             ADD      R0,SP,#+4
   \       0xFE   0x.... 0x....      BL       sbcSemMsgProcess
   \      0x102   0x0007             MOVS     R7,R0
   \      0x104   0xE7E6             B.N      ??sbcSemGestTask_8
    340              }
    341            }
    342          }
    343          
    344          /**
    345          *
    346          * @brief        Decoder message coming from SBC on UART5, or for internal task as debug 
    347          *
    348          * @param [in]   none
    349          *
    350          * @retval       uint8_t: TRUE, if an answer must be sent
    351          *
    352          ***********************************************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    353          static uint32_t sbcSemMsgProcess(frameSbcSem_st* pMsg, uint32_t currTick)
    354          {
   \                     sbcSemMsgProcess: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x0004             MOVS     R4,R0
    355            uint16_t              ixScu, ixLogic;
    356            uint32_t              maskBit;
    357            uint32_t              timeTickTmp;
    358            uint16_t*             pWord;
    359            uint8_t               error_array[EVS_ERROR_ARRAY_SIZE];
    360            scuOpModes_e          locScuMode;
    361            scuRoMapRegister_st*  pScuRoMapRegSlave;
    362            uint8_t               result, cnt;
    363          
    364            
    365            if (pMsg->sbcSemEvent != SBC_SEM_TIMEOUT)
   \        0x8   0xF64F 0x7BFE      MOVW     R11,#+65534
   \        0xC   0x8820             LDRH     R0,[R4, #+0]
   \        0xE   0x4558             CMP      R0,R11
   \       0x10   0xD016             BEQ.N    ??sbcSemMsgProcess_4
    366            {
    367              ixScu = pMsg->data.index; // get modbus address from incoming message 
   \       0x12   0x8860             LDRH     R0,[R4, #+2]
   \       0x14   0x0005             MOVS     R5,R0
    368              
    369              if (ixScu > (uint16_t)MODBUS_BROADCAST_ADDR) 
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0xB280             UXTH     R0,R0
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD006             BEQ.N    ??sbcSemMsgProcess_5
    370                ixLogic = fromRs485ToSem(ixScu); 
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0x.... 0x....      BL       fromRs485ToSem
   \       0x26   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   \       0x2A   0xE002             B.N      ??sbcSemMsgProcess_6
    371              else 
    372                ixLogic = 0;
   \                     ??sbcSemMsgProcess_5: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    373              maskBit = sbcSemMaskBit[ixLogic];
   \                     ??sbcSemMsgProcess_6: (+1)
   \       0x32   0xF8DF 0x0A88      LDR.W    R0,??sbcSemMsgProcess_0+12
   \       0x36   0xF8BD 0x1008      LDRH     R1,[SP, #+8]
   \       0x3A   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \       0x3E   0x0006             MOVS     R6,R0
    374            }
    375          
    376            timeTickTmp = currTick;
   \                     ??sbcSemMsgProcess_4: (+1)
   \       0x40   0x9F08             LDR      R7,[SP, #+32]
    377          
    378            switch (sbcSemInfoMng.sbcSemStates)
   \       0x42   0xF8DF 0xAA70      LDR.W    R10,??sbcSemMsgProcess_0+4
   \       0x46   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xF000 0x81BD      BEQ.W    ??sbcSemMsgProcess_7
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xF000 0x81CB      BEQ.W    ??sbcSemMsgProcess_8
   \       0x56   0x2802             CMP      R0,#+2
   \       0x58   0xF000 0x8205      BEQ.W    ??sbcSemMsgProcess_9
   \       0x5C   0x2803             CMP      R0,#+3
   \       0x5E   0xF000 0x8295      BEQ.W    ??sbcSemMsgProcess_10
   \       0x62   0x2804             CMP      R0,#+4
   \       0x64   0xF000 0x83D3      BEQ.W    ??sbcSemMsgProcess_11
   \       0x68   0x2805             CMP      R0,#+5
   \       0x6A   0xF000 0x86D0      BEQ.W    ??sbcSemMsgProcess_12
   \       0x6E   0x2806             CMP      R0,#+6
   \       0x70   0xF000 0x877B      BEQ.W    ??sbcSemMsgProcess_13
   \       0x74   0x2807             CMP      R0,#+7
   \       0x76   0xF000 0x8778      BEQ.W    ??sbcSemMsgProcess_13
   \       0x7A   0x2808             CMP      R0,#+8
   \       0x7C   0xD013             BEQ.N    ??sbcSemMsgProcess_14
   \       0x7E   0x2809             CMP      R0,#+9
   \       0x80   0xF000 0x80F8      BEQ.W    ??sbcSemMsgProcess_15
   \       0x84   0x280A             CMP      R0,#+10
   \       0x86   0xF000 0x8151      BEQ.W    ??sbcSemMsgProcess_16
   \       0x8A   0x280C             CMP      R0,#+12
   \       0x8C   0xF000 0x82F9      BEQ.W    ??sbcSemMsgProcess_17
   \       0x90   0x280D             CMP      R0,#+13
   \       0x92   0xF000 0x876A      BEQ.W    ??sbcSemMsgProcess_13
   \       0x96   0x280E             CMP      R0,#+14
   \       0x98   0xF000 0x83A0      BEQ.W    ??sbcSemMsgProcess_18
   \       0x9C   0x280F             CMP      R0,#+15
   \       0x9E   0xF000 0x8178      BEQ.W    ??sbcSemMsgProcess_19
   \       0xA2   0xF000 0xBFF2      B.W      ??sbcSemMsgProcess_20
    379            {
    380              case SBC_SEM_WAIT_TO_START:
    381                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_14: (+1)
   \       0xA6   0x8820             LDRH     R0,[R4, #+0]
   \       0xA8   0x2802             CMP      R0,#+2
   \       0xAA   0xF000 0x80D7      BEQ.W    ??sbcSemMsgProcess_21
   \       0xAE   0x2809             CMP      R0,#+9
   \       0xB0   0xF040 0x80DE      BNE.W    ??sbcSemMsgProcess_22
    382                {
    383                  case NOTIFY_START_TASK:
    384           
    385                    pScuRoMapReg = getRoMdbRegs(0);
   \                     ??sbcSemMsgProcess_23: (+1)
   \       0xB4   0xF8DF 0xBC94      LDR.W    R11,??sbcSemMsgProcess_1
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0x.... 0x....      BL       getRoMdbRegs
   \       0xBE   0xF8CB 0x0000      STR      R0,[R11, #+0]
    386                    pScuTmMapReg = getTmMdbRegs(ixLogic);
   \       0xC2   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \       0xC6   0xB2C0             UXTB     R0,R0
   \       0xC8   0x.... 0x....      BL       getTmMdbRegs
   \       0xCC   0xF8DF 0x1C80      LDR.W    R1,??sbcSemMsgProcess_1+4
   \       0xD0   0x6008             STR      R0,[R1, #+0]
    387          
    388                    pScuRoMapReg->scuMapRegNotify.ntfPresences = (uint32_t)0;
   \       0xD2   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0xD6   0x2100             MOVS     R1,#+0
   \       0xD8   0xF8C0 0x10F6      STR      R1,[R0, #+246]
    389                    /* socketPresence structure has been read already in eeprom_read_all() Nick 24/06/2024 */
    390                    if ((socketPresence.matrixConv[0] != 1) || (socketPresence.matrixIdConn[0] != 1) || (socketPresence.matrixIdConn[15] == 0xFF))
   \       0xDC   0xF8DF 0xBC74      LDR.W    R11,??sbcSemMsgProcess_1+8
   \       0xE0   0xF89B 0x0010      LDRB     R0,[R11, #+16]
   \       0xE4   0x2801             CMP      R0,#+1
   \       0xE6   0xD107             BNE.N    ??sbcSemMsgProcess_24
   \       0xE8   0xF89B 0x0030      LDRB     R0,[R11, #+48]
   \       0xEC   0x2801             CMP      R0,#+1
   \       0xEE   0xD103             BNE.N    ??sbcSemMsgProcess_24
   \       0xF0   0xF89B 0x003F      LDRB     R0,[R11, #+63]
   \       0xF4   0x28FF             CMP      R0,#+255
   \       0xF6   0xD133             BNE.N    ??sbcSemMsgProcess_25
    391                    {
    392                      /* put in the matrix the default config */
    393                      if (socketPresence.matrixConv[0] != 1)
   \                     ??sbcSemMsgProcess_24: (+1)
   \       0xF8   0xF89B 0x0010      LDRB     R0,[R11, #+16]
   \       0xFC   0x2801             CMP      R0,#+1
   \       0xFE   0xD00D             BEQ.N    ??sbcSemMsgProcess_26
    394                      {
    395                        /*      destination                                         source                       length */
    396                        memcpy((uint8_t *)&socketPresence.matrixConv, (uint8_t *)&Default_Socket_Presence.matrixConv, (size_t)SCU_NUM);
   \      0x100   0x2010             MOVS     R0,#+16
   \      0x102   0x9006             STR      R0,[SP, #+24]
   \      0x104   0xF8DF 0x0C50      LDR.W    R0,??sbcSemMsgProcess_1+12
   \      0x108   0x9001             STR      R0,[SP, #+4]
   \      0x10A   0xF11B 0x0010      ADDS     R0,R11,#+16
   \      0x10E   0x9000             STR      R0,[SP, #+0]
   \      0x110   0x9A06             LDR      R2,[SP, #+24]
   \      0x112   0x9901             LDR      R1,[SP, #+4]
   \      0x114   0x9800             LDR      R0,[SP, #+0]
   \      0x116   0x.... 0x....      BL       __aeabi_memcpy
   \      0x11A   0x9800             LDR      R0,[SP, #+0]
    397                      }
    398                      if ((socketPresence.matrixIdConn[0] != 1) || (socketPresence.matrixIdConn[15] == 0xFF))
   \                     ??sbcSemMsgProcess_26: (+1)
   \      0x11C   0xF89B 0x0030      LDRB     R0,[R11, #+48]
   \      0x120   0x2801             CMP      R0,#+1
   \      0x122   0xD103             BNE.N    ??sbcSemMsgProcess_27
   \      0x124   0xF89B 0x003F      LDRB     R0,[R11, #+63]
   \      0x128   0x28FF             CMP      R0,#+255
   \      0x12A   0xD10D             BNE.N    ??sbcSemMsgProcess_28
    399                      {
    400                        /*      destination                                         source                       length */
    401                        memcpy((uint8_t *)&socketPresence.matrixIdConn, (uint8_t *)&Default_Socket_Presence.matrixIdConn, (size_t)SCU_NUM);
   \                     ??sbcSemMsgProcess_27: (+1)
   \      0x12C   0x2010             MOVS     R0,#+16
   \      0x12E   0x9006             STR      R0,[SP, #+24]
   \      0x130   0xF8DF 0x0C28      LDR.W    R0,??sbcSemMsgProcess_1+16
   \      0x134   0x9001             STR      R0,[SP, #+4]
   \      0x136   0xF11B 0x0030      ADDS     R0,R11,#+48
   \      0x13A   0x9000             STR      R0,[SP, #+0]
   \      0x13C   0x9A06             LDR      R2,[SP, #+24]
   \      0x13E   0x9901             LDR      R1,[SP, #+4]
   \      0x140   0x9800             LDR      R0,[SP, #+0]
   \      0x142   0x.... 0x....      BL       __aeabi_memcpy
   \      0x146   0x9800             LDR      R0,[SP, #+0]
    402                      }
    403                      if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \                     ??sbcSemMsgProcess_28: (+1)
   \      0x148   0x2254             MOVS     R2,#+84
   \      0x14A   0x4659             MOV      R1,R11
   \      0x14C   0xF44F 0x50F4      MOV      R0,#+7808
   \      0x150   0x.... 0x....      BL       WriteOnEeprom
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD103             BNE.N    ??sbcSemMsgProcess_25
    404                      {
    405                        tPrintf("Matrix Initializated\n\r");
   \      0x158   0xF8DF 0x0C04      LDR.W    R0,??sbcSemMsgProcess_1+20
   \      0x15C   0x.... 0x....      BL       tPrintf
    406                      }
    407                    }
    408                    setDevAlias();  /* set the number on LCD in according with matrix */
   \                     ??sbcSemMsgProcess_25: (+1)
   \      0x160   0x.... 0x....      BL       setDevAlias
    409                    socketPresence.livePresence = socketPresence.activityStatus = sbcSemInfoMng.offLine = sbcSemInfoMng.sbcActive = 0;
   \      0x164   0x2000             MOVS     R0,#+0
   \      0x166   0xF88A 0x0028      STRB     R0,[R10, #+40]
   \      0x16A   0xF88A 0x0027      STRB     R0,[R10, #+39]
   \      0x16E   0xB2C0             UXTB     R0,R0
   \      0x170   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \      0x174   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \      0x178   0xF8CB 0x0004      STR      R0,[R11, #+4]
    410                    if (isSemMasterFz() == TRUE)
   \      0x17C   0x.... 0x....      BL       isSemMasterFz
   \      0x180   0x2801             CMP      R0,#+1
   \      0x182   0xD148             BNE.N    ??sbcSemMsgProcess_29
    411                    {
    412                      socketPresence.assignedDeviceId |= (uint32_t)0x01; // the first device Id is reserverd for SCU  master Principale  
   \      0x184   0xF8DB 0x0050      LDR      R0,[R11, #+80]
   \      0x188   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x18C   0xF8CB 0x0050      STR      R0,[R11, #+80]
    413                      socketPresence.livePresence |= (uint32_t)0x01;  /* the master, bit 0, address 1 is always present*/
   \      0x190   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0x194   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x198   0xF8CB 0x0004      STR      R0,[R11, #+4]
    414                      socketPresence.chainPresence |= (uint32_t)0x01; /* the master, bit 0, address 1 is always present*/
   \      0x19C   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x1A0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x1A4   0xF8CB 0x0000      STR      R0,[R11, #+0]
    415                      setInfoEepromSlaveDone((uint16_t)socketPresence.chainPresence);
   \      0x1A8   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x1AC   0xB280             UXTH     R0,R0
   \      0x1AE   0x.... 0x....      BL       setInfoEepromSlaveDone
    416                      switch (socketPresence.keyPresence)
   \      0x1B2   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \      0x1B6   0xF64A 0x2155      MOVW     R1,#+43605
   \      0x1BA   0x4288             CMP      R0,R1
   \      0x1BC   0xD004             BEQ.N    ??sbcSemMsgProcess_30
   \      0x1BE   0xF64B 0x3166      MOVW     R1,#+47974
   \      0x1C2   0x4288             CMP      R0,R1
   \      0x1C4   0xD009             BEQ.N    ??sbcSemMsgProcess_31
   \      0x1C6   0xE014             B.N      ??sbcSemMsgProcess_32
    417                      {
    418                        case KEY_FULL_CONFIG:
    419          
    420                          // wait 5 sec before master starts with discovery procedure
    421                          restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_START_DISCOVERY);
   \                     ??sbcSemMsgProcess_30: (+1)
   \      0x1C8   0xF242 0x7110      MOVW     R1,#+10000
   \      0x1CC   0x2000             MOVS     R0,#+0
   \      0x1CE   0x.... 0x....      BL       restartSbcSemTimer
    422                         /* master starts discovery phase cheking the presence of secondary master SCU using broadcast address  */
    423                          sbcSemInfoMng.sbcSemStates = SBC_SEM_INIT_DISCOVERY;
   \      0x1D2   0x2000             MOVS     R0,#+0
   \      0x1D4   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    424                          break;
   \      0x1D8   0xE03F             B.N      ??sbcSemMsgProcess_33
    425          
    426                        case KEY_LOCAL_CONFIG:
    427                          sbcSemInfoMng.firstIdFree = 3;  // first address available for master and slave. Bit 0 = addr 1 is reserved primary master Bit 1 = addr 2 for linked slave
   \                     ??sbcSemMsgProcess_31: (+1)
   \      0x1DA   0x2003             MOVS     R0,#+3
   \      0x1DC   0xF8AA 0x0002      STRH     R0,[R10, #+2]
    428                          // wait 100m sec before master starts with discovery procedure
    429                          restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_START_DISCOVERY);
   \      0x1E0   0xF242 0x7110      MOVW     R1,#+10000
   \      0x1E4   0x2000             MOVS     R0,#+0
   \      0x1E6   0x.... 0x....      BL       restartSbcSemTimer
    430                         /* master starts discovery phase cheking the presence of secondary master SCU using broadcast address  */
    431                          sbcSemInfoMng.sbcSemStates = SBC_SEM_INIT_DISCOVERY;
   \      0x1EA   0x2000             MOVS     R0,#+0
   \      0x1EC   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    432                          break;
   \      0x1F0   0xE033             B.N      ??sbcSemMsgProcess_33
    433          
    434                        default:
    435                          
    436                          /* If socket presence structure is not programmed --> in some fw version (< 4.3.2o),
    437                             these informations are in eeprom in another location (0x1F60)*/
    438                          if (is_socketPresence_Programmed() == FALSE)
   \                     ??sbcSemMsgProcess_32: (+1)
   \      0x1F2   0x.... 0x....      BL       is_socketPresence_Programmed
   \      0x1F6   0x2800             CMP      R0,#+0
   \      0x1F8   0xD10C             BNE.N    ??sbcSemMsgProcess_34
    439                              if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&Default_Socket_Presence, sizeof(socketPresence_t)) == osOK)
   \      0x1FA   0x2254             MOVS     R2,#+84
   \      0x1FC   0xF8DF 0x1CE4      LDR.W    R1,??sbcSemMsgProcess_2
   \      0x200   0xF44F 0x50F4      MOV      R0,#+7808
   \      0x204   0x.... 0x....      BL       WriteOnEeprom
   \      0x208   0x2800             CMP      R0,#+0
   \      0x20A   0xD103             BNE.N    ??sbcSemMsgProcess_34
    440                                tPrintf("Socket presence informations programmed to default \n\r");
   \      0x20C   0xF8DF 0x0CD8      LDR.W    R0,??sbcSemMsgProcess_2+4
   \      0x210   0x.... 0x....      BL       tPrintf
    441          
    442                          break;
   \                     ??sbcSemMsgProcess_34: (+1)
   \      0x214   0xE021             B.N      ??sbcSemMsgProcess_33
    443                      }          
    444                    }
    445                    else
    446                    {
    447                      if (getScuAddressTypeMode() == SCU_FIXED_ADDR)
   \                     ??sbcSemMsgProcess_29: (+1)
   \      0x216   0x.... 0x....      BL       getScuAddressTypeMode
   \      0x21A   0x2801             CMP      R0,#+1
   \      0x21C   0xD116             BNE.N    ??sbcSemMsgProcess_35
    448                      {
    449                        /* Fixed address on RS485: just wait 3 sec before entering in operative mode That avoid to send info to Master during power-up phase*/
    450                        restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_OPERATING_STATE);
   \      0x21E   0xF640 0x31B8      MOVW     R1,#+3000
   \      0x222   0x2000             MOVS     R0,#+0
   \      0x224   0x.... 0x....      BL       restartSbcSemTimer
    451                        /* the slave has been already configured */
    452                        socketPresence.keyPresence = KEY_FULL_CONFIG;
   \      0x228   0xF64A 0x2055      MOVW     R0,#+43605
   \      0x22C   0xF8CB 0x0008      STR      R0,[R11, #+8]
    453                        sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_BE_OPERATIVE;
   \      0x230   0x200C             MOVS     R0,#+12
   \      0x232   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    454          
    455                        /* starts the task to manager suspend / release function   */
    456                        remoteMngTaskHandle = osThreadNew(remoteMngTask, NULL, &remoteMngTask_attributes);  
   \      0x236   0xF8DF 0x2D0C      LDR.W    R2,??sbcSemMsgProcess_3
   \      0x23A   0x2100             MOVS     R1,#+0
   \      0x23C   0xF8DF 0x0D08      LDR.W    R0,??sbcSemMsgProcess_3+4
   \      0x240   0x.... 0x....      BL       osThreadNew
   \      0x244   0xF8DF 0x1D04      LDR.W    R1,??sbcSemMsgProcess_3+8
   \      0x248   0x6008             STR      R0,[R1, #+0]
   \      0x24A   0xE006             B.N      ??sbcSemMsgProcess_33
    457                      }
    458                      else
    459                      {
    460                        sbcSemInfoMng.random = NULL_RANDOM;
   \                     ??sbcSemMsgProcess_35: (+1)
   \      0x24C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x250   0xF8CA 0x001C      STR      R0,[R10, #+28]
    461                        /* the slave SCU was not registered from the master so its modbus address it is virtual */
    462                        sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_REGISTER;
   \      0x254   0x2009             MOVS     R0,#+9
   \      0x256   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    463                      }
    464                    }
    465                    break;
   \                     ??sbcSemMsgProcess_33: (+1)
   \      0x25A   0xE009             B.N      ??sbcSemMsgProcess_36
    466          
    467                  case NOTIFY_TO_MASTER_TX:
    468                    /* save the message for future use  */
    469                    headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_21: (+1)
   \      0x25C   0xF8DF 0xA858      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x260   0x0021             MOVS     R1,R4
   \      0x262   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x266   0x.... 0x....      BL       addNode
   \      0x26A   0xF8CA 0x0000      STR      R0,[R10, #+0]
    470                    break;
   \      0x26E   0xE7FF             B.N      ??sbcSemMsgProcess_36
    471          
    472                  default:
    473                    break;
    474                }
    475                break;
   \                     ??sbcSemMsgProcess_22: (+1)
   \                     ??sbcSemMsgProcess_36: (+1)
   \      0x270   0xF000 0xBF18      B.W      ??sbcSemMsgProcess_37
    476          
    477              case SBC_SEM_WAIT_TO_REGISTER:
    478                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_15: (+1)
   \      0x274   0x8820             LDRH     R0,[R4, #+0]
   \      0x276   0x2800             CMP      R0,#+0
   \      0x278   0xD004             BEQ.N    ??sbcSemMsgProcess_38
   \      0x27A   0x2802             CMP      R0,#+2
   \      0x27C   0xD04B             BEQ.N    ??sbcSemMsgProcess_39
   \      0x27E   0x2808             CMP      R0,#+8
   \      0x280   0xD016             BEQ.N    ??sbcSemMsgProcess_40
   \      0x282   0xE051             B.N      ??sbcSemMsgProcess_41
    479                {
    480                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    481                    /* a master start the addressing procedure  */
    482                    if (ixScu == MODBUS_BROADCAST_ADDR)
   \                     ??sbcSemMsgProcess_38: (+1)
   \      0x284   0x0028             MOVS     R0,R5
   \      0x286   0xB280             UXTH     R0,R0
   \      0x288   0x2800             CMP      R0,#+0
   \      0x28A   0xD105             BNE.N    ??sbcSemMsgProcess_42
    483                    {
    484                      sbcSemInfoMng.sbcSemStates = checkToSendReqAddress(pMsg);
   \      0x28C   0x0020             MOVS     R0,R4
   \      0x28E   0x.... 0x....      BL       checkToSendReqAddress
   \      0x292   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \      0x296   0xE00A             B.N      ??sbcSemMsgProcess_43
    485                    }
    486                    else
    487                    {
    488                      if (pMsg->data.rAddr == ADDR_ADDR_S_CONN_RW)
   \                     ??sbcSemMsgProcess_42: (+1)
   \      0x298   0x88A0             LDRH     R0,[R4, #+4]
   \      0x29A   0xF240 0x5113      MOVW     R1,#+1299
   \      0x29E   0x4288             CMP      R0,R1
   \      0x2A0   0xD105             BNE.N    ??sbcSemMsgProcess_43
    489                      {          
    490                        /* another slave request the address:  restart random delay */
    491                        restartSbcSemTimer(TIMER_FOR_REQ_ADDR, (uint32_t)(sbcSemInfoMng.random / FACTOR_FOR_RANDOM_DELAY));
   \      0x2A2   0xF8DA 0x101C      LDR      R1,[R10, #+28]
   \      0x2A6   0x0989             LSRS     R1,R1,#+6
   \      0x2A8   0x2004             MOVS     R0,#+4
   \      0x2AA   0x.... 0x....      BL       restartSbcSemTimer
    492                      }
    493                    }
    494                    break;
   \                     ??sbcSemMsgProcess_43: (+1)
   \      0x2AE   0xE03B             B.N      ??sbcSemMsgProcess_44
    495          
    496                  case NOTIFY_MODBUS_WR_ACK:
    497                    if ((pMsg->data.index == currFrameSbcSem.data.index) &&         // phisical address 1...16 
    498                        (sbcSemInfoMng.random == (uint32_t)sbcSemInfoMng.dataVal))  // it is the ACK referred at our transmssion 
   \                     ??sbcSemMsgProcess_40: (+1)
   \      0x2B0   0xF8DF 0xBC9C      LDR.W    R11,??sbcSemMsgProcess_3+12
   \      0x2B4   0x8860             LDRH     R0,[R4, #+2]
   \      0x2B6   0xF8BB 0x1002      LDRH     R1,[R11, #+2]
   \      0x2BA   0x4288             CMP      R0,R1
   \      0x2BC   0xD12A             BNE.N    ??sbcSemMsgProcess_45
   \      0x2BE   0xF8DA 0x001C      LDR      R0,[R10, #+28]
   \      0x2C2   0xF8BA 0x1004      LDRH     R1,[R10, #+4]
   \      0x2C6   0x4288             CMP      R0,R1
   \      0x2C8   0xD124             BNE.N    ??sbcSemMsgProcess_45
    499                    {
    500                      /* release the transmitter */
    501                      currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0x2CA   0x2005             MOVS     R0,#+5
   \      0x2CC   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    502                      configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x2D0   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x2D4   0x2300             MOVS     R3,#+0
   \      0x2D6   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x2DA   0x4659             MOV      R1,R11
   \      0x2DC   0x.... 0x....      BL       xQueueGenericSend
   \      0x2E0   0x2801             CMP      R0,#+1
   \      0x2E2   0xD009             BEQ.N    ??sbcSemMsgProcess_46
   \      0x2E4   0xB672             CPSID    I
   \      0x2E6   0x2050             MOVS     R0,#+80
   \      0x2E8   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x2EC   0xF3BF 0x8F4F      DSB      SY
   \      0x2F0   0xF3BF 0x8F6F      ISB      SY
   \      0x2F4   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_47: (+1)
   \      0x2F6   0xE7FE             B.N      ??sbcSemMsgProcess_47
    503                      /* stop ACK gard  timer */
    504                      xTimerStop(xSbcSemTimers[TIMER_FOR_ACK], SBCSEM_TIMER_GARD_TIME);
   \                     ??sbcSemMsgProcess_46: (+1)
   \      0x2F8   0xF44F 0x70FA      MOV      R0,#+500
   \      0x2FC   0x9000             STR      R0,[SP, #+0]
   \      0x2FE   0x2300             MOVS     R3,#+0
   \      0x300   0x2200             MOVS     R2,#+0
   \      0x302   0x2103             MOVS     R1,#+3
   \      0x304   0xF8DF 0x07A8      LDR.W    R0,??sbcSemMsgProcess_0
   \      0x308   0x6840             LDR      R0,[R0, #+4]
   \      0x30A   0x.... 0x....      BL       xTimerGenericCommand
    505                      /* the slave SCU wait for address */
    506                      sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_RS485_ADDR; 
   \      0x30E   0x200A             MOVS     R0,#+10
   \      0x310   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    507                    }
    508                    break;
   \                     ??sbcSemMsgProcess_45: (+1)
   \      0x314   0xE008             B.N      ??sbcSemMsgProcess_44
    509          
    510                  case NOTIFY_TO_MASTER_TX:
    511                    if (pMsg->data.rAddr == ADDR_TM_EVSE_READY_RO)  // 0x512 Testing machine starts test
   \                     ??sbcSemMsgProcess_39: (+1)
   \      0x316   0x88A0             LDRH     R0,[R4, #+4]
   \      0x318   0xF240 0x5112      MOVW     R1,#+1298
   \      0x31C   0x4288             CMP      R0,R1
   \      0x31E   0xD102             BNE.N    ??sbcSemMsgProcess_48
    512                    {
    513                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE_COLLAUDO;
   \      0x320   0x200E             MOVS     R0,#+14
   \      0x322   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    514                    }
    515                    break;
   \                     ??sbcSemMsgProcess_48: (+1)
   \      0x326   0xE7FF             B.N      ??sbcSemMsgProcess_44
    516          
    517                  default:
    518                    /* Message or ACK from other skave are discarded */
    519                    break;
    520                }
    521                break;
   \                     ??sbcSemMsgProcess_41: (+1)
   \                     ??sbcSemMsgProcess_44: (+1)
   \      0x328   0xF000 0xBEBC      B.W      ??sbcSemMsgProcess_37
    522          
    523              case SBC_SEM_WAIT_RS485_ADDR:
    524                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_16: (+1)
   \      0x32C   0x8820             LDRH     R0,[R4, #+0]
   \      0x32E   0x2800             CMP      R0,#+0
   \      0x330   0xD007             BEQ.N    ??sbcSemMsgProcess_49
   \      0x332   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x336   0x4288             CMP      R0,R1
   \      0x338   0xD129             BNE.N    ??sbcSemMsgProcess_50
    525                {
    526                  case SBC_SEM_TIMEOUT:
    527                    /* address not received wait for next tentative */
    528                    sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_REGISTER; 
   \                     ??sbcSemMsgProcess_51: (+1)
   \      0x33A   0x2009             MOVS     R0,#+9
   \      0x33C   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    529                    break;
   \      0x340   0xE025             B.N      ??sbcSemMsgProcess_52
    530          
    531                  case SBC_SEM_EVENT_RS485: 
    532                    /* a master ended the addressing procedure  */
    533                    if (ixScu == MODBUS_BROADCAST_ADDR)
   \                     ??sbcSemMsgProcess_49: (+1)
   \      0x342   0x0028             MOVS     R0,R5
   \      0x344   0xB280             UXTH     R0,R0
   \      0x346   0x2800             CMP      R0,#+0
   \      0x348   0xD120             BNE.N    ??sbcSemMsgProcess_53
    534                    {
    535                      result = checkAssignNewAddress(pMsg);
   \      0x34A   0x0020             MOVS     R0,R4
   \      0x34C   0x.... 0x....      BL       checkAssignNewAddress
   \      0x350   0x4680             MOV      R8,R0
    536                      if (result == 0)
   \      0x352   0x4640             MOV      R0,R8
   \      0x354   0xB2C0             UXTB     R0,R0
   \      0x356   0x2800             CMP      R0,#+0
   \      0x358   0xD111             BNE.N    ??sbcSemMsgProcess_54
    537                      {
    538                        if (setScuAddressTypeMode(SCU_FIXED_ADDR) == 0) // try to set the flag to confirm adrress fixed 
   \      0x35A   0x2001             MOVS     R0,#+1
   \      0x35C   0x.... 0x....      BL       setScuAddressTypeMode
   \      0x360   0x2800             CMP      R0,#+0
   \      0x362   0xD108             BNE.N    ??sbcSemMsgProcess_55
    539                        {
    540                          setParamFromAssignedAddr();     // set status, ... before master read info parameters
   \      0x364   0x.... 0x....      BL       setParamFromAssignedAddr
    541                          /* Blank state: to avoid transmission while other SCU are on going phase assignement address  */
    542                          sbcSemInfoMng.sbcSemStates = SBC_SEM_BLANK_AFTER_ASS_ADDR;
   \      0x368   0x200F             MOVS     R0,#+15
   \      0x36A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    543                          /* timeout 100ms for receive address  */
    544                          timeTickTmp = pdMS_TO_TICKS(WAIT_TO_OPERATIVE_POST_ASS_ADDR);  
   \      0x36E   0xF241 0x3088      MOVW     R0,#+5000
   \      0x372   0x0007             MOVS     R7,R0
   \      0x374   0xE00A             B.N      ??sbcSemMsgProcess_53
    545                        }
    546                        else
    547                        {
    548                          sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_REGISTER;              
   \                     ??sbcSemMsgProcess_55: (+1)
   \      0x376   0x2009             MOVS     R0,#+9
   \      0x378   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \      0x37C   0xE006             B.N      ??sbcSemMsgProcess_53
    549                        }
    550                      }
    551                      else
    552                      {
    553                        if (result == 1) sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_REGISTER;
   \                     ??sbcSemMsgProcess_54: (+1)
   \      0x37E   0x4640             MOV      R0,R8
   \      0x380   0xB2C0             UXTB     R0,R0
   \      0x382   0x2801             CMP      R0,#+1
   \      0x384   0xD102             BNE.N    ??sbcSemMsgProcess_53
   \      0x386   0x2009             MOVS     R0,#+9
   \      0x388   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    554                      }
    555                    }
    556                    break;
   \                     ??sbcSemMsgProcess_53: (+1)
   \      0x38C   0xE7FF             B.N      ??sbcSemMsgProcess_52
    557          
    558                  default:
    559                    break;
    560                }
    561                break;
   \                     ??sbcSemMsgProcess_50: (+1)
   \                     ??sbcSemMsgProcess_52: (+1)
   \      0x38E   0xF000 0xBE89      B.W      ??sbcSemMsgProcess_37
    562          
    563              case SBC_SEM_BLANK_AFTER_ASS_ADDR:
    564                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_19: (+1)
   \      0x392   0x8820             LDRH     R0,[R4, #+0]
   \      0x394   0x4558             CMP      R0,R11
   \      0x396   0xD116             BNE.N    ??sbcSemMsgProcess_56
    565                {
    566                  case SBC_SEM_TIMEOUT:
    567                    sendMonMngMsg(MON_SEM_TASK, MON_START);      // activation task for monitor  
   \      0x398   0x2100             MOVS     R1,#+0
   \      0x39A   0x2001             MOVS     R0,#+1
   \      0x39C   0x.... 0x....      BL       sendMonMngMsg
    568                    /* starts the task to manager suspend / release function   */
    569                    remoteMngTaskHandle = osThreadNew(remoteMngTask, NULL, &remoteMngTask_attributes);  
   \      0x3A0   0xF8DF 0x2BA0      LDR.W    R2,??sbcSemMsgProcess_3
   \      0x3A4   0x2100             MOVS     R1,#+0
   \      0x3A6   0xF8DF 0x0BA0      LDR.W    R0,??sbcSemMsgProcess_3+4
   \      0x3AA   0x.... 0x....      BL       osThreadNew
   \      0x3AE   0xF8DF 0x1B9C      LDR.W    R1,??sbcSemMsgProcess_3+8
   \      0x3B2   0x6008             STR      R0,[R1, #+0]
    570                    semSlaveSendActEnrg();                       // ask to send master active energy value 
   \      0x3B4   0x.... 0x....      BL       semSlaveSendActEnrg
    571                    /* now wait a request info from master */
    572                    sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \      0x3B8   0x2004             MOVS     R0,#+4
   \      0x3BA   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    573                    timeTickTmp = portMAX_DELAY;
   \      0x3BE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x3C2   0x0007             MOVS     R7,R0
    574                    break;
   \      0x3C4   0xE7FF             B.N      ??sbcSemMsgProcess_57
    575          
    576                  default:
    577                    break;
    578                }
    579                break;
   \                     ??sbcSemMsgProcess_56: (+1)
   \                     ??sbcSemMsgProcess_57: (+1)
   \      0x3C6   0xF000 0xBE6D      B.W      ??sbcSemMsgProcess_37
    580          
    581          
    582              case SBC_SEM_INIT_DISCOVERY:
    583                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_7: (+1)
   \      0x3CA   0x8820             LDRH     R0,[R4, #+0]
   \      0x3CC   0x2800             CMP      R0,#+0
   \      0x3CE   0xD001             BEQ.N    ??sbcSemMsgProcess_58
   \      0x3D0   0x2802             CMP      R0,#+2
   \      0x3D2   0xD109             BNE.N    ??sbcSemMsgProcess_59
    584                {
    585                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    586                  case NOTIFY_TO_MASTER_TX:
    587                    /* save the message for future use  */
    588                    headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_58: (+1)
   \      0x3D4   0xF8DF 0xA6E0      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x3D8   0x0021             MOVS     R1,R4
   \      0x3DA   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x3DE   0x.... 0x....      BL       addNode
   \      0x3E2   0xF8CA 0x0000      STR      R0,[R10, #+0]
    589                    break;
   \      0x3E6   0xE7FF             B.N      ??sbcSemMsgProcess_60
    590          
    591                  default:
    592                    break;
    593                }
    594                break;
   \                     ??sbcSemMsgProcess_59: (+1)
   \                     ??sbcSemMsgProcess_60: (+1)
   \      0x3E8   0xF000 0xBE5C      B.W      ??sbcSemMsgProcess_37
    595          
    596              case SBC_SEM_DISCOVERY_S:
    597                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_8: (+1)
   \      0x3EC   0x8820             LDRH     R0,[R4, #+0]
   \      0x3EE   0x2800             CMP      R0,#+0
   \      0x3F0   0xD008             BEQ.N    ??sbcSemMsgProcess_61
   \      0x3F2   0x2802             CMP      R0,#+2
   \      0x3F4   0xD02B             BEQ.N    ??sbcSemMsgProcess_62
   \      0x3F6   0x280A             CMP      R0,#+10
   \      0x3F8   0xD028             BEQ.N    ??sbcSemMsgProcess_63
   \      0x3FA   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x3FE   0x4288             CMP      R0,R1
   \      0x400   0xD12F             BNE.N    ??sbcSemMsgProcess_64
    598                {
    599                  case SBC_SEM_TIMEOUT:
    600          
    601                    break;
   \                     ??sbcSemMsgProcess_65: (+1)
   \      0x402   0xE02E             B.N      ??sbcSemMsgProcess_66
    602          
    603                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    604                    if ((pMsg->data.rAddr == ADDR_CONNECTOR_IDS_RW)  || (pMsg->data.rAddr == ADDR_EVSE_TM_RW))// 0x0004 or 0x0022
   \                     ??sbcSemMsgProcess_61: (+1)
   \      0x404   0x88A0             LDRH     R0,[R4, #+4]
   \      0x406   0x2804             CMP      R0,#+4
   \      0x408   0xD002             BEQ.N    ??sbcSemMsgProcess_67
   \      0x40A   0x88A0             LDRH     R0,[R4, #+4]
   \      0x40C   0x2822             CMP      R0,#+34
   \      0x40E   0xD10A             BNE.N    ??sbcSemMsgProcess_68
    605                    {
    606                      /* this is a slave answer where the address has been assigned already */
    607                      socketPresence.livePresence |= maskBit;
   \                     ??sbcSemMsgProcess_67: (+1)
   \      0x410   0xF8DF 0x0940      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x414   0x6841             LDR      R1,[R0, #+4]
   \      0x416   0x4331             ORRS     R1,R6,R1
   \      0x418   0x6041             STR      R1,[R0, #+4]
    608                      restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_DISCOVERY_SLAVE); // the master restart the timeout
   \      0x41A   0xF44F 0x717A      MOV      R1,#+1000
   \      0x41E   0x2000             MOVS     R0,#+0
   \      0x420   0x.... 0x....      BL       restartSbcSemTimer
   \      0x424   0xE011             B.N      ??sbcSemMsgProcess_69
    609                    }
    610                    else
    611                    {
    612                      if (pMsg->data.rAddr == ADDR_ADDR_S_CONN_RW)
   \                     ??sbcSemMsgProcess_68: (+1)
   \      0x426   0x88A0             LDRH     R0,[R4, #+4]
   \      0x428   0xF240 0x5113      MOVW     R1,#+1299
   \      0x42C   0x4288             CMP      R0,R1
   \      0x42E   0xD103             BNE.N    ??sbcSemMsgProcess_70
    613                      {
    614                        mngReqAddress(pMsg);
   \      0x430   0x0020             MOVS     R0,R4
   \      0x432   0x.... 0x....      BL       mngReqAddress
   \      0x436   0xE008             B.N      ??sbcSemMsgProcess_69
    615                      }
    616                      else
    617                      {
    618                        /* save the message for future use  */
    619                        headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_70: (+1)
   \      0x438   0xF8DF 0xA67C      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x43C   0x0021             MOVS     R1,R4
   \      0x43E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x442   0x.... 0x....      BL       addNode
   \      0x446   0xF8CA 0x0000      STR      R0,[R10, #+0]
    620                      }
    621                    }
    622                    break;
   \                     ??sbcSemMsgProcess_69: (+1)
   \      0x44A   0xE00A             B.N      ??sbcSemMsgProcess_66
    623          
    624                  case SCU_EVENT_MSG_FROM_SBC_RD:
    625                    break;
   \                     ??sbcSemMsgProcess_63: (+1)
   \      0x44C   0xE009             B.N      ??sbcSemMsgProcess_66
    626          
    627                  case NOTIFY_TO_MASTER_TX:
    628                    /* save the message for future use  */
    629                    headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_62: (+1)
   \      0x44E   0xF8DF 0xA668      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x452   0x0021             MOVS     R1,R4
   \      0x454   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x458   0x.... 0x....      BL       addNode
   \      0x45C   0xF8CA 0x0000      STR      R0,[R10, #+0]
    630                    break;
   \      0x460   0xE7FF             B.N      ??sbcSemMsgProcess_66
    631          
    632                  default:
    633                    break;
    634                }
    635                break;
   \                     ??sbcSemMsgProcess_64: (+1)
   \                     ??sbcSemMsgProcess_66: (+1)
   \      0x462   0xF000 0xBE1F      B.W      ??sbcSemMsgProcess_37
    636          
    637              case SBC_SEM_RECOVERY_INFO:
    638                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_9: (+1)
   \      0x466   0x8820             LDRH     R0,[R4, #+0]
   \      0x468   0x2802             CMP      R0,#+2
   \      0x46A   0xF000 0x8083      BEQ.W    ??sbcSemMsgProcess_71
   \      0x46E   0x2804             CMP      R0,#+4
   \      0x470   0xD004             BEQ.N    ??sbcSemMsgProcess_72
   \      0x472   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x476   0x4288             CMP      R0,R1
   \      0x478   0xF040 0x8086      BNE.W    ??sbcSemMsgProcess_73
    639                {
    640                  case SBC_SEM_TIMEOUT:
    641                  case RECOVERY_INFO:
    642                    while (txRS485Available() == (uint8_t)FALSE) osDelay(100);
   \                     ??sbcSemMsgProcess_72: (+1)
   \      0x47C   0x.... 0x....      BL       txRS485Available
   \      0x480   0x2800             CMP      R0,#+0
   \      0x482   0xD103             BNE.N    ??sbcSemMsgProcess_74
   \      0x484   0x2064             MOVS     R0,#+100
   \      0x486   0x.... 0x....      BL       osDelay
   \      0x48A   0xE7F7             B.N      ??sbcSemMsgProcess_72
    643                    if (getInfoSocket(sbcSemInfoMng.activityStatus, &sbcSemInfoMng) == FALSE)
   \                     ??sbcSemMsgProcess_74: (+1)
   \      0x48C   0xF8DF 0xA624      LDR.W    R10,??sbcSemMsgProcess_0+4
   \      0x490   0x4651             MOV      R1,R10
   \      0x492   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0x496   0x.... 0x....      BL       getInfoSocket
   \      0x49A   0x2800             CMP      R0,#+0
   \      0x49C   0xD163             BNE.N    ??sbcSemMsgProcess_75
    644                    {
    645                      setCurrentDateTimeInSem();
   \      0x49E   0x.... 0x....      BL       setCurrentDateTimeInSem
    646                      /* all the socket has been discovered */
    647                      if (socketPresence.livePresence > socketPresence.chainPresence)
   \      0x4A2   0xF8DF 0xB8B0      LDR.W    R11,??sbcSemMsgProcess_1+8
   \      0x4A6   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x4AA   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \      0x4AE   0x4288             CMP      R0,R1
   \      0x4B0   0xD203             BCS.N    ??sbcSemMsgProcess_76
    648                      {
    649                        socketPresence.chainPresence = socketPresence.livePresence;
   \      0x4B2   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0x4B6   0xF8CB 0x0000      STR      R0,[R11, #+0]
    650                      }
    651                      sbcSemInfoMng.activeLastDiscovery = socketPresence.livePresence;
   \                     ??sbcSemMsgProcess_76: (+1)
   \      0x4BA   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0x4BE   0xF8CA 0x0020      STR      R0,[R10, #+32]
    652                      /* save in EEPROM also  */
    653                      if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \      0x4C2   0x2254             MOVS     R2,#+84
   \      0x4C4   0x4659             MOV      R1,R11
   \      0x4C6   0xF44F 0x50F4      MOV      R0,#+7808
   \      0x4CA   0x.... 0x....      BL       WriteOnEeprom
   \      0x4CE   0x2800             CMP      R0,#+0
   \      0x4D0   0xD105             BNE.N    ??sbcSemMsgProcess_77
    654                      {
    655                        tPrintf("Presences detected at reset --> 0x%x\n\r", socketPresence.livePresence);
   \      0x4D2   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \      0x4D6   0x.... 0x....      LDR.W    R0,??DataTable4
   \      0x4DA   0x.... 0x....      BL       tPrintf
    656                      }
    657          
    658                      timeTickTmp = portMAX_DELAY;
   \                     ??sbcSemMsgProcess_77: (+1)
   \      0x4DE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x4E2   0x0007             MOVS     R7,R0
    659                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \      0x4E4   0x2004             MOVS     R0,#+4
   \      0x4E6   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    660          
    661                      forceSBCreadScu(sbcSemInfoMng.activityStatus);
   \      0x4EA   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0x4EE   0x.... 0x....      BL       forceSBCreadScu
    662          
    663                      sbcSemInfoMng.pollingFlag = (uint16_t)ENABLED;
   \      0x4F2   0x2001             MOVS     R0,#+1
   \      0x4F4   0xF8AA 0x001A      STRH     R0,[R10, #+26]
    664                      /* the alive task must be started to check slave connection periodically  */
    665                      pollingSlaveTaskHandle = osThreadNew(pollingSlaveTask, NULL, &pollingSlaveTask_attributes);  
   \      0x4F8   0x.... 0x....      LDR.W    R2,??DataTable4_1
   \      0x4FC   0x2100             MOVS     R1,#+0
   \      0x4FE   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \      0x502   0x.... 0x....      BL       osThreadNew
   \      0x506   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \      0x50A   0x6008             STR      R0,[R1, #+0]
    666                      Print_Slave_FW_Version();
   \      0x50C   0x.... 0x....      BL       Print_Slave_FW_Version
    667                      if (getScuOpMode() != SCU_M_STAND_ALONE)
   \      0x510   0x.... 0x....      BL       getScuOpMode
   \      0x514   0x2805             CMP      R0,#+5
   \      0x516   0xD009             BEQ.N    ??sbcSemMsgProcess_78
    668                      {
    669                        /* starts the task to manager suspend / release function   */
    670                        remoteMngTaskHandle = osThreadNew(remoteMngTask, NULL, &remoteMngTask_attributes);  
   \      0x518   0xF8DF 0x2A28      LDR.W    R2,??sbcSemMsgProcess_3
   \      0x51C   0x2100             MOVS     R1,#+0
   \      0x51E   0xF8DF 0x0A28      LDR.W    R0,??sbcSemMsgProcess_3+4
   \      0x522   0x.... 0x....      BL       osThreadNew
   \      0x526   0xF8DF 0x1A24      LDR.W    R1,??sbcSemMsgProcess_3+8
   \      0x52A   0x6008             STR      R0,[R1, #+0]
    671                      }
    672                      if (socketPresence.livePresence == sbcSemInfoMng.activityStatus)
   \                     ??sbcSemMsgProcess_78: (+1)
   \      0x52C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0x530   0xF8DA 0x1014      LDR      R1,[R10, #+20]
   \      0x534   0x4288             CMP      R0,R1
   \      0x536   0xD101             BNE.N    ??sbcSemMsgProcess_79
    673                      {
    674                        /* active the UART5 for communication with SBC only the first time after startup */
    675                        reInitSbcUart();
   \      0x538   0x.... 0x....      BL       reInitSbcUart
    676                      }
    677          
    678                      /* save all the slave parameters in external flash mememory to restore it in the future */
    679                      saveAllSlaveParameters();
   \                     ??sbcSemMsgProcess_79: (+1)
   \      0x53C   0x.... 0x....      BL       saveAllSlaveParameters
    680          
    681                      /* check if there are message to manage in the list */
    682                      if (headMsg != NULL)
   \      0x540   0xF8DF 0xB574      LDR.W    R11,??sbcSemMsgProcess_0+8
   \      0x544   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x548   0x2800             CMP      R0,#+0
   \      0x54A   0xD006             BEQ.N    ??sbcSemMsgProcess_80
    683                      {
    684                        /* re-send the message in the queue list  */
    685                        headMsg = extractSendFirstInList(headMsg);
   \      0x54C   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x550   0x.... 0x....      BL       extractSendFirstInList
   \      0x554   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \      0x558   0xE001             B.N      ??sbcSemMsgProcess_81
    686                      }
    687                      else
    688                      {
    689                        resetPacketStatusNum();
   \                     ??sbcSemMsgProcess_80: (+1)
   \      0x55A   0x.... 0x....      BL       resetPacketStatusNum
    690                      }
    691                      sbcSemInfoMng.discoveryMask = 0;
   \                     ??sbcSemMsgProcess_81: (+1)
   \      0x55E   0x2000             MOVS     R0,#+0
   \      0x560   0xF8CA 0x000A      STR      R0,[R10, #+10]
   \      0x564   0xE005             B.N      ??sbcSemMsgProcess_82
    692                    }
    693                    else
    694                    {
    695                      timeTickTmp = TIMEOUT_ACK_RESP;
   \                     ??sbcSemMsgProcess_75: (+1)
   \      0x566   0xF44F 0x70FA      MOV      R0,#+500
   \      0x56A   0x0007             MOVS     R7,R0
    696                      sbcSemInfoMng.sbcSemStates = SBC_SEM_ACK_RECOVERY_INFO;
   \      0x56C   0x2003             MOVS     R0,#+3
   \      0x56E   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    697                    }
    698                    break;
   \                     ??sbcSemMsgProcess_82: (+1)
   \      0x572   0xE009             B.N      ??sbcSemMsgProcess_83
    699          
    700                  case NOTIFY_TO_MASTER_TX:
    701                    /* save the message for future use  */
    702                    headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_71: (+1)
   \      0x574   0xF8DF 0xA540      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x578   0x0021             MOVS     R1,R4
   \      0x57A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x57E   0x.... 0x....      BL       addNode
   \      0x582   0xF8CA 0x0000      STR      R0,[R10, #+0]
    703                    break;
   \      0x586   0xE7FF             B.N      ??sbcSemMsgProcess_83
    704          
    705                  default:
    706                    break;
    707                }
    708                break;
   \                     ??sbcSemMsgProcess_73: (+1)
   \                     ??sbcSemMsgProcess_83: (+1)
   \      0x588   0xF000 0xBD8C      B.W      ??sbcSemMsgProcess_37
    709          
    710              case SBC_SEM_ACK_RECOVERY_INFO:
    711                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_10: (+1)
   \      0x58C   0x8820             LDRH     R0,[R4, #+0]
   \      0x58E   0x2807             CMP      R0,#+7
   \      0x590   0xD004             BEQ.N    ??sbcSemMsgProcess_84
   \      0x592   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x596   0x4288             CMP      R0,R1
   \      0x598   0xD04F             BEQ.N    ??sbcSemMsgProcess_85
   \      0x59A   0xE070             B.N      ??sbcSemMsgProcess_86
    712                {
    713                  case NOTIFY_MODBUS_RD_ACK:
    714                    if (((sbcSemInfoMng.logicIdSocket + 1) == pMsg->data.index) && (sbcSemInfoMng.dataVal == pMsg->dataToSend.len))
   \                     ??sbcSemMsgProcess_84: (+1)
   \      0x59C   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0x5A0   0x1C40             ADDS     R0,R0,#+1
   \      0x5A2   0x8861             LDRH     R1,[R4, #+2]
   \      0x5A4   0x4288             CMP      R0,R1
   \      0x5A6   0xD112             BNE.N    ??sbcSemMsgProcess_87
   \      0x5A8   0xF8BA 0x0004      LDRH     R0,[R10, #+4]
   \      0x5AC   0x88E1             LDRH     R1,[R4, #+6]
   \      0x5AE   0x4288             CMP      R0,R1
   \      0x5B0   0xD10D             BNE.N    ??sbcSemMsgProcess_87
    715                    {
    716                      /* a previous request to read has been accepted and new data are arrived so store it in the map */
    717                      void* pSrc = (void*)((uint32_t)pMsg->dataToSend.pData + (uint32_t)sizeof(headerAnswRHR_t));
   \      0x5B2   0x68A0             LDR      R0,[R4, #+8]
   \      0x5B4   0x1CC0             ADDS     R0,R0,#+3
   \      0x5B6   0x9006             STR      R0,[SP, #+24]
    718                      /*      destination                  source                         length */
    719                      memcpy((void*)sbcSemInfoMng.pDataRd, pSrc, (size_t)(pMsg->dataToSend.len));
   \      0x5B8   0xF8DA 0xB00E      LDR      R11,[R10, #+14]
   \      0x5BC   0x88E0             LDRH     R0,[R4, #+6]
   \      0x5BE   0x9001             STR      R0,[SP, #+4]
   \      0x5C0   0x9806             LDR      R0,[SP, #+24]
   \      0x5C2   0x9000             STR      R0,[SP, #+0]
   \      0x5C4   0x9A01             LDR      R2,[SP, #+4]
   \      0x5C6   0x9900             LDR      R1,[SP, #+0]
   \      0x5C8   0x4658             MOV      R0,R11
   \      0x5CA   0x.... 0x....      BL       __aeabi_memcpy
    720                    }
    721                    if (sbcSemInfoMng.addrVal == ADDR_START_RDD)
   \                     ??sbcSemMsgProcess_87: (+1)
   \      0x5CE   0xF8BA 0x0006      LDRH     R0,[R10, #+6]
   \      0x5D2   0xF5B0 0x7F40      CMP      R0,#+768
   \      0x5D6   0xD109             BNE.N    ??sbcSemMsgProcess_88
    722                    {
    723                      /* point to next possible slave */
    724                      sbcSemInfoMng.discoveryMask = sbcSemInfoMng.discoveryMask << 1;
   \      0x5D8   0xF11A 0x000A      ADDS     R0,R10,#+10
   \      0x5DC   0x6801             LDR      R1,[R0, #+0]
   \      0x5DE   0x0049             LSLS     R1,R1,#+1
   \      0x5E0   0x6001             STR      R1,[R0, #+0]
    725                      sbcSemInfoMng.logicIdSocket++;
   \      0x5E2   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0x5E6   0x1C40             ADDS     R0,R0,#+1
   \      0x5E8   0xF8AA 0x0008      STRH     R0,[R10, #+8]
    726                    }
    727                    /* release the transmitter */
    728                    currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \                     ??sbcSemMsgProcess_88: (+1)
   \      0x5EC   0xF8DF 0xB960      LDR.W    R11,??sbcSemMsgProcess_3+12
   \      0x5F0   0x2005             MOVS     R0,#+5
   \      0x5F2   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    729                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x5F6   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x5FA   0x2300             MOVS     R3,#+0
   \      0x5FC   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x600   0x4659             MOV      R1,R11
   \      0x602   0x.... 0x....      BL       xQueueGenericSend
   \      0x606   0x2801             CMP      R0,#+1
   \      0x608   0xD009             BEQ.N    ??sbcSemMsgProcess_89
   \      0x60A   0xB672             CPSID    I
   \      0x60C   0x2050             MOVS     R0,#+80
   \      0x60E   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x612   0xF3BF 0x8F4F      DSB      SY
   \      0x616   0xF3BF 0x8F6F      ISB      SY
   \      0x61A   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_90: (+1)
   \      0x61C   0xE7FE             B.N      ??sbcSemMsgProcess_90
    730                    /* release the buffer  */
    731                    if (pMsg->dataToSend.pData != NULL) 
   \                     ??sbcSemMsgProcess_89: (+1)
   \      0x61E   0x68A0             LDR      R0,[R4, #+8]
   \      0x620   0x2800             CMP      R0,#+0
   \      0x622   0xD004             BEQ.N    ??sbcSemMsgProcess_91
    732                    {
    733                      free((void*)pMsg->dataToSend.pData);
   \      0x624   0x68A0             LDR      R0,[R4, #+8]
   \      0x626   0x.... 0x....      BL       free
    734                      pMsg->dataToSend.pData = NULL;
   \      0x62A   0x2000             MOVS     R0,#+0
   \      0x62C   0x60A0             STR      R0,[R4, #+8]
    735                    }
    736                    /* timeout 20ms for next reading   */
    737                    timeTickTmp = pdMS_TO_TICKS(TIMEOUT_RD_REQ);  
   \                     ??sbcSemMsgProcess_91: (+1)
   \      0x62E   0x2014             MOVS     R0,#+20
   \      0x630   0x0007             MOVS     R7,R0
    738                    sbcSemInfoMng.sbcSemStates = SBC_SEM_RECOVERY_INFO;
   \      0x632   0x2002             MOVS     R0,#+2
   \      0x634   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    739                    break;
   \      0x638   0xE021             B.N      ??sbcSemMsgProcess_92
    740          
    741                  case SBC_SEM_TIMEOUT:
    742                    tPrintf("Abort: No info received from Addr = %d!\n\r", sbcSemInfoMng.logicIdSocket + 1);
   \                     ??sbcSemMsgProcess_85: (+1)
   \      0x63A   0xF8BA 0x1008      LDRH     R1,[R10, #+8]
   \      0x63E   0x1C49             ADDS     R1,R1,#+1
   \      0x640   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \      0x644   0x.... 0x....      BL       tPrintf
    743                    socketPresence.livePresence &= (~sbcSemInfoMng.discoveryMask);
   \      0x648   0xF11A 0x010A      ADDS     R1,R10,#+10
   \      0x64C   0x680A             LDR      R2,[R1, #+0]
   \      0x64E   0xF8DF 0x0704      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x652   0x6843             LDR      R3,[R0, #+4]
   \      0x654   0xEA33 0x0202      BICS     R2,R3,R2
   \      0x658   0x6042             STR      R2,[R0, #+4]
    744                    /* timeout 20ms for next reading   */
    745                    if (sbcSemInfoMng.logicIdSocket < SCU_NUM)
   \      0x65A   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0x65E   0x2810             CMP      R0,#+16
   \      0x660   0xDA07             BGE.N    ??sbcSemMsgProcess_93
    746                    {
    747                      sbcSemInfoMng.logicIdSocket++;
   \      0x662   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0x666   0x1C40             ADDS     R0,R0,#+1
   \      0x668   0xF8AA 0x0008      STRH     R0,[R10, #+8]
    748                      sbcSemInfoMng.discoveryMask = sbcSemInfoMng.discoveryMask << 1;
   \      0x66C   0x6808             LDR      R0,[R1, #+0]
   \      0x66E   0x0040             LSLS     R0,R0,#+1
   \      0x670   0x6008             STR      R0,[R1, #+0]
    749                    }
    750                    timeTickTmp = pdMS_TO_TICKS(TIMEOUT_RD_REQ);  
   \                     ??sbcSemMsgProcess_93: (+1)
   \      0x672   0x2014             MOVS     R0,#+20
   \      0x674   0x0007             MOVS     R7,R0
    751                    sbcSemInfoMng.sbcSemStates = SBC_SEM_RECOVERY_INFO;
   \      0x676   0x2002             MOVS     R0,#+2
   \      0x678   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    752                    break;
   \      0x67C   0xE7FF             B.N      ??sbcSemMsgProcess_92
    753          
    754                  default:
    755                    break;
    756                }
    757                break;
   \                     ??sbcSemMsgProcess_86: (+1)
   \                     ??sbcSemMsgProcess_92: (+1)
   \      0x67E   0xF000 0xBD11      B.W      ??sbcSemMsgProcess_37
    758          
    759              case SBC_SEM_WAIT_TO_BE_OPERATIVE:
    760                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_17: (+1)
   \      0x682   0x8820             LDRH     R0,[R4, #+0]
   \      0x684   0x2800             CMP      R0,#+0
   \      0x686   0xD003             BEQ.N    ??sbcSemMsgProcess_94
   \      0x688   0x2802             CMP      R0,#+2
   \      0x68A   0xF000 0x808E      BEQ.W    ??sbcSemMsgProcess_95
   \      0x68E   0xE0A3             B.N      ??sbcSemMsgProcess_96
    761                {
    762                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    763                    if (ixScu == MODBUS_BROADCAST_ADDR)
   \                     ??sbcSemMsgProcess_94: (+1)
   \      0x690   0x0028             MOVS     R0,R5
   \      0x692   0xB280             UXTH     R0,R0
   \      0x694   0x2800             CMP      R0,#+0
   \      0x696   0xF040 0x8087      BNE.W    ??sbcSemMsgProcess_97
    764                    {
    765                      if (pMsg->data.rAddr == ADDR_EVSE_TM_RW)
   \      0x69A   0x88A0             LDRH     R0,[R4, #+4]
   \      0x69C   0x2822             CMP      R0,#+34
   \      0x69E   0xF040 0x8083      BNE.W    ??sbcSemMsgProcess_97
    766                      {
    767                        pWord = (uint16_t *)pMsg->dataToSend.pData;
   \      0x6A2   0x68A0             LDR      R0,[R4, #+8]
   \      0x6A4   0x9003             STR      R0,[SP, #+12]
    768                        if (SCU_S_REPL_ADDR != getStationId()) /* board with address = 99 is for replacement */
   \      0x6A6   0x.... 0x....      BL       getStationId
   \      0x6AA   0x2863             CMP      R0,#+99
   \      0x6AC   0xD049             BEQ.N    ??sbcSemMsgProcess_98
    769                        {
    770                          if (((uint16_t)SCU_S_PS_LIVE == *pWord) || ((uint16_t)SCU_S_PS_STARTUP == *pWord) ||
    771                              ((uint16_t)SCU_S_PS_NEW == *pWord))               // SCU_S_PS_NEW = 6 or SCU_S_PS_LIVE=5  or SCU_S_PS_STARTUP=4
   \      0x6AE   0x9803             LDR      R0,[SP, #+12]
   \      0x6B0   0x8800             LDRH     R0,[R0, #+0]
   \      0x6B2   0x2805             CMP      R0,#+5
   \      0x6B4   0xD007             BEQ.N    ??sbcSemMsgProcess_99
   \      0x6B6   0x9803             LDR      R0,[SP, #+12]
   \      0x6B8   0x8800             LDRH     R0,[R0, #+0]
   \      0x6BA   0x2804             CMP      R0,#+4
   \      0x6BC   0xD003             BEQ.N    ??sbcSemMsgProcess_99
   \      0x6BE   0x9803             LDR      R0,[SP, #+12]
   \      0x6C0   0x8800             LDRH     R0,[R0, #+0]
   \      0x6C2   0x2806             CMP      R0,#+6
   \      0x6C4   0xD170             BNE.N    ??sbcSemMsgProcess_97
    772                          {
    773                            /* a master starts a broadcast request: this is the case when the slave starts long time after master reset  */
    774                            if (socketPresence.keyPresence == KEY_FULL_CONFIG)
   \                     ??sbcSemMsgProcess_99: (+1)
   \      0x6C6   0xF8DF 0x068C      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x6CA   0x6880             LDR      R0,[R0, #+8]
   \      0x6CC   0xF64A 0x2155      MOVW     R1,#+43605
   \      0x6D0   0x4288             CMP      R0,R1
   \      0x6D2   0xD169             BNE.N    ??sbcSemMsgProcess_97
    775                            {
    776                              /* the address in ADDR_CONNECTOR_IDS_RW has been already assigned by master */
    777                              currFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \      0x6D4   0xF8DF 0xB878      LDR.W    R11,??sbcSemMsgProcess_3+12
   \      0x6D8   0x2002             MOVS     R0,#+2
   \      0x6DA   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    778                              currFrameSbcSem.data.index = getPhysicalMdbAddr();  /* rs485SemMsgProcess() use physical address = modbus address   1...247 */
   \      0x6DE   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0x6E2   0xF8AB 0x0002      STRH     R0,[R11, #+2]
    779                              currFrameSbcSem.data.rAddr = ADDR_CONNECTOR_IDS_RW;  // 0x0004
   \      0x6E6   0x2004             MOVS     R0,#+4
   \      0x6E8   0xF8AB 0x0004      STRH     R0,[R11, #+4]
    780                              currFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \      0x6EC   0xF11A 0x0004      ADDS     R0,R10,#+4
   \      0x6F0   0xF8CB 0x0008      STR      R0,[R11, #+8]
    781                              /* to avoid possible conflit on first Tx byte a random delay is used  */
    782                              osDelay((uint32_t)10 * (uint32_t)currFrameSbcSem.data.index);  /* delay in the range 2...50 msec */
   \      0x6F4   0xF8BB 0x0002      LDRH     R0,[R11, #+2]
   \      0x6F8   0x210A             MOVS     R1,#+10
   \      0x6FA   0x4348             MULS     R0,R1,R0
   \      0x6FC   0x.... 0x....      BL       osDelay
    783                              configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x700   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x704   0x2300             MOVS     R3,#+0
   \      0x706   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x70A   0x4659             MOV      R1,R11
   \      0x70C   0x.... 0x....      BL       xQueueGenericSend
   \      0x710   0x2801             CMP      R0,#+1
   \      0x712   0xD009             BEQ.N    ??sbcSemMsgProcess_100
   \      0x714   0xB672             CPSID    I
   \      0x716   0x2050             MOVS     R0,#+80
   \      0x718   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x71C   0xF3BF 0x8F4F      DSB      SY
   \      0x720   0xF3BF 0x8F6F      ISB      SY
   \      0x724   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_101: (+1)
   \      0x726   0xE7FE             B.N      ??sbcSemMsgProcess_101
    784                              sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_WR_MASTER_ACK_STARTUP; 
   \                     ??sbcSemMsgProcess_100: (+1)
   \      0x728   0x200D             MOVS     R0,#+13
   \      0x72A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    785                              // start ACK timer 
    786                              timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_RESP); 
   \      0x72E   0xF44F 0x70FA      MOV      R0,#+500
   \      0x732   0x0007             MOVS     R7,R0
    787                              sendMonMngMsg(MON_SEM_TASK, MON_START);      // activation task for monitor  
   \      0x734   0x2100             MOVS     R1,#+0
   \      0x736   0x2001             MOVS     R0,#+1
   \      0x738   0x.... 0x....      BL       sendMonMngMsg
    788                              semSlaveSendActEnrg();                       // ask to send master active energy value 
   \      0x73C   0x.... 0x....      BL       semSlaveSendActEnrg
   \      0x740   0xE032             B.N      ??sbcSemMsgProcess_97
    789                            }
    790                          }        /* no action in this state: wait time out */
    791                        }
    792                        else
    793                        {
    794                          if ((uint16_t)SCU_S_PS_NEW == *pWord)               // SCU_S_PS_NEW = 6 
   \                     ??sbcSemMsgProcess_98: (+1)
   \      0x742   0x9803             LDR      R0,[SP, #+12]
   \      0x744   0x8800             LDRH     R0,[R0, #+0]
   \      0x746   0x2806             CMP      R0,#+6
   \      0x748   0xD12E             BNE.N    ??sbcSemMsgProcess_97
    795                          {
    796                            /* ask the master to send eeprom configuration data: This is made writing at address ADDR_GET_EEPROM_RW */
    797                            currFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \      0x74A   0xF8DF 0xB804      LDR.W    R11,??sbcSemMsgProcess_3+12
   \      0x74E   0x2002             MOVS     R0,#+2
   \      0x750   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    798                            currFrameSbcSem.data.index = getPhysicalMdbAddr();  /* rs485SemMsgProcess() use physical address = modbus address   1...247 */
   \      0x754   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0x758   0xF8AB 0x0002      STRH     R0,[R11, #+2]
    799                            currFrameSbcSem.data.rAddr = ADDR_GET_EEPROM_RW;    // 0x0523
   \      0x75C   0xF240 0x5023      MOVW     R0,#+1315
   \      0x760   0xF8AB 0x0004      STRH     R0,[R11, #+4]
    800                            sbcSemInfoMng.dataVal = (uint16_t)1099;
   \      0x764   0xF240 0x404B      MOVW     R0,#+1099
   \      0x768   0xF8AA 0x0004      STRH     R0,[R10, #+4]
    801                            currFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \      0x76C   0xF11A 0x0004      ADDS     R0,R10,#+4
   \      0x770   0xF8CB 0x0008      STR      R0,[R11, #+8]
    802                            configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x774   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x778   0x2300             MOVS     R3,#+0
   \      0x77A   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x77E   0x4659             MOV      R1,R11
   \      0x780   0x.... 0x....      BL       xQueueGenericSend
   \      0x784   0x2801             CMP      R0,#+1
   \      0x786   0xD009             BEQ.N    ??sbcSemMsgProcess_102
   \      0x788   0xB672             CPSID    I
   \      0x78A   0x2050             MOVS     R0,#+80
   \      0x78C   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x790   0xF3BF 0x8F4F      DSB      SY
   \      0x794   0xF3BF 0x8F6F      ISB      SY
   \      0x798   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_103: (+1)
   \      0x79A   0xE7FE             B.N      ??sbcSemMsgProcess_103
    803                            sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_WR_MASTER_ACK_STARTUP; 
   \                     ??sbcSemMsgProcess_102: (+1)
   \      0x79C   0x200D             MOVS     R0,#+13
   \      0x79E   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    804                            // start ACK timer 
    805                            timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_RESP); 
   \      0x7A2   0xF44F 0x70FA      MOV      R0,#+500
   \      0x7A6   0x0007             MOVS     R7,R0
    806                          }
    807                        }
    808                      }
    809                    }
    810                    break;
   \                     ??sbcSemMsgProcess_97: (+1)
   \      0x7A8   0xE016             B.N      ??sbcSemMsgProcess_104
    811          
    812                  case NOTIFY_TO_MASTER_TX:
    813                    if (pMsg->data.rAddr == ADDR_TM_EVSE_READY_RO)  // 0x512 Testing machine starts test
   \                     ??sbcSemMsgProcess_95: (+1)
   \      0x7AA   0x88A0             LDRH     R0,[R4, #+4]
   \      0x7AC   0xF240 0x5112      MOVW     R1,#+1298
   \      0x7B0   0x4288             CMP      R0,R1
   \      0x7B2   0xD103             BNE.N    ??sbcSemMsgProcess_105
    814                    {
    815                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE_COLLAUDO;
   \      0x7B4   0x200E             MOVS     R0,#+14
   \      0x7B6   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \      0x7BA   0xE00C             B.N      ??sbcSemMsgProcess_106
    816                    }
    817                    else
    818                    {
    819                      if (SCU_S_REPL_ADDR != getStationId()) /* board with address = 99 is for replacement, so no message storing is need */
   \                     ??sbcSemMsgProcess_105: (+1)
   \      0x7BC   0x.... 0x....      BL       getStationId
   \      0x7C0   0x2863             CMP      R0,#+99
   \      0x7C2   0xD008             BEQ.N    ??sbcSemMsgProcess_106
    820                      {
    821                        /* a previous message is sending, so the current is put in the list */
    822                        headMsg = addNode(headMsg, pMsg);
   \      0x7C4   0xF8DF 0xA2F0      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x7C8   0x0021             MOVS     R1,R4
   \      0x7CA   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x7CE   0x.... 0x....      BL       addNode
   \      0x7D2   0xF8CA 0x0000      STR      R0,[R10, #+0]
    823                      }
    824                    }
    825                    break;
   \                     ??sbcSemMsgProcess_106: (+1)
   \      0x7D6   0xE7FF             B.N      ??sbcSemMsgProcess_104
    826          
    827                  default:
    828                    break;
    829          
    830                }
    831                break;
   \                     ??sbcSemMsgProcess_96: (+1)
   \                     ??sbcSemMsgProcess_104: (+1)
   \      0x7D8   0xF000 0xBC64      B.W      ??sbcSemMsgProcess_37
    832          
    833              case SBC_SEM_OPERATIVE_COLLAUDO:
    834                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_18: (+1)
   \      0x7DC   0x8820             LDRH     R0,[R4, #+0]
   \      0x7DE   0x2800             CMP      R0,#+0
   \      0x7E0   0xD002             BEQ.N    ??sbcSemMsgProcess_107
   \      0x7E2   0x2802             CMP      R0,#+2
   \      0x7E4   0xD009             BEQ.N    ??sbcSemMsgProcess_108
   \      0x7E6   0xE010             B.N      ??sbcSemMsgProcess_109
    835                {
    836                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    837                    /* upgrade the register */
    838                    (void)setChangeRegisterBit(ixScu, pMsg, (uint32_t)maskBit, ixLogic);
   \                     ??sbcSemMsgProcess_107: (+1)
   \      0x7E8   0xF8BD 0x3008      LDRH     R3,[SP, #+8]
   \      0x7EC   0x0032             MOVS     R2,R6
   \      0x7EE   0x0021             MOVS     R1,R4
   \      0x7F0   0x0028             MOVS     R0,R5
   \      0x7F2   0xB280             UXTH     R0,R0
   \      0x7F4   0x.... 0x....      BL       setChangeRegisterBit
    839                    break;
   \      0x7F8   0xE007             B.N      ??sbcSemMsgProcess_110
    840          
    841                  case NOTIFY_TO_MASTER_TX:
    842                    (void)setChangeRegisterBit(SCU_M_P_ADDR, pMsg, (uint32_t)maskBit, ixLogic);
   \                     ??sbcSemMsgProcess_108: (+1)
   \      0x7FA   0xF8BD 0x3008      LDRH     R3,[SP, #+8]
   \      0x7FE   0x0032             MOVS     R2,R6
   \      0x800   0x0021             MOVS     R1,R4
   \      0x802   0x2001             MOVS     R0,#+1
   \      0x804   0x.... 0x....      BL       setChangeRegisterBit
    843                    break;
   \      0x808   0xE7FF             B.N      ??sbcSemMsgProcess_110
    844          
    845                  default:
    846                    break;
    847                }
    848                break;
   \                     ??sbcSemMsgProcess_109: (+1)
   \                     ??sbcSemMsgProcess_110: (+1)
   \      0x80A   0xF000 0xBC4B      B.W      ??sbcSemMsgProcess_37
    849          
    850          
    851              case SBC_SEM_OPERATIVE:
    852                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_11: (+1)
   \      0x80E   0x8820             LDRH     R0,[R4, #+0]
   \      0x810   0x2800             CMP      R0,#+0
   \      0x812   0xD01C             BEQ.N    ??sbcSemMsgProcess_111
   \      0x814   0x2801             CMP      R0,#+1
   \      0x816   0xF000 0x8167      BEQ.W    ??sbcSemMsgProcess_112
   \      0x81A   0x2802             CMP      R0,#+2
   \      0x81C   0xF000 0x81B9      BEQ.W    ??sbcSemMsgProcess_113
   \      0x820   0x2804             CMP      R0,#+4
   \      0x822   0xF000 0x8255      BEQ.W    ??sbcSemMsgProcess_114
   \      0x826   0x2807             CMP      R0,#+7
   \      0x828   0xF000 0x82A0      BEQ.W    ??sbcSemMsgProcess_115
   \      0x82C   0x280A             CMP      R0,#+10
   \      0x82E   0xF000 0x8231      BEQ.W    ??sbcSemMsgProcess_116
   \      0x832   0x280B             CMP      R0,#+11
   \      0x834   0xF000 0x8249      BEQ.W    ??sbcSemMsgProcess_117
   \      0x838   0x280C             CMP      R0,#+12
   \      0x83A   0xD008             BEQ.N    ??sbcSemMsgProcess_111
   \      0x83C   0x280D             CMP      R0,#+13
   \      0x83E   0xF000 0x8153      BEQ.W    ??sbcSemMsgProcess_112
   \      0x842   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x846   0x4288             CMP      R0,R1
   \      0x848   0xF000 0x8242      BEQ.W    ??sbcSemMsgProcess_114
   \      0x84C   0xE2DE             B.N      ??sbcSemMsgProcess_118
    853                {
    854                  case POLLING_CHANGE_INFO:
    855                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    856                    toggleHeartLed();
   \                     ??sbcSemMsgProcess_111: (+1)
   \      0x84E   0x.... 0x....      BL       toggleHeartLed
    857                    if (isSemMasterFz() == TRUE) 
   \      0x852   0x.... 0x....      BL       isSemMasterFz
   \      0x856   0x2801             CMP      R0,#+1
   \      0x858   0xF040 0x80CC      BNE.W    ??sbcSemMsgProcess_119
    858                    {
    859                      if (pMsg->data.rAddr == ADDR_ADDR_S_CONN_RW)  // 0x513
   \      0x85C   0x88A0             LDRH     R0,[R4, #+4]
   \      0x85E   0xF240 0x5113      MOVW     R1,#+1299
   \      0x862   0x4288             CMP      R0,R1
   \      0x864   0xD103             BNE.N    ??sbcSemMsgProcess_120
    860                      {
    861                        /* a new slave (socket) has been inserted in the chain and ask its address */
    862                        mngReqAddress(pMsg);
   \      0x866   0x0020             MOVS     R0,R4
   \      0x868   0x.... 0x....      BL       mngReqAddress
   \      0x86C   0xE13B             B.N      ??sbcSemMsgProcess_121
    863                      }
    864                      else
    865                      {
    866                        if ((pMsg->data.rAddr == ADDR_CONNECTOR_IDS_RW) || (pMsg->data.rAddr == ADDR_EVSE_TM_RW)) // 0x0004 or 0x0022  ADDR_EVSE_TM_RW
   \                     ??sbcSemMsgProcess_120: (+1)
   \      0x86E   0x88A0             LDRH     R0,[R4, #+4]
   \      0x870   0x2804             CMP      R0,#+4
   \      0x872   0xD002             BEQ.N    ??sbcSemMsgProcess_122
   \      0x874   0x88A0             LDRH     R0,[R4, #+4]
   \      0x876   0x2822             CMP      R0,#+34
   \      0x878   0xD137             BNE.N    ??sbcSemMsgProcess_123
    867                        {
    868                          /* this is a slave answer where the address has been assigned already: this is the case the socket has RS485 off-line and we reconnect its later  */
    869                          /* update activity status */                               
    870                          sbcSemInfoMng.activityStatus |= maskBit;
   \                     ??sbcSemMsgProcess_122: (+1)
   \      0x87A   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0x87E   0x4330             ORRS     R0,R6,R0
   \      0x880   0xF8CA 0x0014      STR      R0,[R10, #+20]
    871                          if ((socketPresence.livePresence & maskBit) == 0)
   \      0x884   0xF8DF 0x04CC      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x888   0x6840             LDR      R0,[R0, #+4]
   \      0x88A   0x4230             TST      R0,R6
   \      0x88C   0xD105             BNE.N    ??sbcSemMsgProcess_124
    872                          {
    873                            /* recover all info */
    874          #ifdef COME_ERA
    875                            /* the live presence bit will be update at the end of recovery info phase Nick 30/07/2024 */
    876                            socketPresence.livePresence |= maskBit; 
    877          #endif
    878                            restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_NEXT_DISCOVERY); // the master restart the timeout 500msec
   \      0x88E   0xF640 0x11C4      MOVW     R1,#+2500
   \      0x892   0x2000             MOVS     R0,#+0
   \      0x894   0x.... 0x....      BL       restartSbcSemTimer
   \      0x898   0xE125             B.N      ??sbcSemMsgProcess_121
    879                          }
    880                          else
    881                          {
    882                            if (pMsg->data.rAddr == ADDR_EVSE_TM_RW) // 0x0022 ADDR_EVSE_TM_RW
   \                     ??sbcSemMsgProcess_124: (+1)
   \      0x89A   0x88A0             LDRH     R0,[R4, #+4]
   \      0x89C   0x2822             CMP      R0,#+34
   \      0x89E   0xF040 0x8122      BNE.W    ??sbcSemMsgProcess_121
    883                            {
    884                              pWord = (uint16_t *)pMsg->dataToSend.pData;
   \      0x8A2   0x68A0             LDR      R0,[R4, #+8]
   \      0x8A4   0x9003             STR      R0,[SP, #+12]
    885                              pScuRoMapRegSlave = getRoMdbRegs(ixLogic);
   \      0x8A6   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0x8AA   0xB2C0             UXTB     R0,R0
   \      0x8AC   0x.... 0x....      BL       getRoMdbRegs
   \      0x8B0   0x9004             STR      R0,[SP, #+16]
    886                              if  (pScuRoMapRegSlave->scuMapRegStatusMeas.ntfChgStat != *pWord)
   \      0x8B2   0x9804             LDR      R0,[SP, #+16]
   \      0x8B4   0xF8B0 0x0124      LDRH     R0,[R0, #+292]
   \      0x8B8   0x9903             LDR      R1,[SP, #+12]
   \      0x8BA   0x8809             LDRH     R1,[R1, #+0]
   \      0x8BC   0x4288             CMP      R0,R1
   \      0x8BE   0xF000 0x8112      BEQ.W    ??sbcSemMsgProcess_121
    887                              {
    888                                /* the current state stored in the slave map, isn't the same coming from polling */
    889                                /* so update the map and notify to SEM                                           */
    890                                pScuRoMapRegSlave->scuMapRegStatusMeas.ntfChgStat = pMsg->status = *pWord;
   \      0x8C2   0x9803             LDR      R0,[SP, #+12]
   \      0x8C4   0x8800             LDRH     R0,[R0, #+0]
   \      0x8C6   0x81A0             STRH     R0,[R4, #+12]
   \      0x8C8   0x89A0             LDRH     R0,[R4, #+12]
   \      0x8CA   0x9904             LDR      R1,[SP, #+16]
   \      0x8CC   0xF8A1 0x0124      STRH     R0,[R1, #+292]
    891                                /* upgrade the register */
    892                                pMsg->data.rAddr = ADDR_EVSE_CHARGE_STATUS_RO;
   \      0x8D0   0xF240 0x6001      MOVW     R0,#+1537
   \      0x8D4   0x80A0             STRH     R0,[R4, #+4]
    893                                result = (uint8_t)setChangeRegisterBit(ixScu, pMsg, (uint32_t)maskBit, ixLogic);
   \      0x8D6   0xF8BD 0x3008      LDRH     R3,[SP, #+8]
   \      0x8DA   0x0032             MOVS     R2,R6
   \      0x8DC   0x0021             MOVS     R1,R4
   \      0x8DE   0x0028             MOVS     R0,R5
   \      0x8E0   0xB280             UXTH     R0,R0
   \      0x8E2   0x.... 0x....      BL       setChangeRegisterBit
   \      0x8E6   0x4680             MOV      R8,R0
   \      0x8E8   0xE0FD             B.N      ??sbcSemMsgProcess_121
    894                              }
    895                            }
    896                          }
    897                        }
    898                        else
    899                        {
    900                          if (pMsg->data.rAddr == ADDR_GET_EEPROM_RW)
   \                     ??sbcSemMsgProcess_123: (+1)
   \      0x8EA   0x88A0             LDRH     R0,[R4, #+4]
   \      0x8EC   0xF240 0x5123      MOVW     R1,#+1315
   \      0x8F0   0x4288             CMP      R0,R1
   \      0x8F2   0xD13E             BNE.N    ??sbcSemMsgProcess_125
    901                          {
    902                            /* this is a slave SCU board used as replacement for first address fail. First of all we find first address fail */
    903                            for (cnt = 0, maskBit = (uint32_t)1, result = SCU_NUM; cnt < SCU_NUM; cnt++, maskBit = maskBit << 1)
   \      0x8F4   0x2000             MOVS     R0,#+0
   \      0x8F6   0x4681             MOV      R9,R0
   \      0x8F8   0x2001             MOVS     R0,#+1
   \      0x8FA   0x0006             MOVS     R6,R0
   \      0x8FC   0x2010             MOVS     R0,#+16
   \      0x8FE   0x4680             MOV      R8,R0
   \                     ??sbcSemMsgProcess_126: (+1)
   \      0x900   0x4648             MOV      R0,R9
   \      0x902   0xB2C0             UXTB     R0,R0
   \      0x904   0x2810             CMP      R0,#+16
   \      0x906   0xDA1E             BGE.N    ??sbcSemMsgProcess_127
    904                            {
    905                              if (cnt == 0) continue;
   \      0x908   0x4648             MOV      R0,R9
   \      0x90A   0xB2C0             UXTB     R0,R0
   \      0x90C   0x2800             CMP      R0,#+0
   \      0x90E   0xD016             BEQ.N    ??sbcSemMsgProcess_128
    906                              if (((socketPresence.chainPresence & maskBit) != 0) && ((socketPresence.livePresence & maskBit) == 0)) 
   \                     ??sbcSemMsgProcess_129: (+1)
   \      0x910   0xF8DF 0x0440      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x914   0x6801             LDR      R1,[R0, #+0]
   \      0x916   0x4231             TST      R1,R6
   \      0x918   0xD011             BEQ.N    ??sbcSemMsgProcess_128
   \      0x91A   0x6841             LDR      R1,[R0, #+4]
   \      0x91C   0x4231             TST      R1,R6
   \      0x91E   0xD10E             BNE.N    ??sbcSemMsgProcess_128
    907                              {
    908                                /* this is the index of a fail board. The jolly SCU is placed at the lower number diplayed on LCD, i.e. minimum connector Id  */
    909                                if (socketPresence.matrixIdConn[cnt] < result) result = socketPresence.matrixIdConn[cnt];
   \      0x920   0x4649             MOV      R1,R9
   \      0x922   0xB2C9             UXTB     R1,R1
   \      0x924   0x4401             ADD      R1,R0,R1
   \      0x926   0xF891 0x1030      LDRB     R1,[R1, #+48]
   \      0x92A   0x4642             MOV      R2,R8
   \      0x92C   0xB2D2             UXTB     R2,R2
   \      0x92E   0x4291             CMP      R1,R2
   \      0x930   0xD205             BCS.N    ??sbcSemMsgProcess_128
   \      0x932   0x4649             MOV      R1,R9
   \      0x934   0xB2C9             UXTB     R1,R1
   \      0x936   0x4408             ADD      R0,R0,R1
   \      0x938   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \      0x93C   0x4680             MOV      R8,R0
    910                              }
    911                            }
   \                     ??sbcSemMsgProcess_128: (+1)
   \      0x93E   0xF119 0x0901      ADDS     R9,R9,#+1
   \      0x942   0x0076             LSLS     R6,R6,#+1
   \      0x944   0xE7DC             B.N      ??sbcSemMsgProcess_126
    912                            if (result < SCU_NUM)
   \                     ??sbcSemMsgProcess_127: (+1)
   \      0x946   0x4640             MOV      R0,R8
   \      0x948   0xB2C0             UXTB     R0,R0
   \      0x94A   0x2810             CMP      R0,#+16
   \      0x94C   0xF280 0x80CB      BGE.W    ??sbcSemMsgProcess_121
    913                            {
    914                              /* recovery the address on RS485 for first fail board to be cloned */
    915                              cnt = socketPresence.matrixConv[result]; 
   \      0x950   0xF8DF 0x0400      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x954   0x4641             MOV      R1,R8
   \      0x956   0xB2C9             UXTB     R1,R1
   \      0x958   0x4408             ADD      R0,R0,R1
   \      0x95A   0x7C00             LDRB     R0,[R0, #+16]
   \      0x95C   0x4681             MOV      R9,R0
    916                              /* we have found the address of replaced slave SCU */
    917                              if (sendEeepromInfoForCloning(cnt) == 0)
   \      0x95E   0x4648             MOV      R0,R9
   \      0x960   0xB2C0             UXTB     R0,R0
   \      0x962   0x.... 0x....      BL       sendEeepromInfoForCloning
   \      0x966   0x2800             CMP      R0,#+0
   \      0x968   0xF000 0x8250      BEQ.W    ??sbcSemMsgProcess_130
    918                              {
    919                                break;
    920                              }
    921                              /* restart the master to check if cloned SCU works properly (detected with all info) */
    922                              activeImmediateReset(); 
   \                     ??sbcSemMsgProcess_131: (+1)
   \      0x96C   0x.... 0x....      BL       activeImmediateReset
   \      0x970   0xE0B9             B.N      ??sbcSemMsgProcess_121
    923                            }
    924                          }
    925                          else
    926                          {
    927                            /* upgrade the register */
    928                            result = (uint8_t)setChangeRegisterBit(ixScu, pMsg, (uint32_t)maskBit, ixLogic);
   \                     ??sbcSemMsgProcess_125: (+1)
   \      0x972   0xF8BD 0x3008      LDRH     R3,[SP, #+8]
   \      0x976   0x0032             MOVS     R2,R6
   \      0x978   0x0021             MOVS     R1,R4
   \      0x97A   0x0028             MOVS     R0,R5
   \      0x97C   0xB280             UXTH     R0,R0
   \      0x97E   0x.... 0x....      BL       setChangeRegisterBit
   \      0x982   0x4680             MOV      R8,R0
    929                            if (result == (uint8_t)SEND_ACK)
   \      0x984   0x4640             MOV      R0,R8
   \      0x986   0xB2C0             UXTB     R0,R0
   \      0x988   0x2801             CMP      R0,#+1
   \      0x98A   0xD124             BNE.N    ??sbcSemMsgProcess_132
    930                            {
    931                              /* a message froma slave on  RS485 has been received: Set the activity bit */
    932                              sbcSemInfoMng.activityStatus |= maskBit;
   \      0x98C   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0x990   0x4330             ORRS     R0,R6,R0
   \      0x992   0xF8CA 0x0014      STR      R0,[R10, #+20]
    933                              if ((sbcSemInfoMng.scuInDwldIdx == ixScu) && (pMsg->data.rAddr == ADDR_EVSE_ERROR2_RO))
   \      0x996   0xF8BA 0x0012      LDRH     R0,[R10, #+18]
   \      0x99A   0x0029             MOVS     R1,R5
   \      0x99C   0xB289             UXTH     R1,R1
   \      0x99E   0x4288             CMP      R0,R1
   \      0x9A0   0xF040 0x80A1      BNE.W    ??sbcSemMsgProcess_121
   \      0x9A4   0x88A0             LDRH     R0,[R4, #+4]
   \      0x9A6   0xF240 0x4105      MOVW     R1,#+1029
   \      0x9AA   0x4288             CMP      R0,R1
   \      0x9AC   0xF040 0x809B      BNE.W    ??sbcSemMsgProcess_121
    934                              {
    935                                /* the rebooting phase in the slave is terminated: it is necessary to re-scan all info  */
    936                                sbcSemInfoMng.scuInDwldIdx = (uint16_t)0;
   \      0x9B0   0x2000             MOVS     R0,#+0
   \      0x9B2   0xF8AA 0x0012      STRH     R0,[R10, #+18]
    937                                /* set initial socket info */
    938                                sbcSemInfoMng.discoveryMask = (uint32_t)0x2;
   \      0x9B6   0x2002             MOVS     R0,#+2
   \      0x9B8   0xF8CA 0x000A      STR      R0,[R10, #+10]
    939                                sbcSemInfoMng.logicIdSocket = (uint16_t)0x1;
   \      0x9BC   0x2001             MOVS     R0,#+1
   \      0x9BE   0xF8AA 0x0008      STRH     R0,[R10, #+8]
    940                                sbcSemInfoMng.sbcSemStates = SBC_SEM_RECOVERY_INFO;
   \      0x9C2   0x2002             MOVS     R0,#+2
   \      0x9C4   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    941                                sbcSemInfoMng.addrVal = ADDR_START_RDD;
   \      0x9C8   0xF44F 0x7040      MOV      R0,#+768
   \      0x9CC   0xF8AA 0x0006      STRH     R0,[R10, #+6]
    942                                /* timeout 20ms for starting recovery info procedure  */
    943                                timeTickTmp = pdMS_TO_TICKS(TIMEOUT_RD_REQ);  
   \      0x9D0   0x2014             MOVS     R0,#+20
   \      0x9D2   0x0007             MOVS     R7,R0
   \      0x9D4   0xE087             B.N      ??sbcSemMsgProcess_121
    944                              }
    945                            }
    946                            else
    947                            {
    948                              if (result == (uint8_t)SEND_RETRY)
   \                     ??sbcSemMsgProcess_132: (+1)
   \      0x9D6   0x4640             MOV      R0,R8
   \      0x9D8   0xB2C0             UXTB     R0,R0
   \      0x9DA   0x2802             CMP      R0,#+2
   \      0x9DC   0xF040 0x8083      BNE.W    ??sbcSemMsgProcess_121
    949                              {
    950                                /* the current message cannot be managed now, so put in the list */
    951                                headMsg = addNode(headMsg, pMsg);
   \      0x9E0   0xF8DF 0xA0D4      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x9E4   0x0021             MOVS     R1,R4
   \      0x9E6   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x9EA   0x.... 0x....      BL       addNode
   \      0x9EE   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \      0x9F2   0xE078             B.N      ??sbcSemMsgProcess_121
    952                              }
    953                            }
    954                          }
    955                        }
    956                      }
    957                    }
    958                    else
    959                    {
    960                      /* a master start the addressing procedure after a its reboot */
    961                      if (ixScu == MODBUS_BROADCAST_ADDR)
   \                     ??sbcSemMsgProcess_119: (+1)
   \      0x9F4   0x0028             MOVS     R0,R5
   \      0x9F6   0xB280             UXTH     R0,R0
   \      0x9F8   0x2800             CMP      R0,#+0
   \      0x9FA   0xD16E             BNE.N    ??sbcSemMsgProcess_133
    962                      {
    963                        if (pMsg->data.rAddr == ADDR_EVSE_TM_RW)  // AUTOCONFIG_FUNCTION_RW = ADDR_EVSE_TM_RW = 0x0022 is the register used for polling 
   \      0x9FC   0x88A0             LDRH     R0,[R4, #+4]
   \      0x9FE   0x2822             CMP      R0,#+34
   \      0xA00   0xD171             BNE.N    ??sbcSemMsgProcess_121
    964                        {
    965                          pWord = (uint16_t *)pMsg->dataToSend.pData;
   \      0xA02   0x68A0             LDR      R0,[R4, #+8]
   \      0xA04   0x9003             STR      R0,[SP, #+12]
    966                          if (((uint16_t)SCU_S_PS_STARTUP == *pWord) || ((uint16_t)SCU_S_PS_LIVE == *pWord))  // SCU_S_PS_STARTUP = SCU_S_S = 4 or SCU_S_PS_LIVE in polling phase 
   \      0xA06   0x9803             LDR      R0,[SP, #+12]
   \      0xA08   0x8800             LDRH     R0,[R0, #+0]
   \      0xA0A   0x2804             CMP      R0,#+4
   \      0xA0C   0xD003             BEQ.N    ??sbcSemMsgProcess_134
   \      0xA0E   0x9803             LDR      R0,[SP, #+12]
   \      0xA10   0x8800             LDRH     R0,[R0, #+0]
   \      0xA12   0x2805             CMP      R0,#+5
   \      0xA14   0xD158             BNE.N    ??sbcSemMsgProcess_135
    967                          {
    968                            ixLogic = getLogicalMdbAddrSem();
   \                     ??sbcSemMsgProcess_134: (+1)
   \      0xA16   0x.... 0x....      BL       getLogicalMdbAddrSem
   \      0xA1A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    969                            maskBit = sbcSemMaskBit[ixLogic];
   \      0xA1E   0x4827             LDR.N    R0,??sbcSemMsgProcess_0+12
   \      0xA20   0xF8BD 0x1008      LDRH     R1,[SP, #+8]
   \      0xA24   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \      0xA28   0x0006             MOVS     R6,R0
    970          #ifdef POLLING_ONLY_INACTIVE
    971                            /* the slave responde to polling only if has been inactive during polling period (about 6 sec) */
    972                            if ((socketPresence.keyPresence == KEY_FULL_CONFIG) && 
    973                                ((sbcSemInfoMng.offLine == TRUE) || ((sbcSemInfoMng.activityStatus & maskBit) == 0) || (((uint16_t)SCU_S_S == *pWord))))
    974          #else
    975                            /* the slave responde to polling always (about 6 sec) */
    976                            if (socketPresence.keyPresence == KEY_FULL_CONFIG)
   \      0xA2A   0x48CA             LDR.N    R0,??sbcSemMsgProcess_1+8
   \      0xA2C   0x6880             LDR      R0,[R0, #+8]
   \      0xA2E   0xF64A 0x2155      MOVW     R1,#+43605
   \      0xA32   0x4288             CMP      R0,R1
   \      0xA34   0xD144             BNE.N    ??sbcSemMsgProcess_136
    977          #endif
    978                            {
    979                              sbcSemInfoMng.offLine = FALSE;
   \      0xA36   0x2000             MOVS     R0,#+0
   \      0xA38   0xF88A 0x0027      STRB     R0,[R10, #+39]
    980                              /* the address in ADDR_CONNECTOR_IDS_RW has been already assigned by master */
    981                              currFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \      0xA3C   0xF8DF 0xB510      LDR.W    R11,??sbcSemMsgProcess_3+12
   \      0xA40   0x2002             MOVS     R0,#+2
   \      0xA42   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    982                              currFrameSbcSem.data.index = getPhysicalMdbAddr();  /* rs485SemMsgProcess() use phisical address 1...16 */
   \      0xA46   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0xA4A   0xF8AB 0x0002      STRH     R0,[R11, #+2]
    983                              //currFrameSbcSem.data.rAddr = ADDR_CONNECTOR_IDS_RW;
    984                              currFrameSbcSem.data.rAddr = ADDR_EVSE_TM_RW;  // ADDR_EVSE_CHARGE_STATUS_RO or ADDR_EVSE_TM_RW
   \      0xA4E   0x2022             MOVS     R0,#+34
   \      0xA50   0xF8AB 0x0004      STRH     R0,[R11, #+4]
    985                              
    986                              currFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \      0xA54   0xF11A 0x0004      ADDS     R0,R10,#+4
   \      0xA58   0xF8CB 0x0008      STR      R0,[R11, #+8]
    987                              /* to avoid possible conflit on first Tx byte a random delay is used  */
    988                              osDelay((uint32_t)10 * (uint32_t)currFrameSbcSem.data.index);  /* delay in the range 2...50 msec */
   \      0xA5C   0xF8BB 0x0002      LDRH     R0,[R11, #+2]
   \      0xA60   0x210A             MOVS     R1,#+10
   \      0xA62   0x4348             MULS     R0,R1,R0
   \      0xA64   0x.... 0x....      BL       osDelay
    989                              configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xA68   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xA6C   0x2300             MOVS     R3,#+0
   \      0xA6E   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xA72   0x4659             MOV      R1,R11
   \      0xA74   0x.... 0x....      BL       xQueueGenericSend
   \      0xA78   0x2801             CMP      R0,#+1
   \      0xA7A   0xD009             BEQ.N    ??sbcSemMsgProcess_137
   \      0xA7C   0xB672             CPSID    I
   \      0xA7E   0x2050             MOVS     R0,#+80
   \      0xA80   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xA84   0xF3BF 0x8F4F      DSB      SY
   \      0xA88   0xF3BF 0x8F6F      ISB      SY
   \      0xA8C   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_138: (+1)
   \      0xA8E   0xE7FE             B.N      ??sbcSemMsgProcess_138
    990                              sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_WR_MASTER_POLL_ACK;
   \                     ??sbcSemMsgProcess_137: (+1)
   \      0xA90   0x2007             MOVS     R0,#+7
   \      0xA92   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    991                              // start ACK timer 
    992                              xTimerReset (xSbcSemTimers[TIMER_FOR_ACK], 0);
   \      0xA96   0x.... 0x....      BL       xTaskGetTickCount
   \      0xA9A   0x0002             MOVS     R2,R0
   \      0xA9C   0x2000             MOVS     R0,#+0
   \      0xA9E   0x9000             STR      R0,[SP, #+0]
   \      0xAA0   0x2300             MOVS     R3,#+0
   \      0xAA2   0x2102             MOVS     R1,#+2
   \      0xAA4   0x4802             LDR.N    R0,??sbcSemMsgProcess_0
   \      0xAA6   0x6840             LDR      R0,[R0, #+4]
   \      0xAA8   0x.... 0x....      BL       xTimerGenericCommand
   \      0xAAC   0xE01B             B.N      ??sbcSemMsgProcess_121
   \      0xAAE   0xBF00             Nop
   \                     ??sbcSemMsgProcess_0:
   \      0xAB0   0x....'....        DC32     xSbcSemTimers
   \      0xAB4   0x....'....        DC32     sbcSemInfoMng
   \      0xAB8   0x....'....        DC32     headMsg
   \      0xABC   0x....'....        DC32     sbcSemMaskBit
    993                            }
    994                            else
    995                            {
    996                              sbcSemInfoMng.activityStatus = 0;
   \                     ??sbcSemMsgProcess_136: (+1)
   \      0xAC0   0x2000             MOVS     R0,#+0
   \      0xAC2   0xF8CA 0x0014      STR      R0,[R10, #+20]
   \      0xAC6   0xE00E             B.N      ??sbcSemMsgProcess_121
    997                            }
    998                          }
    999                          else
   1000                          {
   1001                            if ((uint16_t)SCU_ALL_FACTORY_PARAM == *pWord) 
   \                     ??sbcSemMsgProcess_135: (+1)
   \      0xAC8   0x9803             LDR      R0,[SP, #+12]
   \      0xACA   0x8800             LDRH     R0,[R0, #+0]
   \      0xACC   0xF64F 0x71EC      MOVW     R1,#+65516
   \      0xAD0   0x4288             CMP      R0,R1
   \      0xAD2   0xD108             BNE.N    ??sbcSemMsgProcess_121
   1002                            {
   1003                              /* for debug only */
   1004                              restoreFactoryDefault();
   \      0xAD4   0x.... 0x....      BL       restoreFactoryDefault
   \      0xAD8   0xE005             B.N      ??sbcSemMsgProcess_121
   1005                            }
   1006                          }
   1007                        }
   1008                      }
   1009                      else
   1010                      {
   1011                        /* SCU slave: a write operation has been done from master over RS485, so an update can be possible  */
   1012                        semUpdateConfig(pMsg);
   \                     ??sbcSemMsgProcess_133: (+1)
   \      0xADA   0x0020             MOVS     R0,R4
   \      0xADC   0x.... 0x....      BL       semUpdateConfig
   1013                        osDelay(10);
   \      0xAE0   0x200A             MOVS     R0,#+10
   \      0xAE2   0x.... 0x....      BL       osDelay
   1014                      }
   1015                    }
   1016                    break;
   \                     ??sbcSemMsgProcess_121: (+1)
   \      0xAE6   0xE191             B.N      ??sbcSemMsgProcess_130
   1017          
   1018                  case SBC_SEM_EVENT_UART5_SEND_DWLD_CMD:
   1019                  case SBC_SEM_EVENT_UART5:
   1020                    locScuMode = getScuOpMode();
   \                     ??sbcSemMsgProcess_112: (+1)
   \      0xAE8   0x.... 0x....      BL       getScuOpMode
   \      0xAEC   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1021                    /* message coming from SBC: the writing can be referred to the master or for a slave  */
   1022                    if ((locScuMode == SCU_M_P) && (getPhysicalMdbAddr() == pMsg->data.index))
   \      0xAF0   0xF8BD 0x000A      LDRH     R0,[SP, #+10]
   \      0xAF4   0x2802             CMP      R0,#+2
   \      0xAF6   0xD10A             BNE.N    ??sbcSemMsgProcess_139
   \      0xAF8   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0xAFC   0xB2C0             UXTB     R0,R0
   \      0xAFE   0x8861             LDRH     R1,[R4, #+2]
   \      0xB00   0xB280             UXTH     R0,R0
   \      0xB02   0x4288             CMP      R0,R1
   \      0xB04   0xD103             BNE.N    ??sbcSemMsgProcess_139
   1023                    {
   1024                      /* the write operation refer the SCU MASTER */
   1025                      semUpdateConfig(pMsg);
   \      0xB06   0x0020             MOVS     R0,R4
   \      0xB08   0x.... 0x....      BL       semUpdateConfig
   \      0xB0C   0xE040             B.N      ??sbcSemMsgProcess_140
   1026                    }
   1027                    else
   1028                    {
   1029                      if ((locScuMode == SCU_M_STAND_ALONE) && ((pMsg->data.rAddr == ADDR_FILE_COMMAND_RW) || (pMsg->data.rAddr == ADDR_FILE_SIZE_RW)) &&  
   1030                          (pMsg->sbcSemEvent != SBC_SEM_EVENT_UART5_SEND_DWLD_CMD))
   \                     ??sbcSemMsgProcess_139: (+1)
   \      0xB0E   0xF8BD 0x000A      LDRH     R0,[SP, #+10]
   \      0xB12   0x2805             CMP      R0,#+5
   \      0xB14   0xD10B             BNE.N    ??sbcSemMsgProcess_141
   \      0xB16   0x88A0             LDRH     R0,[R4, #+4]
   \      0xB18   0xF5B0 0x7F80      CMP      R0,#+256
   \      0xB1C   0xD004             BEQ.N    ??sbcSemMsgProcess_142
   \      0xB1E   0x88A0             LDRH     R0,[R4, #+4]
   \      0xB20   0xF240 0x1101      MOVW     R1,#+257
   \      0xB24   0x4288             CMP      R0,R1
   \      0xB26   0xD102             BNE.N    ??sbcSemMsgProcess_141
   \                     ??sbcSemMsgProcess_142: (+1)
   \      0xB28   0x8820             LDRH     R0,[R4, #+0]
   \      0xB2A   0x280D             CMP      R0,#+13
   \      0xB2C   0xD130             BNE.N    ??sbcSemMsgProcess_140
   1031                      {
   1032                        /* the stand alone SCU send the FW upload message on RS485 only at received both info  */
   1033                      }
   1034                      else
   1035                      {
   1036                        /* the write operation refer the SCU SLAVE so the writing must be sent over RS485  */
   1037                        /* no more master secondary SCU are present in the chain */
   1038                        sbcSemInfoMng.dataVal = (uint16_t)1;  // for discovery primary/secondary slave SCU 
   \                     ??sbcSemMsgProcess_141: (+1)
   \      0xB2E   0x2001             MOVS     R0,#+1
   \      0xB30   0xF8AA 0x0004      STRH     R0,[R10, #+4]
   1039                        currFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \      0xB34   0xF8DF 0xB418      LDR.W    R11,??sbcSemMsgProcess_3+12
   \      0xB38   0x2003             MOVS     R0,#+3
   \      0xB3A   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1040                        currFrameSbcSem.data.index = pMsg->data.index;  // phisical address 1...16 or 0 for broadcast 
   \      0xB3E   0x8860             LDRH     R0,[R4, #+2]
   \      0xB40   0xF8AB 0x0002      STRH     R0,[R11, #+2]
   1041                        currFrameSbcSem.data.rAddr = pMsg->data.rAddr;
   \      0xB44   0x88A0             LDRH     R0,[R4, #+4]
   \      0xB46   0xF8AB 0x0004      STRH     R0,[R11, #+4]
   1042                        currFrameSbcSem.dataToSend.len = pMsg->dataToSend.len;
   \      0xB4A   0x88E0             LDRH     R0,[R4, #+6]
   \      0xB4C   0xF8AB 0x0006      STRH     R0,[R11, #+6]
   1043                        currFrameSbcSem.dataToSend.pData = (uint8_t*)pMsg->dataToSend.pData;
   \      0xB50   0x68A0             LDR      R0,[R4, #+8]
   \      0xB52   0xF8CB 0x0008      STR      R0,[R11, #+8]
   1044                        configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xB56   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xB5A   0x2300             MOVS     R3,#+0
   \      0xB5C   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xB60   0x4659             MOV      R1,R11
   \      0xB62   0x.... 0x....      BL       xQueueGenericSend
   \      0xB66   0x2801             CMP      R0,#+1
   \      0xB68   0xD009             BEQ.N    ??sbcSemMsgProcess_143
   \      0xB6A   0xB672             CPSID    I
   \      0xB6C   0x2050             MOVS     R0,#+80
   \      0xB6E   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xB72   0xF3BF 0x8F4F      DSB      SY
   \      0xB76   0xF3BF 0x8F6F      ISB      SY
   \      0xB7A   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_144: (+1)
   \      0xB7C   0xE7FE             B.N      ??sbcSemMsgProcess_144
   1045                        if (pMsg->data.index != MODBUS_BROADCAST_ADDR)
   \                     ??sbcSemMsgProcess_143: (+1)
   \      0xB7E   0x8860             LDRH     R0,[R4, #+2]
   \      0xB80   0x2800             CMP      R0,#+0
   \      0xB82   0xD005             BEQ.N    ??sbcSemMsgProcess_140
   1046                        {
   1047                          timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_RESP); 
   \      0xB84   0xF44F 0x70FA      MOV      R0,#+500
   \      0xB88   0x0007             MOVS     R7,R0
   1048                          sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_WR_ACK;
   \      0xB8A   0x2005             MOVS     R0,#+5
   \      0xB8C   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1049                        }
   1050                      }
   1051                    }
   1052                    break;
   \                     ??sbcSemMsgProcess_140: (+1)
   \      0xB90   0xE13C             B.N      ??sbcSemMsgProcess_130
   1053          
   1054                  case NOTIFY_TO_MASTER_TX:
   1055                    if ((getScuOpMode() == SCU_M_P) && (getPhysicalMdbAddr() == pMsg->data.index))
   \                     ??sbcSemMsgProcess_113: (+1)
   \      0xB92   0x.... 0x....      BL       getScuOpMode
   \      0xB96   0x2802             CMP      R0,#+2
   \      0xB98   0xD120             BNE.N    ??sbcSemMsgProcess_145
   \      0xB9A   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0xB9E   0xB2C0             UXTB     R0,R0
   \      0xBA0   0x8861             LDRH     R1,[R4, #+2]
   \      0xBA2   0xB280             UXTH     R0,R0
   \      0xBA4   0x4288             CMP      R0,R1
   \      0xBA6   0xD119             BNE.N    ??sbcSemMsgProcess_145
   1056                    {
   1057                      result = (uint8_t)setChangeRegisterBit(ixScu, pMsg, (uint32_t)maskBit, ixLogic); 
   \      0xBA8   0xF8BD 0x3008      LDRH     R3,[SP, #+8]
   \      0xBAC   0x0032             MOVS     R2,R6
   \      0xBAE   0x0021             MOVS     R1,R4
   \      0xBB0   0x0028             MOVS     R0,R5
   \      0xBB2   0xB280             UXTH     R0,R0
   \      0xBB4   0x.... 0x....      BL       setChangeRegisterBit
   \      0xBB8   0x4680             MOV      R8,R0
   1058                      if (result == (uint8_t)SEND_RETRY)
   \      0xBBA   0x4640             MOV      R0,R8
   \      0xBBC   0xB2C0             UXTB     R0,R0
   \      0xBBE   0x2802             CMP      R0,#+2
   \      0xBC0   0xD108             BNE.N    ??sbcSemMsgProcess_146
   1059                      {
   1060                        /* the current message cannot be managed now, so put in the list */
   1061                        headMsg = addNode(headMsg, pMsg);
   \      0xBC2   0x.... 0x....      LDR.W    R10,??DataTable7
   \      0xBC6   0x0021             MOVS     R1,R4
   \      0xBC8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xBCC   0x.... 0x....      BL       addNode
   \      0xBD0   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1062                      }
   1063                      osDelay(100);
   \                     ??sbcSemMsgProcess_146: (+1)
   \      0xBD4   0x2064             MOVS     R0,#+100
   \      0xBD6   0x.... 0x....      BL       osDelay
   \      0xBDA   0xE05A             B.N      ??sbcSemMsgProcess_147
   1064                    }
   1065                    else
   1066                    {
   1067                      /* if FW update is ongoing on a slave device, don't notify changes to master */
   1068                      if (getStatusDwnl() == FALSE)
   \                     ??sbcSemMsgProcess_145: (+1)
   \      0xBDC   0x.... 0x....      BL       getStatusDwnl
   \      0xBE0   0x2800             CMP      R0,#+0
   \      0xBE2   0xD156             BNE.N    ??sbcSemMsgProcess_147
   1069                      {
   1070                        result = (uint8_t)setChangeRegisterBit(SCU_M_P_ADDR, pMsg, (uint32_t)maskBit, ixLogic);
   \      0xBE4   0xF8BD 0x3008      LDRH     R3,[SP, #+8]
   \      0xBE8   0x0032             MOVS     R2,R6
   \      0xBEA   0x0021             MOVS     R1,R4
   \      0xBEC   0x2001             MOVS     R0,#+1
   \      0xBEE   0x.... 0x....      BL       setChangeRegisterBit
   \      0xBF2   0x4680             MOV      R8,R0
   1071                        if (result == (uint8_t)SEND_ACK)
   \      0xBF4   0x4640             MOV      R0,R8
   \      0xBF6   0xB2C0             UXTB     R0,R0
   \      0xBF8   0x2801             CMP      R0,#+1
   \      0xBFA   0xD13A             BNE.N    ??sbcSemMsgProcess_148
   1072                        {
   1073                          /* a change inside a slave occured. Data must be sent to master over RS485  */
   1074                          currFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \      0xBFC   0xF8DF 0xB350      LDR.W    R11,??sbcSemMsgProcess_3+12
   \      0xC00   0x2002             MOVS     R0,#+2
   \      0xC02   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1075                          currFrameSbcSem.data.index = pMsg->data.index;  //  physical address 1...16 
   \      0xC06   0x8860             LDRH     R0,[R4, #+2]
   \      0xC08   0xF8AB 0x0002      STRH     R0,[R11, #+2]
   1076                          currFrameSbcSem.data.rAddr = pMsg->data.rAddr;
   \      0xC0C   0x88A0             LDRH     R0,[R4, #+4]
   \      0xC0E   0xF8AB 0x0004      STRH     R0,[R11, #+4]
   1077                          currFrameSbcSem.dataToSend.len = pMsg->dataToSend.len;
   \      0xC12   0x88E0             LDRH     R0,[R4, #+6]
   \      0xC14   0xF8AB 0x0006      STRH     R0,[R11, #+6]
   1078                          currFrameSbcSem.dataToSend.pData = (uint8_t*)&pMsg->dataToSend.pData;
   \      0xC18   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xC1C   0xF8CB 0x0008      STR      R0,[R11, #+8]
   1079                          configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xC20   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xC24   0x2300             MOVS     R3,#+0
   \      0xC26   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xC2A   0x4659             MOV      R1,R11
   \      0xC2C   0x.... 0x....      BL       xQueueGenericSend
   \      0xC30   0x2801             CMP      R0,#+1
   \      0xC32   0xD009             BEQ.N    ??sbcSemMsgProcess_149
   \      0xC34   0xB672             CPSID    I
   \      0xC36   0x2050             MOVS     R0,#+80
   \      0xC38   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xC3C   0xF3BF 0x8F4F      DSB      SY
   \      0xC40   0xF3BF 0x8F6F      ISB      SY
   \      0xC44   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_150: (+1)
   \      0xC46   0xE7FE             B.N      ??sbcSemMsgProcess_150
   1080                          /* reset the activity bit: will be set when ACK will be received */
   1081                          sbcSemInfoMng.activityStatus &= (~maskBit);
   \                     ??sbcSemMsgProcess_149: (+1)
   \      0xC48   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0xC4C   0x43B0             BICS     R0,R0,R6
   \      0xC4E   0xF8CA 0x0014      STR      R0,[R10, #+20]
   1082          
   1083                          // start ACK timer 
   1084                          xTimerReset (xSbcSemTimers[TIMER_FOR_ACK], 0);
   \      0xC52   0x.... 0x....      BL       xTaskGetTickCount
   \      0xC56   0x2100             MOVS     R1,#+0
   \      0xC58   0x9100             STR      R1,[SP, #+0]
   \      0xC5A   0x2300             MOVS     R3,#+0
   \      0xC5C   0x0002             MOVS     R2,R0
   \      0xC5E   0x2102             MOVS     R1,#+2
   \      0xC60   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0xC64   0x6840             LDR      R0,[R0, #+4]
   \      0xC66   0x.... 0x....      BL       xTimerGenericCommand
   1085                          sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_WR_MASTER_ACK;
   \      0xC6A   0x2006             MOVS     R0,#+6
   \      0xC6C   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \      0xC70   0xE00F             B.N      ??sbcSemMsgProcess_147
   1086                        }
   1087                        else
   1088                        {
   1089                          if (result == (uint8_t)SEND_RETRY)
   \                     ??sbcSemMsgProcess_148: (+1)
   \      0xC72   0x4640             MOV      R0,R8
   \      0xC74   0xB2C0             UXTB     R0,R0
   \      0xC76   0x2802             CMP      R0,#+2
   \      0xC78   0xD10B             BNE.N    ??sbcSemMsgProcess_147
   1090                          {
   1091                            /* the current message cannot be managed now, so restore it in first position The sequence timing cannot be modified!  */
   1092                            headMsg = addNode(headMsg, pMsg);
   \      0xC7A   0x.... 0x....      LDR.W    R10,??DataTable7
   \      0xC7E   0x0021             MOVS     R1,R4
   \      0xC80   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xC84   0x.... 0x....      BL       addNode
   \      0xC88   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1093                            osDelay(100);
   \      0xC8C   0x2064             MOVS     R0,#+100
   \      0xC8E   0x.... 0x....      BL       osDelay
   1094                          }
   1095                        }
   1096                      }
   1097                    }
   1098                    break;
   \                     ??sbcSemMsgProcess_147: (+1)
   \      0xC92   0xE0BB             B.N      ??sbcSemMsgProcess_130
   1099          
   1100                  case SCU_EVENT_MSG_FROM_SBC_RD:
   1101                    if (resetChangeRegisterBit(ixLogic, pMsg->data.rAddr, pMsg->dataToSend.len) == TRUE)
   \                     ??sbcSemMsgProcess_116: (+1)
   \      0xC94   0x88E2             LDRH     R2,[R4, #+6]
   \      0xC96   0x88A1             LDRH     R1,[R4, #+4]
   \      0xC98   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0xC9C   0x.... 0x....      BL       resetChangeRegisterBit
   \      0xCA0   0x2801             CMP      R0,#+1
   \      0xCA2   0xD111             BNE.N    ??sbcSemMsgProcess_151
   1102                    {
   1103                      sbcSemInfoMng.sbcActive = TRUE;
   \      0xCA4   0x2001             MOVS     R0,#+1
   \      0xCA6   0xF88A 0x0028      STRB     R0,[R10, #+40]
   1104                      //tPrintf("Socket %d Event 0x%X closed!\n\r", ixScu, pMsg->data.rAddr);
   1105                      if (headMsg != NULL)
   \      0xCAA   0x.... 0x....      LDR.W    R10,??DataTable7
   \      0xCAE   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xCB2   0x2800             CMP      R0,#+0
   \      0xCB4   0xD006             BEQ.N    ??sbcSemMsgProcess_152
   1106                      {
   1107                        /* re-send a message in the queue list if present */
   1108                        headMsg = extractSendFirstInList(headMsg);
   \      0xCB6   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xCBA   0x.... 0x....      BL       extractSendFirstInList
   \      0xCBE   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \      0xCC2   0xE001             B.N      ??sbcSemMsgProcess_151
   1109                      }
   1110                      else
   1111                      {
   1112                        resetPacketStatusNum();
   \                     ??sbcSemMsgProcess_152: (+1)
   \      0xCC4   0x.... 0x....      BL       resetPacketStatusNum
   1113                      }
   1114                    }
   1115                    break;
   \                     ??sbcSemMsgProcess_151: (+1)
   \      0xCC8   0xE0A0             B.N      ??sbcSemMsgProcess_130
   1116          
   1117                  case SCU_EVENT_MSG_FROM_MASTER_RD:
   1118                    if (getPhysicalMdbAddr() == pMsg->data.index)  // phisical address 1...16 
   \                     ??sbcSemMsgProcess_117: (+1)
   \      0xCCA   0x.... 0x....      BL       getPhysicalMdbAddr
   1119                    {
   1120                      ;
   1121                    }
   1122                    break;
   \      0xCCE   0xE09D             B.N      ??sbcSemMsgProcess_130
   1123                    
   1124                  case SBC_SEM_TIMEOUT:
   1125                  case RECOVERY_INFO:
   1126                    while (txRS485Available() == (uint8_t)FALSE) osDelay(100);
   \                     ??sbcSemMsgProcess_114: (+1)
   \      0xCD0   0x.... 0x....      BL       txRS485Available
   \      0xCD4   0x2800             CMP      R0,#+0
   \      0xCD6   0xD103             BNE.N    ??sbcSemMsgProcess_153
   \      0xCD8   0x2064             MOVS     R0,#+100
   \      0xCDA   0x.... 0x....      BL       osDelay
   \      0xCDE   0xE7F7             B.N      ??sbcSemMsgProcess_114
   1127                    if (getInfoSocket((sbcSemInfoMng.activityStatus & (~sbcSemInfoMng.activeLastDiscovery)), &sbcSemInfoMng) == FALSE)
   \                     ??sbcSemMsgProcess_153: (+1)
   \      0xCE0   0x.... 0x....      LDR.W    R10,??DataTable8_1
   \      0xCE4   0x4651             MOV      R1,R10
   \      0xCE6   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0xCEA   0xF8DA 0x2020      LDR      R2,[R10, #+32]
   \      0xCEE   0x4390             BICS     R0,R0,R2
   \      0xCF0   0x.... 0x....      BL       getInfoSocket
   \      0xCF4   0x2800             CMP      R0,#+0
   \      0xCF6   0xD135             BNE.N    ??sbcSemMsgProcess_154
   1128                    {
   1129          
   1130                      /* force the SBC to read new data from added SCU */
   1131                      forceSBCreadScu(sbcSemInfoMng.activityStatus & (~sbcSemInfoMng.activeLastDiscovery));
   \      0xCF8   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0xCFC   0xF8DA 0x1020      LDR      R1,[R10, #+32]
   \      0xD00   0x4388             BICS     R0,R0,R1
   \      0xD02   0x.... 0x....      BL       forceSBCreadScu
   1132          
   1133                      /* all new add socket has been discovered */
   1134                      sbcSemInfoMng.activeLastDiscovery = socketPresence.chainPresence = socketPresence.livePresence;
   \      0xD06   0xF8DF 0xB04C      LDR.W    R11,??sbcSemMsgProcess_1+8
   \      0xD0A   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0xD0E   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \      0xD12   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0xD16   0xF8CA 0x0020      STR      R0,[R10, #+32]
   1135          
   1136                      /* save in EEPROM also  */
   1137                      if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \      0xD1A   0x2254             MOVS     R2,#+84
   \      0xD1C   0x4659             MOV      R1,R11
   \      0xD1E   0xF44F 0x50F4      MOV      R0,#+7808
   \      0xD22   0x.... 0x....      BL       WriteOnEeprom
   \      0xD26   0x2800             CMP      R0,#+0
   \      0xD28   0xD105             BNE.N    ??sbcSemMsgProcess_155
   1138                      {
   1139                        tPrintf("Presences detected --> 0x%x\n\r", socketPresence.chainPresence);
   \      0xD2A   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0xD2E   0x.... 0x....      LDR.W    R0,??DataTable9
   \      0xD32   0x.... 0x....      BL       tPrintf
   1140                      }
   1141          
   1142                      /* save all the slave parameters in external flash mememory to restore it in the future */
   1143                      saveAllSlaveParameters();
   \                     ??sbcSemMsgProcess_155: (+1)
   \      0xD36   0x.... 0x....      BL       saveAllSlaveParameters
   1144          
   1145                      sbcSemInfoMng.discoveryMask = 0;
   \      0xD3A   0x2000             MOVS     R0,#+0
   \      0xD3C   0xF8CA 0x000A      STR      R0,[R10, #+10]
   1146                      timeTickTmp = portMAX_DELAY;
   \      0xD40   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0xD44   0x0007             MOVS     R7,R0
   1147                      Print_Slave_FW_Version();
   \      0xD46   0x.... 0x....      BL       Print_Slave_FW_Version
   \      0xD4A   0xE00E             B.N      ??sbcSemMsgProcess_156
   \                     ??sbcSemMsgProcess_1:
   \      0xD4C   0x....'....        DC32     pScuRoMapReg
   \      0xD50   0x....'....        DC32     pScuTmMapReg
   \      0xD54   0x....'....        DC32     socketPresence
   \      0xD58   0x....'....        DC32     Default_Socket_Presence+16
   \      0xD5C   0x....'....        DC32     Default_Socket_Presence+48
   \      0xD60   0x....'....        DC32     ?_19
   1148                    }
   1149                    else
   1150                    {
   1151                      timeTickTmp = TIMEOUT_ACK_RESP;
   \                     ??sbcSemMsgProcess_154: (+1)
   \      0xD64   0xF44F 0x70FA      MOV      R0,#+500
   \      0xD68   0x0007             MOVS     R7,R0
   1152                    }
   1153                    break;
   \                     ??sbcSemMsgProcess_156: (+1)
   \      0xD6A   0xE04F             B.N      ??sbcSemMsgProcess_130
   1154          
   1155                  case NOTIFY_MODBUS_RD_ACK:
   1156                    if (((sbcSemInfoMng.logicIdSocket + 1) == pMsg->data.index) && (sbcSemInfoMng.dataVal == pMsg->dataToSend.len))
   \                     ??sbcSemMsgProcess_115: (+1)
   \      0xD6C   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0xD70   0x1C40             ADDS     R0,R0,#+1
   \      0xD72   0x8861             LDRH     R1,[R4, #+2]
   \      0xD74   0x4288             CMP      R0,R1
   \      0xD76   0xD148             BNE.N    ??sbcSemMsgProcess_157
   \      0xD78   0xF8BA 0x0004      LDRH     R0,[R10, #+4]
   \      0xD7C   0x88E1             LDRH     R1,[R4, #+6]
   \      0xD7E   0x4288             CMP      R0,R1
   \      0xD80   0xD143             BNE.N    ??sbcSemMsgProcess_157
   1157                    {
   1158                      /* a previous request to read has been accepted and new data are arrived so store it in the map */
   1159                      void* pSrc = (void*)((uint32_t)pMsg->dataToSend.pData + (uint32_t)sizeof(headerAnswRHR_t));
   \      0xD82   0x68A0             LDR      R0,[R4, #+8]
   \      0xD84   0x1CC0             ADDS     R0,R0,#+3
   \      0xD86   0x9006             STR      R0,[SP, #+24]
   1160                      /*      destination                  source                         length */
   1161                      memcpy((void*)sbcSemInfoMng.pDataRd, pSrc, (size_t)(pMsg->dataToSend.len));
   \      0xD88   0xF8DA 0xB00E      LDR      R11,[R10, #+14]
   \      0xD8C   0x88E0             LDRH     R0,[R4, #+6]
   \      0xD8E   0x9001             STR      R0,[SP, #+4]
   \      0xD90   0x9806             LDR      R0,[SP, #+24]
   \      0xD92   0x9000             STR      R0,[SP, #+0]
   \      0xD94   0x9A01             LDR      R2,[SP, #+4]
   \      0xD96   0x9900             LDR      R1,[SP, #+0]
   \      0xD98   0x4658             MOV      R0,R11
   \      0xD9A   0x.... 0x....      BL       __aeabi_memcpy
   1162                      if (sbcSemInfoMng.addrVal == ADDR_START_RDD)
   \      0xD9E   0xF8BA 0x0006      LDRH     R0,[R10, #+6]
   \      0xDA2   0xF5B0 0x7F40      CMP      R0,#+768
   \      0xDA6   0xD10D             BNE.N    ??sbcSemMsgProcess_158
   1163                      {
   1164                        /* point to next possible slave */
   1165                        sbcSemInfoMng.addrVal = ADDR_START_RDD;
   \      0xDA8   0xF44F 0x7040      MOV      R0,#+768
   \      0xDAC   0xF8AA 0x0006      STRH     R0,[R10, #+6]
   1166                        sbcSemInfoMng.discoveryMask = sbcSemInfoMng.discoveryMask << 1;
   \      0xDB0   0xF11A 0x000A      ADDS     R0,R10,#+10
   \      0xDB4   0x6801             LDR      R1,[R0, #+0]
   \      0xDB6   0x0049             LSLS     R1,R1,#+1
   \      0xDB8   0x6001             STR      R1,[R0, #+0]
   1167                        sbcSemInfoMng.logicIdSocket++;
   \      0xDBA   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0xDBE   0x1C40             ADDS     R0,R0,#+1
   \      0xDC0   0xF8AA 0x0008      STRH     R0,[R10, #+8]
   1168                      }
   1169                      /* timeout 20ms for next reading   */
   1170                      timeTickTmp = pdMS_TO_TICKS(TIMEOUT_RD_REQ);  
   \                     ??sbcSemMsgProcess_158: (+1)
   \      0xDC4   0x2014             MOVS     R0,#+20
   \      0xDC6   0x0007             MOVS     R7,R0
   1171                      /* release the transmitter */
   1172                      currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;             
   \      0xDC8   0xF8DF 0xA184      LDR.W    R10,??sbcSemMsgProcess_3+12
   \      0xDCC   0x2005             MOVS     R0,#+5
   \      0xDCE   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1173                      configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xDD2   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xDD6   0x2300             MOVS     R3,#+0
   \      0xDD8   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xDDC   0x4651             MOV      R1,R10
   \      0xDDE   0x.... 0x....      BL       xQueueGenericSend
   \      0xDE2   0x2801             CMP      R0,#+1
   \      0xDE4   0xD009             BEQ.N    ??sbcSemMsgProcess_159
   \      0xDE6   0xB672             CPSID    I
   \      0xDE8   0x2050             MOVS     R0,#+80
   \      0xDEA   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xDEE   0xF3BF 0x8F4F      DSB      SY
   \      0xDF2   0xF3BF 0x8F6F      ISB      SY
   \      0xDF6   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_160: (+1)
   \      0xDF8   0xE7FE             B.N      ??sbcSemMsgProcess_160
   1174                      /* release the buffer  */
   1175                      if (pMsg->dataToSend.pData != NULL) 
   \                     ??sbcSemMsgProcess_159: (+1)
   \      0xDFA   0x68A0             LDR      R0,[R4, #+8]
   \      0xDFC   0x2800             CMP      R0,#+0
   \      0xDFE   0xD004             BEQ.N    ??sbcSemMsgProcess_157
   1176                      {
   1177                        free((void*)pMsg->dataToSend.pData);
   \      0xE00   0x68A0             LDR      R0,[R4, #+8]
   \      0xE02   0x.... 0x....      BL       free
   1178                        pMsg->dataToSend.pData = NULL;
   \      0xE06   0x2000             MOVS     R0,#+0
   \      0xE08   0x60A0             STR      R0,[R4, #+8]
   1179                      }
   1180                    }
   1181                    break;
   \                     ??sbcSemMsgProcess_157: (+1)
   \      0xE0A   0xE7FF             B.N      ??sbcSemMsgProcess_130
   1182          
   1183                  default:
   1184                    break;
   1185          
   1186                }
   1187                break;
   \                     ??sbcSemMsgProcess_118: (+1)
   \                     ??sbcSemMsgProcess_130: (+1)
   \      0xE0C   0xE14A             B.N      ??sbcSemMsgProcess_37
   1188          
   1189              case SBC_SEM_WAIT_WR_ACK:
   1190                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_12: (+1)
   \      0xE0E   0x8820             LDRH     R0,[R4, #+0]
   \      0xE10   0x1E40             SUBS     R0,R0,#+1
   \      0xE12   0x2801             CMP      R0,#+1
   \      0xE14   0xF240 0x809E      BLS.W    ??sbcSemMsgProcess_161
   \      0xE18   0x1FC0             SUBS     R0,R0,#+7
   \      0xE1A   0xD004             BEQ.N    ??sbcSemMsgProcess_162
   \      0xE1C   0xF64F 0x71F6      MOVW     R1,#+65526
   \      0xE20   0x1A40             SUBS     R0,R0,R1
   \      0xE22   0xD042             BEQ.N    ??sbcSemMsgProcess_163
   \      0xE24   0xE0A0             B.N      ??sbcSemMsgProcess_164
   1191                {
   1192                  case NOTIFY_MODBUS_WR_ACK:
   1193                    if (pMsg->data.index == currFrameSbcSem.data.index)  // phisical address 1...16 
   \                     ??sbcSemMsgProcess_162: (+1)
   \      0xE26   0xF8DF 0xB128      LDR.W    R11,??sbcSemMsgProcess_3+12
   \      0xE2A   0x8860             LDRH     R0,[R4, #+2]
   \      0xE2C   0xF8BB 0x1002      LDRH     R1,[R11, #+2]
   \      0xE30   0x4288             CMP      R0,R1
   \      0xE32   0xD139             BNE.N    ??sbcSemMsgProcess_165
   1194                    {
   1195                      /* the ack coming from expected socket */
   1196                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \      0xE34   0x2004             MOVS     R0,#+4
   \      0xE36   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1197                      /* release the transmitter */
   1198                      currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0xE3A   0x2005             MOVS     R0,#+5
   \      0xE3C   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1199                      configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xE40   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xE44   0x2300             MOVS     R3,#+0
   \      0xE46   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xE4A   0x4659             MOV      R1,R11
   \      0xE4C   0x.... 0x....      BL       xQueueGenericSend
   \      0xE50   0x2801             CMP      R0,#+1
   \      0xE52   0xD009             BEQ.N    ??sbcSemMsgProcess_166
   \      0xE54   0xB672             CPSID    I
   \      0xE56   0x2050             MOVS     R0,#+80
   \      0xE58   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xE5C   0xF3BF 0x8F4F      DSB      SY
   \      0xE60   0xF3BF 0x8F6F      ISB      SY
   \      0xE64   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_167: (+1)
   \      0xE66   0xE7FE             B.N      ??sbcSemMsgProcess_167
   1200                      /* the bridge to RS485 successfully: inform the SBC with ACK to WMR message */
   1201                      sendAnswToSem(NO_ERROR, 
   1202                                    (uint8_t)currFrameSbcSem.data.index, 
   1203                                    currFrameSbcSem.data.rAddr, 
   1204                                    currFrameSbcSem.dataToSend.len, 
   1205                                    SCU_EVENT_MSG_FROM_SBC, 
   1206                                    FUNCTION_WRITE_MULTIPLE_REG);
   \                     ??sbcSemMsgProcess_166: (+1)
   \      0xE68   0x2010             MOVS     R0,#+16
   \      0xE6A   0x9001             STR      R0,[SP, #+4]
   \      0xE6C   0x2003             MOVS     R0,#+3
   \      0xE6E   0x9000             STR      R0,[SP, #+0]
   \      0xE70   0xF8BB 0x3006      LDRH     R3,[R11, #+6]
   \      0xE74   0xF8BB 0x2004      LDRH     R2,[R11, #+4]
   \      0xE78   0xF8BB 0x1002      LDRH     R1,[R11, #+2]
   \      0xE7C   0xB2C9             UXTB     R1,R1
   \      0xE7E   0x2000             MOVS     R0,#+0
   \      0xE80   0x.... 0x....      BL       sendAnswToSem
   1207                      
   1208                      if (headMsg != NULL)
   \      0xE84   0x.... 0x....      LDR.W    R10,??DataTable7
   \      0xE88   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xE8C   0x2800             CMP      R0,#+0
   \      0xE8E   0xD006             BEQ.N    ??sbcSemMsgProcess_168
   1209                      {
   1210                        /* re-send the message in the queue list  */
   1211                        headMsg = extractSendFirstInList(headMsg);
   \      0xE90   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xE94   0x.... 0x....      BL       extractSendFirstInList
   \      0xE98   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \      0xE9C   0xE001             B.N      ??sbcSemMsgProcess_169
   1212                      }
   1213                      else
   1214                      {
   1215                        resetPacketStatusNum();
   \                     ??sbcSemMsgProcess_168: (+1)
   \      0xE9E   0x.... 0x....      BL       resetPacketStatusNum
   1216                      }
   1217                      timeTickTmp = portMAX_DELAY;
   \                     ??sbcSemMsgProcess_169: (+1)
   \      0xEA2   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0xEA6   0x0007             MOVS     R7,R0
   1218                    }
   1219                    break;
   \                     ??sbcSemMsgProcess_165: (+1)
   \      0xEA8   0xE05E             B.N      ??sbcSemMsgProcess_170
   1220          
   1221                  case SBC_SEM_TIMEOUT:
   1222                    sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \                     ??sbcSemMsgProcess_163: (+1)
   \      0xEAA   0x2004             MOVS     R0,#+4
   \      0xEAC   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1223                    /* release the transmitter */
   1224                    currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0xEB0   0xF8DF 0xA09C      LDR.W    R10,??sbcSemMsgProcess_3+12
   \      0xEB4   0x2005             MOVS     R0,#+5
   \      0xEB6   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1225                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xEBA   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xEBE   0x2300             MOVS     R3,#+0
   \      0xEC0   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xEC4   0x4651             MOV      R1,R10
   \      0xEC6   0x.... 0x....      BL       xQueueGenericSend
   \      0xECA   0x2801             CMP      R0,#+1
   \      0xECC   0xD00E             BEQ.N    ??sbcSemMsgProcess_171
   \      0xECE   0xB672             CPSID    I
   \      0xED0   0x2050             MOVS     R0,#+80
   \      0xED2   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xED6   0xF3BF 0x8F4F      DSB      SY
   \      0xEDA   0xF3BF 0x8F6F      ISB      SY
   \      0xEDE   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_172: (+1)
   \      0xEE0   0xE7FE             B.N      ??sbcSemMsgProcess_172
   \      0xEE2   0xBF00             Nop
   \                     ??sbcSemMsgProcess_2:
   \      0xEE4   0x....'....        DC32     Default_Socket_Presence
   \      0xEE8   0x....'....        DC32     ?_20
   1226                    /* no ack coming from expected socket --> socket unavailable */
   1227                    ixScu = currFrameSbcSem.data.index - 1;
   \                     ??sbcSemMsgProcess_171: (+1)
   \      0xEEC   0xF8BA 0x0002      LDRH     R0,[R10, #+2]
   \      0xEF0   0x1E40             SUBS     R0,R0,#+1
   \      0xEF2   0x0005             MOVS     R5,R0
   1228                    /* non info pendig, so upgrade the register */
   1229                    pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] |= (uint32_t)0x04;  // Unavailable status
   \      0xEF4   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \      0xEF8   0x6801             LDR      R1,[R0, #+0]
   \      0xEFA   0x002A             MOVS     R2,R5
   \      0xEFC   0xB292             UXTH     R2,R2
   \      0xEFE   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0xF02   0xF8B1 0x1102      LDRH     R1,[R1, #+258]
   \      0xF06   0xF051 0x0104      ORRS     R1,R1,#0x4
   \      0xF0A   0x6802             LDR      R2,[R0, #+0]
   \      0xF0C   0x002B             MOVS     R3,R5
   \      0xF0E   0xB29B             UXTH     R3,R3
   \      0xF10   0xEB02 0x0243      ADD      R2,R2,R3, LSL #+1
   \      0xF14   0xF8A2 0x1102      STRH     R1,[R2, #+258]
   1230                    maskBit = sbcSemMaskBit[ixScu];
   \      0xF18   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \      0xF1C   0x002A             MOVS     R2,R5
   \      0xF1E   0xB292             UXTH     R2,R2
   \      0xF20   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \      0xF24   0x000E             MOVS     R6,R1
   1231                    pScuRoMapReg->scuMapRegNotify.ntfChangeRo |= (uint32_t)maskBit;
   \      0xF26   0x6802             LDR      R2,[R0, #+0]
   \      0xF28   0xF8D2 0x10FA      LDR      R1,[R2, #+250]
   \      0xF2C   0x6802             LDR      R2,[R0, #+0]
   \      0xF2E   0x4331             ORRS     R1,R6,R1
   \      0xF30   0xF8C2 0x10FA      STR      R1,[R2, #+250]
   1232                    pScuRoMapReg->scuMapRegStatusMeas.ntfChgStat = (uint16_t)9;
   \      0xF34   0x2109             MOVS     R1,#+9
   \      0xF36   0x6800             LDR      R0,[R0, #+0]
   \      0xF38   0xF8A0 0x1124      STRH     R1,[R0, #+292]
   1233                    timeTickTmp = portMAX_DELAY;
   \      0xF3C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0xF40   0x0007             MOVS     R7,R0
   1234                    break;
   \      0xF42   0xE011             B.N      ??sbcSemMsgProcess_170
   \                     ??sbcSemMsgProcess_3:
   \      0xF44   0x....'....        DC32     remoteMngTask_attributes
   \      0xF48   0x....'....        DC32     remoteMngTask
   \      0xF4C   0x....'....        DC32     remoteMngTaskHandle
   \      0xF50   0x....'....        DC32     currFrameSbcSem
   1235          
   1236                  case SBC_SEM_EVENT_UART5:
   1237                  case NOTIFY_TO_MASTER_TX:
   1238                    /* a previous message is sending, so the current is put in the list */
   1239                    headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_161: (+1)
   \      0xF54   0x.... 0x....      LDR.W    R10,??DataTable7
   \      0xF58   0x0021             MOVS     R1,R4
   \      0xF5A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xF5E   0x.... 0x....      BL       addNode
   \      0xF62   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1240                    break;
   \      0xF66   0xE7FF             B.N      ??sbcSemMsgProcess_170
   1241          
   1242                  default:
   1243                    break;
   1244          
   1245                }
   1246                break;
   \                     ??sbcSemMsgProcess_164: (+1)
   \                     ??sbcSemMsgProcess_170: (+1)
   \      0xF68   0xE09C             B.N      ??sbcSemMsgProcess_37
   1247                
   1248              case SBC_SEM_WAIT_WR_MASTER_ACK:
   1249              case SBC_SEM_WAIT_WR_MASTER_ACK_STARTUP:
   1250              case SBC_SEM_WAIT_WR_MASTER_POLL_ACK:
   1251                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_13: (+1)
   \      0xF6A   0x8820             LDRH     R0,[R4, #+0]
   \      0xF6C   0x2802             CMP      R0,#+2
   \      0xF6E   0xD07D             BEQ.N    ??sbcSemMsgProcess_173
   \      0xF70   0x2808             CMP      R0,#+8
   \      0xF72   0xF040 0x8089      BNE.W    ??sbcSemMsgProcess_174
   1252                {
   1253                  case NOTIFY_MODBUS_WR_ACK:
   1254          #ifdef ADDR_NO_TRANSLATION
   1255                    if ((pMsg->data.index == SCU_M_P_ADDR) && (pMsg->data.rAddr == currFrameSbcSem.data.rAddr))
   1256          #else
   1257                    if ((pMsg->data.index == getPhysicalMdbAddr()) && (pMsg->data.rAddr == currFrameSbcSem.data.rAddr))
   \                     ??sbcSemMsgProcess_175: (+1)
   \      0xF76   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0xF7A   0x8861             LDRH     R1,[R4, #+2]
   \      0xF7C   0xB2C0             UXTB     R0,R0
   \      0xF7E   0xB280             UXTH     R0,R0
   \      0xF80   0x4281             CMP      R1,R0
   \      0xF82   0xD172             BNE.N    ??sbcSemMsgProcess_176
   \      0xF84   0x.... 0x....      LDR.W    R11,??DataTable9_3
   \      0xF88   0x88A0             LDRH     R0,[R4, #+4]
   \      0xF8A   0xF8BB 0x1004      LDRH     R1,[R11, #+4]
   \      0xF8E   0x4288             CMP      R0,R1
   \      0xF90   0xD16B             BNE.N    ??sbcSemMsgProcess_176
   1258          #endif
   1259                    {
   1260                      /* stop ACK gard  timer */
   1261                      xTimerStop(xSbcSemTimers[TIMER_FOR_ACK], SBCSEM_TIMER_GARD_TIME);
   \      0xF92   0xF44F 0x70FA      MOV      R0,#+500
   \      0xF96   0x9000             STR      R0,[SP, #+0]
   \      0xF98   0x2300             MOVS     R3,#+0
   \      0xF9A   0x2200             MOVS     R2,#+0
   \      0xF9C   0x2103             MOVS     R1,#+3
   \      0xF9E   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0xFA2   0x6840             LDR      R0,[R0, #+4]
   \      0xFA4   0x.... 0x....      BL       xTimerGenericCommand
   1262                      /* the ack coming from the master i.e physical address SCU_M_P_ADDR = 1 */
   1263                      /* release the transmitter */
   1264                      currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0xFA8   0x2005             MOVS     R0,#+5
   \      0xFAA   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1265                      configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xFAE   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xFB2   0x2300             MOVS     R3,#+0
   \      0xFB4   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xFB8   0x4659             MOV      R1,R11
   \      0xFBA   0x.... 0x....      BL       xQueueGenericSend
   \      0xFBE   0x2801             CMP      R0,#+1
   \      0xFC0   0xD009             BEQ.N    ??sbcSemMsgProcess_177
   \      0xFC2   0xB672             CPSID    I
   \      0xFC4   0x2050             MOVS     R0,#+80
   \      0xFC6   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xFCA   0xF3BF 0x8F4F      DSB      SY
   \      0xFCE   0xF3BF 0x8F6F      ISB      SY
   \      0xFD2   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_178: (+1)
   \      0xFD4   0xE7FE             B.N      ??sbcSemMsgProcess_178
   1266                      if (resetChangeRegisterBit(ixLogic, pMsg->data.rAddr, pMsg->dataToSend.len) == TRUE)
   \                     ??sbcSemMsgProcess_177: (+1)
   \      0xFD6   0x88E2             LDRH     R2,[R4, #+6]
   \      0xFD8   0x88A1             LDRH     R1,[R4, #+4]
   \      0xFDA   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0xFDE   0x.... 0x....      BL       resetChangeRegisterBit
   \      0xFE2   0x2801             CMP      R0,#+1
   \      0xFE4   0xD106             BNE.N    ??sbcSemMsgProcess_179
   1267                      {
   1268                        tPrintf("Socket %d Event 0x%X sent!\n\r", ixScu, pMsg->data.rAddr);
   \      0xFE6   0x88A2             LDRH     R2,[R4, #+4]
   \      0xFE8   0x0029             MOVS     R1,R5
   \      0xFEA   0xB289             UXTH     R1,R1
   \      0xFEC   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \      0xFF0   0x.... 0x....      BL       tPrintf
   1269                      }
   1270                      if (SCU_S_REPL_ADDR == getStationId()) /* board with address = 99 is for replacement, so no message storing is need */
   \                     ??sbcSemMsgProcess_179: (+1)
   \      0xFF4   0x.... 0x....      BL       getStationId
   \      0xFF8   0x2863             CMP      R0,#+99
   \      0xFFA   0xD106             BNE.N    ??sbcSemMsgProcess_180
   1271                      {
   1272                        sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_BE_OPERATIVE;
   \      0xFFC   0x200C             MOVS     R0,#+12
   \      0xFFE   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1273                        timeTickTmp = portMAX_DELAY;
   \     0x1002   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \     0x1006   0x0007             MOVS     R7,R0
   1274                        break;
   \     0x1008   0xE03E             B.N      ??sbcSemMsgProcess_181
   1275                      }
   1276          
   1277                      if (headMsg != NULL)
   \                     ??sbcSemMsgProcess_180: (+1)
   \     0x100A   0x.... 0x....      LDR.W    R11,??DataTable7
   \     0x100E   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \     0x1012   0x2800             CMP      R0,#+0
   \     0x1014   0xD006             BEQ.N    ??sbcSemMsgProcess_182
   1278                      {
   1279                        /* re-send a message in the queue list if present */
   1280                        headMsg = extractSendFirstInList(headMsg);
   \     0x1016   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \     0x101A   0x.... 0x....      BL       extractSendFirstInList
   \     0x101E   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \     0x1022   0xE001             B.N      ??sbcSemMsgProcess_183
   1281                      }
   1282                      else
   1283                      {
   1284                        resetPacketStatusNum();
   \                     ??sbcSemMsgProcess_182: (+1)
   \     0x1024   0x.... 0x....      BL       resetPacketStatusNum
   1285                      }
   1286          
   1287                      if (sbcSemInfoMng.sbcSemStates != SBC_SEM_WAIT_WR_MASTER_POLL_ACK)
   \                     ??sbcSemMsgProcess_183: (+1)
   \     0x1028   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \     0x102C   0x2807             CMP      R0,#+7
   \     0x102E   0xD004             BEQ.N    ??sbcSemMsgProcess_184
   1288                      {
   1289                        /* a message froma slave on  RS485 to master has been aknoledged: Set the activity bit */
   1290                        sbcSemInfoMng.activityStatus |= maskBit;
   \     0x1030   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \     0x1034   0x4330             ORRS     R0,R6,R0
   \     0x1036   0xF8CA 0x0014      STR      R0,[R10, #+20]
   1291                      }
   1292          
   1293                      if (sbcSemInfoMng.sbcSemStates == SBC_SEM_WAIT_WR_MASTER_ACK_STARTUP)
   \                     ??sbcSemMsgProcess_184: (+1)
   \     0x103A   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \     0x103E   0x280D             CMP      R0,#+13
   \     0x1040   0xD109             BNE.N    ??sbcSemMsgProcess_185
   1294                      {
   1295                        evs_error_get(error_array, 0, 0, 0);
   \     0x1042   0x2300             MOVS     R3,#+0
   \     0x1044   0x2200             MOVS     R2,#+0
   \     0x1046   0x2100             MOVS     R1,#+0
   \     0x1048   0xA805             ADD      R0,SP,#+20
   \     0x104A   0x.... 0x....      BL       evs_error_get
   1296                        updateModbusErrorRegisters(error_array, TRUE);
   \     0x104E   0x2101             MOVS     R1,#+1
   \     0x1050   0xA805             ADD      R0,SP,#+20
   \     0x1052   0x.... 0x....      BL       updateModbusErrorRegisters
   1297                      }
   1298                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \                     ??sbcSemMsgProcess_185: (+1)
   \     0x1056   0x2004             MOVS     R0,#+4
   \     0x1058   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1299                      sendMonMngMsg(MON_SEM_TASK, MON_START);      // activation task for monitor  
   \     0x105C   0x2100             MOVS     R1,#+0
   \     0x105E   0x2001             MOVS     R0,#+1
   \     0x1060   0x.... 0x....      BL       sendMonMngMsg
   1300                      timeTickTmp = portMAX_DELAY;
   \     0x1064   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \     0x1068   0x0007             MOVS     R7,R0
   1301                    }
   1302                    break;
   \                     ??sbcSemMsgProcess_176: (+1)
   \     0x106A   0xE00D             B.N      ??sbcSemMsgProcess_181
   1303          
   1304                  case NOTIFY_TO_MASTER_TX:
   1305                    if (SCU_S_REPL_ADDR != getStationId()) /* board with address = 99 is for replacement, so no message storing is need */
   \                     ??sbcSemMsgProcess_173: (+1)
   \     0x106C   0x.... 0x....      BL       getStationId
   \     0x1070   0x2863             CMP      R0,#+99
   \     0x1072   0xD008             BEQ.N    ??sbcSemMsgProcess_186
   1306                    {
   1307                      /* a previous message is sending, so the current is put in the list */
   1308                      headMsg = addNode(headMsg, pMsg);
   \     0x1074   0x.... 0x....      LDR.W    R10,??DataTable7
   \     0x1078   0x0021             MOVS     R1,R4
   \     0x107A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \     0x107E   0x.... 0x....      BL       addNode
   \     0x1082   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1309                    }
   1310                    break;
   \                     ??sbcSemMsgProcess_186: (+1)
   \     0x1086   0xE7FF             B.N      ??sbcSemMsgProcess_181
   1311          
   1312                  default:
   1313                    break;
   1314          
   1315                }
   1316                break;
   \                     ??sbcSemMsgProcess_174: (+1)
   \                     ??sbcSemMsgProcess_181: (+1)
   \     0x1088   0xE00C             B.N      ??sbcSemMsgProcess_37
   1317                
   1318          
   1319              default:
   1320                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_20: (+1)
   \     0x108A   0x8820             LDRH     R0,[R4, #+0]
   \     0x108C   0x2802             CMP      R0,#+2
   \     0x108E   0xD109             BNE.N    ??sbcSemMsgProcess_187
   1321                {       
   1322                  case NOTIFY_TO_MASTER_TX:
   1323                    /* A notification to master was sent, but automa status is not managed, so put in the queue */
   1324                    headMsg = addNode(headMsg, pMsg);
   \     0x1090   0x.... 0x....      LDR.W    R10,??DataTable7
   \     0x1094   0x0021             MOVS     R1,R4
   \     0x1096   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \     0x109A   0x.... 0x....      BL       addNode
   \     0x109E   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1325                    break;
   \     0x10A2   0xE7FF             B.N      ??sbcSemMsgProcess_188
   1326                    
   1327                  default:
   1328                    break;
   1329                }
   1330                break;
   1331            }
   1332          
   1333            if (pMsg->sbcSemEvent == NOTIFY_MODBUS_WR_ACK)
   \                     ??sbcSemMsgProcess_187: (+1)
   \                     ??sbcSemMsgProcess_188: (+1)
   \                     ??sbcSemMsgProcess_37: (+1)
   \     0x10A4   0x8820             LDRH     R0,[R4, #+0]
   \     0x10A6   0x2808             CMP      R0,#+8
   \     0x10A8   0xD105             BNE.N    ??sbcSemMsgProcess_189
   1334            {
   1335              if (pMsg->dataToSend.pData != NULL)
   \     0x10AA   0x68A0             LDR      R0,[R4, #+8]
   \     0x10AC   0x2800             CMP      R0,#+0
   \     0x10AE   0xD002             BEQ.N    ??sbcSemMsgProcess_189
   1336              {
   1337                /* free temporary payload buffer */
   1338                free(pMsg->dataToSend.pData);
   \     0x10B0   0x68A0             LDR      R0,[R4, #+8]
   \     0x10B2   0x.... 0x....      BL       free
   1339              }
   1340            }
   1341          
   1342            return (timeTickTmp);
   \                     ??sbcSemMsgProcess_189: (+1)
   \     0x10B6   0x0038             MOVS     R0,R7
   \     0x10B8   0xB009             ADD      SP,SP,#+36
   \     0x10BA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1343          }
   1344          // --------------------------------------------------------------------------------------------------------------------------- //
   1345          
   1346          /**
   1347          *
   1348          * @brief        Get the pointer to task queue
   1349          *
   1350          * @param [in]   none
   1351          *
   1352          * @retval       xQueueHandle: pointer to defined  queue
   1353          *
   1354          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1355          xQueueHandle getSbcSemQueueHandle(void)
   1356          {
   1357             return(sbcSemQueue);
   \                     getSbcSemQueueHandle: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable10
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR
   1358          }
   1359          
   1360          
   1361          

   \                                 In section .text, align 2, keep-with-next
   1362          void rs485SemGestTask (void * pvParameters)
   1363          {
   \                     rs485SemGestTask: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   1364            uint32_t       timeTick;
   1365            frameSbcSem_st tmpframers485Sem;  
   1366          
   1367            /*-------- Creates an empty mailbox for uart  messages --------------------------*/
   1368            rs485SemQueue = xQueueCreate(NUM_BUFF_RS485_SEM, sizeof(frameSbcSem_st));
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable10_1
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2112             MOVS     R1,#+18
   \        0xE   0x2010             MOVS     R0,#+16
   \       0x10   0x.... 0x....      BL       xQueueGenericCreate
   \       0x14   0x6028             STR      R0,[R5, #+0]
   1369            configASSERT(rs485SemQueue != NULL);
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD109             BNE.N    ??rs485SemGestTask_0
   \       0x1C   0xB672             CPSID    I
   \       0x1E   0x2050             MOVS     R0,#+80
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   \       0x2C   0xB662             CPSIE    I
   \                     ??rs485SemGestTask_1: (+1)
   \       0x2E   0xE7FE             B.N      ??rs485SemGestTask_1
   1370            
   1371            /* init structure for management */
   1372            rs485SemInfoMng.rs485SemStates = RS485_SEM_OPERATIVE;
   \                     ??rs485SemGestTask_0: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \       0x36   0x8008             STRH     R0,[R1, #+0]
   1373              
   1374            //timeTick = pdMS_TO_TICKS(TIMEOUT_RESP_500);
   1375            timeTick = portMAX_DELAY;
   \       0x38   0xF05F 0x36FF      MOVS     R6,#+4294967295
   1376          
   1377            for (;;)
   1378            {
   1379              /* Wait for some event from Rx/Tx uart SBC (typically UART5)  */
   1380              if (xQueueReceive(rs485SemQueue, (void *)&framers485Sem, timeTick) == pdPASS)
   \                     ??rs485SemGestTask_2: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R7,??DataTable10_3
   \       0x40   0x0032             MOVS     R2,R6
   \       0x42   0x0039             MOVS     R1,R7
   \       0x44   0x6828             LDR      R0,[R5, #+0]
   \       0x46   0x.... 0x....      BL       xQueueReceive
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xD104             BNE.N    ??rs485SemGestTask_3
   1381              {
   1382                timeTick = rs485SemMsgProcess(&framers485Sem);
   \       0x4E   0x0038             MOVS     R0,R7
   \       0x50   0x.... 0x....      BL       rs485SemMsgProcess
   \       0x54   0x0006             MOVS     R6,R0
   \       0x56   0xE7F1             B.N      ??rs485SemGestTask_2
   1383              }
   1384              else
   1385              {
   1386                tmpframers485Sem.sbcSemEvent = SBC_SEM_TIMEOUT;
   \                     ??rs485SemGestTask_3: (+1)
   \       0x58   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0x5C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1387                timeTick = rs485SemMsgProcess(&tmpframers485Sem);
   \       0x60   0x4668             MOV      R0,SP
   \       0x62   0x.... 0x....      BL       rs485SemMsgProcess
   \       0x66   0x0006             MOVS     R6,R0
   \       0x68   0xE7E8             B.N      ??rs485SemGestTask_2
   1388              }
   1389            }
   1390          }
   1391          
   1392          
   1393          
   1394          /**
   1395          *
   1396          * @brief        Decoder message from / to RS485 (slave <---> master) 
   1397          *
   1398          * @param [in]   none
   1399          *
   1400          * @retval       uint32_t: timeout value 
   1401          *
   1402          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1403          static uint32_t rs485SemMsgProcess(frameSbcSem_st* pMsg)
   1404          {
   \                     rs485SemMsgProcess: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   1405            uint16_t              ixScuPhysical, ixScuLogical;
   1406            uint32_t              timeTickTmp;
   1407            scuRoMapRegister_st*  pRoRegs;
   1408            scuRwMapRegister_st*  pRwRegs;
   1409            tmMapRegister_st*     pTmRegs;
   1410          #ifndef ADDR_NO_TRANSLATION
   1411            uint8_t               addrRs485;   
   1412          #endif
   1413          
   1414            timeTickTmp = portMAX_DELAY;
   \        0x6   0xF05F 0x37FF      MOVS     R7,#+4294967295
   1415          
   1416            if (pMsg->sbcSemEvent != SBC_SEM_TIMEOUT)
   \        0xA   0x8820             LDRH     R0,[R4, #+0]
   \        0xC   0xF64F 0x71FE      MOVW     R1,#+65534
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD027             BEQ.N    ??rs485SemMsgProcess_0
   1417            {
   1418              if (pMsg->data.index == MODBUS_BROADCAST_ADDR)
   \       0x14   0x8860             LDRH     R0,[R4, #+2]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD105             BNE.N    ??rs485SemMsgProcess_1
   1419              {
   1420                ixScuLogical = ixScuPhysical = pMsg->data.index;
   \       0x1A   0x8860             LDRH     R0,[R4, #+2]
   \       0x1C   0x0005             MOVS     R5,R0
   \       0x1E   0x002E             MOVS     R6,R5
   1421                addrRs485 = MODBUS_BROADCAST_ADDR;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x4682             MOV      R10,R0
   \       0x24   0xE00F             B.N      ??rs485SemMsgProcess_2
   1422              }
   1423              else
   1424              {
   1425                ixScuPhysical = pMsg->data.index;                     // physical address 1...16    
   \                     ??rs485SemMsgProcess_1: (+1)
   \       0x26   0x8860             LDRH     R0,[R4, #+2]
   \       0x28   0x0005             MOVS     R5,R0
   1426                ixScuLogical = pMsg->data.index - 1;                  // logical address  0...15
   \       0x2A   0x8860             LDRH     R0,[R4, #+2]
   \       0x2C   0x1E40             SUBS     R0,R0,#+1
   \       0x2E   0x0006             MOVS     R6,R0
   1427          #ifndef ADDR_NO_TRANSLATION
   1428                addrRs485 = socketPresence.matrixConv[ixScuLogical];  // modbus address   1...247
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \       0x34   0x0031             MOVS     R1,R6
   \       0x36   0xB289             UXTH     R1,R1
   \       0x38   0x4408             ADD      R0,R0,R1
   \       0x3A   0x7C00             LDRB     R0,[R0, #+16]
   \       0x3C   0x4682             MOV      R10,R0
   1429                rs485SemInfoMng.rs485RWmR.regAdd = pMsg->data.rAddr;
   \       0x3E   0x88A0             LDRH     R0,[R4, #+4]
   \       0x40   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \       0x44   0x8108             STRH     R0,[R1, #+8]
   1430          #endif
   1431              }
   1432          
   1433              pRoRegs = getRoMdbRegs(ixScuLogical);
   \                     ??rs485SemMsgProcess_2: (+1)
   \       0x46   0x0030             MOVS     R0,R6
   \       0x48   0xB2C0             UXTB     R0,R0
   \       0x4A   0x.... 0x....      BL       getRoMdbRegs
   \       0x4E   0x4680             MOV      R8,R0
   1434              pRwRegs = getRwMdbRegs(ixScuLogical);
   \       0x50   0x0030             MOVS     R0,R6
   \       0x52   0xB2C0             UXTB     R0,R0
   \       0x54   0x.... 0x....      BL       getRwMdbRegs
   \       0x58   0x4681             MOV      R9,R0
   1435              pTmRegs = getTmMdbRegs(ixScuLogical);
   \       0x5A   0x0030             MOVS     R0,R6
   \       0x5C   0xB2C0             UXTB     R0,R0
   \       0x5E   0x.... 0x....      BL       getTmMdbRegs
   \       0x62   0x9000             STR      R0,[SP, #+0]
   1436            }
   1437          
   1438            switch (rs485SemInfoMng.rs485SemStates)
   \                     ??rs485SemMsgProcess_0: (+1)
   \       0x64   0x.... 0x....      LDR.W    R11,??DataTable10_2
   \       0x68   0xF8BB 0x0000      LDRH     R0,[R11, #+0]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD006             BEQ.N    ??rs485SemMsgProcess_3
   \       0x70   0x1E40             SUBS     R0,R0,#+1
   \       0x72   0xD005             BEQ.N    ??rs485SemMsgProcess_4
   \       0x74   0x1EC0             SUBS     R0,R0,#+3
   \       0x76   0x2801             CMP      R0,#+1
   \       0x78   0xF240 0x8126      BLS.W    ??rs485SemMsgProcess_5
   \       0x7C   0xE15C             B.N      ??rs485SemMsgProcess_6
   1439            {
   1440              case RS485_SEM_IDLE:
   1441                break;
   \                     ??rs485SemMsgProcess_3: (+1)
   \       0x7E   0xE15B             B.N      ??rs485SemMsgProcess_7
   1442          
   1443              case RS485_SEM_OPERATIVE:
   1444                switch (pMsg->sbcSemEvent)
   \                     ??rs485SemMsgProcess_4: (+1)
   \       0x80   0x8820             LDRH     R0,[R4, #+0]
   \       0x82   0x2802             CMP      R0,#+2
   \       0x84   0xD006             BEQ.N    ??rs485SemMsgProcess_8
   \       0x86   0x2803             CMP      R0,#+3
   \       0x88   0xF000 0x80C2      BEQ.W    ??rs485SemMsgProcess_9
   \       0x8C   0x2806             CMP      R0,#+6
   \       0x8E   0xF000 0x80FA      BEQ.W    ??rs485SemMsgProcess_10
   \       0x92   0xE118             B.N      ??rs485SemMsgProcess_11
   1445                {
   1446                  case NOTIFY_TO_MASTER_TX:
   1447                    switch (pMsg->data.rAddr)
   \                     ??rs485SemMsgProcess_8: (+1)
   \       0x94   0x88A0             LDRH     R0,[R4, #+4]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD04C             BEQ.N    ??rs485SemMsgProcess_12
   \       0x9A   0x1E80             SUBS     R0,R0,#+2
   \       0x9C   0xD050             BEQ.N    ??rs485SemMsgProcess_13
   \       0x9E   0x1E80             SUBS     R0,R0,#+2
   \       0xA0   0xD040             BEQ.N    ??rs485SemMsgProcess_14
   \       0xA2   0x381E             SUBS     R0,R0,#+30
   \       0xA4   0xF000 0x808A      BEQ.W    ??rs485SemMsgProcess_15
   \       0xA8   0xF240 0x31E2      MOVW     R1,#+994
   \       0xAC   0x1A40             SUBS     R0,R0,R1
   \       0xAE   0xD05F             BEQ.N    ??rs485SemMsgProcess_16
   \       0xB0   0x1E40             SUBS     R0,R0,#+1
   \       0xB2   0xD065             BEQ.N    ??rs485SemMsgProcess_17
   \       0xB4   0xF44F 0x7187      MOV      R1,#+270
   \       0xB8   0x1A40             SUBS     R0,R0,R1
   \       0xBA   0xD069             BEQ.N    ??rs485SemMsgProcess_18
   \       0xBC   0x1E40             SUBS     R0,R0,#+1
   \       0xBE   0xD06E             BEQ.N    ??rs485SemMsgProcess_19
   \       0xC0   0x1E40             SUBS     R0,R0,#+1
   \       0xC2   0xD073             BEQ.N    ??rs485SemMsgProcess_20
   \       0xC4   0x380E             SUBS     R0,R0,#+14
   \       0xC6   0xF000 0x8081      BEQ.W    ??rs485SemMsgProcess_21
   \       0xCA   0x38DD             SUBS     R0,R0,#+221
   \       0xCC   0xD012             BEQ.N    ??rs485SemMsgProcess_22
   \       0xCE   0x1E40             SUBS     R0,R0,#+1
   \       0xD0   0xD008             BEQ.N    ??rs485SemMsgProcess_23
   \       0xD2   0x380D             SUBS     R0,R0,#+13
   \       0xD4   0xD016             BEQ.N    ??rs485SemMsgProcess_24
   \       0xD6   0x3833             SUBS     R0,R0,#+51
   \       0xD8   0xD042             BEQ.N    ??rs485SemMsgProcess_25
   \       0xDA   0x380F             SUBS     R0,R0,#+15
   \       0xDC   0xD038             BEQ.N    ??rs485SemMsgProcess_26
   \       0xDE   0x3818             SUBS     R0,R0,#+24
   \       0xE0   0xD018             BEQ.N    ??rs485SemMsgProcess_27
   \       0xE2   0xE07A             B.N      ??rs485SemMsgProcess_28
   1448                    {
   1449                      case ADDR_EVSE_CHARGE_STATUS_RO:
   1450                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegStatusMeas.ntfChgStat);
   \                     ??rs485SemMsgProcess_23: (+1)
   \       0xE4   0x2002             MOVS     R0,#+2
   \       0xE6   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1451                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.ntfChgStat; 
   \       0xEA   0xF518 0x7092      ADDS     R0,R8,#+292
   \       0xEE   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1452          #ifdef ADDR_NO_TRANSLATION
   1453                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_EVSE_CHARGE_STATUS_RO;
   1454          #endif
   1455                        break;
   \       0xF2   0xE075             B.N      ??rs485SemMsgProcess_29
   1456          
   1457                      case ADDR_EVSE_EVENT_FLAGS_RO:
   1458                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegStatusMeas.ntfSktEvent);
   \                     ??rs485SemMsgProcess_22: (+1)
   \       0xF4   0x2002             MOVS     R0,#+2
   \       0xF6   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1459                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.ntfSktEvent; 
   \       0xFA   0xF518 0x7091      ADDS     R0,R8,#+290
   \       0xFE   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1460          #ifdef ADDR_NO_TRANSLATION
   1461                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_EVSE_EVENT_FLAGS_RO;
   1462          #endif
   1463                        break;
   \      0x102   0xE06D             B.N      ??rs485SemMsgProcess_29
   1464          
   1465                      case ADDR_VOLTAGE_AC_RO:
   1466                        rs485SemInfoMng.rs485RWmR.numBytes = (ADDR_SCU_RESERVED6B - ADDR_VOLTAGE_AC_RO) * 2; // transmit until last info TIME_INCHARGE_RO
   \                     ??rs485SemMsgProcess_24: (+1)
   \      0x104   0x20B8             MOVS     R0,#+184
   \      0x106   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1467                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.mtVsys; 
   \      0x10A   0xF518 0x709F      ADDS     R0,R8,#+318
   \      0x10E   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1468          #ifdef ADDR_NO_TRANSLATION
   1469                        rs485SemInfoMng.rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_VOLTAGE_AC_RO;
   1470          #endif
   1471                        break;
   \      0x112   0xE065             B.N      ??rs485SemMsgProcess_29
   1472          
   1473                      case ADDR_TIME_IN_CHARGE_RO:
   1474                        rs485SemInfoMng.rs485RWmR.numBytes = (LEN_TIME_IN_CHARGE_RO) * 2; // transmit only info TIME_INCHARGE_RO
   \                     ??rs485SemMsgProcess_27: (+1)
   \      0x114   0x2004             MOVS     R0,#+4
   \      0x116   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1475                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.timeInCharge; 
   \      0x11A   0xF518 0x70F9      ADDS     R0,R8,#+498
   \      0x11E   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1476          #ifdef ADDR_NO_TRANSLATION
   1477                        rs485SemInfoMng.rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_TIME_IN_CHARGE_RO;
   1478          #endif
   1479                        break;
   \      0x122   0xE05D             B.N      ??rs485SemMsgProcess_29
   1480          
   1481                      case ADDR_CONNECTOR_IDS_RW:
   1482                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRwRegs->scuSetRegister.devAlias);
   \                     ??rs485SemMsgProcess_14: (+1)
   \      0x124   0x2002             MOVS     R0,#+2
   \      0x126   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1483                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRwRegs->scuSetRegister.devAlias; 
   \      0x12A   0xF119 0x0008      ADDS     R0,R9,#+8
   \      0x12E   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1484          #ifdef ADDR_NO_TRANSLATION
   1485                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_CONNECTOR_IDS_RW;
   1486          #endif
   1487                        break;
   \      0x132   0xE055             B.N      ??rs485SemMsgProcess_29
   1488          
   1489                    case ADDR_CONNECTOR_TYPE_RW:
   1490                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(scuSetRegister_st);
   \                     ??rs485SemMsgProcess_12: (+1)
   \      0x134   0x20D2             MOVS     R0,#+210
   \      0x136   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1491                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRwRegs->scuSetRegister.connType; 
   \      0x13A   0xF8CB 0x9002      STR      R9,[R11, #+2]
   1492          #ifdef ADDR_NO_TRANSLATION
   1493                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_CONNECTOR_TYPE_RW;
   1494          #endif
   1495                        break;
   \      0x13E   0xE04F             B.N      ??rs485SemMsgProcess_29
   1496          
   1497                      case ADDR_ENERGY_METERS_RW:
   1498                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRwRegs->scuSetRegister.mtType);
   \                     ??rs485SemMsgProcess_13: (+1)
   \      0x140   0x2002             MOVS     R0,#+2
   \      0x142   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1499                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRwRegs->scuSetRegister.mtType; 
   \      0x146   0xF119 0x0004      ADDS     R0,R9,#+4
   \      0x14A   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1500          #ifdef ADDR_NO_TRANSLATION
   1501                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_ENERGY_METERS_RW;
   1502          #endif
   1503                        break;
   \      0x14E   0xE047             B.N      ??rs485SemMsgProcess_29
   1504          
   1505                      case ADDR_UID_AUTHORIZATION_RO:
   1506                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegStatusMeas.uidAuth);
   \                     ??rs485SemMsgProcess_26: (+1)
   \      0x150   0x2030             MOVS     R0,#+48
   \      0x152   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1507                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.uidAuth; 
   \      0x156   0xF518 0x70E1      ADDS     R0,R8,#+450
   \      0x15A   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1508          #ifdef ADDR_NO_TRANSLATION
   1509                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_UID_AUTHORIZATION_RO;
   1510          #endif
   1511                        break;
   \      0x15E   0xE03F             B.N      ??rs485SemMsgProcess_29
   1512          
   1513                      case ADDR_SESSION_ID_RO:
   1514                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegStatusMeas.evSessionId);
   \                     ??rs485SemMsgProcess_25: (+1)
   \      0x160   0x2004             MOVS     R0,#+4
   \      0x162   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1515                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.evSessionId; 
   \      0x166   0xF518 0x70D2      ADDS     R0,R8,#+420
   \      0x16A   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1516          #ifdef ADDR_NO_TRANSLATION
   1517                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_SESSION_ID_RO;
   1518          #endif
   1519                        break;
   \      0x16E   0xE037             B.N      ??rs485SemMsgProcess_29
   1520          
   1521                      case ADDR_EVSE_ERROR1_RO:
   1522                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegNotify.ntfErr1);
   \                     ??rs485SemMsgProcess_16: (+1)
   \      0x170   0x2002             MOVS     R0,#+2
   \      0x172   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1523                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegNotify.ntfErr1; 
   \      0x176   0xF118 0x00FE      ADDS     R0,R8,#+254
   \      0x17A   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1524          #ifdef ADDR_NO_TRANSLATION
   1525                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_EVSE_ERROR1_RO;
   1526          #endif
   1527                        break;
   \      0x17E   0xE02F             B.N      ??rs485SemMsgProcess_29
   1528                        
   1529                      case ADDR_EVSE_ERROR2_RO:
   1530                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegNotify.ntfErr2);
   \                     ??rs485SemMsgProcess_17: (+1)
   \      0x180   0x2002             MOVS     R0,#+2
   \      0x182   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1531                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegNotify.ntfErr2; 
   \      0x186   0xF518 0x7080      ADDS     R0,R8,#+256
   \      0x18A   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1532          #ifdef ADDR_NO_TRANSLATION
   1533                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_EVSE_ERROR2_RO;
   1534          #endif
   1535                        break;
   \      0x18E   0xE027             B.N      ??rs485SemMsgProcess_29
   1536          
   1537                      case ADDR_ADDR_S_CONN_RW:
   1538                        rs485SemInfoMng.rs485RWmR.numBytes = pMsg->dataToSend.len;
   \                     ??rs485SemMsgProcess_18: (+1)
   \      0x190   0x88E0             LDRH     R0,[R4, #+6]
   \      0x192   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1539                        rs485SemInfoMng.pOriginData = (uint8_t*)pMsg->dataToSend.pData; 
   \      0x196   0x68A0             LDR      R0,[R4, #+8]
   \      0x198   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1540          #ifdef ADDR_NO_TRANSLATION
   1541                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_ADDR_S_CONN_RW;
   1542          #endif
   1543                        break;
   \      0x19C   0xE020             B.N      ??rs485SemMsgProcess_29
   1544          
   1545                      case ADDR_TM_ADDR_REQ_RW:
   1546                        rs485SemInfoMng.rs485RWmR.numBytes = pMsg->dataToSend.len;
   \                     ??rs485SemMsgProcess_19: (+1)
   \      0x19E   0x88E0             LDRH     R0,[R4, #+6]
   \      0x1A0   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1547                        rs485SemInfoMng.pOriginData = (uint8_t*)pMsg->dataToSend.pData; 
   \      0x1A4   0x68A0             LDR      R0,[R4, #+8]
   \      0x1A6   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1548          #ifdef ADDR_NO_TRANSLATION
   1549                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_TM_ADDR_REQ_RW;
   1550          #endif
   1551                        break;
   \      0x1AA   0xE019             B.N      ??rs485SemMsgProcess_29
   1552          
   1553                      case ADDR_TM_ADDR_ASS_RW:
   1554                        /* in the ADDR_TM_ADDR_REQ_RW there is the randomId received*/
   1555                        /* in the ADDR_TM_ADDR_ASS_RW there is the physical address assigned */
   1556                        rs485SemInfoMng.rs485RWmR.numBytes = pMsg->dataToSend.len;
   \                     ??rs485SemMsgProcess_20: (+1)
   \      0x1AC   0x88E0             LDRH     R0,[R4, #+6]
   \      0x1AE   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1557                        rs485SemInfoMng.pOriginData = (uint8_t*)&pTmRegs->tmAddrReq; 
   \      0x1B2   0x9800             LDR      R0,[SP, #+0]
   \      0x1B4   0x3008             ADDS     R0,R0,#+8
   \      0x1B6   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1558          #ifdef ADDR_NO_TRANSLATION
   1559                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_TM_ADDR_REQ_RW;
   1560          #endif
   1561                        break;
   \      0x1BA   0xE011             B.N      ??rs485SemMsgProcess_29
   1562          
   1563                      case ADDR_EVSE_TM_RW:
   1564                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegStatusMeas.ntfChgStat);
   \                     ??rs485SemMsgProcess_15: (+1)
   \      0x1BC   0x2002             MOVS     R0,#+2
   \      0x1BE   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1565                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.ntfChgStat; 
   \      0x1C2   0xF518 0x7092      ADDS     R0,R8,#+292
   \      0x1C6   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1566          #ifdef ADDR_NO_TRANSLATION
   1567                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_EVSE_CHARGE_STATUS_RO;
   1568          #endif
   1569                        break;
   \      0x1CA   0xE009             B.N      ??rs485SemMsgProcess_29
   1570                        
   1571                      case ADDR_GET_EEPROM_RW:
   1572                        /* this address is used by SCU jolly to request info at the master to clone the previous broken board */
   1573                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pTmRegs->tmGetEeprom);
   \                     ??rs485SemMsgProcess_21: (+1)
   \      0x1CC   0x2002             MOVS     R0,#+2
   \      0x1CE   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1574                        rs485SemInfoMng.pOriginData = (uint8_t*)pMsg->dataToSend.pData; 
   \      0x1D2   0x68A0             LDR      R0,[R4, #+8]
   \      0x1D4   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1575          #ifdef ADDR_NO_TRANSLATION
   1576                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_GET_EEPROM_RW;
   1577          #endif
   1578                        break;
   \      0x1D8   0xE002             B.N      ??rs485SemMsgProcess_29
   1579          
   1580                      default:
   1581                        rs485SemInfoMng.pOriginData = NULL; 
   \                     ??rs485SemMsgProcess_28: (+1)
   \      0x1DA   0x2000             MOVS     R0,#+0
   \      0x1DC   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1582                        break;
   1583                    }
   1584                    if (rs485SemInfoMng.pOriginData != NULL)
   \                     ??rs485SemMsgProcess_29: (+1)
   \      0x1E0   0xF11B 0x0102      ADDS     R1,R11,#+2
   \      0x1E4   0x6808             LDR      R0,[R1, #+0]
   \      0x1E6   0x2800             CMP      R0,#+0
   \      0x1E8   0xD011             BEQ.N    ??rs485SemMsgProcess_30
   1585                    {
   1586          #ifdef ADDR_NO_TRANSLATION
   1587                      /* data must be sent to SCU master over RS485 */
   1588                      currFrameSbcSem.data.index = rs485RWmR.unitId = SCU_M_P_ADDR;  /* the message must be sent to SCU master */
   1589          #else
   1590                      currFrameSbcSem.data.index = ixScuPhysical;  /* the message must be sent to SCU master */
   \      0x1EA   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \      0x1EE   0x8045             STRH     R5,[R0, #+2]
   1591                      rs485SemInfoMng.rs485RWmR.unitId = addrRs485;
   \      0x1F0   0xF88B 0xA006      STRB     R10,[R11, #+6]
   1592          #endif
   1593                      writeMasterModbusRegister(rs485SemInfoMng.pOriginData, &rs485SemInfoMng.rs485RWmR);
   \      0x1F4   0x6808             LDR      R0,[R1, #+0]
   \      0x1F6   0xF11B 0x0106      ADDS     R1,R11,#+6
   \      0x1FA   0x.... 0x....      BL       writeMasterModbusRegister
   1594                      rs485SemInfoMng.rs485SemStates = RS485_SEM_ACK_WAITING_WR;
   \      0x1FE   0x2004             MOVS     R0,#+4
   \      0x200   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1595                      /* set parameter for retransmission */
   1596                      rs485SemInfoMng.numRetry = (uint16_t)0;
   \      0x204   0x2000             MOVS     R0,#+0
   \      0x206   0xF8AB 0x0013      STRH     R0,[R11, #+19]
   1597                      timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_TRANSMITTER_RESP); 
   \      0x20A   0x2064             MOVS     R0,#+100
   \      0x20C   0x0007             MOVS     R7,R0
   1598                    }
   1599                    break;
   \                     ??rs485SemMsgProcess_30: (+1)
   \      0x20E   0xE05A             B.N      ??rs485SemMsgProcess_31
   1600          
   1601                  case NOTIFY_TO_SLAVE_TX:
   1602                    if  ((pMsg->data.rAddr < ADDR_RESERVED_A) ||                                                          // area RW configurazioni 
   1603                         ((pMsg->data.rAddr >= ADDR_FILE_COMMAND_RW)  && (pMsg->data.rAddr < ADDR_END_RW_REGS_WO)) ||     // area RW FW upgrade
   1604                         ((pMsg->data.rAddr >= ADDR_TM_MEASURED_CURRENT_RW)  && (pMsg->data.rAddr < ADDR_RESERVED_B)))    // area RW collaudo
   \                     ??rs485SemMsgProcess_9: (+1)
   \      0x210   0x88A0             LDRH     R0,[R4, #+4]
   \      0x212   0x2869             CMP      R0,#+105
   \      0x214   0xDB10             BLT.N    ??rs485SemMsgProcess_32
   \      0x216   0x88A0             LDRH     R0,[R4, #+4]
   \      0x218   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x21C   0xDB03             BLT.N    ??rs485SemMsgProcess_33
   \      0x21E   0x88A0             LDRH     R0,[R4, #+4]
   \      0x220   0xF5B0 0x7F82      CMP      R0,#+260
   \      0x224   0xDB08             BLT.N    ??rs485SemMsgProcess_32
   \                     ??rs485SemMsgProcess_33: (+1)
   \      0x226   0x88A0             LDRH     R0,[R4, #+4]
   \      0x228   0xF5B0 0x6FA2      CMP      R0,#+1296
   \      0x22C   0xDB2A             BLT.N    ??rs485SemMsgProcess_34
   \      0x22E   0x88A0             LDRH     R0,[R4, #+4]
   \      0x230   0xF240 0x5124      MOVW     R1,#+1316
   \      0x234   0x4288             CMP      R0,R1
   \      0x236   0xDA25             BGE.N    ??rs485SemMsgProcess_34
   1605                    {
   1606                      /* filter on register to send to a slave */
   1607          #ifdef ADDR_NO_TRANSLATION
   1608                        rs485SemInfoMng.rs485RWmR.unitId = ixScuPhysical;  /* the message must be sent to SCU slave */
   1609          #else
   1610                      rs485SemInfoMng.rs485RWmR.unitId = addrRs485;     /* the message must be sent to SCU slave */
   \                     ??rs485SemMsgProcess_32: (+1)
   \      0x238   0xF88B 0xA006      STRB     R10,[R11, #+6]
   1611          #endif
   1612                      rs485SemInfoMng.rs485RWmR.numWords = pMsg->dataToSend.len;
   \      0x23C   0x88E0             LDRH     R0,[R4, #+6]
   \      0x23E   0xF8AB 0x000A      STRH     R0,[R11, #+10]
   1613                      rs485SemInfoMng.rs485RWmR.numBytes = 2 * rs485SemInfoMng.rs485RWmR.numWords;
   \      0x242   0xF8BB 0x000A      LDRH     R0,[R11, #+10]
   \      0x246   0xB2C0             UXTB     R0,R0
   \      0x248   0x0040             LSLS     R0,R0,#+1
   \      0x24A   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1614                      rs485SemInfoMng.pOriginData = (uint8_t*)pMsg->dataToSend.pData; 
   \      0x24E   0x68A0             LDR      R0,[R4, #+8]
   \      0x250   0xF11B 0x0102      ADDS     R1,R11,#+2
   \      0x254   0x6008             STR      R0,[R1, #+0]
   1615                      rs485SemInfoMng.rs485RWmR.regAdd = pMsg->data.rAddr;
   \      0x256   0x88A0             LDRH     R0,[R4, #+4]
   \      0x258   0xF8AB 0x0008      STRH     R0,[R11, #+8]
   1616                      writeMasterModbusRegister(rs485SemInfoMng.pOriginData, &rs485SemInfoMng.rs485RWmR);
   \      0x25C   0x6808             LDR      R0,[R1, #+0]
   \      0x25E   0xF11B 0x0106      ADDS     R1,R11,#+6
   \      0x262   0x.... 0x....      BL       writeMasterModbusRegister
   1617                      if (rs485SemInfoMng.rs485RWmR.unitId != MODBUS_BROADCAST_ADDR)
   \      0x266   0xF89B 0x0006      LDRB     R0,[R11, #+6]
   \      0x26A   0x2800             CMP      R0,#+0
   \      0x26C   0xD00A             BEQ.N    ??rs485SemMsgProcess_34
   1618                      {
   1619                        currFrameSbcSem.data.index = rs485SemInfoMng.rs485RWmR.unitId;  // phisical address 1...16
   \      0x26E   0xF89B 0x0006      LDRB     R0,[R11, #+6]
   \      0x272   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \      0x276   0x8048             STRH     R0,[R1, #+2]
   1620                        timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_RESP); 
   \      0x278   0xF44F 0x70FA      MOV      R0,#+500
   \      0x27C   0x0007             MOVS     R7,R0
   1621                        rs485SemInfoMng.rs485SemStates = RS485_SEM_ACK_WAITING_WR;
   \      0x27E   0x2004             MOVS     R0,#+4
   \      0x280   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1622                      }
   1623                    }
   1624                    break;
   \                     ??rs485SemMsgProcess_34: (+1)
   \      0x284   0xE01F             B.N      ??rs485SemMsgProcess_31
   1625          
   1626                  case NOTIFY_TO_SLAVE_RX:
   1627                    rs485SemInfoMng.rs485Rd.numBytes = pMsg->dataToSend.len;
   \                     ??rs485SemMsgProcess_10: (+1)
   \      0x286   0x88E0             LDRH     R0,[R4, #+6]
   \      0x288   0xF8AB 0x0011      STRH     R0,[R11, #+17]
   1628          #ifdef ADDR_NO_TRANSLATION
   1629                    rs485SemInfoMng.rs485Rd.unitId = ixScuPhysical;  /* the message must be sent to SCU slave */
   1630          #else
   1631                    rs485SemInfoMng.rs485Rd.unitId = addrRs485;     /* the message must be sent to SCU slave */
   \      0x28C   0xF88B 0xA00D      STRB     R10,[R11, #+13]
   1632          #endif
   1633                    rs485SemInfoMng.rs485Rd.regAdd = pMsg->data.rAddr;
   \      0x290   0x88A0             LDRH     R0,[R4, #+4]
   \      0x292   0xF8AB 0x000F      STRH     R0,[R11, #+15]
   1634                    readMasterModbusRegister(&rs485SemInfoMng.rs485Rd);
   \      0x296   0xF11B 0x000D      ADDS     R0,R11,#+13
   \      0x29A   0x.... 0x....      BL       readMasterModbusRegister
   1635                    currFrameSbcSem.data.index = rs485SemInfoMng.rs485Rd.unitId;  // phisical address 1...16
   \      0x29E   0xF89B 0x000D      LDRB     R0,[R11, #+13]
   \      0x2A2   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \      0x2A6   0x8048             STRH     R0,[R1, #+2]
   1636                    if (pMsg->data.rAddr == ADDR_GET_EEPROM_RW)
   \      0x2A8   0x88A0             LDRH     R0,[R4, #+4]
   \      0x2AA   0xF240 0x5123      MOVW     R1,#+1315
   \      0x2AE   0x4288             CMP      R0,R1
   \      0x2B0   0xD103             BNE.N    ??rs485SemMsgProcess_35
   1637                    {
   1638                      /* in this case the time out must be longer: the slave will transmit about 1KB and this means about 44ms */
   1639                      timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_RESP); // use 500ms
   \      0x2B2   0xF44F 0x70FA      MOV      R0,#+500
   \      0x2B6   0x0007             MOVS     R7,R0
   \      0x2B8   0xE001             B.N      ??rs485SemMsgProcess_36
   1640                    }
   1641                    else
   1642                    {
   1643                      /* in this case the time out must be longer: the slave will transmit about 1KB and this means about 44ms */
   1644                      timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_TRANSMITTER_RESP); 
   \                     ??rs485SemMsgProcess_35: (+1)
   \      0x2BA   0x2064             MOVS     R0,#+100
   \      0x2BC   0x0007             MOVS     R7,R0
   1645                    }
   1646                    rs485SemInfoMng.rs485SemStates = RS485_SEM_ACK_WAITING_RD;
   \                     ??rs485SemMsgProcess_36: (+1)
   \      0x2BE   0x2005             MOVS     R0,#+5
   \      0x2C0   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1647                    break;
   \      0x2C4   0xE7FF             B.N      ??rs485SemMsgProcess_31
   1648          
   1649                  default:
   1650                    break;
   1651          
   1652                }
   1653                break;
   \                     ??rs485SemMsgProcess_11: (+1)
   \                     ??rs485SemMsgProcess_31: (+1)
   \      0x2C6   0xE037             B.N      ??rs485SemMsgProcess_7
   1654          
   1655              case RS485_SEM_ACK_WAITING_WR:
   1656              case RS485_SEM_ACK_WAITING_RD:
   1657                switch (pMsg->sbcSemEvent)
   \                     ??rs485SemMsgProcess_5: (+1)
   \      0x2C8   0x8820             LDRH     R0,[R4, #+0]
   \      0x2CA   0x2805             CMP      R0,#+5
   \      0x2CC   0xD02F             BEQ.N    ??rs485SemMsgProcess_37
   \      0x2CE   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x2D2   0x4288             CMP      R0,R1
   \      0x2D4   0xD12F             BNE.N    ??rs485SemMsgProcess_38
   1658                {
   1659                  case SBC_SEM_TIMEOUT:
   1660                    /* no answer. Take here some action to recover the error */
   1661                    if (rs485SemInfoMng.numRetry >= NUM_TRANS_RETRY)
   \                     ??rs485SemMsgProcess_39: (+1)
   \      0x2D6   0xF8BB 0x0013      LDRH     R0,[R11, #+19]
   \      0x2DA   0x2802             CMP      R0,#+2
   \      0x2DC   0xDB06             BLT.N    ??rs485SemMsgProcess_40
   1662                    {
   1663                      rs485SemInfoMng.numRetry = (uint16_t)0;
   \      0x2DE   0x2000             MOVS     R0,#+0
   \      0x2E0   0xF8AB 0x0013      STRH     R0,[R11, #+19]
   1664                      rs485SemInfoMng.rs485SemStates = RS485_SEM_OPERATIVE;
   \      0x2E4   0x2001             MOVS     R0,#+1
   \      0x2E6   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   \      0x2EA   0xE01F             B.N      ??rs485SemMsgProcess_41
   1665                    }
   1666                    else
   1667                    {
   1668                      /* no ACK received, so retry the transmission */
   1669                      rs485SemInfoMng.numRetry++;
   \                     ??rs485SemMsgProcess_40: (+1)
   \      0x2EC   0xF8BB 0x0013      LDRH     R0,[R11, #+19]
   \      0x2F0   0x1C40             ADDS     R0,R0,#+1
   \      0x2F2   0xF8AB 0x0013      STRH     R0,[R11, #+19]
   1670                      if (rs485SemInfoMng.rs485SemStates == RS485_SEM_ACK_WAITING_WR)
   \      0x2F6   0xF8BB 0x0000      LDRH     R0,[R11, #+0]
   \      0x2FA   0x2804             CMP      R0,#+4
   \      0x2FC   0xD106             BNE.N    ??rs485SemMsgProcess_42
   1671                      {
   1672                        writeMasterModbusRegister(rs485SemInfoMng.pOriginData, &rs485SemInfoMng.rs485RWmR);
   \      0x2FE   0xF8DB 0x0002      LDR      R0,[R11, #+2]
   \      0x302   0xF11B 0x0106      ADDS     R1,R11,#+6
   \      0x306   0x.... 0x....      BL       writeMasterModbusRegister
   \      0x30A   0xE003             B.N      ??rs485SemMsgProcess_43
   1673                      }
   1674                      else
   1675                      {
   1676                        readMasterModbusRegister(&rs485SemInfoMng.rs485Rd);
   \                     ??rs485SemMsgProcess_42: (+1)
   \      0x30C   0xF11B 0x000D      ADDS     R0,R11,#+13
   \      0x310   0x.... 0x....      BL       readMasterModbusRegister
   1677                      }
   1678                      tPrintf("Socket %d retrasmission!\n\r", getNumSocketLcd(ixScuLogical));
   \                     ??rs485SemMsgProcess_43: (+1)
   \      0x314   0x0030             MOVS     R0,R6
   \      0x316   0xB2C0             UXTB     R0,R0
   \      0x318   0x.... 0x....      BL       getNumSocketLcd
   \      0x31C   0x0001             MOVS     R1,R0
   \      0x31E   0xB2C9             UXTB     R1,R1
   \      0x320   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \      0x324   0x.... 0x....      BL       tPrintf
   1679                      timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_TRANSMITTER_RESP); 
   \      0x328   0x2064             MOVS     R0,#+100
   \      0x32A   0x0007             MOVS     R7,R0
   1680                    }
   1681                    break;
   \                     ??rs485SemMsgProcess_41: (+1)
   \      0x32C   0xE003             B.N      ??rs485SemMsgProcess_44
   1682          
   1683                  case NOTIFY_MODBUS_ACK:
   1684                    rs485SemInfoMng.rs485SemStates = RS485_SEM_OPERATIVE;
   \                     ??rs485SemMsgProcess_37: (+1)
   \      0x32E   0x2001             MOVS     R0,#+1
   \      0x330   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1685                    break;
   \      0x334   0xE7FF             B.N      ??rs485SemMsgProcess_44
   1686          
   1687                  default:
   1688                    break;
   1689                }
   1690                break;
   \                     ??rs485SemMsgProcess_38: (+1)
   \                     ??rs485SemMsgProcess_44: (+1)
   \      0x336   0xE7FF             B.N      ??rs485SemMsgProcess_7
   1691          
   1692              default:
   1693                break;
   1694            }
   1695          
   1696            return (timeTickTmp);
   \                     ??rs485SemMsgProcess_6: (+1)
   \                     ??rs485SemMsgProcess_7: (+1)
   \      0x338   0x0038             MOVS     R0,R7
   \      0x33A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1697          }
   1698          // --------------------------------------------------------------------------------------------------------------------------- //
   1699          
   1700          /**
   1701          *
   1702          * @brief        Get the pointer to task queue
   1703          *
   1704          * @param [in]   none
   1705          *
   1706          * @retval       xQueueHandle: pointer to defined  queue
   1707          *
   1708          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1709          xQueueHandle getRs485SemQueueHandle(void)
   1710          {
   1711             return(rs485SemQueue);
   \                     getRs485SemQueueHandle: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR
   1712          }
   1713          
   1714          /**
   1715          *
   1716          * @brief        build an async WRMR message to SCU on RS485  
   1717          *
   1718          * @param [in]   scuRWmultipleReg_st* : pointer to struct where is store the message 
   1719          *
   1720          * @retval       none:  
   1721          *
   1722          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1723          static void  writeMasterModbusRegister (uint8_t* pOriginData, headerReqRWMR_st* pScuRWmR)
   1724          {
   \                     writeMasterModbusRegister: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1725            uint8_t*                pEnd;
   1726            rs485RWmultipleReg_st*  pMsg;
   1727            uint8_t*                pMallocTx;
   1728            uint16_t                length;
   1729            crcMode_u               crc;
   1730          
   1731            pMallocTx = (uint8_t*)malloc(sizeof(headerReqRWMR_st) + pScuRWmR->numBytes + (uint16_t)sizeof(crc)); // remember + 2 for checksum 
   \        0x8   0x79A8             LDRB     R0,[R5, #+6]
   \        0xA   0x3009             ADDS     R0,R0,#+9
   \        0xC   0x.... 0x....      BL       malloc
   \       0x10   0x0007             MOVS     R7,R0
   1732            pMsg = (rs485RWmultipleReg_st*)pMallocTx;
   \       0x12   0x003E             MOVS     R6,R7
   1733            /* the command must be executed    */
   1734            length = (uint16_t)sizeof(headerReqRWMR_st) + pScuRWmR->numBytes;
   \       0x14   0xF895 0x8006      LDRB     R8,[R5, #+6]
   \       0x18   0xF118 0x0807      ADDS     R8,R8,#+7
   1735            pMsg->unitId = pScuRWmR->unitId; 
   \       0x1C   0x7828             LDRB     R0,[R5, #+0]
   \       0x1E   0x7030             STRB     R0,[R6, #+0]
   1736            pMsg->function = FUNCTION_WRITE_MULTIPLE_REG;
   \       0x20   0x2010             MOVS     R0,#+16
   \       0x22   0x7070             STRB     R0,[R6, #+1]
   1737            pMsg->regAdd = swapW(pScuRWmR->regAdd);
   \       0x24   0x8868             LDRH     R0,[R5, #+2]
   \       0x26   0x.... 0x....      BL       swapW
   \       0x2A   0x8070             STRH     R0,[R6, #+2]
   1738            pScuRWmR->numWords = pScuRWmR->numBytes / 2;
   \       0x2C   0x79A8             LDRB     R0,[R5, #+6]
   \       0x2E   0x2102             MOVS     R1,#+2
   \       0x30   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \       0x34   0x80A8             STRH     R0,[R5, #+4]
   1739            pMsg->numWords = swapW(pScuRWmR->numWords);
   \       0x36   0x88A8             LDRH     R0,[R5, #+4]
   \       0x38   0x.... 0x....      BL       swapW
   \       0x3C   0x80B0             STRH     R0,[R6, #+4]
   1740            pMsg->numBytes = pScuRWmR->numBytes;
   \       0x3E   0x79A8             LDRB     R0,[R5, #+6]
   \       0x40   0x71B0             STRB     R0,[R6, #+6]
   1741          
   1742            /*      destination               source          length */
   1743            memcpy((void*)pMsg->data, (void*)pOriginData, (size_t)pScuRWmR->numBytes);
   \       0x42   0xF895 0xA006      LDRB     R10,[R5, #+6]
   \       0x46   0x46A3             MOV      R11,R4
   \       0x48   0xF116 0x0907      ADDS     R9,R6,#+7
   \       0x4C   0x4652             MOV      R2,R10
   \       0x4E   0x4659             MOV      R1,R11
   \       0x50   0x4648             MOV      R0,R9
   \       0x52   0x.... 0x....      BL       __aeabi_memcpy
   1744            
   1745            /* now found the CRC message */
   1746            crc.crcW = crcEvaluation ((uint8_t*)pMsg, length);
   \       0x56   0x4641             MOV      R1,R8
   \       0x58   0xB289             UXTH     R1,R1
   \       0x5A   0x0030             MOVS     R0,R6
   \       0x5C   0x.... 0x....      BL       crcEvaluation
   \       0x60   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1747            /* position pEnd pointer on crc field */
   1748            pEnd =  (uint8_t*)((uint32_t)pMsg + (uint32_t)length);
   \       0x64   0xFA16 0xF088      UXTAH    R0,R6,R8
   1749            *pEnd = crc.crcLH_st.crcL;
   \       0x68   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x6C   0x7001             STRB     R1,[R0, #+0]
   1750            pEnd++;
   \       0x6E   0xF110 0x0901      ADDS     R9,R0,#+1
   1751            *pEnd = crc.crcLH_st.crcH;
   \       0x72   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x76   0xF889 0x0000      STRB     R0,[R9, #+0]
   1752            length += sizeof(crc.crcW);
   \       0x7A   0xF118 0x0802      ADDS     R8,R8,#+2
   1753          
   1754            if (xSemaphoreTake(getScuSinapsiTxUartSemaphoreHandle(), portMAX_DELAY) == pdTRUE)
   \       0x7E   0x.... 0x....      BL       getScuSinapsiTxUartSemaphoreHandle
   \       0x82   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0x86   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x8A   0x2801             CMP      R0,#+1
   \       0x8C   0xD107             BNE.N    ??writeMasterModbusRegister_0
   1755            {
   1756              setMallocTx485(pMallocTx);
   \       0x8E   0x0038             MOVS     R0,R7
   \       0x90   0x.... 0x....      BL       setMallocTx485
   1757              /* start transmission on UART RS485 to SCU RS485 Bus using DMA */
   1758              txOnRs485Bus((uint8_t*)pMsg, (uint16_t)length); 
   \       0x94   0x4641             MOV      R1,R8
   \       0x96   0xB289             UXTH     R1,R1
   \       0x98   0x0030             MOVS     R0,R6
   \       0x9A   0x.... 0x....      BL       txOnRs485Bus
   1759            }
   1760          }
   \                     ??writeMasterModbusRegister_0: (+1)
   \       0x9E   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}
   1761          
   1762          /**
   1763          *
   1764          * @brief        build an async RIR message to slave on RS485  
   1765          *
   1766          * @param [in]   headerRHR_t* : pointer to struct where is stored the read info 
   1767          *
   1768          * @retval       none:  
   1769          *
   1770          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1771          static void  readMasterModbusRegister (headerRHR_t* pScuRIR)
   1772          {
   \                     readMasterModbusRegister: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   1773            uint8_t*                pEnd;
   1774            headerRHR_t*            pMsg;
   1775            uint8_t*                pMallocTx;
   1776            uint16_t                length;
   1777            crcMode_u               crc;
   1778          
   1779            pMallocTx = (uint8_t*)malloc(sizeof(headerRHR_t) + (uint16_t)sizeof(crc)); // remember + 2 for checksum 
   \        0x6   0x2008             MOVS     R0,#+8
   \        0x8   0x.... 0x....      BL       malloc
   \        0xC   0x0006             MOVS     R6,R0
   1780            pMsg = (headerRHR_t*)pMallocTx;
   \        0xE   0x0035             MOVS     R5,R6
   1781            /* the command must be executed    */
   1782            length = (uint16_t)sizeof(headerRHR_t);
   \       0x10   0x2706             MOVS     R7,#+6
   1783            pMsg->unitId = pScuRIR->unitId; 
   \       0x12   0x7820             LDRB     R0,[R4, #+0]
   \       0x14   0x7028             STRB     R0,[R5, #+0]
   1784            pMsg->function = FUNCTION_READ_INPUT_REG;
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0x7068             STRB     R0,[R5, #+1]
   1785            pMsg->regAdd = swapW(pScuRIR->regAdd);
   \       0x1A   0x8860             LDRH     R0,[R4, #+2]
   \       0x1C   0x.... 0x....      BL       swapW
   \       0x20   0x8068             STRH     R0,[R5, #+2]
   1786            pMsg->numBytes = swapW(pScuRIR->numBytes);
   \       0x22   0x88A0             LDRH     R0,[R4, #+4]
   \       0x24   0x.... 0x....      BL       swapW
   \       0x28   0x80A8             STRH     R0,[R5, #+4]
   1787          
   1788            /* now found the CRC message */
   1789            crc.crcW = crcEvaluation ((uint8_t*)pMsg, length);
   \       0x2A   0x0039             MOVS     R1,R7
   \       0x2C   0xB289             UXTH     R1,R1
   \       0x2E   0x0028             MOVS     R0,R5
   \       0x30   0x.... 0x....      BL       crcEvaluation
   \       0x34   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1790            /* position pEnd pointer on crc field */
   1791            pEnd =  (uint8_t*)((uint32_t)pMsg + (uint32_t)length);
   \       0x38   0xFA15 0xF087      UXTAH    R0,R5,R7
   1792            *pEnd = crc.crcLH_st.crcL;
   \       0x3C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x40   0x7001             STRB     R1,[R0, #+0]
   1793            pEnd++;
   \       0x42   0xF110 0x0801      ADDS     R8,R0,#+1
   1794            *pEnd = crc.crcLH_st.crcH;
   \       0x46   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x4A   0xF888 0x0000      STRB     R0,[R8, #+0]
   1795            length += sizeof(crc.crcW);
   \       0x4E   0x1CBF             ADDS     R7,R7,#+2
   1796          
   1797            if (xSemaphoreTake(getScuSinapsiTxUartSemaphoreHandle(), portMAX_DELAY) == pdTRUE)
   \       0x50   0x.... 0x....      BL       getScuSinapsiTxUartSemaphoreHandle
   \       0x54   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0x58   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x5C   0x2801             CMP      R0,#+1
   \       0x5E   0xD107             BNE.N    ??readMasterModbusRegister_0
   1798            {
   1799              setMallocTx485(pMallocTx);
   \       0x60   0x0030             MOVS     R0,R6
   \       0x62   0x.... 0x....      BL       setMallocTx485
   1800              /* start transmission on UART RS485 to SCU RS485 Bus using DMA */
   1801              txOnRs485Bus((uint8_t*)pMsg, (uint16_t)length); 
   \       0x66   0x0039             MOVS     R1,R7
   \       0x68   0xB289             UXTH     R1,R1
   \       0x6A   0x0028             MOVS     R0,R5
   \       0x6C   0x.... 0x....      BL       txOnRs485Bus
   1802            }
   1803          }
   \                     ??readMasterModbusRegister_0: (+1)
   \       0x70   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}
   1804          
   1805          /**
   1806          *
   1807          * @brief       get info from a socket 
   1808          *
   1809          * @param [in]  uint32_t : mask bit for the socket    
   1810          * @param [in]  sbcSemInfoMng_st* : info for discovery    
   1811          *  
   1812          * @retval      uint8_t: TRUE, more slave must be checked; FALSE 
   1813          *              end procedure 
   1814          *  
   1815          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1816          static uint8_t getInfoSocket(uint32_t presenceMask, sbcSemInfoMng_st* pInfo) 
   1817          {
   \                     getInfoSocket: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   1818            uint32_t              result;
   1819            frameSbcSem_st        tmpFrameSbcSem;
   1820            scuRwMapRegister_st*  pRwRegs;
   1821            scuRoMapRegister_st*  pRoRegs; 
   1822            tmMapRegister_st*     pTmRegs;
   1823          
   1824            if (pInfo->logicIdSocket >= SCU_NUM) return(FALSE);
   \        0xA   0x8930             LDRH     R0,[R6, #+8]
   \        0xC   0x2810             CMP      R0,#+16
   \        0xE   0xDB01             BLT.N    ??getInfoSocket_0
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE12C             B.N      ??getInfoSocket_1
   1825          
   1826            pRwRegs = getRwMdbRegs(pInfo->logicIdSocket);
   \                     ??getInfoSocket_0: (+1)
   \       0x14   0x8930             LDRH     R0,[R6, #+8]
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x.... 0x....      BL       getRwMdbRegs
   \       0x1C   0x0007             MOVS     R7,R0
   1827            pRoRegs = getRoMdbRegs(pInfo->logicIdSocket);
   \       0x1E   0x8930             LDRH     R0,[R6, #+8]
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x.... 0x....      BL       getRoMdbRegs
   \       0x26   0x4680             MOV      R8,R0
   1828          
   1829            do
   1830            {
   1831              result = presenceMask & pInfo->discoveryMask;
   \                     ??getInfoSocket_2: (+1)
   \       0x28   0xF8D6 0x000A      LDR      R0,[R6, #+10]
   \       0x2C   0x4028             ANDS     R0,R0,R5
   \       0x2E   0x0004             MOVS     R4,R0
   1832              if ((result) != (uint32_t)0)
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xF000 0x80FE      BEQ.W    ??getInfoSocket_3
   1833              {
   1834                /* the socket with this mask is present */
   1835                switch (pInfo->addrVal)
   \       0x36   0x88F0             LDRH     R0,[R6, #+6]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD06B             BEQ.N    ??getInfoSocket_4
   \       0x3C   0xF5B0 0x7F40      CMP      R0,#+768
   \       0x40   0xD00D             BEQ.N    ??getInfoSocket_5
   \       0x42   0xF240 0x4104      MOVW     R1,#+1028
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xF000 0x8090      BEQ.W    ??getInfoSocket_6
   \       0x4C   0xF240 0x5123      MOVW     R1,#+1315
   \       0x50   0x4288             CMP      R0,R1
   \       0x52   0xF000 0x80BA      BEQ.W    ??getInfoSocket_7
   \       0x56   0xF5B0 0x6FC0      CMP      R0,#+1536
   \       0x5A   0xD02D             BEQ.N    ??getInfoSocket_8
   \       0x5C   0xE0FB             B.N      ??getInfoSocket_9
   1836                {
   1837                  case ADDR_START_RDD:
   1838                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_RX;
   \                     ??getInfoSocket_5: (+1)
   \       0x5E   0x2006             MOVS     R0,#+6
   \       0x60   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1839                    tmpFrameSbcSem.data.index = pInfo->logicIdSocket + 1; // physical address 1...16 
   \       0x64   0x8930             LDRH     R0,[R6, #+8]
   \       0x66   0x1C40             ADDS     R0,R0,#+1
   \       0x68   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1840                    tmpFrameSbcSem.data.rAddr = ADDR_START_RDD;
   \       0x6C   0xF44F 0x7040      MOV      R0,#+768
   \       0x70   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1841                    pInfo->pDataRd = (uint8_t*)&pRoRegs->scuMapRegInfoVer;
   \       0x74   0xF8C6 0x800E      STR      R8,[R6, #+14]
   1842                    tmpFrameSbcSem.dataToSend.len = (uint16_t)(ADDR_SCU_RESERVED1 - ADDR_START_RDD);  /* richiedo la lettura di tutta la remote inventory: versione FW, SN, ... */
   \       0x78   0x207B             MOVS     R0,#+123
   \       0x7A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1843                    pInfo->dataVal = tmpFrameSbcSem.dataToSend.len * 2;  // lenght in bytes 
   \       0x7E   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \       0x82   0xB280             UXTH     R0,R0
   \       0x84   0x0040             LSLS     R0,R0,#+1
   \       0x86   0x80B0             STRH     R0,[R6, #+4]
   1844                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \       0x88   0x.... 0x....      BL       getRs485SemQueueHandle
   \       0x8C   0x2300             MOVS     R3,#+0
   \       0x8E   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x92   0x4669             MOV      R1,SP
   \       0x94   0x.... 0x....      BL       xQueueGenericSend
   \       0x98   0x2801             CMP      R0,#+1
   \       0x9A   0xD009             BEQ.N    ??getInfoSocket_10
   \       0x9C   0xB672             CPSID    I
   \       0x9E   0x2050             MOVS     R0,#+80
   \       0xA0   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xA4   0xF3BF 0x8F4F      DSB      SY
   \       0xA8   0xF3BF 0x8F6F      ISB      SY
   \       0xAC   0xB662             CPSIE    I
   \                     ??getInfoSocket_11: (+1)
   \       0xAE   0xE7FE             B.N      ??getInfoSocket_11
   1845                    /* point to next info to request  */
   1846                    pInfo->addrVal = ADDR_EVSE_EVENT_FLAGS_RO;
   \                     ??getInfoSocket_10: (+1)
   \       0xB0   0xF44F 0x60C0      MOV      R0,#+1536
   \       0xB4   0x80F0             STRH     R0,[R6, #+6]
   1847                    break;
   \       0xB6   0xE0CE             B.N      ??getInfoSocket_9
   1848          
   1849                  case ADDR_EVSE_EVENT_FLAGS_RO:
   1850                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_RX;
   \                     ??getInfoSocket_8: (+1)
   \       0xB8   0x2006             MOVS     R0,#+6
   \       0xBA   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1851                    tmpFrameSbcSem.data.index = pInfo->logicIdSocket + 1;  // physical address 1...16 
   \       0xBE   0x8930             LDRH     R0,[R6, #+8]
   \       0xC0   0x1C40             ADDS     R0,R0,#+1
   \       0xC2   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1852                    tmpFrameSbcSem.data.rAddr = ADDR_EVSE_EVENT_FLAGS_RO;
   \       0xC6   0xF44F 0x60C0      MOV      R0,#+1536
   \       0xCA   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1853                    pInfo->pDataRd = (uint8_t*)&pRoRegs->scuMapRegStatusMeas;
   \       0xCE   0xF518 0x7091      ADDS     R0,R8,#+290
   \       0xD2   0xF8C6 0x000E      STR      R0,[R6, #+14]
   1854                    tmpFrameSbcSem.dataToSend.len = (uint16_t)(ADDR_SCU_RESERVED6B - ADDR_EVSE_EVENT_FLAGS_RO);  /* richiedo la lettura dello stato di tutti gli eventi */
   \       0xD6   0x206A             MOVS     R0,#+106
   \       0xD8   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1855                    pInfo->dataVal = tmpFrameSbcSem.dataToSend.len * 2;  // lenght in bytes  
   \       0xDC   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \       0xE0   0xB280             UXTH     R0,R0
   \       0xE2   0x0040             LSLS     R0,R0,#+1
   \       0xE4   0x80B0             STRH     R0,[R6, #+4]
   1856                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \       0xE6   0x.... 0x....      BL       getRs485SemQueueHandle
   \       0xEA   0x2300             MOVS     R3,#+0
   \       0xEC   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0xF0   0x4669             MOV      R1,SP
   \       0xF2   0x.... 0x....      BL       xQueueGenericSend
   \       0xF6   0x2801             CMP      R0,#+1
   \       0xF8   0xD009             BEQ.N    ??getInfoSocket_12
   \       0xFA   0xB672             CPSID    I
   \       0xFC   0x2050             MOVS     R0,#+80
   \       0xFE   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x102   0xF3BF 0x8F4F      DSB      SY
   \      0x106   0xF3BF 0x8F6F      ISB      SY
   \      0x10A   0xB662             CPSIE    I
   \                     ??getInfoSocket_13: (+1)
   \      0x10C   0xE7FE             B.N      ??getInfoSocket_13
   1857                    /* point to next info to request  */
   1858                    pInfo->addrVal = ADDR_CONNECTOR_TYPE_RW;
   \                     ??getInfoSocket_12: (+1)
   \      0x10E   0x2000             MOVS     R0,#+0
   \      0x110   0x80F0             STRH     R0,[R6, #+6]
   1859                    break;
   \      0x112   0xE0A0             B.N      ??getInfoSocket_9
   1860          
   1861                  case ADDR_CONNECTOR_TYPE_RW:
   1862                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_RX;
   \                     ??getInfoSocket_4: (+1)
   \      0x114   0x2006             MOVS     R0,#+6
   \      0x116   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1863                    tmpFrameSbcSem.data.index = pInfo->logicIdSocket + 1;   // physical address 1...16 
   \      0x11A   0x8930             LDRH     R0,[R6, #+8]
   \      0x11C   0x1C40             ADDS     R0,R0,#+1
   \      0x11E   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1864                    tmpFrameSbcSem.data.rAddr = ADDR_CONNECTOR_TYPE_RW;
   \      0x122   0x2000             MOVS     R0,#+0
   \      0x124   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1865                    pInfo->pDataRd = (uint8_t*)&pRwRegs->scuSetRegister;
   \      0x128   0xF8C6 0x700E      STR      R7,[R6, #+14]
   1866                    tmpFrameSbcSem.dataToSend.len = (uint16_t)(ADDR_RESERVED_A - ADDR_CONNECTOR_TYPE_RW);  /* richiedo la lettura delle configurazioni  */
   \      0x12C   0x2069             MOVS     R0,#+105
   \      0x12E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1867                    pInfo->dataVal = tmpFrameSbcSem.dataToSend.len * 2;  // lenght in bytes 
   \      0x132   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x136   0xB280             UXTH     R0,R0
   \      0x138   0x0040             LSLS     R0,R0,#+1
   \      0x13A   0x80B0             STRH     R0,[R6, #+4]
   1868                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x13C   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x140   0x2300             MOVS     R3,#+0
   \      0x142   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x146   0x4669             MOV      R1,SP
   \      0x148   0x.... 0x....      BL       xQueueGenericSend
   \      0x14C   0x2801             CMP      R0,#+1
   \      0x14E   0xD009             BEQ.N    ??getInfoSocket_14
   \      0x150   0xB672             CPSID    I
   \      0x152   0x2050             MOVS     R0,#+80
   \      0x154   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x158   0xF3BF 0x8F4F      DSB      SY
   \      0x15C   0xF3BF 0x8F6F      ISB      SY
   \      0x160   0xB662             CPSIE    I
   \                     ??getInfoSocket_15: (+1)
   \      0x162   0xE7FE             B.N      ??getInfoSocket_15
   1869                    /* point to next info to request  */
   1870                    pInfo->addrVal = ADDR_EVSE_ERROR1_RO;
   \                     ??getInfoSocket_14: (+1)
   \      0x164   0xF240 0x4004      MOVW     R0,#+1028
   \      0x168   0x80F0             STRH     R0,[R6, #+6]
   1871                    break;
   \      0x16A   0xE074             B.N      ??getInfoSocket_9
   1872          
   1873                  case ADDR_EVSE_ERROR1_RO:
   1874                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_RX;
   \                     ??getInfoSocket_6: (+1)
   \      0x16C   0x2006             MOVS     R0,#+6
   \      0x16E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1875                    tmpFrameSbcSem.data.index = pInfo->logicIdSocket + 1;   // physical address 1...16 
   \      0x172   0x8930             LDRH     R0,[R6, #+8]
   \      0x174   0x1C40             ADDS     R0,R0,#+1
   \      0x176   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1876                    tmpFrameSbcSem.data.rAddr = ADDR_EVSE_ERROR1_RO;
   \      0x17A   0xF240 0x4004      MOVW     R0,#+1028
   \      0x17E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1877                    pInfo->pDataRd = (uint8_t*)&pRoRegs->scuMapRegNotify.ntfErr1;
   \      0x182   0xF118 0x00FE      ADDS     R0,R8,#+254
   \      0x186   0xF8C6 0x000E      STR      R0,[R6, #+14]
   1878                    tmpFrameSbcSem.dataToSend.len = (uint16_t)(ADDR_EVSE_CHANGE_REGISTERS_RO  - ADDR_EVSE_ERROR1_RO);  /* richiedo la lettura degli errori  */
   \      0x18A   0x2002             MOVS     R0,#+2
   \      0x18C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1879                    pInfo->dataVal = tmpFrameSbcSem.dataToSend.len * 2;  // lenght in bytes 
   \      0x190   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x194   0xB280             UXTH     R0,R0
   \      0x196   0x0040             LSLS     R0,R0,#+1
   \      0x198   0x80B0             STRH     R0,[R6, #+4]
   1880                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x19A   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x19E   0x2300             MOVS     R3,#+0
   \      0x1A0   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x1A4   0x4669             MOV      R1,SP
   \      0x1A6   0x.... 0x....      BL       xQueueGenericSend
   \      0x1AA   0x2801             CMP      R0,#+1
   \      0x1AC   0xD009             BEQ.N    ??getInfoSocket_16
   \      0x1AE   0xB672             CPSID    I
   \      0x1B0   0x2050             MOVS     R0,#+80
   \      0x1B2   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x1B6   0xF3BF 0x8F4F      DSB      SY
   \      0x1BA   0xF3BF 0x8F6F      ISB      SY
   \      0x1BE   0xB662             CPSIE    I
   \                     ??getInfoSocket_17: (+1)
   \      0x1C0   0xE7FE             B.N      ??getInfoSocket_17
   1881          #if BOARD_REPAIR
   1882                    if ((pInfo->discoveryMask & pInfo->infoEepromSlaveToDo) == 0)
   1883                    {
   1884                      /* point to next possible slave */
   1885                      pInfo->addrVal = ADDR_START_RDD;
   1886                    }
   1887                    else
   1888                    {
   1889                      /* eeprom info parameter must be reuired to the slave */
   1890                      pInfo->addrVal = ADDR_GET_EEPROM_RW;
   1891                      /* reset the flag: only one time the request must be performed */
   1892                      pInfo->infoEepromSlaveToDo &= (~pInfo->discoveryMask);
   1893                    }
   1894          #else
   1895                    /* point to next possible slave */
   1896                    pInfo->addrVal = ADDR_START_RDD;
   \                     ??getInfoSocket_16: (+1)
   \      0x1C2   0xF44F 0x7040      MOV      R0,#+768
   \      0x1C6   0x80F0             STRH     R0,[R6, #+6]
   1897          #endif
   1898                    break;
   \      0x1C8   0xE045             B.N      ??getInfoSocket_9
   1899          
   1900                  case ADDR_GET_EEPROM_RW:
   1901                    pTmRegs = getTmMdbRegs(pInfo->logicIdSocket);
   \                     ??getInfoSocket_7: (+1)
   \      0x1CA   0x8930             LDRH     R0,[R6, #+8]
   \      0x1CC   0xB2C0             UXTB     R0,R0
   \      0x1CE   0x.... 0x....      BL       getTmMdbRegs
   \      0x1D2   0x4681             MOV      R9,R0
   1902                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_RX;
   \      0x1D4   0x2006             MOVS     R0,#+6
   \      0x1D6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1903                    tmpFrameSbcSem.data.index = pInfo->logicIdSocket + 1;   // physical address 1...16 
   \      0x1DA   0x8930             LDRH     R0,[R6, #+8]
   \      0x1DC   0x1C40             ADDS     R0,R0,#+1
   \      0x1DE   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1904                    tmpFrameSbcSem.data.rAddr = ADDR_GET_EEPROM_RW;
   \      0x1E2   0xF240 0x5023      MOVW     R0,#+1315
   \      0x1E6   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1905                    pInfo->pDataRd = (uint8_t*)&pTmRegs->tmGetEeprom;  
   \      0x1EA   0xF119 0x0026      ADDS     R0,R9,#+38
   \      0x1EE   0xF8C6 0x000E      STR      R0,[R6, #+14]
   1906                    tmpFrameSbcSem.dataToSend.len = (uint16_t)(LEN_TM_GET_EEPROM_RW);  /* richiedo la lettura della EEPROM  */
   \      0x1F2   0x2001             MOVS     R0,#+1
   \      0x1F4   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1907                    pInfo->dataVal = tmpFrameSbcSem.dataToSend.len * 2;  // lenght in bytes 
   \      0x1F8   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x1FC   0xB280             UXTH     R0,R0
   \      0x1FE   0x0040             LSLS     R0,R0,#+1
   \      0x200   0x80B0             STRH     R0,[R6, #+4]
   1908                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x202   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x206   0x2300             MOVS     R3,#+0
   \      0x208   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x20C   0x4669             MOV      R1,SP
   \      0x20E   0x.... 0x....      BL       xQueueGenericSend
   \      0x212   0x2801             CMP      R0,#+1
   \      0x214   0xD009             BEQ.N    ??getInfoSocket_18
   \      0x216   0xB672             CPSID    I
   \      0x218   0x2050             MOVS     R0,#+80
   \      0x21A   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x21E   0xF3BF 0x8F4F      DSB      SY
   \      0x222   0xF3BF 0x8F6F      ISB      SY
   \      0x226   0xB662             CPSIE    I
   \                     ??getInfoSocket_19: (+1)
   \      0x228   0xE7FE             B.N      ??getInfoSocket_19
   1909                    /* point to next possible slave */
   1910                    pInfo->addrVal = ADDR_START_RDD;
   \                     ??getInfoSocket_18: (+1)
   \      0x22A   0xF44F 0x7040      MOV      R0,#+768
   \      0x22E   0x80F0             STRH     R0,[R6, #+6]
   1911                    break;
   \      0x230   0xE011             B.N      ??getInfoSocket_9
   1912                }
   1913              }
   1914              else
   1915              {
   1916                pInfo->discoveryMask = pInfo->discoveryMask << 1;
   \                     ??getInfoSocket_3: (+1)
   \      0x232   0xF8D6 0x000A      LDR      R0,[R6, #+10]
   \      0x236   0x0040             LSLS     R0,R0,#+1
   \      0x238   0xF8C6 0x000A      STR      R0,[R6, #+10]
   1917                pInfo->logicIdSocket++;
   \      0x23C   0x8930             LDRH     R0,[R6, #+8]
   \      0x23E   0x1C40             ADDS     R0,R0,#+1
   \      0x240   0x8130             STRH     R0,[R6, #+8]
   1918                pRwRegs = getRwMdbRegs(pInfo->logicIdSocket);
   \      0x242   0x8930             LDRH     R0,[R6, #+8]
   \      0x244   0xB2C0             UXTB     R0,R0
   \      0x246   0x.... 0x....      BL       getRwMdbRegs
   \      0x24A   0x0007             MOVS     R7,R0
   1919                pRoRegs = getRoMdbRegs(pInfo->logicIdSocket);
   \      0x24C   0x8930             LDRH     R0,[R6, #+8]
   \      0x24E   0xB2C0             UXTB     R0,R0
   \      0x250   0x.... 0x....      BL       getRoMdbRegs
   \      0x254   0x4680             MOV      R8,R0
   1920              }
   1921            }while ((result == (uint32_t)0) && (pInfo->logicIdSocket < SCU_NUM));
   \                     ??getInfoSocket_9: (+1)
   \      0x256   0x2C00             CMP      R4,#+0
   \      0x258   0xD103             BNE.N    ??getInfoSocket_20
   \      0x25A   0x8930             LDRH     R0,[R6, #+8]
   \      0x25C   0x2810             CMP      R0,#+16
   \      0x25E   0xF6FF 0xAEE3      BLT.W    ??getInfoSocket_2
   1922          
   1923            if (pInfo->logicIdSocket >= SCU_NUM) return(FALSE); else return(TRUE);
   \                     ??getInfoSocket_20: (+1)
   \      0x262   0x8930             LDRH     R0,[R6, #+8]
   \      0x264   0x2810             CMP      R0,#+16
   \      0x266   0xDB01             BLT.N    ??getInfoSocket_21
   \      0x268   0x2000             MOVS     R0,#+0
   \      0x26A   0xE000             B.N      ??getInfoSocket_1
   \                     ??getInfoSocket_21: (+1)
   \      0x26C   0x2001             MOVS     R0,#+1
   \                     ??getInfoSocket_1: (+1)
   \      0x26E   0xB005             ADD      SP,SP,#+20
   \      0x270   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1924          
   1925          }
   1926          
   1927          /**
   1928          *
   1929          * @brief       get info on RS485 transmission status  
   1930          *
   1931          * @param [in]  uint32_t : mask bit for the socket    
   1932          * @param [in]  sbcSemInfoMng_st* : info for discovery    
   1933          *  
   1934          * @retval      uint8_t: TRUE transmission complete (Tx + ACK) 
   1935          *  
   1936          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1937          uint8_t txRS485Available(void) 
   1938          {
   1939            if (rs485SemInfoMng.rs485SemStates == RS485_SEM_OPERATIVE) return(TRUE); else return(FALSE);
   \                     txRS485Available: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \        0x4   0x8800             LDRH     R0,[R0, #+0]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??txRS485Available_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??txRS485Available_1
   \                     ??txRS485Available_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??txRS485Available_1: (+1)
   \       0x10   0x4770             BX       LR
   1940          }
   1941          
   1942          /**
   1943          *
   1944          * @brief       Actuators_Mdb_to_Eeprom_Translate translate modbus to
   1945          *              Eeprom codification
   1946          *           
   1947          * @param [in]  pointer to the variable to change
   1948          *  
   1949          * @retval      None
   1950          *  
   1951          ****************************************************************/
   1952          

   \                                 In section .text, align 2, keep-with-next
   1953          void Actuators_Mdb_to_Eeprom_Translate (uint8_t *ptr)
   1954          {
   \                     Actuators_Mdb_to_Eeprom_Translate: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1955            uint8_t tmp = 0, tmp1 = FALSE;
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1956              
   1957            if((*ptr & ACT_BLCK) == ACT_BLCK)
   \        0xC   0x7820             LDRB     R0,[R4, #+0]
   \        0xE   0x07C0             LSLS     R0,R0,#+31
   \       0x10   0xD501             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_0
   1958            {
   1959              tmp |= BLOCK_ATT0;
   \       0x12   0xF055 0x0508      ORRS     R5,R5,#0x8
   1960            }
   1961            
   1962            if((*ptr & ACT_MIRR) == ACT_MIRR)
   \                     ??Actuators_Mdb_to_Eeprom_Translate_0: (+1)
   \       0x16   0x7820             LDRB     R0,[R4, #+0]
   \       0x18   0x0780             LSLS     R0,R0,#+30
   \       0x1A   0xD501             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_1
   1963            {
   1964              tmp |= CONTACT_ATT0;
   \       0x1C   0xF055 0x0540      ORRS     R5,R5,#0x40
   1965            }
   1966            
   1967            if((*ptr & ACT_RCBO) == ACT_RCBO)
   \                     ??Actuators_Mdb_to_Eeprom_Translate_1: (+1)
   \       0x20   0x7820             LDRB     R0,[R4, #+0]
   \       0x22   0x0740             LSLS     R0,R0,#+29
   \       0x24   0xD501             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_2
   1968            {
   1969              tmp |= RCBO_ATT0;
   \       0x26   0xF055 0x0580      ORRS     R5,R5,#0x80
   1970            }
   1971          
   1972            /* Check if BBCK must be enabled */
   1973            if ((*ptr & ACT_BACK) == ACT_BACK)
   \                     ??Actuators_Mdb_to_Eeprom_Translate_2: (+1)
   \       0x2A   0x7820             LDRB     R0,[R4, #+0]
   \       0x2C   0x06C0             LSLS     R0,R0,#+27
   \       0x2E   0xD504             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_3
   1974            {
   1975              /* Set flag for SEM */
   1976              tmp |= BBCK_ATT0; 
   \       0x30   0xF055 0x0520      ORRS     R5,R5,#0x20
   1977              /* Set backup flag for webUI http */
   1978              tmp1 = TRUE;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1979            }
   1980          
   1981            /* Save Backup flag in eeprom (for webUI http )*/
   1982            eeprom_array_set(BATTERY_CONFIG_EADD, (uint8_t*)&tmp1, 1);    
   \                     ??Actuators_Mdb_to_Eeprom_Translate_3: (+1)
   \       0x3A   0x2201             MOVS     R2,#+1
   \       0x3C   0x4669             MOV      R1,SP
   \       0x3E   0x2007             MOVS     R0,#+7
   \       0x40   0x.... 0x....      BL       eeprom_array_set
   1983            
   1984            /* Get LCD_TYPE address from eeprom, where WIFI_ON is saved */
   1985            eeprom_param_get(LCD_TYPE_EADD, (uint8_t *)&tmp1, 1);
   \       0x44   0x2201             MOVS     R2,#+1
   \       0x46   0x4669             MOV      R1,SP
   \       0x48   0x2034             MOVS     R0,#+52
   \       0x4A   0x.... 0x....      BL       eeprom_param_get
   1986            /* Check if WIFI must be enabled or not */
   1987            if((*ptr & ACT_WIFI) == ACT_WIFI)
   \       0x4E   0x7820             LDRB     R0,[R4, #+0]
   \       0x50   0x0700             LSLS     R0,R0,#+28
   \       0x52   0xD506             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_4
   1988              tmp1 |= WIFI_ON;        /* Enable WIFI */
   \       0x54   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x58   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x5C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x60   0xE005             B.N      ??Actuators_Mdb_to_Eeprom_Translate_5
   1989            else
   1990              tmp1 &= ~WIFI_ON;       /* Disable WIFI */
   \                     ??Actuators_Mdb_to_Eeprom_Translate_4: (+1)
   \       0x62   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x66   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \       0x6A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1991            
   1992            /* Save new configuration */
   1993            
   1994            /*** SAVE ON EEPROM ***/   
   1995            EEPROM_Save_Config (LCD_TYPE_EADD, (uint8_t *)&tmp1, 1);
   \                     ??Actuators_Mdb_to_Eeprom_Translate_5: (+1)
   \       0x6E   0x2201             MOVS     R2,#+1
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0x2034             MOVS     R0,#+52
   \       0x74   0x.... 0x....      BL       EEPROM_Save_Config
   1996            
   1997            /* Get configuration of hw check2 from modbus */ 
   1998            /* P.S --> PAUT in modbus map is inside hw checks settings */
   1999            tmp1 = getHwChecks2();
   \       0x78   0x.... 0x....      BL       getHwChecks2
   \       0x7C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2000          
   2001            /* PAUT enabled? check in modbus map */
   2002            if (tmp1 & PAUT_CRL2)
   \       0x80   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x84   0x0700             LSLS     R0,R0,#+28
   \       0x86   0xD502             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_6
   2003              tmp |= PAUT_ATT0;   /* Set Post authorization mode */
   \       0x88   0xF055 0x0510      ORRS     R5,R5,#0x10
   \       0x8C   0xE001             B.N      ??Actuators_Mdb_to_Eeprom_Translate_7
   2004            else
   2005              tmp &= ~PAUT_ATT0;  /* Reset Post authorization mode */ 
   \                     ??Actuators_Mdb_to_Eeprom_Translate_6: (+1)
   \       0x8E   0xF015 0x05EF      ANDS     R5,R5,#0xEF
   2006            
   2007            *ptr = tmp;
   \                     ??Actuators_Mdb_to_Eeprom_Translate_7: (+1)
   \       0x92   0x7025             STRB     R5,[R4, #+0]
   2008          }
   \       0x94   0xBD31             POP      {R0,R4,R5,PC}
   2009          
   2010          /**
   2011          *
   2012          * @brief       Save HW Checks and Actuators into Eeeprom 
   2013          *              
   2014          *           
   2015          * @param [in]  Modbus address of the register to save
   2016          *  
   2017          * @retval      None
   2018          *  
   2019          ****************************************************************/
   2020          

   \                                 In section .text, align 2, keep-with-next
   2021          void HW_CHECKS_ACTUATORS_EEprom_Save (uint16_t rAddr)
   2022          {
   \                     HW_CHECKS_ACTUATORS_EEprom_Save: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2023            uint8_t   HwCheckTmp, temp8;
   2024            uint16_t  hwCheck;
   2025            static uint8_t   temp[5];
   2026            uint8_t collaudoFlag;
   2027            
   2028            /* Save in EEPROM check flags and actuator presence */
   2029            switch (rAddr)  
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB280             UXTH     R0,R0
   \        0x8   0x2826             CMP      R0,#+38
   \        0xA   0xD004             BEQ.N    ??HW_CHECKS_ACTUATORS_EEprom_Save_0
   \        0xC   0xD34C             BCC.N    ??HW_CHECKS_ACTUATORS_EEprom_Save_1
   \        0xE   0x2828             CMP      R0,#+40
   \       0x10   0xD033             BEQ.N    ??HW_CHECKS_ACTUATORS_EEprom_Save_2
   \       0x12   0xD31C             BCC.N    ??HW_CHECKS_ACTUATORS_EEprom_Save_3
   \       0x14   0xE048             B.N      ??HW_CHECKS_ACTUATORS_EEprom_Save_1
   2030            {
   2031              case ADDR_HW_CHECKS1_RW:                    /* Prepare HW_CHECK1_RW */
   2032                  /* Get configuration from eeprom */
   2033                  eeprom_param_get(CONTROL_BYTE0_EADD, &HwCheckTmp, 1);
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_0: (+1)
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x2010             MOVS     R0,#+16
   \       0x1C   0x.... 0x....      BL       eeprom_param_get
   2034                  /* bit 4 and 5 have a different codification between Modbus map and Eeprom: BLE and WiFi in modbus, 
   2035                     REMOTE and PULS in GSY and WebUI ???) */
   2036                  /* Configuration from EEprom --> Consider bit 4 and 5, used for REMOTE and PULS */
   2037                  HwCheckTmp &= (uint8_t)(REMOTE_CRL0 | PULS_CRL0);  
   \       0x20   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x24   0xF010 0x0030      ANDS     R0,R0,#0x30
   \       0x28   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2038                  /* Get configuration from modbus */
   2039                  hwCheck = getHwChecks1();
   \       0x2C   0x.... 0x....      BL       getHwChecks1
   2040                  /* Clear bit4 and 5, reserved for REMOTE and PULS */
   2041                  hwCheck &= ~(uint8_t)(REMOTE_CRL0 | PULS_CRL0);
   \       0x30   0xF64F 0x71CF      MOVW     R1,#+65487
   \       0x34   0x4008             ANDS     R0,R1,R0
   \       0x36   0x0005             MOVS     R5,R0
   2042                  temp[0] = (uint8_t)hwCheck | HwCheckTmp;  
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x3C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x40   0x4329             ORRS     R1,R1,R5
   \       0x42   0x7001             STRB     R1,[R0, #+0]
   2043                  temp[1] = (uint8_t)(hwCheck >> 8);
   \       0x44   0x0029             MOVS     R1,R5
   \       0x46   0xB289             UXTH     R1,R1
   \       0x48   0x0A09             LSRS     R1,R1,#+8
   \       0x4A   0x7041             STRB     R1,[R0, #+1]
   2044                break;
   \       0x4C   0xE02C             B.N      ??HW_CHECKS_ACTUATORS_EEprom_Save_4
   2045                
   2046              case ADDR_HW_CHECKS2_RW:                   /* Prepare HW_CHECK2_RW */
   2047                  /* Get configuration from modbus */      
   2048                  hwCheck = getHwChecks2();
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_3: (+1)
   \       0x4E   0x.... 0x....      BL       getHwChecks2
   \       0x52   0x0005             MOVS     R5,R0
   2049                  temp[2] = (uint8_t)hwCheck;  
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x58   0x7085             STRB     R5,[R0, #+2]
   2050                  temp[3] = (uint8_t)(hwCheck >> 8);
   \       0x5A   0x0029             MOVS     R1,R5
   \       0x5C   0xB289             UXTH     R1,R1
   \       0x5E   0x0A09             LSRS     R1,R1,#+8
   \       0x60   0x70C1             STRB     R1,[R0, #+3]
   2051                  /* Set HGTP configuration in eeprom for webserver GUI */
   2052                  temp8 = (hwCheck & HGTP_CRL2) >> HGTP_CRL2_bit_pos;        
   \       0x62   0x0028             MOVS     R0,R5
   \       0x64   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \       0x68   0xF88D 0x0001      STRB     R0,[SP, #+1]
   2053                  
   2054                  /*** SAVE ON EEPROM ***/                   
   2055                  EEPROM_Save_Config (TEMP_CTRL_ENB_EADD, &temp8, 1);
   \       0x6C   0x2201             MOVS     R2,#+1
   \       0x6E   0xF10D 0x0101      ADD      R1,SP,#+1
   \       0x72   0x203B             MOVS     R0,#+59
   \       0x74   0x.... 0x....      BL       EEPROM_Save_Config
   2056                break;
   \       0x78   0xE016             B.N      ??HW_CHECKS_ACTUATORS_EEprom_Save_4
   2057                
   2058              case ADDR_HW_ACTUATORS_RW:                /* Prepare HW_ACTUATORS_RW */
   2059                  /* Get actuators from modbus */
   2060                  temp[4] = (uint8_t)getHwActuators();                   
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_2: (+1)
   \       0x7A   0x.... 0x....      LDR.W    R7,??DataTable12
   \       0x7E   0x.... 0x....      BL       getHwActuators
   \       0x82   0x7138             STRB     R0,[R7, #+4]
   2061                  /* Translate actuators informations from modbus format to eeprom format */
   2062                  Actuators_Mdb_to_Eeprom_Translate (&temp[4]);  
   \       0x84   0x1D38             ADDS     R0,R7,#+4
   \       0x86   0x.... 0x....      BL       Actuators_Mdb_to_Eeprom_Translate
   2063                  /* Write settings into eeprom */
   2064                  /*** SAVE ON EEPROM ***/           
   2065                  EEPROM_Save_Config (CONTROL_BYTE0_EADD, (uint8_t *)temp, 5);                                    
   \       0x8A   0x2205             MOVS     R2,#+5
   \       0x8C   0x0039             MOVS     R1,R7
   \       0x8E   0x2010             MOVS     R0,#+16
   \       0x90   0x.... 0x....      BL       EEPROM_Save_Config
   2066          
   2067                  collaudoFlag = getCollaudoRunning();
   \       0x94   0x.... 0x....      BL       getCollaudoRunning
   \       0x98   0x0006             MOVS     R6,R0
   2068                  /* reset immediato  */
   2069                  if(!collaudoFlag)
   \       0x9A   0x0030             MOVS     R0,R6
   \       0x9C   0xB2C0             UXTB     R0,R0
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD101             BNE.N    ??HW_CHECKS_ACTUATORS_EEprom_Save_5
   2070                  {
   2071                    activeImmediateReset(); 
   \       0xA2   0x.... 0x....      BL       activeImmediateReset
   2072                  }
   2073                break;  
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_5: (+1)
   \       0xA6   0xE7FF             B.N      ??HW_CHECKS_ACTUATORS_EEprom_Save_4
   2074                
   2075              default:
   2076                break;
   2077            }
   2078            
   2079          }
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_1: (+1)
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_4: (+1)
   \       0xA8   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .bss, align 4
   \                     `HW_CHECKS_ACTUATORS_EEprom_Save::temp`:
   \        0x0                      DS8 8
   2080          
   2081          /**
   2082          *
   2083          * @brief       Save HW Flags into Eeeprom 
   2084          *              
   2085          *           
   2086          * @param [in]  None
   2087          *  
   2088          * @retval      None
   2089          *  
   2090          ****************************************************************/
   2091          

   \                                 In section .text, align 2, keep-with-next
   2092          void HW_PRESENCE_FLAG_EEprom_Save (void)
   2093          {
   \                     HW_PRESENCE_FLAG_EEprom_Save: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   2094             uint8_t   HwFlagsEeprom;
   2095             uint16_t  temp16;
   2096          
   2097             /* Prepare information to save in Eeprom  according to this codification:
   2098             
   2099              LCD_TYPE_EADDR in Eeprom
   2100          
   2101              Bit 0 --> LCD_ON
   2102              Bit 2 --> WIFI_ON 
   2103              Bit 3 --> DIFF_RIARMABILE
   2104          
   2105             */
   2106             
   2107             temp16 = getHwFlags();
   \        0x2   0x.... 0x....      BL       getHwFlags
   \        0x6   0x0004             MOVS     R4,R0
   2108             eeprom_param_get(LCD_TYPE_EADD, (uint8_t *)&HwFlagsEeprom, 1);
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x2034             MOVS     R0,#+52
   \        0xE   0x.... 0x....      BL       eeprom_param_get
   2109             /* Check Display LCD presence */
   2110             if ((temp16 & DISPLAY_LCD_FLAG) == DISPLAY_LCD_FLAG)
   \       0x12   0x07A0             LSLS     R0,R4,#+30
   \       0x14   0xD506             BPL.N    ??HW_PRESENCE_FLAG_EEprom_Save_0
   2111               HwFlagsEeprom |= LCD_2X20;
   \       0x16   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x1A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x1E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x22   0xE005             B.N      ??HW_PRESENCE_FLAG_EEprom_Save_1
   2112             else 
   2113               HwFlagsEeprom &= ~LCD_2X20;     
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_0: (+1)
   \       0x24   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x28   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \       0x2C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2114             /* Check WIFI module presence */
   2115             if ((temp16 & WIFI_CONNECTION_FLAG) == WIFI_CONNECTION_FLAG)
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_1: (+1)
   \       0x30   0x0720             LSLS     R0,R4,#+28
   \       0x32   0xD506             BPL.N    ??HW_PRESENCE_FLAG_EEprom_Save_2
   2116               HwFlagsEeprom |= WIFI_ON;
   \       0x34   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x38   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x3C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x40   0xE005             B.N      ??HW_PRESENCE_FLAG_EEprom_Save_3
   2117             else
   2118               HwFlagsEeprom &= ~WIFI_ON;     
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_2: (+1)
   \       0x42   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x46   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \       0x4A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2119             /* Check DIFF RIARMABILE module presence */
   2120             if ((temp16 & DIFF_RIARM_FLAG) == DIFF_RIARM_FLAG)
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_3: (+1)
   \       0x4E   0x07E0             LSLS     R0,R4,#+31
   \       0x50   0xD506             BPL.N    ??HW_PRESENCE_FLAG_EEprom_Save_4
   2121               HwFlagsEeprom |= DIRI_ON;           
   \       0x52   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x56   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x5A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x5E   0xE005             B.N      ??HW_PRESENCE_FLAG_EEprom_Save_5
   2122             else
   2123               HwFlagsEeprom &= ~DIRI_ON;                
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_4: (+1)
   \       0x60   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x64   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \       0x68   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2124             /* Write settings into eeprom */   
   2125             /*** SAVE ON EEPROM ***/   
   2126             EEPROM_Save_Config (LCD_TYPE_EADD, (uint8_t *)&HwFlagsEeprom, 1);
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_5: (+1)
   \       0x6C   0x2201             MOVS     R2,#+1
   \       0x6E   0x4669             MOV      R1,SP
   \       0x70   0x2034             MOVS     R0,#+52
   \       0x72   0x.... 0x....      BL       EEPROM_Save_Config
   2127          }
   \       0x76   0xBD13             POP      {R0,R1,R4,PC}
   2128          
   2129          /**
   2130          *
   2131          * @brief       Set new connector ID in conversion matrix
   2132          *              
   2133          *           
   2134          * @param [in]  Connector ID
   2135          *  
   2136          * @retval      None
   2137          *  
   2138          ****************************************************************/
   2139          

   \                                 In section .text, align 2, keep-with-next
   2140          void CONN_ID_Set_New (uint16_t New_Connector_ID)
   2141          {
   \                     CONN_ID_Set_New: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2142            uint8_t  mdbAddr;
   2143            
   2144            /* get address on modbus and relative modbus pointer area   */
   2145            mdbAddr = getLogicalMdbAddrSem();  
   \        0x4   0x.... 0x....      BL       getLogicalMdbAddrSem
   \        0x8   0x0005             MOVS     R5,R0
   2146            /* Set New connector ID in matrix */
   2147            socketPresence.matrixIdConn[mdbAddr] = New_Connector_ID;
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable10_4
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x4408             ADD      R0,R1,R0
   \       0x14   0xF880 0x4030      STRB     R4,[R0, #+48]
   2148            /* Save in eeprom */
   2149            WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t));
   \       0x18   0x2254             MOVS     R2,#+84
   \       0x1A   0xF44F 0x50F4      MOV      R0,#+7808
   \       0x1E   0x.... 0x....      BL       WriteOnEeprom
   2150          }
   \       0x22   0xBD31             POP      {R0,R4,R5,PC}
   2151          
   2152          /**
   2153          *
   2154          * @brief       parser config area to apply the new 
   2155          *              configuration
   2156          *
   2157          * @param [in]  frameSbcSem_st* : pointer to info    
   2158          *  
   2159          * @retval      none 
   2160          *  
   2161          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2162          static void semUpdateConfig(frameSbcSem_st* pMsg) 
   2163          {
   \                     semUpdateConfig: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2164            frameRemote_st  frameRemote;  
   2165            static uint8_t  temp[5];
   2166            uint16_t        temp16;
   2167            uint32_t        temp32;
   2168          
   2169            if (pMsg->data.rAddr <= ADDR_RESERVED_A)
   \        0x4   0x88A0             LDRH     R0,[R4, #+4]
   \        0x6   0x286A             CMP      R0,#+106
   \        0x8   0xF280 0x8199      BGE.W    ??semUpdateConfig_0
   2170            {
   2171                  
   2172              /* we are in configuration parameter area */
   2173              switch (pMsg->data.rAddr)
   \        0xC   0x88A0             LDRH     R0,[R4, #+4]
   \        0xE   0x1E40             SUBS     R0,R0,#+1
   \       0x10   0xF000 0x8129      BEQ.W    ??semUpdateConfig_1
   \       0x14   0x1EC0             SUBS     R0,R0,#+3
   \       0x16   0xF000 0x816F      BEQ.W    ??semUpdateConfig_2
   \       0x1A   0x381F             SUBS     R0,R0,#+31
   \       0x1C   0xF000 0x80DF      BEQ.W    ??semUpdateConfig_3
   \       0x20   0x1E80             SUBS     R0,R0,#+2
   \       0x22   0xF000 0x8123      BEQ.W    ??semUpdateConfig_4
   \       0x26   0x1E40             SUBS     R0,R0,#+1
   \       0x28   0x2802             CMP      R0,#+2
   \       0x2A   0xD923             BLS.N    ??semUpdateConfig_5
   \       0x2C   0x380F             SUBS     R0,R0,#+15
   \       0x2E   0xD05C             BEQ.N    ??semUpdateConfig_6
   \       0x30   0x1F40             SUBS     R0,R0,#+5
   \       0x32   0xF000 0x80FC      BEQ.W    ??semUpdateConfig_7
   \       0x36   0x1E80             SUBS     R0,R0,#+2
   \       0x38   0xF000 0x813C      BEQ.W    ??semUpdateConfig_8
   \       0x3C   0x1E80             SUBS     R0,R0,#+2
   \       0x3E   0xD025             BEQ.N    ??semUpdateConfig_9
   \       0x40   0x1E80             SUBS     R0,R0,#+2
   \       0x42   0xF000 0x813B      BEQ.W    ??semUpdateConfig_10
   \       0x46   0x1E40             SUBS     R0,R0,#+1
   \       0x48   0xF000 0x816C      BEQ.W    ??semUpdateConfig_11
   \       0x4C   0x3819             SUBS     R0,R0,#+25
   \       0x4E   0xF000 0x8116      BEQ.W    ??semUpdateConfig_12
   \       0x52   0x1E80             SUBS     R0,R0,#+2
   \       0x54   0xF000 0x811A      BEQ.W    ??semUpdateConfig_13
   \       0x58   0x1E40             SUBS     R0,R0,#+1
   \       0x5A   0xF000 0x8121      BEQ.W    ??semUpdateConfig_14
   \       0x5E   0x1E40             SUBS     R0,R0,#+1
   \       0x60   0xF000 0x8136      BEQ.W    ??semUpdateConfig_15
   \       0x64   0x1E40             SUBS     R0,R0,#+1
   \       0x66   0xF000 0x813D      BEQ.W    ??semUpdateConfig_16
   \       0x6A   0x1E40             SUBS     R0,R0,#+1
   \       0x6C   0x2805             CMP      R0,#+5
   \       0x6E   0xF240 0x8121      BLS.W    ??semUpdateConfig_8
   \       0x72   0xE164             B.N      ??semUpdateConfig_17
   2174              {
   2175                case ADDR_HW_CHECKS1_RW:
   2176                case ADDR_HW_CHECKS2_RW:
   2177                case ADDR_HW_ACTUATORS_RW:
   2178                  /* Save HW CHECKS and ACTUATORS into EEPROM */
   2179                  HW_CHECKS_ACTUATORS_EEprom_Save(pMsg->data.rAddr);        
   \                     ??semUpdateConfig_5: (+1)
   \       0x74   0x88A0             LDRH     R0,[R4, #+4]
   \       0x76   0x.... 0x....      BL       HW_CHECKS_ACTUATORS_EEprom_Save
   2180                  if (isSemMasterFz() == FALSE) 
   \       0x7A   0x.... 0x....      BL       isSemMasterFz
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD103             BNE.N    ??semUpdateConfig_18
   2181                  {
   2182                    /* the slave must send the change in EEPROM to the master when all 3 regs are written  */
   2183                    restartSbcSemTimer(TIMER_FOR_REQ_ADDR, WAIT_FOR_EEPROM_WRITE);
   \       0x82   0x21C8             MOVS     R1,#+200
   \       0x84   0x2004             MOVS     R0,#+4
   \       0x86   0x.... 0x....      BL       restartSbcSemTimer
   2184                  }
   2185                  break;
   \                     ??semUpdateConfig_18: (+1)
   \       0x8A   0xE158             B.N      ??semUpdateConfig_0
   2186                  
   2187                case ADDR_AUTHORIZATION_FEEDBACK_RW:
   2188                  
   2189                  if (*((uint16_t*)pMsg->dataToSend.pData) == (uint16_t)0x0001)
   \                     ??semUpdateConfig_9: (+1)
   \       0x8C   0x68A0             LDR      R0,[R4, #+8]
   \       0x8E   0x8800             LDRH     R0,[R0, #+0]
   \       0x90   0x2801             CMP      R0,#+1
   \       0x92   0xD11A             BNE.N    ??semUpdateConfig_19
   2190                  {
   2191                    frameRemote.currentEvent = REMOTE_EVS_AUTH_START;
   \       0x94   0x2017             MOVS     R0,#+23
   \       0x96   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2192                    frameRemote.currentData = (uint16_t)0x0001;
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xF8AD 0x0005      STRH     R0,[SP, #+5]
   2193                    configASSERT(xQueueSendToBack(remoteMngQueue, (void *)&frameRemote, portMAX_DELAY) == pdPASS); // remoteSuspRelProcess()
   \       0xA0   0x2300             MOVS     R3,#+0
   \       0xA2   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0xA6   0xA901             ADD      R1,SP,#+4
   \       0xA8   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \       0xAC   0x6800             LDR      R0,[R0, #+0]
   \       0xAE   0x.... 0x....      BL       xQueueGenericSend
   \       0xB2   0x2801             CMP      R0,#+1
   \       0xB4   0xD018             BEQ.N    ??semUpdateConfig_20
   \       0xB6   0xB672             CPSID    I
   \       0xB8   0x2050             MOVS     R0,#+80
   \       0xBA   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xBE   0xF3BF 0x8F4F      DSB      SY
   \       0xC2   0xF3BF 0x8F6F      ISB      SY
   \       0xC6   0xB662             CPSIE    I
   \                     ??semUpdateConfig_21: (+1)
   \       0xC8   0xE7FE             B.N      ??semUpdateConfig_21
   2194                  }
   2195                  else if (*((uint16_t*)pMsg->dataToSend.pData) == (uint16_t)0x0002)
   \                     ??semUpdateConfig_19: (+1)
   \       0xCA   0x68A0             LDR      R0,[R4, #+8]
   \       0xCC   0x8800             LDRH     R0,[R0, #+0]
   \       0xCE   0x2802             CMP      R0,#+2
   \       0xD0   0xD103             BNE.N    ??semUpdateConfig_22
   2196                  {
   2197                    send_to_evs(EVS_AUTH_NEG);
   \       0xD2   0x201A             MOVS     R0,#+26
   \       0xD4   0x.... 0x....      BL       send_to_evs
   \       0xD8   0xE006             B.N      ??semUpdateConfig_20
   2198                  }
   2199                  else if (*((uint16_t*)pMsg->dataToSend.pData) == (uint16_t)0x0003)
   \                     ??semUpdateConfig_22: (+1)
   \       0xDA   0x68A0             LDR      R0,[R4, #+8]
   \       0xDC   0x8800             LDRH     R0,[R0, #+0]
   \       0xDE   0x2803             CMP      R0,#+3
   \       0xE0   0xD102             BNE.N    ??semUpdateConfig_20
   2200                  {
   2201                    send_to_evs(EVS_AUTH_STOP);
   \       0xE2   0x2019             MOVS     R0,#+25
   \       0xE4   0x.... 0x....      BL       send_to_evs
   2202                  }
   2203                  
   2204                  break;
   \                     ??semUpdateConfig_20: (+1)
   \       0xE8   0xE129             B.N      ??semUpdateConfig_0
   2205                  
   2206                case ADDR_REMOTE_COMMANDS_RW:
   2207                  temp16 = *((uint16_t*)pMsg->dataToSend.pData);
   \                     ??semUpdateConfig_6: (+1)
   \       0xEA   0x68A0             LDR      R0,[R4, #+8]
   \       0xEC   0x8800             LDRH     R0,[R0, #+0]
   \       0xEE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2208                  if (temp16 == (uint16_t)0x0001)
   \       0xF2   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0xF6   0x2801             CMP      R0,#+1
   \       0xF8   0xD11A             BNE.N    ??semUpdateConfig_23
   2209                  {
   2210                    frameRemote.currentEvent = REMOTE_EVS_AUTH_STOP;
   \       0xFA   0x2019             MOVS     R0,#+25
   \       0xFC   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2211                    frameRemote.currentData = (uint16_t)0x0001;
   \      0x100   0x2001             MOVS     R0,#+1
   \      0x102   0xF8AD 0x0005      STRH     R0,[SP, #+5]
   2212                    configASSERT(xQueueSendToBack(remoteMngQueue, (void *)&frameRemote, portMAX_DELAY) == pdPASS); // remoteSuspRelProcess()
   \      0x106   0x2300             MOVS     R3,#+0
   \      0x108   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x10C   0xA901             ADD      R1,SP,#+4
   \      0x10E   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \      0x112   0x6800             LDR      R0,[R0, #+0]
   \      0x114   0x.... 0x....      BL       xQueueGenericSend
   \      0x118   0x2801             CMP      R0,#+1
   \      0x11A   0xD05F             BEQ.N    ??semUpdateConfig_24
   \      0x11C   0xB672             CPSID    I
   \      0x11E   0x2050             MOVS     R0,#+80
   \      0x120   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x124   0xF3BF 0x8F4F      DSB      SY
   \      0x128   0xF3BF 0x8F6F      ISB      SY
   \      0x12C   0xB662             CPSIE    I
   \                     ??semUpdateConfig_25: (+1)
   \      0x12E   0xE7FE             B.N      ??semUpdateConfig_25
   2213                  }
   2214                  else if (temp16 == (uint16_t)0x0002)
   \                     ??semUpdateConfig_23: (+1)
   \      0x130   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x134   0x2802             CMP      R0,#+2
   \      0x136   0xD107             BNE.N    ??semUpdateConfig_26
   2215                  {
   2216                    /* inizio carica */
   2217                    lastCommandSent = EVS_AUTH_START;
   \      0x138   0x2017             MOVS     R0,#+23
   \      0x13A   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \      0x13E   0x7008             STRB     R0,[R1, #+0]
   2218                    send_to_evs(EVS_AUTH_START);
   \      0x140   0x2017             MOVS     R0,#+23
   \      0x142   0x.... 0x....      BL       send_to_evs
   \      0x146   0xE049             B.N      ??semUpdateConfig_24
   2219                  }
   2220                  else if (temp16 == (uint16_t)MODE_AVAILABLE)
   \                     ??semUpdateConfig_26: (+1)
   \      0x148   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x14C   0x2805             CMP      R0,#+5
   \      0x14E   0xD10E             BNE.N    ??semUpdateConfig_27
   2221                  {
   2222                    temp[0] = (uint8_t)EVS_MODE_AVAILABLE;
   \      0x150   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \      0x154   0x2001             MOVS     R0,#+1
   \      0x156   0x7008             STRB     R0,[R1, #+0]
   2223                    
   2224                    /*** SAVE ON EEPROM ***/
   2225                    EEPROM_Save_Config (SOCKET_ENABLE_EADD, (uint8_t*)temp, 1);
   \      0x158   0x2201             MOVS     R2,#+1
   \      0x15A   0x2006             MOVS     R0,#+6
   \      0x15C   0x.... 0x....      BL       EEPROM_Save_Config
   2226                    
   2227                    evs_reserved_set(0);
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0x.... 0x....      BL       evs_reserved_set
   2228                    
   2229                    send_to_evs(EVS_AUTORIZATION_MODE);
   \      0x166   0x2003             MOVS     R0,#+3
   \      0x168   0x.... 0x....      BL       send_to_evs
   \      0x16C   0xE036             B.N      ??semUpdateConfig_24
   2230                  }
   2231                  else if (temp16 == (uint16_t)MODE_UNAVAILABLE)
   \                     ??semUpdateConfig_27: (+1)
   \      0x16E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x172   0x2806             CMP      R0,#+6
   \      0x174   0xD10B             BNE.N    ??semUpdateConfig_28
   2232                  {
   2233                    temp[0] = (uint8_t)EVS_MODE_UNAVAILABLE;
   \      0x176   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \      0x17A   0x2000             MOVS     R0,#+0
   \      0x17C   0x7008             STRB     R0,[R1, #+0]
   2234                    
   2235                    /*** SAVE ON EEPROM ***/
   2236                    EEPROM_Save_Config (SOCKET_ENABLE_EADD, (uint8_t*)temp, 1);
   \      0x17E   0x2201             MOVS     R2,#+1
   \      0x180   0x2006             MOVS     R0,#+6
   \      0x182   0x.... 0x....      BL       EEPROM_Save_Config
   2237                                  
   2238                    send_to_evs(EVS_AUTORIZATION_MODE);
   \      0x186   0x2003             MOVS     R0,#+3
   \      0x188   0x.... 0x....      BL       send_to_evs
   \      0x18C   0xE026             B.N      ??semUpdateConfig_24
   2239                  }
   2240                  else if (temp16 == (uint16_t)MODE_RESERVED)
   \                     ??semUpdateConfig_28: (+1)
   \      0x18E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x192   0x2807             CMP      R0,#+7
   \      0x194   0xD106             BNE.N    ??semUpdateConfig_29
   2241                  {
   2242          //          temp[0] = (uint8_t)EVS_MODE_AVAILABLE | (uint8_t)EVS_MODE_RESERVED;
   2243          //          eeprom_param_set(SOCKET_ENABLE_EADD, (uint8_t*)temp, 1);
   2244                    evs_reserved_set(1);
   \      0x196   0x2001             MOVS     R0,#+1
   \      0x198   0x.... 0x....      BL       evs_reserved_set
   2245                    send_to_evs(EVS_AUTORIZATION_MODE);
   \      0x19C   0x2003             MOVS     R0,#+3
   \      0x19E   0x.... 0x....      BL       send_to_evs
   \      0x1A2   0xE01B             B.N      ??semUpdateConfig_24
   2246                  }
   2247                  else if (temp16 == (uint16_t)HARD_REBOOT)
   \                     ??semUpdateConfig_29: (+1)
   \      0x1A4   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1A8   0x28FD             CMP      R0,#+253
   \      0x1AA   0xD102             BNE.N    ??semUpdateConfig_30
   2248                  {
   2249                    /* reset immediato  */
   2250                    activeImmediateReset();
   \      0x1AC   0x.... 0x....      BL       activeImmediateReset
   \      0x1B0   0xE014             B.N      ??semUpdateConfig_24
   2251                  }        
   2252                  else if ((temp16 >= REMOVE_CONNECTOR_ID_START) && (temp16 <= REMOVE_CONNECTOR_ID_END))
   \                     ??semUpdateConfig_30: (+1)
   \      0x1B2   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1B6   0xF64D 0x5102      MOVW     R1,#+56578
   \      0x1BA   0x4288             CMP      R0,R1
   \      0x1BC   0xDB0E             BLT.N    ??semUpdateConfig_24
   \      0x1BE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1C2   0xF64D 0x5111      MOVW     R1,#+56593
   \      0x1C6   0x4288             CMP      R0,R1
   \      0x1C8   0xDA08             BGE.N    ??semUpdateConfig_24
   2253                  {
   2254                    temp[0] = (uint8_t)(temp16 - REMOVE_CONNECTOR_ID_START) + (uint8_t)1; // logic id 1..15 (logic 0 is master and cannot be removed)
   \      0x1CA   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \      0x1CE   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \      0x1D2   0x1E49             SUBS     R1,R1,#+1
   \      0x1D4   0x7001             STRB     R1,[R0, #+0]
   2255                    removeSocketFromList(temp[0]);
   \      0x1D6   0x7800             LDRB     R0,[R0, #+0]
   \      0x1D8   0x.... 0x....      BL       removeSocketFromList
   2256                  }
   2257                  
   2258                  break;
   \                     ??semUpdateConfig_24: (+1)
   \      0x1DC   0xE0AF             B.N      ??semUpdateConfig_0
   2259                  
   2260                case ADDR_EVSE_OPERATION_MODE_RW:
   2261                  
   2262                  temp16 = getOperationMode();
   \                     ??semUpdateConfig_3: (+1)
   \      0x1DE   0x.... 0x....      BL       getOperationMode
   \      0x1E2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2263                  temp[0] = (uint8_t)(temp16);   /* evse_mode in modbus map --> FREE, PERSONAl, NET */
   \      0x1E6   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \      0x1EA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1EE   0x7008             STRB     R0,[R1, #+0]
   2264                  temp[1] = (uint8_t)(temp16 / 0x100) ;  /* master_mode --> LOCAL - OCPP */ 
   \      0x1F0   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1F4   0xF44F 0x7280      MOV      R2,#+256
   \      0x1F8   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \      0x1FC   0x7048             STRB     R0,[R1, #+1]
   2265                  /* Check if LOCAL mode */
   2266                  if (temp[1] <= (char)0x01)
   \      0x1FE   0x7848             LDRB     R0,[R1, #+1]
   \      0x200   0x2802             CMP      R0,#+2
   \      0x202   0xDA0A             BGE.N    ??semUpdateConfig_31
   2267                  {
   2268                    if (temp[0] <= EVS_NET_MODE)  /* EVS_FREE_MODE = 0, EVS_PERS_MODE = 1, EVS_NET_MODE = 2 NON gestiti: EVS_OCPP_MODE = 3*/
   \      0x204   0x7808             LDRB     R0,[R1, #+0]
   \      0x206   0x2803             CMP      R0,#+3
   \      0x208   0xDA10             BGE.N    ??semUpdateConfig_32
   2269                    {
   2270                      /* set the current operative mode                       */            
   2271                      /*** SAVE ON EEPROM ***/
   2272                      EEPROM_Save_Config (EVS_MODE_EADD, (uint8_t*)&temp[0], 1);
   \      0x20A   0x2201             MOVS     R2,#+1
   \      0x20C   0x200B             MOVS     R0,#+11
   \      0x20E   0x.... 0x....      BL       EEPROM_Save_Config
   2273                                    
   2274                      send_to_evs(EVS_AUTORIZATION_MODE);
   \      0x212   0x2003             MOVS     R0,#+3
   \      0x214   0x.... 0x....      BL       send_to_evs
   \      0x218   0xE008             B.N      ??semUpdateConfig_32
   2275                    }
   2276                  }
   2277                  else
   2278                  {
   2279                    temp[0] = (char)EVS_OCPP_MODE;
   \                     ??semUpdateConfig_31: (+1)
   \      0x21A   0x2003             MOVS     R0,#+3
   \      0x21C   0x7008             STRB     R0,[R1, #+0]
   2280                    /* set OCPP = 3 as current operative mode                       */          
   2281                    /*** SAVE ON EEPROM ***/
   2282                    EEPROM_Save_Config (EVS_MODE_EADD, (uint8_t*)&temp[0], 1);
   \      0x21E   0x2201             MOVS     R2,#+1
   \      0x220   0x200B             MOVS     R0,#+11
   \      0x222   0x.... 0x....      BL       EEPROM_Save_Config
   2283                    send_to_evs(EVS_AUTORIZATION_MODE);
   \      0x226   0x2003             MOVS     R0,#+3
   \      0x228   0x.... 0x....      BL       send_to_evs
   2284                  }        
   2285                  
   2286                  break;
   \                     ??semUpdateConfig_32: (+1)
   \      0x22C   0xE087             B.N      ??semUpdateConfig_0
   2287                  
   2288                case ADDR_MAX_TEMPORARY_POWER_AC:        
   2289                  frameRemote.currentEvent = REMOTE_MAX_POWER_CHANGE;
   \                     ??semUpdateConfig_7: (+1)
   \      0x22E   0x200F             MOVS     R0,#+15
   \      0x230   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2290                  frameRemote.currentData = (uint16_t)0x0002;
   \      0x234   0x2002             MOVS     R0,#+2
   \      0x236   0xF8AD 0x0005      STRH     R0,[SP, #+5]
   2291                  configASSERT(xQueueSendToBack(remoteMngQueue, (void *)&frameRemote, portMAX_DELAY) == pdPASS); // remoteSuspRelProcess()      
   \      0x23A   0x2300             MOVS     R3,#+0
   \      0x23C   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x240   0xA901             ADD      R1,SP,#+4
   \      0x242   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \      0x246   0x6800             LDR      R0,[R0, #+0]
   \      0x248   0x.... 0x....      BL       xQueueGenericSend
   \      0x24C   0x2801             CMP      R0,#+1
   \      0x24E   0xD009             BEQ.N    ??semUpdateConfig_33
   \      0x250   0xB672             CPSID    I
   \      0x252   0x2050             MOVS     R0,#+80
   \      0x254   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x258   0xF3BF 0x8F4F      DSB      SY
   \      0x25C   0xF3BF 0x8F6F      ISB      SY
   \      0x260   0xB662             CPSIE    I
   \                     ??semUpdateConfig_34: (+1)
   \      0x262   0xE7FE             B.N      ??semUpdateConfig_34
   2292                  break;
   \                     ??semUpdateConfig_33: (+1)
   \      0x264   0xE06B             B.N      ??semUpdateConfig_0
   2293                  
   2294                case ADDR_HWC_FLAGS_RW:        
   2295                  /* Save Hw flags into Eeprom */
   2296                  HW_PRESENCE_FLAG_EEprom_Save ();                  
   \                     ??semUpdateConfig_1: (+1)
   \      0x266   0x.... 0x....      BL       HW_PRESENCE_FLAG_EEprom_Save
   2297                  break;
   \      0x26A   0xE068             B.N      ??semUpdateConfig_0
   2298          
   2299                case ADDR_DISPLAY_DEFAULT_LANGUAGE_RW:
   2300                  /* get language received */
   2301                  temp16 = getDefaultLanguage();              
   \                     ??semUpdateConfig_4: (+1)
   \      0x26C   0x.... 0x....      BL       getDefaultLanguage
   \      0x270   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2302                  /* Uniformato a pagina Web Nik e Modbus v21.3. Esempio se bit n.5 settato a 1 --> in eeprom finisce il valore 0x05 - 1 (non bit mask ma enum) */      
   2303                  LANG_Modbus_to_EEprom_Translate ((uint32_t)temp16);
   \      0x274   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x278   0x.... 0x....      BL       LANG_Modbus_to_EEprom_Translate
   2304                  break;
   \      0x27C   0xE05F             B.N      ??semUpdateConfig_0
   2305                  
   2306                case ADDR_DISPLAY_LANGUAGES_RW:
   2307                  /* Get available languages */
   2308                  temp32 = getAvailableLanguages();
   \                     ??semUpdateConfig_12: (+1)
   \      0x27E   0x.... 0x....      BL       getAvailableLanguages
   \      0x282   0x0005             MOVS     R5,R0
   2309                  /* Translate from Modbus to eeprom format */
   2310                  LANG_Available_Mdb_to_EEprom_Translate (temp32);        
   \      0x284   0x0028             MOVS     R0,R5
   \      0x286   0x.... 0x....      BL       LANG_Available_Mdb_to_EEprom_Translate
   2311                  break;
   \      0x28A   0xE058             B.N      ??semUpdateConfig_0
   2312          
   2313                case ADDR_MAX_TYPICAL_CURRENT_RW:
   2314                  /* Get Max typical current */
   2315                  temp16 = getMaxTypicalCurrent();
   \                     ??semUpdateConfig_13: (+1)
   \      0x28C   0x.... 0x....      BL       getMaxTypicalCurrent
   \      0x290   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2316                  /* Store into eeprom location */        
   2317                  /*** SAVE ON EEPROM ***/
   2318                  EEPROM_Save_Config (M3T_CURRENT_EADD, (uint8_t*)&temp16, 1);
   \      0x294   0x2201             MOVS     R2,#+1
   \      0x296   0x4669             MOV      R1,SP
   \      0x298   0x200C             MOVS     R0,#+12
   \      0x29A   0x.... 0x....      BL       EEPROM_Save_Config
   2319                  break;
   \      0x29E   0xE04E             B.N      ??semUpdateConfig_0
   2320                  
   2321                case ADDR_MAX_SIMPLIFIED_CURRENT_RW:
   2322                  /* Get Max typical current */
   2323                  temp16 = getMaxSimplifiedCurrent();
   \                     ??semUpdateConfig_14: (+1)
   \      0x2A0   0x.... 0x....      BL       getMaxSimplifiedCurrent
   \      0x2A4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2324                  /* Store into eeprom location */        
   2325                  /*** SAVE ON EEPROM ***/
   2326                  EEPROM_Save_Config (M3S_CURRENT_EADD, (uint8_t*)&temp16, 1);
   \      0x2A8   0x2201             MOVS     R2,#+1
   \      0x2AA   0x4669             MOV      R1,SP
   \      0x2AC   0x200D             MOVS     R0,#+13
   \      0x2AE   0x.... 0x....      BL       EEPROM_Save_Config
   2327                  break;
   \      0x2B2   0xE044             B.N      ??semUpdateConfig_0
   2328                  
   2329                case ADDR_PM_MODE_RW:
   2330                case ADDR_PM_IMIN_RW:
   2331                case ADDR_PM_PMAX_RW:
   2332                case ADDR_PM_FLAGS_RW:
   2333                case ADDR_PM_HPOWER_RW:
   2334                case ADDR_PM_DSET_RW:
   2335                case ADDR_PM_DMAX_RW:
   2336                  /* Translate from MOdbus to EEprom format */
   2337                  PM_Mdb_to_EEprom_Translate(pMsg->data.rAddr);
   \                     ??semUpdateConfig_8: (+1)
   \      0x2B4   0x88A0             LDRH     R0,[R4, #+4]
   \      0x2B6   0x.... 0x....      BL       PM_Mdb_to_EEprom_Translate
   2338                  break;
   \      0x2BA   0xE040             B.N      ??semUpdateConfig_0
   2339                  
   2340                case ADDR_MENU_VISIBILITY_RW:
   2341                  /* Get PM menu visibility flag */
   2342                  temp16 = getPmMenuVisibility();
   \                     ??semUpdateConfig_10: (+1)
   \      0x2BC   0x.... 0x....      BL       getPmMenuVisibility
   \      0x2C0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2343                  /* Store into eeprom location */        
   2344                  /*** SAVE ON EEPROM ***/
   2345                  EEPROM_Save_Config (HIDDEN_MENU_VIS_EADD, (uint8_t*)&temp16, 1);
   \      0x2C4   0x2201             MOVS     R2,#+1
   \      0x2C6   0x4669             MOV      R1,SP
   \      0x2C8   0x2035             MOVS     R0,#+53
   \      0x2CA   0x.... 0x....      BL       EEPROM_Save_Config
   2346                  break;
   \      0x2CE   0xE036             B.N      ??semUpdateConfig_0
   2347                 
   2348              case ADDR_CHARGE_TIME_RW:
   2349                  /* Get Charge by Time value */      
   2350                  temp16 = getChargeByTime();
   \                     ??semUpdateConfig_15: (+1)
   \      0x2D0   0x.... 0x....      BL       getChargeByTime
   \      0x2D4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2351                  /* Store into eeprom location */        
   2352                  /*** SAVE ON EEPROM ***/
   2353                  EEPROM_Save_Config (TCHARGE_TIME_EADD, (uint8_t*)&temp16, 1);
   \      0x2D8   0x2201             MOVS     R2,#+1
   \      0x2DA   0x4669             MOV      R1,SP
   \      0x2DC   0x2022             MOVS     R0,#+34
   \      0x2DE   0x.... 0x....      BL       EEPROM_Save_Config
   2354                  break;
   \      0x2E2   0xE02C             B.N      ??semUpdateConfig_0
   2355                  
   2356              case ADDR_CHARGE_MAX_ENERGY_RW:
   2357                  /* Get Charge by Energy value */      
   2358                  temp16 = getChargeByEnergy();
   \                     ??semUpdateConfig_16: (+1)
   \      0x2E4   0x.... 0x....      BL       getChargeByEnergy
   \      0x2E8   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2359                  /* Store into eeprom location */        
   2360                  /*** SAVE ON EEPROM ***/
   2361                  EEPROM_Save_Config (ENRG_LIMIT_EADD, (uint8_t*)&temp16, 1);
   \      0x2EC   0x2201             MOVS     R2,#+1
   \      0x2EE   0x4669             MOV      R1,SP
   \      0x2F0   0x2037             MOVS     R0,#+55
   \      0x2F2   0x.... 0x....      BL       EEPROM_Save_Config
   2362                  break;        
   \      0x2F6   0xE022             B.N      ??semUpdateConfig_0
   2363                          
   2364              case ADDR_CONNECTOR_IDS_RW:
   2365                  /* Get Connector ID from modbus map */
   2366                  temp16 = getConnectorId();
   \                     ??semUpdateConfig_2: (+1)
   \      0x2F8   0x.... 0x....      BL       getConnectorId
   \      0x2FC   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2367                  /* Set new connector ID on conversion matrix */
   2368                  CONN_ID_Set_New (temp16);  
   \      0x300   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x304   0x.... 0x....      BL       CONN_ID_Set_New
   2369                  /* Set also the new number to show on LCD with the new value of connector ID*/
   2370                  numberOnLcd = temp16;        
   \      0x308   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x30C   0x.... 0x....      LDR.W    R1,??DataTable13
   \      0x310   0x7008             STRB     R0,[R1, #+0]
   2371                  if (isSemMasterFz() == FALSE) 
   \      0x312   0x.... 0x....      BL       isSemMasterFz
   \      0x316   0x2800             CMP      R0,#+0
   \      0x318   0xD103             BNE.N    ??semUpdateConfig_35
   2372                  {
   2373                    /* the slave must send the change in EEPROM to the master when all 3 regs are written  */
   2374                    restartSbcSemTimer(TIMER_FOR_REQ_ADDR, WAIT_FOR_EEPROM_WRITE);
   \      0x31A   0x21C8             MOVS     R1,#+200
   \      0x31C   0x2004             MOVS     R0,#+4
   \      0x31E   0x.... 0x....      BL       restartSbcSemTimer
   2375                  }
   2376                  break;
   \                     ??semUpdateConfig_35: (+1)
   \      0x322   0xE00C             B.N      ??semUpdateConfig_0
   2377                  
   2378          
   2379                case ADDR_TIMEOUT_RANGE1_RW:
   2380                  /* get the timeout value from SEM message */
   2381                  temp16 = *((uint16_t*)pMsg->dataToSend.pData);
   \                     ??semUpdateConfig_11: (+1)
   \      0x324   0x68A0             LDR      R0,[R4, #+8]
   \      0x326   0x8800             LDRH     R0,[R0, #+0]
   \      0x328   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2382                  /* save this value and set for Evs Manager */
   2383                  saveTimeoutRange1(temp16);
   \      0x32C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x330   0x.... 0x....      BL       saveTimeoutRange1
   2384                  setWaitTimeValue(temp16);
   \      0x334   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x338   0x.... 0x....      BL       setWaitTimeValue
   2385                  break;
   \      0x33C   0xE7FF             B.N      ??semUpdateConfig_0
   2386          
   2387                default:
   2388                  /* not a configuration register */
   2389                  break;
   2390                  
   2391              }
   2392            }
   2393            
   2394          }
   \                     ??semUpdateConfig_17: (+1)
   \                     ??semUpdateConfig_0: (+1)
   \      0x33E   0xBD37             POP      {R0-R2,R4,R5,PC}

   \                                 In section .bss, align 4
   \                     `semUpdateConfig::temp`:
   \        0x0                      DS8 8
   2395          
   2396          /**
   2397          *
   2398          * @brief       start the task management 
   2399          *
   2400          * @param [in]  none    
   2401          *  
   2402          * @retval      none 
   2403          *  
   2404          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2405          void startSbcSemProcess(void) 
   2406          {
   \                     startSbcSemProcess: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   2407            frameSbcSem_st        tmpFrameSbcSem;  
   2408          
   2409            tmpFrameSbcSem.sbcSemEvent = NOTIFY_START_TASK;
   \        0x4   0x2009             MOVS     R0,#+9
   \        0x6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2410            tmpFrameSbcSem.data.index = getPhysicalMdbAddr();
   \        0xA   0x.... 0x....      BL       getPhysicalMdbAddr
   \        0xE   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   2411            tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \       0x12   0x.... 0x....      BL       getPacketStatusNum
   \       0x16   0xF10D 0x010E      ADD      R1,SP,#+14
   \       0x1A   0x6008             STR      R0,[R1, #+0]
   2412            configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \       0x1C   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x20   0x2300             MOVS     R3,#+0
   \       0x22   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x26   0x4669             MOV      R1,SP
   \       0x28   0x.... 0x....      BL       xQueueGenericSend
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD009             BEQ.N    ??startSbcSemProcess_0
   \       0x30   0xB672             CPSID    I
   \       0x32   0x2050             MOVS     R0,#+80
   \       0x34   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x38   0xF3BF 0x8F4F      DSB      SY
   \       0x3C   0xF3BF 0x8F6F      ISB      SY
   \       0x40   0xB662             CPSIE    I
   \                     ??startSbcSemProcess_1: (+1)
   \       0x42   0xE7FE             B.N      ??startSbcSemProcess_1
   2413          }
   \                     ??startSbcSemProcess_0: (+1)
   \       0x44   0xB005             ADD      SP,SP,#+20
   \       0x46   0xBD00             POP      {PC}
   2414          
   2415          /**
   2416          *
   2417          * @brief       set in the modbus map hardware configuration 
   2418          *
   2419          * @param [in]  
   2420          *  
   2421          * @retval      none 
   2422          *  
   2423          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2424          void  upgradeModbusHwConfig(void) 
   2425          {
   \                     upgradeModbusHwConfig: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   2426            uint8_t               mdbAddr;
   2427            frameSbcSem_st        tmpFrameSbcSem;  
   2428            uint16_t              idConn;
   2429          
   2430            idConn = fromRs485ToSem((uint16_t)getPhysicalMdbAddr());
   \        0x4   0x.... 0x....      BL       getPhysicalMdbAddr
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0xB280             UXTH     R0,R0
   \        0xC   0x.... 0x....      BL       fromRs485ToSem
   \       0x10   0x0005             MOVS     R5,R0
   2431            mdbAddr = (uint8_t)idConn;
   \       0x12   0x002C             MOVS     R4,R5
   2432          
   2433            /* Init modbus registers according to the setting in eeprom */
   2434            initModbusRegisters();
   \       0x14   0x.... 0x....      BL       initModbusRegisters
   2435            
   2436            /* If SEM, send this setting to the Master */
   2437            if (isSemMode())
   \       0x18   0x.... 0x....      BL       isSemMode
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD023             BEQ.N    ??upgradeModbusHwConfig_0
   2438            {
   2439              /* send the info to notify manager */
   2440              tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2441              tmpFrameSbcSem.data.index = mdbAddr + 1;  // phisical address 1...16 
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x1C40             ADDS     R0,R0,#+1
   \       0x2C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   2442              tmpFrameSbcSem.data.rAddr = ADDR_CONNECTOR_TYPE_RW;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   2443              tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \       0x36   0x.... 0x....      BL       getPacketStatusNum
   \       0x3A   0xF10D 0x010E      ADD      R1,SP,#+14
   \       0x3E   0x6008             STR      R0,[R1, #+0]
   2444              configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \       0x40   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x44   0x2300             MOVS     R3,#+0
   \       0x46   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x.... 0x....      BL       xQueueGenericSend
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD009             BEQ.N    ??upgradeModbusHwConfig_0
   \       0x54   0xB672             CPSID    I
   \       0x56   0x2050             MOVS     R0,#+80
   \       0x58   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x5C   0xF3BF 0x8F4F      DSB      SY
   \       0x60   0xF3BF 0x8F6F      ISB      SY
   \       0x64   0xB662             CPSIE    I
   \                     ??upgradeModbusHwConfig_1: (+1)
   \       0x66   0xE7FE             B.N      ??upgradeModbusHwConfig_1
   2445            }
   2446          }
   \                     ??upgradeModbusHwConfig_0: (+1)
   \       0x68   0xB005             ADD      SP,SP,#+20
   \       0x6A   0xBD30             POP      {R4,R5,PC}
   2447          
   2448          /**
   2449          *
   2450          * @brief       upgrade bit for error or status notification  
   2451          *
   2452          * @param [in]  
   2453          *  
   2454          * @retval      none 
   2455          *  
   2456          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2457          void  upgradeModbusReg(uint16_t errAddr) 
   2458          {
   \                     upgradeModbusReg: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   2459            frameSbcSem_st          tmpFrameSbcSem;  
   2460            uint8_t                 mdbAddr;
   2461          
   2462            if (isSemMode() == FALSE)
   \        0x6   0x.... 0x....      BL       isSemMode
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD02C             BEQ.N    ??upgradeModbusReg_0
   2463              return;
   2464            
   2465            if (getSbcSemQueueHandle() == NULL)
   \                     ??upgradeModbusReg_1: (+1)
   \        0xE   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD028             BEQ.N    ??upgradeModbusReg_0
   2466              return;
   2467          
   2468            mdbAddr = getLogicalMdbAddrSem();
   \                     ??upgradeModbusReg_2: (+1)
   \       0x16   0x.... 0x....      BL       getLogicalMdbAddrSem
   \       0x1A   0x0005             MOVS     R5,R0
   2469            /* send the info to notify manager ADDR_EVSE_ERROR1_RO */
   2470            tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2471            tmpFrameSbcSem.data.index = mdbAddr + 1; // phisical address 1...16
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x1C40             ADDS     R0,R0,#+1
   \       0x28   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   2472            tmpFrameSbcSem.data.rAddr = errAddr;
   \       0x2C   0xF8AD 0x4004      STRH     R4,[SP, #+4]
   2473            tmpFrameSbcSem.dataToSend.len = (uint16_t)1;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   2474            tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \       0x36   0x.... 0x....      BL       getPacketStatusNum
   \       0x3A   0xF10D 0x010E      ADD      R1,SP,#+14
   \       0x3E   0x6008             STR      R0,[R1, #+0]
   2475            configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \       0x40   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x44   0x2300             MOVS     R3,#+0
   \       0x46   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x.... 0x....      BL       xQueueGenericSend
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD009             BEQ.N    ??upgradeModbusReg_3
   \       0x54   0xB672             CPSID    I
   \       0x56   0x2050             MOVS     R0,#+80
   \       0x58   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x5C   0xF3BF 0x8F4F      DSB      SY
   \       0x60   0xF3BF 0x8F6F      ISB      SY
   \       0x64   0xB662             CPSIE    I
   \                     ??upgradeModbusReg_4: (+1)
   \       0x66   0xE7FE             B.N      ??upgradeModbusReg_4
   2476          }
   \                     ??upgradeModbusReg_3: (+1)
   \                     ??upgradeModbusReg_0: (+1)
   \       0x68   0xB005             ADD      SP,SP,#+20
   \       0x6A   0xBD30             POP      {R4,R5,PC}
   2477          
   2478          /**
   2479          *
   2480          * @brief       set the property bit in the register change 
   2481          *              notification
   2482          *
   2483          * @param [in]  uint16_t: SCU physical index 01...32 
   2484          * @param [in]  uint16_t: base changed register 
   2485          * @param [in]  uint16_t: mask bit 
   2486          * @param [in]  uint16_t: device Id i.e. logical index in array 
   2487          *        structures 
   2488          *  
   2489          * @retval      bitNotifyResult_e: success if TRUE 
   2490          *  
   2491          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2492          static bitNotifyResult_e  setChangeRegisterBit(uint16_t ixScu, frameSbcSem_st* pMsg, uint32_t mskBit, uint16_t deviceId) 
   2493          {
   \                     setChangeRegisterBit: (+1)
   \        0x0   0xE92D 0x4FF5      PUSH     {R0,R2,R4-R11,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x001D             MOVS     R5,R3
   2494            scuRoMapRegister_st*    pRoRegs;
   2495            scuRwMapRegister_st*    pRwRegs;
   2496            uint16_t                val, regChanged;
   2497            uint8_t                 logicAddr, ix, strReg[36], toPrint, toUpdate;
   2498            bitNotifyResult_e       result; 
   2499          
   2500            result = SEND_ACK;
   \        0xA   0xF05F 0x0A01      MOVS     R10,#+1
   2501            val = 0;
   \        0xE   0x2700             MOVS     R7,#+0
   2502             toPrint = toUpdate = TRUE;
   \       0x10   0xF05F 0x0901      MOVS     R9,#+1
   \       0x14   0xF88D 0x900C      STRB     R9,[SP, #+12]
   2503          
   2504            logicAddr = (uint8_t)deviceId;
   \       0x18   0x46A8             MOV      R8,R5
   2505          
   2506            pRoRegs = getRoMdbRegs(logicAddr);
   \       0x1A   0x4640             MOV      R0,R8
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x.... 0x....      BL       getRoMdbRegs
   \       0x22   0x0006             MOVS     R6,R0
   2507            pRwRegs = getRwMdbRegs(logicAddr);
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0x.... 0x....      BL       getRwMdbRegs
   \       0x2C   0x9004             STR      R0,[SP, #+16]
   2508          
   2509            regChanged = pMsg->data.rAddr;
   \       0x2E   0x88A0             LDRH     R0,[R4, #+4]
   \       0x30   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   2510            switch (regChanged) 
   \       0x34   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xF000 0x80E3      BEQ.W    ??setChangeRegisterBit_0
   \       0x3E   0x1E80             SUBS     R0,R0,#+2
   \       0x40   0xF000 0x8116      BEQ.W    ??setChangeRegisterBit_1
   \       0x44   0xF240 0x4102      MOVW     R1,#+1026
   \       0x48   0x1A40             SUBS     R0,R0,R1
   \       0x4A   0xF000 0x80A5      BEQ.W    ??setChangeRegisterBit_2
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0xF000 0x80BD      BEQ.W    ??setChangeRegisterBit_3
   \       0x54   0xF240 0x11FB      MOVW     R1,#+507
   \       0x58   0x1A40             SUBS     R0,R0,R1
   \       0x5A   0xD028             BEQ.N    ??setChangeRegisterBit_4
   \       0x5C   0x1E40             SUBS     R0,R0,#+1
   \       0x5E   0xD041             BEQ.N    ??setChangeRegisterBit_5
   \       0x60   0x380D             SUBS     R0,R0,#+13
   \       0x62   0xF000 0x8124      BEQ.W    ??setChangeRegisterBit_6
   \       0x66   0x1E80             SUBS     R0,R0,#+2
   \       0x68   0xF000 0x8121      BEQ.W    ??setChangeRegisterBit_6
   \       0x6C   0x3831             SUBS     R0,R0,#+49
   \       0x6E   0xF000 0x80E3      BEQ.W    ??setChangeRegisterBit_7
   \       0x72   0x380F             SUBS     R0,R0,#+15
   \       0x74   0xD003             BEQ.N    ??setChangeRegisterBit_8
   \       0x76   0x3818             SUBS     R0,R0,#+24
   \       0x78   0xF000 0x8125      BEQ.W    ??setChangeRegisterBit_9
   \       0x7C   0xE12A             B.N      ??setChangeRegisterBit_10
   2511            {
   2512              case ADDR_UID_AUTHORIZATION_RO:
   2513                /* set in the map the right value for the origin of the change  */
   2514                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)UID_AUTHORIZATION_BIT;
   \                     ??setChangeRegisterBit_8: (+1)
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable15
   \       0x82   0x6801             LDR      R1,[R0, #+0]
   \       0x84   0x4642             MOV      R2,R8
   \       0x86   0xB2D2             UXTB     R2,R2
   \       0x88   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \       0x8C   0x6800             LDR      R0,[R0, #+0]
   \       0x8E   0x4642             MOV      R2,R8
   \       0x90   0xB2D2             UXTB     R2,R2
   \       0x92   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \       0x96   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \       0x9A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x9E   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2515                /*         destination           source */
   2516                strcpy((char *)strReg, AddrUidStr);
   \       0xA2   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \       0xA6   0xA805             ADD      R0,SP,#+20
   \       0xA8   0x.... 0x....      BL       strcpy
   2517                break;
   \       0xAC   0xE114             B.N      ??setChangeRegisterBit_11
   2518          
   2519              case ADDR_EVSE_EVENT_FLAGS_RO:
   2520                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)SOCKET_EVENT_FLAG_BIT;
   \                     ??setChangeRegisterBit_4: (+1)
   \       0xAE   0x.... 0x....      LDR.W    R0,??DataTable15
   \       0xB2   0x6801             LDR      R1,[R0, #+0]
   \       0xB4   0x4642             MOV      R2,R8
   \       0xB6   0xB2D2             UXTB     R2,R2
   \       0xB8   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \       0xBC   0x6800             LDR      R0,[R0, #+0]
   \       0xBE   0x4642             MOV      R2,R8
   \       0xC0   0xB2D2             UXTB     R2,R2
   \       0xC2   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \       0xC6   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \       0xCA   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0xCE   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2521                /*         destination           source */
   2522                strcpy((char *)strReg, AddrEventFlag);
   \       0xD2   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \       0xD6   0xA805             ADD      R0,SP,#+20
   \       0xD8   0x.... 0x....      BL       strcpy
   2523                val = pRoRegs->scuMapRegStatusMeas.ntfSktEvent;
   \       0xDC   0xF8B6 0x0122      LDRH     R0,[R6, #+290]
   \       0xE0   0x0007             MOVS     R7,R0
   2524                break;
   \       0xE2   0xE0F9             B.N      ??setChangeRegisterBit_11
   2525          
   2526              case ADDR_EVSE_CHARGE_STATUS_RO:
   2527          #ifdef COME_ERA
   2528                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)EVSE_CONNECTOR_STATUS_BIT_RO;
   2529                /*         destination           source */
   2530                strcpy((char *)strReg, AddrChargStatus);
   2531                ix = (uint8_t)pRoRegs->scuMapRegStatusMeas.ntfChgStat;
   2532                val = pRoRegs->scuMapRegStatusMeas.ntfChgStat;
   2533                if (ix <= END_CHARGE_STATE)
   2534                {
   2535                  /*         destination       source */
   2536                  strcat((char *)strReg, nameState[ix]);
   2537                }
   2538                if (val == (uint16_t)MDBSTATE_REBOOTING)
   2539                {
   2540                  /* reset max_temporary_power when a reboot on slave occurred */
   2541                  pRwRegs->scuSetRegister.maxTempPowerAc = (uint32_t)0;
   2542                }
   2543                if (val == (uint16_t)MDBSTATE_REBOOTING)
   2544                {
   2545                  /* reset max_temporary_power when a reboot on slave occurred */
   2546                  pRwRegs->scuSetRegister.maxTempPowerAc = (uint32_t)0;
   2547                }
   2548          #else
   2549          
   2550                val = pMsg->status;
   \                     ??setChangeRegisterBit_5: (+1)
   \       0xE4   0x89A0             LDRH     R0,[R4, #+12]
   \       0xE6   0x0007             MOVS     R7,R0
   2551                if (prevState[logicAddr] != val)
   \       0xE8   0x.... 0x....      LDR.W    R11,??DataTable16
   \       0xEC   0x4640             MOV      R0,R8
   \       0xEE   0xB2C0             UXTB     R0,R0
   \       0xF0   0xF83B 0x0010      LDRH     R0,[R11, R0, LSL #+1]
   \       0xF4   0x0039             MOVS     R1,R7
   \       0xF6   0xB289             UXTH     R1,R1
   \       0xF8   0x4288             CMP      R0,R1
   \       0xFA   0xD04A             BEQ.N    ??setChangeRegisterBit_12
   2552                {
   2553                  if ((getScuOpMode() != SCU_M_P) || (pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] & (uint16_t)EVSE_CONNECTOR_STATUS_BIT_RO) == (uint16_t)0)
   \       0xFC   0x.... 0x....      BL       getScuOpMode
   \      0x100   0x2802             CMP      R0,#+2
   \      0x102   0xD10A             BNE.N    ??setChangeRegisterBit_13
   \      0x104   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x108   0x6800             LDR      R0,[R0, #+0]
   \      0x10A   0x4641             MOV      R1,R8
   \      0x10C   0xB2C9             UXTB     R1,R1
   \      0x10E   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x112   0xF890 0x0102      LDRB     R0,[R0, #+258]
   \      0x116   0x0740             LSLS     R0,R0,#+29
   \      0x118   0xD439             BMI.N    ??setChangeRegisterBit_14
   2554                  {
   2555                    pRoRegs->scuMapRegStatusMeas.ntfChgStat = prevState[logicAddr] = val;
   \                     ??setChangeRegisterBit_13: (+1)
   \      0x11A   0x4640             MOV      R0,R8
   \      0x11C   0xB2C0             UXTB     R0,R0
   \      0x11E   0xF82B 0x7010      STRH     R7,[R11, R0, LSL #+1]
   \      0x122   0x4640             MOV      R0,R8
   \      0x124   0xB2C0             UXTB     R0,R0
   \      0x126   0xF83B 0x0010      LDRH     R0,[R11, R0, LSL #+1]
   \      0x12A   0xF8A6 0x0124      STRH     R0,[R6, #+292]
   2556                    pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)EVSE_CONNECTOR_STATUS_BIT_RO;
   \      0x12E   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x132   0x6801             LDR      R1,[R0, #+0]
   \      0x134   0x4642             MOV      R2,R8
   \      0x136   0xB2D2             UXTB     R2,R2
   \      0x138   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x13C   0x6800             LDR      R0,[R0, #+0]
   \      0x13E   0x4642             MOV      R2,R8
   \      0x140   0xB2D2             UXTB     R2,R2
   \      0x142   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x146   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x14A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \      0x14E   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2557                    /*         destination           source */
   2558                    strcpy((char *)strReg, AddrChargStatus);
   \      0x152   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \      0x156   0xA805             ADD      R0,SP,#+20
   \      0x158   0x.... 0x....      BL       strcpy
   2559                    ix = (uint8_t)pRoRegs->scuMapRegStatusMeas.ntfChgStat;
   \      0x15C   0xF8B6 0x0124      LDRH     R0,[R6, #+292]
   \      0x160   0xF88D 0x000D      STRB     R0,[SP, #+13]
   2560                    if (ix <= SUSPENDED_NOPOWER_STATE)
   \      0x164   0xF89D 0x000D      LDRB     R0,[SP, #+13]
   \      0x168   0x280F             CMP      R0,#+15
   \      0x16A   0xDA08             BGE.N    ??setChangeRegisterBit_15
   2561                    {
   2562                      /*         destination       source */
   2563                      strcat((char *)strReg, nameState[ix]);
   \      0x16C   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \      0x170   0xF89D 0x100D      LDRB     R1,[SP, #+13]
   \      0x174   0xF850 0x1021      LDR      R1,[R0, R1, LSL #+2]
   \      0x178   0xA805             ADD      R0,SP,#+20
   \      0x17A   0x.... 0x....      BL       strcat
   2564                    }
   2565                    if (val == (uint16_t)MDBSTATE_REBOOTING)
   \                     ??setChangeRegisterBit_15: (+1)
   \      0x17E   0x0038             MOVS     R0,R7
   \      0x180   0xB280             UXTH     R0,R0
   \      0x182   0x280D             CMP      R0,#+13
   \      0x184   0xD107             BNE.N    ??setChangeRegisterBit_16
   2566                    {
   2567                      /* reset max_temporary_power when a reboot on slave occurred */
   2568                      pRwRegs->scuSetRegister.maxTempPowerAc = (uint32_t)0;
   \      0x186   0x9804             LDR      R0,[SP, #+16]
   \      0x188   0x2100             MOVS     R1,#+0
   \      0x18A   0x6741             STR      R1,[R0, #+116]
   \      0x18C   0xE003             B.N      ??setChangeRegisterBit_16
   2569                    }
   2570                  }
   2571                  else
   2572                  {
   2573                    /* previus info has not been read from SBC */
   2574                    return(SEND_RETRY);
   \                     ??setChangeRegisterBit_14: (+1)
   \      0x18E   0x2002             MOVS     R0,#+2
   \      0x190   0xE0DC             B.N      ??setChangeRegisterBit_17
   2575                  }
   2576                }
   2577                else
   2578                {
   2579                  result = SEND_NULL;
   \                     ??setChangeRegisterBit_12: (+1)
   \      0x192   0x2000             MOVS     R0,#+0
   \      0x194   0x4682             MOV      R10,R0
   2580                }
   2581          #endif
   2582                break;
   \                     ??setChangeRegisterBit_16: (+1)
   \      0x196   0xE09F             B.N      ??setChangeRegisterBit_11
   2583          
   2584              case ADDR_EVSE_ERROR1_RO:
   2585                  pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)EVSE_ERROR1_BIT_RO;
   \                     ??setChangeRegisterBit_2: (+1)
   \      0x198   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x19C   0x6801             LDR      R1,[R0, #+0]
   \      0x19E   0x4642             MOV      R2,R8
   \      0x1A0   0xB2D2             UXTB     R2,R2
   \      0x1A2   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x1A6   0x6800             LDR      R0,[R0, #+0]
   \      0x1A8   0x4642             MOV      R2,R8
   \      0x1AA   0xB2D2             UXTB     R2,R2
   \      0x1AC   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x1B0   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x1B4   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x1B8   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2586                  /*         destination   source */
   2587                  strcpy((char *)strReg, AddrErr1);
   \      0x1BC   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \      0x1C0   0xA805             ADD      R0,SP,#+20
   \      0x1C2   0x.... 0x....      BL       strcpy
   2588                  val = pRoRegs->scuMapRegNotify.ntfErr1;
   \      0x1C6   0xF8B6 0x00FE      LDRH     R0,[R6, #+254]
   \      0x1CA   0x0007             MOVS     R7,R0
   2589                  break;
   \      0x1CC   0xE084             B.N      ??setChangeRegisterBit_11
   2590          
   2591              case ADDR_EVSE_ERROR2_RO:
   2592                  pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)EVSE_ERROR2_BIT_RO;
   \                     ??setChangeRegisterBit_3: (+1)
   \      0x1CE   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x1D2   0x6801             LDR      R1,[R0, #+0]
   \      0x1D4   0x4642             MOV      R2,R8
   \      0x1D6   0xB2D2             UXTB     R2,R2
   \      0x1D8   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x1DC   0x6800             LDR      R0,[R0, #+0]
   \      0x1DE   0x4642             MOV      R2,R8
   \      0x1E0   0xB2D2             UXTB     R2,R2
   \      0x1E2   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x1E6   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x1EA   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x1EE   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2593                  /*         destination   source */
   2594                  strcpy((char *)strReg, AddrErr2);
   \      0x1F2   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \      0x1F6   0xA805             ADD      R0,SP,#+20
   \      0x1F8   0x.... 0x....      BL       strcpy
   2595                  val = pRoRegs->scuMapRegNotify.ntfErr2;
   \      0x1FC   0xF8B6 0x0100      LDRH     R0,[R6, #+256]
   \      0x200   0x0007             MOVS     R7,R0
   2596                  break;
   \      0x202   0xE069             B.N      ??setChangeRegisterBit_11
   2597          
   2598              case ADDR_CONNECTOR_TYPE_RW:
   2599                  pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)CONFIGURATIONS_BIT_RW;
   \                     ??setChangeRegisterBit_0: (+1)
   \      0x204   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x208   0x6801             LDR      R1,[R0, #+0]
   \      0x20A   0x4642             MOV      R2,R8
   \      0x20C   0xB2D2             UXTB     R2,R2
   \      0x20E   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x212   0x6800             LDR      R0,[R0, #+0]
   \      0x214   0x4642             MOV      R2,R8
   \      0x216   0xB2D2             UXTB     R2,R2
   \      0x218   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x21C   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x220   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x224   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2600                  /*         destination     source */
   2601                  strcpy((char *)strReg, AddrConnType);
   \      0x228   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \      0x22C   0xA805             ADD      R0,SP,#+20
   \      0x22E   0x.... 0x....      BL       strcpy
   2602                  val = 0;
   \      0x232   0x2000             MOVS     R0,#+0
   \      0x234   0x0007             MOVS     R7,R0
   2603                  break;
   \      0x236   0xE04F             B.N      ??setChangeRegisterBit_11
   2604          
   2605              case ADDR_SESSION_ID_RO:
   2606                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)SESSION_ID_BIT_RO;
   \                     ??setChangeRegisterBit_7: (+1)
   \      0x238   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x23C   0x6801             LDR      R1,[R0, #+0]
   \      0x23E   0x4642             MOV      R2,R8
   \      0x240   0xB2D2             UXTB     R2,R2
   \      0x242   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x246   0x6800             LDR      R0,[R0, #+0]
   \      0x248   0x4642             MOV      R2,R8
   \      0x24A   0xB2D2             UXTB     R2,R2
   \      0x24C   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x250   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x254   0xF050 0x0020      ORRS     R0,R0,#0x20
   \      0x258   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2607                /*         destination     source */
   2608                strcpy((char *)strReg, AddrSessId);
   \      0x25C   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \      0x260   0xA805             ADD      R0,SP,#+20
   \      0x262   0x.... 0x....      BL       strcpy
   2609                val = pRoRegs->scuMapRegStatusMeas.evSessionId;
   \      0x266   0xF516 0x71D2      ADDS     R1,R6,#+420
   \      0x26A   0x6808             LDR      R0,[R1, #+0]
   \      0x26C   0x0007             MOVS     R7,R0
   2610                break;
   \      0x26E   0xE033             B.N      ??setChangeRegisterBit_11
   2611                
   2612              case ADDR_ENERGY_METERS_RW:
   2613          #ifdef COME_ERA
   2614                /* workaround: on detect EM type set EM error, so the SEM is ready to read it when receive the clearing alarm */
   2615                /* clearing is made by socket at the and of the detected procedure                                            */
   2616                pRoRegs->scuMapRegNotify.ntfErr1 |= ((uint16_t)ERROR1_EMTR);
   2617          #else
   2618                /* an energy meter has been detected, so an EM error must be removed */
   2619                pRoRegs->scuMapRegNotify.ntfErr1 &= (~(uint16_t)ERROR1_EMTR);
   \                     ??setChangeRegisterBit_1: (+1)
   \      0x270   0xF8B6 0x10FE      LDRH     R1,[R6, #+254]
   \      0x274   0xF64B 0x70FF      MOVW     R0,#+49151
   \      0x278   0x4001             ANDS     R1,R0,R1
   \      0x27A   0xF8A6 0x10FE      STRH     R1,[R6, #+254]
   2620          #endif
   2621                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)EVSE_ERROR1_BIT_RO;
   \      0x27E   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x282   0x6801             LDR      R1,[R0, #+0]
   \      0x284   0x4642             MOV      R2,R8
   \      0x286   0xB2D2             UXTB     R2,R2
   \      0x288   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x28C   0x6800             LDR      R0,[R0, #+0]
   \      0x28E   0x4642             MOV      R2,R8
   \      0x290   0xB2D2             UXTB     R2,R2
   \      0x292   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x296   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x29A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x29E   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2622                /*         destination           source */
   2623                strcpy((char *)strReg, AddrEm);
   \      0x2A2   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \      0x2A6   0xA805             ADD      R0,SP,#+20
   \      0x2A8   0x.... 0x....      BL       strcpy
   2624                break;
   \      0x2AC   0xE014             B.N      ??setChangeRegisterBit_11
   2625           
   2626              case ADDR_CURRENT_AC_L1_RO:
   2627              case ADDR_VOLTAGE_AC_RO:
   2628                /*   destination           source */
   2629                strcpy((char *)strReg, AddrMeasure);
   \                     ??setChangeRegisterBit_6: (+1)
   \      0x2AE   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \      0x2B2   0xA805             ADD      R0,SP,#+20
   \      0x2B4   0x.... 0x....      BL       strcpy
   2630                /* for measure upgrade no setting is necessary SEM read it automatically with polling */
   2631                result = SEND_ACK;
   \      0x2B8   0x2001             MOVS     R0,#+1
   \      0x2BA   0x4682             MOV      R10,R0
   2632                toPrint = toUpdate = FALSE;
   \      0x2BC   0x2000             MOVS     R0,#+0
   \      0x2BE   0x4681             MOV      R9,R0
   \      0x2C0   0xF88D 0x900C      STRB     R9,[SP, #+12]
   2633                break;
   \      0x2C4   0xE008             B.N      ??setChangeRegisterBit_11
   2634          
   2635              case ADDR_TIME_IN_CHARGE_RO:
   2636                /* for measure upgrade no setting is necessary SEM read it automatically with polling */
   2637                result = SEND_ACK;
   \                     ??setChangeRegisterBit_9: (+1)
   \      0x2C6   0x2001             MOVS     R0,#+1
   \      0x2C8   0x4682             MOV      R10,R0
   2638                toPrint = toUpdate = FALSE;
   \      0x2CA   0x2000             MOVS     R0,#+0
   \      0x2CC   0x4681             MOV      R9,R0
   \      0x2CE   0xF88D 0x900C      STRB     R9,[SP, #+12]
   2639                break;
   \      0x2D2   0xE001             B.N      ??setChangeRegisterBit_11
   2640                
   2641              default:
   2642                result = SEND_NULL;
   \                     ??setChangeRegisterBit_10: (+1)
   \      0x2D4   0x2000             MOVS     R0,#+0
   \      0x2D6   0x4682             MOV      R10,R0
   2643                break;
   2644            }
   2645            if (result == SEND_ACK)
   \                     ??setChangeRegisterBit_11: (+1)
   \      0x2D8   0x4650             MOV      R0,R10
   \      0x2DA   0xB2C0             UXTB     R0,R0
   \      0x2DC   0x2801             CMP      R0,#+1
   \      0x2DE   0xD133             BNE.N    ??setChangeRegisterBit_18
   2646            {
   2647              // if a slave has been removed from discovered list only at the end of discovery phase must inform SEM 
   2648              if ((isSemMasterFz() == TRUE) && (toUpdate == TRUE) && ((sbcSemInfoMng.activeLastDiscovery & mskBit) != 0))
   \      0x2E0   0x.... 0x....      BL       isSemMasterFz
   \      0x2E4   0x2801             CMP      R0,#+1
   \      0x2E6   0xD113             BNE.N    ??setChangeRegisterBit_19
   \      0x2E8   0x4648             MOV      R0,R9
   \      0x2EA   0xB2C0             UXTB     R0,R0
   \      0x2EC   0x2801             CMP      R0,#+1
   \      0x2EE   0xD10F             BNE.N    ??setChangeRegisterBit_19
   \      0x2F0   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \      0x2F4   0x6A00             LDR      R0,[R0, #+32]
   \      0x2F6   0x9910             LDR      R1,[SP, #+64]
   \      0x2F8   0x4208             TST      R0,R1
   \      0x2FA   0xD009             BEQ.N    ??setChangeRegisterBit_19
   2649              {
   2650                /* set the bit position for this SCU where the change occurred */
   2651                pScuRoMapReg->scuMapRegNotify.ntfChangeRo |= mskBit; 
   \      0x2FC   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x300   0x6802             LDR      R2,[R0, #+0]
   \      0x302   0xF8D2 0x10FA      LDR      R1,[R2, #+250]
   \      0x306   0x6802             LDR      R2,[R0, #+0]
   \      0x308   0x9810             LDR      R0,[SP, #+64]
   \      0x30A   0x4301             ORRS     R1,R0,R1
   \      0x30C   0xF8C2 0x10FA      STR      R1,[R2, #+250]
   2652              }
   2653              if (toPrint == TRUE)
   \                     ??setChangeRegisterBit_19: (+1)
   \      0x310   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \      0x314   0x2801             CMP      R0,#+1
   \      0x316   0xD117             BNE.N    ??setChangeRegisterBit_18
   2654              {
   2655                tPrintf("Socket %d Reg=0x%X %s Value= 0x%X at %s N=0x%X\n\r", getNumSocketLcd(deviceId), regChanged, strReg, val, getHmsStr(), pMsg->timeEntry);
   \      0x318   0x.... 0x....      BL       getHmsStr
   \      0x31C   0x4683             MOV      R11,R0
   \      0x31E   0x0028             MOVS     R0,R5
   \      0x320   0xB2C0             UXTB     R0,R0
   \      0x322   0x.... 0x....      BL       getNumSocketLcd
   \      0x326   0xF8D4 0x100E      LDR      R1,[R4, #+14]
   \      0x32A   0x9102             STR      R1,[SP, #+8]
   \      0x32C   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \      0x330   0x0039             MOVS     R1,R7
   \      0x332   0xB289             UXTH     R1,R1
   \      0x334   0x9100             STR      R1,[SP, #+0]
   \      0x336   0xAB05             ADD      R3,SP,#+20
   \      0x338   0xF8BD 0x200E      LDRH     R2,[SP, #+14]
   \      0x33C   0xB2C0             UXTB     R0,R0
   \      0x33E   0x0001             MOVS     R1,R0
   \      0x340   0x.... 0x....      LDR.W    R0,??DataTable16_10
   \      0x344   0x.... 0x....      BL       tPrintf
   2656              }
   2657            }
   2658            return(result);
   \                     ??setChangeRegisterBit_18: (+1)
   \      0x348   0x4650             MOV      R0,R10
   \      0x34A   0xB2C0             UXTB     R0,R0
   \                     ??setChangeRegisterBit_17: (+1)
   \      0x34C   0xB011             ADD      SP,SP,#+68
   \      0x34E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2659          }
   2660          
   2661          /**
   2662          *
   2663          * @brief       reset the property bit in the register change 
   2664          *              notification
   2665          *
   2666          * @param [in]  uint16_t: SCU logical index 00...31 
   2667          * @param [in]  uint16_t: base changed register 
   2668          * @param [in]  uint16_t: num word to be read  
   2669          *  
   2670          * @retval      uint8_t: success if TRUE 
   2671          *  
   2672          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2673          static uint8_t  resetChangeRegisterBit(uint16_t ixScu, uint16_t regChanged, uint16_t lenRd) 
   2674          {
   \                     resetChangeRegisterBit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   2675            scuRoMapRegister_st*  pScuIxRoMapReg;
   2676            uint8_t               result;
   2677          
   2678            result = FALSE;
   \        0xA   0x2700             MOVS     R7,#+0
   2679          
   2680            if ((regChanged == ADDR_EVSE_EVENT_FLAGS_RO) && (lenRd >= (ADDR_SCU_RESERVED6B - ADDR_EVSE_EVENT_FLAGS_RO)))
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0xB280             UXTH     R0,R0
   \       0x10   0xF5B0 0x6FC0      CMP      R0,#+1536
   \       0x14   0xD14C             BNE.N    ??resetChangeRegisterBit_0
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xB280             UXTH     R0,R0
   \       0x1A   0x286A             CMP      R0,#+106
   \       0x1C   0xDB48             BLT.N    ??resetChangeRegisterBit_0
   2681            {
   2682              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] = (uint16_t)0;
   \       0x1E   0x.... 0x....      LDR.W    R8,??DataTable15
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x28   0x0022             MOVS     R2,R4
   \       0x2A   0xB292             UXTH     R2,R2
   \       0x2C   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \       0x30   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2683              /* no more events to manage for this SCU, so the status bit can be resetted */
   2684              pScuRoMapReg->scuMapRegNotify.ntfChangeRo &= (~(uint32_t)sbcSemMaskBit[ixScu]);
   \       0x34   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x38   0xF8D0 0x10FA      LDR      R1,[R0, #+250]
   \       0x3C   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0x44   0x0023             MOVS     R3,R4
   \       0x46   0xB29B             UXTH     R3,R3
   \       0x48   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \       0x4C   0x4381             BICS     R1,R1,R0
   \       0x4E   0xF8C2 0x10FA      STR      R1,[R2, #+250]
   2685              pScuIxRoMapReg = getRoMdbRegs(ixScu);
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0x.... 0x....      BL       getRoMdbRegs
   \       0x5A   0x4681             MOV      R9,R0
   2686              if (pScuIxRoMapReg->scuMapRegStatusMeas.uidAuth[0] != 0)
   \       0x5C   0xF899 0x01C2      LDRB     R0,[R9, #+450]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD023             BEQ.N    ??resetChangeRegisterBit_1
   2687              {
   2688                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)UID_AUTHORIZATION_BIT); result = TRUE;
   \       0x64   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x68   0x0021             MOVS     R1,R4
   \       0x6A   0xB289             UXTH     R1,R1
   \       0x6C   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \       0x70   0xF8B0 0x1102      LDRH     R1,[R0, #+258]
   \       0x74   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0x78   0x4001             ANDS     R1,R0,R1
   \       0x7A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x7E   0x0022             MOVS     R2,R4
   \       0x80   0xB292             UXTH     R2,R2
   \       0x82   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \       0x86   0xF8A0 0x1102      STRH     R1,[R0, #+258]
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0x0007             MOVS     R7,R0
   2689                pScuIxRoMapReg->scuMapRegStatusMeas.uidAuth[0] = pScuRoMapReg->scuMapRegStatusMeas.uidAuth[1] = (uint8_t)0;
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x94   0xF881 0x01C3      STRB     R0,[R1, #+451]
   \       0x98   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x9C   0xF890 0x01C3      LDRB     R0,[R0, #+451]
   \       0xA0   0xF889 0x01C2      STRB     R0,[R9, #+450]
   2690                gsy_quick_polling_update(RFID_PENDING, 0);
   \       0xA4   0x2100             MOVS     R1,#+0
   \       0xA6   0x2010             MOVS     R0,#+16
   \       0xA8   0x.... 0x....      BL       gsy_quick_polling_update
   2691              }
   2692              return (TRUE);
   \                     ??resetChangeRegisterBit_1: (+1)
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0xE0F0             B.N      ??resetChangeRegisterBit_2
   2693            }
   2694              
   2695            /* reset the bit of the read register by SBC-SEM */
   2696            if (regChanged == ADDR_UID_AUTHORIZATION_RO)
   \                     ??resetChangeRegisterBit_0: (+1)
   \       0xB0   0x0028             MOVS     R0,R5
   \       0xB2   0xB280             UXTH     R0,R0
   \       0xB4   0xF5B0 0x6FCA      CMP      R0,#+1616
   \       0xB8   0xD122             BNE.N    ??resetChangeRegisterBit_3
   2697            {
   2698              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)UID_AUTHORIZATION_BIT); result = TRUE;
   \       0xBA   0x.... 0x....      LDR.W    R1,??DataTable15
   \       0xBE   0x6808             LDR      R0,[R1, #+0]
   \       0xC0   0x0022             MOVS     R2,R4
   \       0xC2   0xB292             UXTH     R2,R2
   \       0xC4   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \       0xC8   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \       0xCC   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0xD0   0x4002             ANDS     R2,R0,R2
   \       0xD2   0x6808             LDR      R0,[R1, #+0]
   \       0xD4   0x0023             MOVS     R3,R4
   \       0xD6   0xB29B             UXTH     R3,R3
   \       0xD8   0xEB00 0x0043      ADD      R0,R0,R3, LSL #+1
   \       0xDC   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0x0007             MOVS     R7,R0
   2699              pScuRoMapReg->scuMapRegStatusMeas.uidAuth[0] = pScuRoMapReg->scuMapRegStatusMeas.uidAuth[1] = (uint8_t)0;
   \       0xE4   0x2000             MOVS     R0,#+0
   \       0xE6   0x680A             LDR      R2,[R1, #+0]
   \       0xE8   0xF882 0x01C3      STRB     R0,[R2, #+451]
   \       0xEC   0x6808             LDR      R0,[R1, #+0]
   \       0xEE   0xF890 0x01C3      LDRB     R0,[R0, #+451]
   \       0xF2   0x6809             LDR      R1,[R1, #+0]
   \       0xF4   0xF881 0x01C2      STRB     R0,[R1, #+450]
   2700              gsy_quick_polling_update(RFID_PENDING, 0);
   \       0xF8   0x2100             MOVS     R1,#+0
   \       0xFA   0x2010             MOVS     R0,#+16
   \       0xFC   0x.... 0x....      BL       gsy_quick_polling_update
   2701            }
   2702            if (regChanged == ADDR_EVSE_EVENT_FLAGS_RO)
   \                     ??resetChangeRegisterBit_3: (+1)
   \      0x100   0x0028             MOVS     R0,R5
   \      0x102   0xB280             UXTH     R0,R0
   \      0x104   0xF5B0 0x6FC0      CMP      R0,#+1536
   \      0x108   0xD114             BNE.N    ??resetChangeRegisterBit_4
   2703            {
   2704              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)SOCKET_EVENT_FLAG_BIT); result = TRUE;
   \      0x10A   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x10E   0x6808             LDR      R0,[R1, #+0]
   \      0x110   0x0022             MOVS     R2,R4
   \      0x112   0xB292             UXTH     R2,R2
   \      0x114   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x118   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x11C   0xF64F 0x70FD      MOVW     R0,#+65533
   \      0x120   0x4002             ANDS     R2,R0,R2
   \      0x122   0x6808             LDR      R0,[R1, #+0]
   \      0x124   0x0021             MOVS     R1,R4
   \      0x126   0xB289             UXTH     R1,R1
   \      0x128   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x12C   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x130   0x2001             MOVS     R0,#+1
   \      0x132   0x0007             MOVS     R7,R0
   2705            }
   2706            if (regChanged == ADDR_EVSE_CHARGE_STATUS_RO)
   \                     ??resetChangeRegisterBit_4: (+1)
   \      0x134   0x0028             MOVS     R0,R5
   \      0x136   0xF240 0x6101      MOVW     R1,#+1537
   \      0x13A   0xB280             UXTH     R0,R0
   \      0x13C   0x4288             CMP      R0,R1
   \      0x13E   0xD114             BNE.N    ??resetChangeRegisterBit_5
   2707            {
   2708              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)EVSE_CONNECTOR_STATUS_BIT_RO); result = TRUE;
   \      0x140   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x144   0x6808             LDR      R0,[R1, #+0]
   \      0x146   0x0022             MOVS     R2,R4
   \      0x148   0xB292             UXTH     R2,R2
   \      0x14A   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x14E   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x152   0xF64F 0x70FB      MOVW     R0,#+65531
   \      0x156   0x4002             ANDS     R2,R0,R2
   \      0x158   0x6808             LDR      R0,[R1, #+0]
   \      0x15A   0x0021             MOVS     R1,R4
   \      0x15C   0xB289             UXTH     R1,R1
   \      0x15E   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x162   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x166   0x2001             MOVS     R0,#+1
   \      0x168   0x0007             MOVS     R7,R0
   2709            }
   2710            if ((regChanged <= ADDR_EVSE_ERROR1_RO) && (regChanged + lenRd > ADDR_EVSE_ERROR1_RO))
   \                     ??resetChangeRegisterBit_5: (+1)
   \      0x16A   0xF240 0x4005      MOVW     R0,#+1029
   \      0x16E   0x0029             MOVS     R1,R5
   \      0x170   0xB289             UXTH     R1,R1
   \      0x172   0x4281             CMP      R1,R0
   \      0x174   0xDA1A             BGE.N    ??resetChangeRegisterBit_6
   \      0x176   0x0031             MOVS     R1,R6
   \      0x178   0xB289             UXTH     R1,R1
   \      0x17A   0xFA11 0xF185      UXTAH    R1,R1,R5
   \      0x17E   0x4281             CMP      R1,R0
   \      0x180   0xDB14             BLT.N    ??resetChangeRegisterBit_6
   2711            {
   2712              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)EVSE_ERROR1_BIT_RO); result = TRUE;
   \      0x182   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x186   0x6808             LDR      R0,[R1, #+0]
   \      0x188   0x0022             MOVS     R2,R4
   \      0x18A   0xB292             UXTH     R2,R2
   \      0x18C   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x190   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x194   0xF64F 0x70F7      MOVW     R0,#+65527
   \      0x198   0x4002             ANDS     R2,R0,R2
   \      0x19A   0x6808             LDR      R0,[R1, #+0]
   \      0x19C   0x0021             MOVS     R1,R4
   \      0x19E   0xB289             UXTH     R1,R1
   \      0x1A0   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x1A4   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x1A8   0x2001             MOVS     R0,#+1
   \      0x1AA   0x0007             MOVS     R7,R0
   2713            }
   2714            if ((regChanged <= ADDR_EVSE_ERROR2_RO) && (regChanged + lenRd > ADDR_EVSE_ERROR2_RO))
   \                     ??resetChangeRegisterBit_6: (+1)
   \      0x1AC   0xF240 0x4006      MOVW     R0,#+1030
   \      0x1B0   0x0029             MOVS     R1,R5
   \      0x1B2   0xB289             UXTH     R1,R1
   \      0x1B4   0x4281             CMP      R1,R0
   \      0x1B6   0xDA1A             BGE.N    ??resetChangeRegisterBit_7
   \      0x1B8   0x0031             MOVS     R1,R6
   \      0x1BA   0xB289             UXTH     R1,R1
   \      0x1BC   0xFA11 0xF185      UXTAH    R1,R1,R5
   \      0x1C0   0x4281             CMP      R1,R0
   \      0x1C2   0xDB14             BLT.N    ??resetChangeRegisterBit_7
   2715            {
   2716              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)EVSE_ERROR2_BIT_RO); result = TRUE;
   \      0x1C4   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x1C8   0x6808             LDR      R0,[R1, #+0]
   \      0x1CA   0x0022             MOVS     R2,R4
   \      0x1CC   0xB292             UXTH     R2,R2
   \      0x1CE   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x1D2   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x1D6   0xF64F 0x70EF      MOVW     R0,#+65519
   \      0x1DA   0x4002             ANDS     R2,R0,R2
   \      0x1DC   0x6808             LDR      R0,[R1, #+0]
   \      0x1DE   0x0021             MOVS     R1,R4
   \      0x1E0   0xB289             UXTH     R1,R1
   \      0x1E2   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x1E6   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x1EA   0x2001             MOVS     R0,#+1
   \      0x1EC   0x0007             MOVS     R7,R0
   2717            }
   2718            if (regChanged == ADDR_CONNECTOR_TYPE_RW)
   \                     ??resetChangeRegisterBit_7: (+1)
   \      0x1EE   0x0028             MOVS     R0,R5
   \      0x1F0   0xB280             UXTH     R0,R0
   \      0x1F2   0x2800             CMP      R0,#+0
   \      0x1F4   0xD114             BNE.N    ??resetChangeRegisterBit_8
   2719            {
   2720              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)CONFIGURATIONS_BIT_RW); result = TRUE;
   \      0x1F6   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x1FA   0x6808             LDR      R0,[R1, #+0]
   \      0x1FC   0x0022             MOVS     R2,R4
   \      0x1FE   0xB292             UXTH     R2,R2
   \      0x200   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x204   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x208   0xF64F 0x50FF      MOVW     R0,#+65023
   \      0x20C   0x4002             ANDS     R2,R0,R2
   \      0x20E   0x6808             LDR      R0,[R1, #+0]
   \      0x210   0x0021             MOVS     R1,R4
   \      0x212   0xB289             UXTH     R1,R1
   \      0x214   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x218   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x21C   0x2001             MOVS     R0,#+1
   \      0x21E   0x0007             MOVS     R7,R0
   2721            }
   2722            if (regChanged == ADDR_SESSION_ID_RO)
   \                     ??resetChangeRegisterBit_8: (+1)
   \      0x220   0x0028             MOVS     R0,R5
   \      0x222   0xF240 0x6141      MOVW     R1,#+1601
   \      0x226   0xB280             UXTH     R0,R0
   \      0x228   0x4288             CMP      R0,R1
   \      0x22A   0xD114             BNE.N    ??resetChangeRegisterBit_9
   2723            {
   2724              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)SESSION_ID_BIT_RO); result = TRUE;
   \      0x22C   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x230   0x6808             LDR      R0,[R1, #+0]
   \      0x232   0x0022             MOVS     R2,R4
   \      0x234   0xB292             UXTH     R2,R2
   \      0x236   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x23A   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x23E   0xF64F 0x70DF      MOVW     R0,#+65503
   \      0x242   0x4002             ANDS     R2,R0,R2
   \      0x244   0x6808             LDR      R0,[R1, #+0]
   \      0x246   0x0021             MOVS     R1,R4
   \      0x248   0xB289             UXTH     R1,R1
   \      0x24A   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x24E   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x252   0x2001             MOVS     R0,#+1
   \      0x254   0x0007             MOVS     R7,R0
   2725            }
   2726          
   2727            if (result == TRUE)
   \                     ??resetChangeRegisterBit_9: (+1)
   \      0x256   0x0038             MOVS     R0,R7
   \      0x258   0xB2C0             UXTB     R0,R0
   \      0x25A   0x2801             CMP      R0,#+1
   \      0x25C   0xD117             BNE.N    ??resetChangeRegisterBit_10
   2728            {
   2729              if (pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] == (uint16_t)0)
   \      0x25E   0x.... 0x....      LDR.W    R2,??DataTable15
   \      0x262   0x6810             LDR      R0,[R2, #+0]
   \      0x264   0x0021             MOVS     R1,R4
   \      0x266   0xB289             UXTH     R1,R1
   \      0x268   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x26C   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x270   0x2800             CMP      R0,#+0
   \      0x272   0xD10C             BNE.N    ??resetChangeRegisterBit_10
   2730              {
   2731                /* no more events to manage for this SCU, so the status bit can be resetted */
   2732                pScuRoMapReg->scuMapRegNotify.ntfChangeRo &= (~(uint32_t)sbcSemMaskBit[ixScu]);
   \      0x274   0x6810             LDR      R0,[R2, #+0]
   \      0x276   0xF8D0 0x10FA      LDR      R1,[R0, #+250]
   \      0x27A   0x6812             LDR      R2,[R2, #+0]
   \      0x27C   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x280   0x0023             MOVS     R3,R4
   \      0x282   0xB29B             UXTH     R3,R3
   \      0x284   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \      0x288   0x4381             BICS     R1,R1,R0
   \      0x28A   0xF8C2 0x10FA      STR      R1,[R2, #+250]
   2733              }
   2734            }
   2735            return(result);
   \                     ??resetChangeRegisterBit_10: (+1)
   \      0x28E   0x0038             MOVS     R0,R7
   \      0x290   0xB2C0             UXTB     R0,R0
   \                     ??resetChangeRegisterBit_2: (+1)
   \      0x292   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2736          }
   2737          
   2738          /**
   2739          *
   2740          * @brief       set the property UID bytes in the registers 
   2741          *
   2742          * @param [in]  none 
   2743          *  
   2744          * @retval      none 
   2745          *  
   2746          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2747          void setUIDinfoROmap (void) 
   2748          {
   \                     setUIDinfoROmap: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   2749            scuRoMapRegister_st*    pRoRegs;
   2750            uint8_t                 mdbAddr;
   2751          
   2752            mdbAddr = getLogicalMdbAddrSem();
   \        0x2   0x.... 0x....      BL       getLogicalMdbAddrSem
   \        0x6   0x0005             MOVS     R5,R0
   2753            pRoRegs = getRoMdbRegs(mdbAddr);
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x.... 0x....      BL       getRoMdbRegs
   \       0x10   0x0004             MOVS     R4,R0
   2754          
   2755            /* set in the map the right value for len, card type and UID */
   2756            rfid_uid_get((uint8_t *)&pRoRegs->scuMapRegStatusMeas.uidAuth[2], (sl030_type_en*)(&pRoRegs->scuMapRegStatusMeas.uidAuth[1]));
   \       0x12   0xF204 0x11C3      ADDW     R1,R4,#+451
   \       0x16   0xF514 0x70E2      ADDS     R0,R4,#+452
   \       0x1A   0x.... 0x....      BL       rfid_uid_get
   2757            if ((pRoRegs->scuMapRegStatusMeas.uidAuth[6] == 0) && (pRoRegs->scuMapRegStatusMeas.uidAuth[7] == 0) &&
   2758                (pRoRegs->scuMapRegStatusMeas.uidAuth[8] == 0) && (pRoRegs->scuMapRegStatusMeas.uidAuth[9] == 0))
   \       0x1E   0xF894 0x01C8      LDRB     R0,[R4, #+456]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10F             BNE.N    ??setUIDinfoROmap_0
   \       0x26   0xF894 0x01C9      LDRB     R0,[R4, #+457]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD10B             BNE.N    ??setUIDinfoROmap_0
   \       0x2E   0xF894 0x01CA      LDRB     R0,[R4, #+458]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD107             BNE.N    ??setUIDinfoROmap_0
   \       0x36   0xF894 0x01CB      LDRB     R0,[R4, #+459]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD103             BNE.N    ??setUIDinfoROmap_0
   2759            {
   2760              pRoRegs->scuMapRegStatusMeas.uidAuth[0] = (uint8_t)4;
   \       0x3E   0x2004             MOVS     R0,#+4
   \       0x40   0xF884 0x01C2      STRB     R0,[R4, #+450]
   \       0x44   0xE002             B.N      ??setUIDinfoROmap_1
   2761            }
   2762            else
   2763            {
   2764              pRoRegs->scuMapRegStatusMeas.uidAuth[0] = (uint8_t)7;
   \                     ??setUIDinfoROmap_0: (+1)
   \       0x46   0x2007             MOVS     R0,#+7
   \       0x48   0xF884 0x01C2      STRB     R0,[R4, #+450]
   2765            }
   2766          }
   \                     ??setUIDinfoROmap_1: (+1)
   \       0x4C   0xBD31             POP      {R0,R4,R5,PC}
   2767          
   2768          /**
   2769          *
   2770          * @brief        callback to manager timers   
   2771          *
   2772          * @param [in]   TimerHandle_t: the elapsed timer 
   2773          *
   2774          * @retval       none
   2775          *
   2776          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2777          static void sbcSemTimCallBack (TimerHandle_t pxTimer)
   2778          {
   \                     sbcSemTimCallBack: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x0004             MOVS     R4,R0
   2779            frameSbcSem_st        tmpFrameSbcSem;  
   2780            uint32_t              timer_id, val;
   2781            scuOpModes_e          locScuMode;
   2782            uint8_t               result;
   2783          
   2784            /* find the led  which the timer is referred */
   2785            timer_id = (uint32_t)pvTimerGetTimerID(pxTimer);
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       pvTimerGetTimerID
   \        0xE   0x0006             MOVS     R6,R0
   2786          
   2787            switch (timer_id)
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD00A             BEQ.N    ??sbcSemTimCallBack_0
   \       0x14   0x2E02             CMP      R6,#+2
   \       0x16   0xF000 0x81DE      BEQ.W    ??sbcSemTimCallBack_1
   \       0x1A   0xF0C0 0x813D      BCC.W    ??sbcSemTimCallBack_2
   \       0x1E   0x2E04             CMP      R6,#+4
   \       0x20   0xF000 0x81FA      BEQ.W    ??sbcSemTimCallBack_3
   \       0x24   0xF0C0 0x81DA      BCC.W    ??sbcSemTimCallBack_4
   \       0x28   0xE24B             B.N      ??sbcSemTimCallBack_5
   2788            {
   2789              case (uint32_t)TIMER_FIND_CONFIG:
   2790                switch (sbcSemInfoMng.sbcSemStates)
   \                     ??sbcSemTimCallBack_0: (+1)
   \       0x2A   0x.... 0x....      LDR.W    R7,??DataTable16_9
   \       0x2E   0x8838             LDRH     R0,[R7, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD008             BEQ.N    ??sbcSemTimCallBack_6
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD05F             BEQ.N    ??sbcSemTimCallBack_7
   \       0x38   0x2804             CMP      R0,#+4
   \       0x3A   0xF000 0x80F3      BEQ.W    ??sbcSemTimCallBack_8
   \       0x3E   0x280C             CMP      R0,#+12
   \       0x40   0xF000 0x80CB      BEQ.W    ??sbcSemTimCallBack_9
   \       0x44   0xE127             B.N      ??sbcSemTimCallBack_10
   2791                {
   2792                  case SBC_SEM_INIT_DISCOVERY:
   2793                    if (isSemMasterFz() == TRUE)
   \                     ??sbcSemTimCallBack_6: (+1)
   \       0x46   0x.... 0x....      BL       isSemMasterFz
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xD12D             BNE.N    ??sbcSemTimCallBack_11
   2794                    {
   2795                      sbcSemInfoMng.dataVal = (uint16_t)SCU_S_PS_STARTUP;  // for discovery slave SCU (slave primary, i.e with TFT or slave secondary) 
   \       0x4E   0x2004             MOVS     R0,#+4
   \       0x50   0x80B8             STRH     R0,[R7, #+4]
   2796                      tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \       0x52   0x2003             MOVS     R0,#+3
   \       0x54   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   2797                      tmpFrameSbcSem.data.index = MODBUS_BROADCAST_ADDR;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   2798                      tmpFrameSbcSem.data.rAddr = ADDR_EVSE_TM_RW;
   \       0x5E   0x2022             MOVS     R0,#+34
   \       0x60   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   2799                      tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \       0x64   0x1D38             ADDS     R0,R7,#+4
   \       0x66   0x9004             STR      R0,[SP, #+16]
   2800                      tmpFrameSbcSem.dataToSend.len = LEN_EVSE_TM_MODE_RW;
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   2801                      configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \       0x6E   0x.... 0x....      BL       getRs485SemQueueHandle
   \       0x72   0x2300             MOVS     R3,#+0
   \       0x74   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x78   0xA902             ADD      R1,SP,#+8
   \       0x7A   0x.... 0x....      BL       xQueueGenericSend
   \       0x7E   0x2801             CMP      R0,#+1
   \       0x80   0xD009             BEQ.N    ??sbcSemTimCallBack_12
   \       0x82   0xB672             CPSID    I
   \       0x84   0x2050             MOVS     R0,#+80
   \       0x86   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x8A   0xF3BF 0x8F4F      DSB      SY
   \       0x8E   0xF3BF 0x8F6F      ISB      SY
   \       0x92   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_13: (+1)
   \       0x94   0xE7FE             B.N      ??sbcSemTimCallBack_13
   2802                      restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_DISCOVERY_SLAVE); // the master restart the timeout 1000msec
   \                     ??sbcSemTimCallBack_12: (+1)
   \       0x96   0xF44F 0x717A      MOV      R1,#+1000
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x.... 0x....      BL       restartSbcSemTimer
   2803                      sbcSemInfoMng.activityStatus = 0; 
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0x6178             STR      R0,[R7, #+20]
   2804                      sbcSemInfoMng.sbcSemStates = SBC_SEM_DISCOVERY_S;
   \       0xA4   0x2001             MOVS     R0,#+1
   \       0xA6   0x8038             STRH     R0,[R7, #+0]
   \       0xA8   0xE025             B.N      ??sbcSemTimCallBack_14
   2805                    }
   2806                    else
   2807                    {
   2808                      /* the ack coming from expected socket */
   2809                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \                     ??sbcSemTimCallBack_11: (+1)
   \       0xAA   0x2004             MOVS     R0,#+4
   \       0xAC   0x8038             STRH     R0,[R7, #+0]
   2810                      locScuMode = getScuOpMode();
   \       0xAE   0x.... 0x....      BL       getScuOpMode
   \       0xB2   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   2811                      if ((locScuMode == SCU_S_P) || (locScuMode == SCU_S_S))
   \       0xB6   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \       0xBA   0x2803             CMP      R0,#+3
   \       0xBC   0xD003             BEQ.N    ??sbcSemTimCallBack_15
   \       0xBE   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \       0xC2   0x2804             CMP      R0,#+4
   \       0xC4   0xD117             BNE.N    ??sbcSemTimCallBack_14
   2812                      {
   2813                        /* after update it is necessary a slave must inform the master about new FW   */
   2814                        val = HAL_RTCEx_BKUPRead((RTC_HandleTypeDef*) getHandleRtc(), BACKUP_HW_INFO);
   \                     ??sbcSemTimCallBack_15: (+1)
   \       0xC6   0x.... 0x....      BL       getHandleRtc
   \       0xCA   0x2109             MOVS     R1,#+9
   \       0xCC   0x.... 0x....      BL       HAL_RTCEx_BKUPRead
   \       0xD0   0x0005             MOVS     R5,R0
   2815                        if ((val & NOTIFY_FW_UPD_MASK) == NOTIFY_FW_UPD_FLAG)
   \       0xD2   0xF415 0x1040      ANDS     R0,R5,#0x300000
   \       0xD6   0xF5B0 0x1F80      CMP      R0,#+1048576
   \       0xDA   0xD10C             BNE.N    ??sbcSemTimCallBack_14
   2816                        {
   2817                          /* reset the flag */
   2818                          val &= (~NOTIFY_FW_UPD_MASK);
   \       0xDC   0xF435 0x1540      BICS     R5,R5,#0x300000
   2819                          HAL_RTCEx_BKUPWrite((RTC_HandleTypeDef*)getHandleRtc(), (uint32_t)BACKUP_HW_INFO, val);       
   \       0xE0   0x.... 0x....      BL       getHandleRtc
   \       0xE4   0x002A             MOVS     R2,R5
   \       0xE6   0x2109             MOVS     R1,#+9
   \       0xE8   0x.... 0x....      BL       HAL_RTCEx_BKUPWrite
   2820                          /* send the info on communication error   */
   2821                          sendEventToSemMng(NOTIFY_TO_MASTER_TX, ADDR_EVSE_ERROR2_RO);
   \       0xEC   0xF240 0x4105      MOVW     R1,#+1029
   \       0xF0   0x2002             MOVS     R0,#+2
   \       0xF2   0x.... 0x....      BL       sendEventToSemMng
   2822                        }
   2823                      }
   2824                    }
   2825                    break;
   \                     ??sbcSemTimCallBack_14: (+1)
   \       0xF6   0xE0CE             B.N      ??sbcSemTimCallBack_16
   2826          
   2827                  case SBC_SEM_DISCOVERY_S:
   2828                    /* no more master secondary SCU are present in the chain */
   2829                    if ((socketPresence.livePresence & (~SCU_MASTER_MASK_BIT)) == 0)
   \                     ??sbcSemTimCallBack_7: (+1)
   \       0xF8   0x.... 0x....      LDR.W    R8,??DataTable22
   \       0xFC   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \      0x100   0x0840             LSRS     R0,R0,#+1
   \      0x102   0x0040             LSLS     R0,R0,#+1
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD11E             BNE.N    ??sbcSemTimCallBack_17
   2830                    {
   2831                      pScuRoMapReg->scuMapRegNotify.ntfPresences = (uint32_t)0x01; // only SCU master is present --> stand alone socket
   \      0x108   0x.... 0x....      LDR.W    R9,??DataTable15
   \      0x10C   0xF05F 0x0A01      MOVS     R10,#+1
   \      0x110   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x114   0xF8C0 0xA0F6      STR      R10,[R0, #+246]
   2832                      socketPresence.chainPresence |= (uint32_t)0x01;
   \      0x118   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x11C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x120   0xF8C8 0x0000      STR      R0,[R8, #+0]
   2833                      /* the alive task must be started to check if a slave will be connected   */
   2834                      sbcSemInfoMng.discoveryMask = 0;
   \      0x124   0xF117 0x0B0A      ADDS     R11,R7,#+10
   \      0x128   0x2000             MOVS     R0,#+0
   \      0x12A   0xF8CB 0x0000      STR      R0,[R11, #+0]
   2835                      if (getScuOpMode() == SCU_M_STAND_ALONE)
   \      0x12E   0x.... 0x....      BL       getScuOpMode
   \      0x132   0x2805             CMP      R0,#+5
   \      0x134   0xD119             BNE.N    ??sbcSemTimCallBack_18
   2836                      {
   2837                        /* set initial socket info */
   2838                        sbcSemInfoMng.discoveryMask = (uint32_t)0x1;
   \      0x136   0xF8CB 0xA000      STR      R10,[R11, #+0]
   2839                        /* only the SCU Isolated is present For SEM this SCU must be put in OFF-LINE */
   2840                        pScuRoMapReg->scuMapRegStatusMeas.ntfChgStat = (uint16_t)MDBSTATE_UNAVAILABLE;
   \      0x13A   0x2009             MOVS     R0,#+9
   \      0x13C   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x140   0xF8A1 0x0124      STRH     R0,[R1, #+292]
   \      0x144   0xE011             B.N      ??sbcSemTimCallBack_18
   2841                      }
   2842                    }
   2843                    else
   2844                    {
   2845                      if (getRemotePmFlag() == FALSE) setPmRemoteSemFlag(TRUE); // we are working in SEM with one slave present atleast 
   \                     ??sbcSemTimCallBack_17: (+1)
   \      0x146   0x.... 0x....      BL       getRemotePmFlag
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD102             BNE.N    ??sbcSemTimCallBack_19
   \      0x14E   0x2001             MOVS     R0,#+1
   \      0x150   0x.... 0x....      BL       setPmRemoteSemFlag
   2846                      if (getScuOpMode() == SCU_M_STAND_ALONE)
   \                     ??sbcSemTimCallBack_19: (+1)
   \      0x154   0x.... 0x....      BL       getScuOpMode
   \      0x158   0x2805             CMP      R0,#+5
   \      0x15A   0xD103             BNE.N    ??sbcSemTimCallBack_20
   2847                      {
   2848                        /* set initial socket info */
   2849                        sbcSemInfoMng.discoveryMask = (uint32_t)0x1;
   \      0x15C   0x2001             MOVS     R0,#+1
   \      0x15E   0xF8C7 0x000A      STR      R0,[R7, #+10]
   \      0x162   0xE002             B.N      ??sbcSemTimCallBack_18
   2850                      }
   2851                      else
   2852                      {
   2853                        /* set initial socket info */
   2854                        sbcSemInfoMng.discoveryMask = (uint32_t)0x2;
   \                     ??sbcSemTimCallBack_20: (+1)
   \      0x164   0x2002             MOVS     R0,#+2
   \      0x166   0xF8C7 0x000A      STR      R0,[R7, #+10]
   2855                      }
   2856                    }
   2857                    sbcSemInfoMng.activityStatus = socketPresence.livePresence; // set mask for discovery procedure
   \                     ??sbcSemTimCallBack_18: (+1)
   \      0x16A   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \      0x16E   0x6178             STR      R0,[R7, #+20]
   2858          
   2859                    sbcSemInfoMng.addrVal = ADDR_START_RDD;  // to get info on  discovered primary/secondary slave an master SCU 
   \      0x170   0xF44F 0x7040      MOV      R0,#+768
   \      0x174   0x80F8             STRH     R0,[R7, #+6]
   2860                    tmpFrameSbcSem.sbcSemEvent = RECOVERY_INFO;
   \      0x176   0x2104             MOVS     R1,#+4
   \      0x178   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   2861                    tmpFrameSbcSem.data.rAddr = sbcSemInfoMng.addrVal = ADDR_START_RDD;
   \      0x17C   0x80F8             STRH     R0,[R7, #+6]
   \      0x17E   0x88F8             LDRH     R0,[R7, #+6]
   \      0x180   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   2862                    sbcSemInfoMng.sbcSemStates = SBC_SEM_RECOVERY_INFO;
   \      0x184   0x2002             MOVS     R0,#+2
   \      0x186   0x8038             STRH     R0,[R7, #+0]
   2863                    if (getScuOpMode() == SCU_M_P)
   \      0x188   0x.... 0x....      BL       getScuOpMode
   \      0x18C   0x2802             CMP      R0,#+2
   \      0x18E   0xD105             BNE.N    ??sbcSemTimCallBack_21
   2864                    {
   2865                      /* set initial socket info */
   2866                      sbcSemInfoMng.logicIdSocket = (uint16_t)0x1;
   \      0x190   0x2001             MOVS     R0,#+1
   \      0x192   0x8138             STRH     R0,[R7, #+8]
   2867                      tmpFrameSbcSem.data.index = (uint16_t)0x1;
   \      0x194   0x2001             MOVS     R0,#+1
   \      0x196   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   \      0x19A   0xE004             B.N      ??sbcSemTimCallBack_22
   2868                    }
   2869                    else
   2870                    {
   2871                      /* SCU_M_STAND_ALONE case */
   2872                      sbcSemInfoMng.logicIdSocket = (uint16_t)0x0;
   \                     ??sbcSemTimCallBack_21: (+1)
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0x8138             STRH     R0,[R7, #+8]
   2873                      tmpFrameSbcSem.data.index = (uint16_t)0x0;
   \      0x1A0   0x2000             MOVS     R0,#+0
   \      0x1A2   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   2874                    }
   2875                    tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \                     ??sbcSemTimCallBack_22: (+1)
   \      0x1A6   0x.... 0x....      BL       getPacketStatusNum
   \      0x1AA   0xF10D 0x0116      ADD      R1,SP,#+22
   \      0x1AE   0x6008             STR      R0,[R1, #+0]
   2876                    configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \      0x1B0   0x.... 0x....      BL       getSbcSemQueueHandle
   \      0x1B4   0x2300             MOVS     R3,#+0
   \      0x1B6   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x1BA   0xA902             ADD      R1,SP,#+8
   \      0x1BC   0x.... 0x....      BL       xQueueGenericSend
   \      0x1C0   0x2801             CMP      R0,#+1
   \      0x1C2   0xD009             BEQ.N    ??sbcSemTimCallBack_23
   \      0x1C4   0xB672             CPSID    I
   \      0x1C6   0x2050             MOVS     R0,#+80
   \      0x1C8   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x1CC   0xF3BF 0x8F4F      DSB      SY
   \      0x1D0   0xF3BF 0x8F6F      ISB      SY
   \      0x1D4   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_24: (+1)
   \      0x1D6   0xE7FE             B.N      ??sbcSemTimCallBack_24
   2877                    break;
   \                     ??sbcSemTimCallBack_23: (+1)
   \      0x1D8   0xE05D             B.N      ??sbcSemTimCallBack_16
   2878          
   2879                  case SBC_SEM_WAIT_TO_BE_OPERATIVE:
   2880                    /* the ack coming from expected socket */
   2881                    locScuMode = getScuOpMode();
   \                     ??sbcSemTimCallBack_9: (+1)
   \      0x1DA   0x.... 0x....      BL       getScuOpMode
   \      0x1DE   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   2882                    if ((locScuMode == SCU_S_P) || (locScuMode == SCU_S_S))
   \      0x1E2   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x1E6   0x2803             CMP      R0,#+3
   \      0x1E8   0xD003             BEQ.N    ??sbcSemTimCallBack_25
   \      0x1EA   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x1EE   0x2804             CMP      R0,#+4
   \      0x1F0   0xD117             BNE.N    ??sbcSemTimCallBack_26
   2883                    {
   2884                      /* after update it is necessary a slave must inform the master about new FW   */
   2885                      val = HAL_RTCEx_BKUPRead((RTC_HandleTypeDef*) getHandleRtc(), BACKUP_HW_INFO);
   \                     ??sbcSemTimCallBack_25: (+1)
   \      0x1F2   0x.... 0x....      BL       getHandleRtc
   \      0x1F6   0x2109             MOVS     R1,#+9
   \      0x1F8   0x.... 0x....      BL       HAL_RTCEx_BKUPRead
   \      0x1FC   0x0005             MOVS     R5,R0
   2886                      if ((val & NOTIFY_FW_UPD_MASK) == NOTIFY_FW_UPD_FLAG)
   \      0x1FE   0xF415 0x1040      ANDS     R0,R5,#0x300000
   \      0x202   0xF5B0 0x1F80      CMP      R0,#+1048576
   \      0x206   0xD10C             BNE.N    ??sbcSemTimCallBack_26
   2887                      {
   2888                        /* reset the flag */
   2889                        val &= (~NOTIFY_FW_UPD_MASK);
   \      0x208   0xF435 0x1540      BICS     R5,R5,#0x300000
   2890                        HAL_RTCEx_BKUPWrite((RTC_HandleTypeDef*)getHandleRtc(), (uint32_t)BACKUP_HW_INFO, val);       
   \      0x20C   0x.... 0x....      BL       getHandleRtc
   \      0x210   0x002A             MOVS     R2,R5
   \      0x212   0x2109             MOVS     R1,#+9
   \      0x214   0x.... 0x....      BL       HAL_RTCEx_BKUPWrite
   2891                        /* send the info on communication error   */
   2892                        sendEventToSemMng(NOTIFY_TO_MASTER_TX, ADDR_EVSE_ERROR2_RO);
   \      0x218   0xF240 0x4105      MOVW     R1,#+1029
   \      0x21C   0x2002             MOVS     R0,#+2
   \      0x21E   0x.... 0x....      BL       sendEventToSemMng
   2893                      }
   2894                    }
   2895                    break;
   \                     ??sbcSemTimCallBack_26: (+1)
   \      0x222   0xE038             B.N      ??sbcSemTimCallBack_16
   2896          
   2897                  case SBC_SEM_OPERATIVE:
   2898                    sbcSemInfoMng.addrVal = ADDR_START_RDD;  // to get info on  discovered primary/secondary slave an master SCU 
   \                     ??sbcSemTimCallBack_8: (+1)
   \      0x224   0xF44F 0x7040      MOV      R0,#+768
   \      0x228   0x80F8             STRH     R0,[R7, #+6]
   2899                    tmpFrameSbcSem.sbcSemEvent = RECOVERY_INFO;
   \      0x22A   0x2104             MOVS     R1,#+4
   \      0x22C   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   2900                    tmpFrameSbcSem.data.rAddr = sbcSemInfoMng.addrVal = ADDR_START_RDD;
   \      0x230   0x80F8             STRH     R0,[R7, #+6]
   \      0x232   0x88F8             LDRH     R0,[R7, #+6]
   \      0x234   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   2901                    /* set initial socket info */
   2902                    if (getScuOpMode() == SCU_M_P)
   \      0x238   0x.... 0x....      BL       getScuOpMode
   \      0x23C   0x2802             CMP      R0,#+2
   \      0x23E   0xD108             BNE.N    ??sbcSemTimCallBack_27
   2903                    {
   2904                      /* set initial socket info */
   2905                      sbcSemInfoMng.discoveryMask = (uint32_t)0x2;
   \      0x240   0x2002             MOVS     R0,#+2
   \      0x242   0xF8C7 0x000A      STR      R0,[R7, #+10]
   2906                      sbcSemInfoMng.logicIdSocket = (uint16_t)0x1;
   \      0x246   0x2001             MOVS     R0,#+1
   \      0x248   0x8138             STRH     R0,[R7, #+8]
   2907                      tmpFrameSbcSem.data.index = (uint16_t)0x1;
   \      0x24A   0x2001             MOVS     R0,#+1
   \      0x24C   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   \      0x250   0xE007             B.N      ??sbcSemTimCallBack_28
   2908                    }
   2909                    else
   2910                    {
   2911                      /* SCU_M_STAND_ALONE case */
   2912                      sbcSemInfoMng.discoveryMask = (uint32_t)0x1;
   \                     ??sbcSemTimCallBack_27: (+1)
   \      0x252   0x2001             MOVS     R0,#+1
   \      0x254   0xF8C7 0x000A      STR      R0,[R7, #+10]
   2913                      sbcSemInfoMng.logicIdSocket = (uint16_t)0x0;
   \      0x258   0x2000             MOVS     R0,#+0
   \      0x25A   0x8138             STRH     R0,[R7, #+8]
   2914                      tmpFrameSbcSem.data.index = (uint16_t)0x0;
   \      0x25C   0x2000             MOVS     R0,#+0
   \      0x25E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   2915                    }
   2916                    tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \                     ??sbcSemTimCallBack_28: (+1)
   \      0x262   0x.... 0x....      BL       getPacketStatusNum
   \      0x266   0xF10D 0x0116      ADD      R1,SP,#+22
   \      0x26A   0x6008             STR      R0,[R1, #+0]
   2917                    configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \      0x26C   0x.... 0x....      BL       getSbcSemQueueHandle
   \      0x270   0x2300             MOVS     R3,#+0
   \      0x272   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x276   0xA902             ADD      R1,SP,#+8
   \      0x278   0x.... 0x....      BL       xQueueGenericSend
   \      0x27C   0x2801             CMP      R0,#+1
   \      0x27E   0xD009             BEQ.N    ??sbcSemTimCallBack_29
   \      0x280   0xB672             CPSID    I
   \      0x282   0x2050             MOVS     R0,#+80
   \      0x284   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x288   0xF3BF 0x8F4F      DSB      SY
   \      0x28C   0xF3BF 0x8F6F      ISB      SY
   \      0x290   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_30: (+1)
   \      0x292   0xE7FE             B.N      ??sbcSemTimCallBack_30
   2918                    break;
   \                     ??sbcSemTimCallBack_29: (+1)
   \      0x294   0xE7FF             B.N      ??sbcSemTimCallBack_16
   2919          
   2920                  default:
   2921                    break;
   2922                }
   2923                break;
   \                     ??sbcSemTimCallBack_10: (+1)
   \                     ??sbcSemTimCallBack_16: (+1)
   \      0x296   0xE114             B.N      ??sbcSemTimCallBack_31
   2924          
   2925              case TIMER_FOR_ACK:
   2926                switch (sbcSemInfoMng.sbcSemStates)  
   \                     ??sbcSemTimCallBack_2: (+1)
   \      0x298   0x.... 0x....      LDR.W    R7,??DataTable16_9
   \      0x29C   0x8838             LDRH     R0,[R7, #+0]
   \      0x29E   0x2800             CMP      R0,#+0
   \      0x2A0   0xD008             BEQ.N    ??sbcSemTimCallBack_32
   \      0x2A2   0x2804             CMP      R0,#+4
   \      0x2A4   0xD074             BEQ.N    ??sbcSemTimCallBack_33
   \      0x2A6   0x2806             CMP      R0,#+6
   \      0x2A8   0xD073             BEQ.N    ??sbcSemTimCallBack_34
   \      0x2AA   0x2807             CMP      R0,#+7
   \      0x2AC   0xD071             BEQ.N    ??sbcSemTimCallBack_34
   \      0x2AE   0x2809             CMP      R0,#+9
   \      0x2B0   0xD032             BEQ.N    ??sbcSemTimCallBack_35
   \      0x2B2   0xE08F             B.N      ??sbcSemTimCallBack_36
   2927                {
   2928                  case SBC_SEM_INIT_DISCOVERY:
   2929                    /* release the transmitter */
   2930                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \                     ??sbcSemTimCallBack_32: (+1)
   \      0x2B4   0x2005             MOVS     R0,#+5
   \      0x2B6   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   2931                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x2BA   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x2BE   0x2300             MOVS     R3,#+0
   \      0x2C0   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x2C4   0xA902             ADD      R1,SP,#+8
   \      0x2C6   0x.... 0x....      BL       xQueueGenericSend
   \      0x2CA   0x2801             CMP      R0,#+1
   \      0x2CC   0xD009             BEQ.N    ??sbcSemTimCallBack_37
   \      0x2CE   0xB672             CPSID    I
   \      0x2D0   0x2050             MOVS     R0,#+80
   \      0x2D2   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x2D6   0xF3BF 0x8F4F      DSB      SY
   \      0x2DA   0xF3BF 0x8F6F      ISB      SY
   \      0x2DE   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_38: (+1)
   \      0x2E0   0xE7FE             B.N      ??sbcSemTimCallBack_38
   2932                    /* the previous message hasn't received ACK: possible conflit on firstr Tx byte? Retry */
   2933                    osDelay(getRandomDelay());  /* delay in the range 2...50 msec */
   \                     ??sbcSemTimCallBack_37: (+1)
   \      0x2E2   0x.... 0x....      BL       getRandomDelay
   \      0x2E6   0xB2C0             UXTB     R0,R0
   \      0x2E8   0x.... 0x....      BL       osDelay
   2934                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x2EC   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x2F0   0x2300             MOVS     R3,#+0
   \      0x2F2   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x2F6   0x.... 0x....      LDR.W    R1,??DataTable24
   \      0x2FA   0x.... 0x....      BL       xQueueGenericSend
   \      0x2FE   0x2801             CMP      R0,#+1
   \      0x300   0xD009             BEQ.N    ??sbcSemTimCallBack_39
   \      0x302   0xB672             CPSID    I
   \      0x304   0x2050             MOVS     R0,#+80
   \      0x306   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x30A   0xF3BF 0x8F4F      DSB      SY
   \      0x30E   0xF3BF 0x8F6F      ISB      SY
   \      0x312   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_40: (+1)
   \      0x314   0xE7FE             B.N      ??sbcSemTimCallBack_40
   2935                    break;
   \                     ??sbcSemTimCallBack_39: (+1)
   \      0x316   0xE05D             B.N      ??sbcSemTimCallBack_41
   2936          
   2937                  case SBC_SEM_WAIT_TO_REGISTER:
   2938                    if (sbcSemInfoMng.firstIdFree > (uint16_t)SCU_M_P_ADDR)
   \                     ??sbcSemTimCallBack_35: (+1)
   \      0x318   0x8878             LDRH     R0,[R7, #+2]
   \      0x31A   0x2802             CMP      R0,#+2
   \      0x31C   0xDB37             BLT.N    ??sbcSemTimCallBack_42
   2939                    {
   2940                      locScuMode = getScuOpMode();
   \      0x31E   0x.... 0x....      BL       getScuOpMode
   \      0x322   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   2941                      if (getScuOpMode() == SCU_S_S)
   \      0x326   0x.... 0x....      BL       getScuOpMode
   \      0x32A   0x2804             CMP      R0,#+4
   \      0x32C   0xD10C             BNE.N    ??sbcSemTimCallBack_43
   2942                      {
   2943                        if (socketPresence.keyPresence == KEY_FULL_MASTER_P)
   \      0x32E   0x.... 0x....      LDR.W    R0,??DataTable22
   \      0x332   0x6881             LDR      R1,[R0, #+8]
   \      0x334   0x2988             CMP      R1,#+136
   \      0x336   0xD103             BNE.N    ??sbcSemTimCallBack_44
   2944                        {
   2945                          /* the edge address coming from Broadcast procedure SCU MASTER */
   2946                          socketPresence.keyPresence = KEY_FULL_MASTER_P_S;
   \      0x338   0xF64D 0x5188      MOVW     R1,#+56712
   \      0x33C   0x6081             STR      R1,[R0, #+8]
   \      0x33E   0xE008             B.N      ??sbcSemTimCallBack_45
   2947                        }
   2948                        else
   2949                        {
   2950                          /* the edge address coming from linked secondary master  */
   2951                          socketPresence.keyPresence = KEY_FULL_MASTER_S;
   \                     ??sbcSemTimCallBack_44: (+1)
   \      0x340   0xF44F 0x415D      MOV      R1,#+56576
   \      0x344   0x6081             STR      R1,[R0, #+8]
   \      0x346   0xE004             B.N      ??sbcSemTimCallBack_45
   2952                        }
   2953                      }
   2954                      else
   2955                      {
   2956                        socketPresence.keyPresence = KEY_FULL_CONFIG;
   \                     ??sbcSemTimCallBack_43: (+1)
   \      0x348   0xF64A 0x2055      MOVW     R0,#+43605
   \      0x34C   0x.... 0x....      LDR.W    R1,??DataTable22
   \      0x350   0x6088             STR      R0,[R1, #+8]
   2957                      }
   2958                      result = (uint8_t)sbcSemInfoMng.firstIdFree; sbcSemInfoMng.firstIdFree = 0; 
   \                     ??sbcSemTimCallBack_45: (+1)
   \      0x352   0x8878             LDRH     R0,[R7, #+2]
   \      0x354   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \      0x358   0x2000             MOVS     R0,#+0
   \      0x35A   0x8078             STRH     R0,[R7, #+2]
   2959                      if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \      0x35C   0x2254             MOVS     R2,#+84
   \      0x35E   0x.... 0x....      LDR.W    R1,??DataTable22
   \      0x362   0xF44F 0x50F4      MOV      R0,#+7808
   \      0x366   0x.... 0x....      BL       WriteOnEeprom
   \      0x36A   0x2800             CMP      R0,#+0
   \      0x36C   0xD10F             BNE.N    ??sbcSemTimCallBack_42
   2960                      {
   2961                        tPrintf("Assigned address %d\n\r", result);
   \      0x36E   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \      0x372   0x.... 0x....      LDR.W    R0,??DataTable27
   \      0x376   0x.... 0x....      BL       tPrintf
   2962                        /* a new address must be set */
   2963                        eeprom_array_set(RS485_ADD_EADD, (uint8_t*)&result, 1);
   \      0x37A   0x2201             MOVS     R2,#+1
   \      0x37C   0xA901             ADD      R1,SP,#+4
   \      0x37E   0x2009             MOVS     R0,#+9
   \      0x380   0x.... 0x....      BL       eeprom_array_set
   2964                        /* Send event to update eeprom */
   2965                        send_to_eeprom(EEPROM_UPDATE); 
   \      0x384   0x2002             MOVS     R0,#+2
   \      0x386   0x.... 0x....      BL       send_to_eeprom
   2966          
   2967                        /* restart with new RS485 address */
   2968                        activeImmediateReset();
   \      0x38A   0x.... 0x....      BL       activeImmediateReset
   2969                      }
   2970                    }
   2971                    break;
   \                     ??sbcSemTimCallBack_42: (+1)
   \      0x38E   0xE021             B.N      ??sbcSemTimCallBack_41
   2972          
   2973                  case SBC_SEM_OPERATIVE:
   2974                    break;
   \                     ??sbcSemTimCallBack_33: (+1)
   \      0x390   0xE020             B.N      ??sbcSemTimCallBack_41
   2975          
   2976                  case SBC_SEM_WAIT_WR_MASTER_ACK:
   2977                  case SBC_SEM_WAIT_WR_MASTER_POLL_ACK: 
   2978                    sbcSemInfoMng.offLine = TRUE;
   \                     ??sbcSemTimCallBack_34: (+1)
   \      0x392   0x2001             MOVS     R0,#+1
   \      0x394   0xF887 0x0027      STRB     R0,[R7, #+39]
   2979                    tPrintf("Master unavailable!\n\r");
   \      0x398   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \      0x39C   0x.... 0x....      BL       tPrintf
   2980                    /* communication problem with master */
   2981                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0x3A0   0x2005             MOVS     R0,#+5
   \      0x3A2   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   2982                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x3A6   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x3AA   0x2300             MOVS     R3,#+0
   \      0x3AC   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x3B0   0xA902             ADD      R1,SP,#+8
   \      0x3B2   0x.... 0x....      BL       xQueueGenericSend
   \      0x3B6   0x2801             CMP      R0,#+1
   \      0x3B8   0xD009             BEQ.N    ??sbcSemTimCallBack_46
   \      0x3BA   0xB672             CPSID    I
   \      0x3BC   0x2050             MOVS     R0,#+80
   \      0x3BE   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x3C2   0xF3BF 0x8F4F      DSB      SY
   \      0x3C6   0xF3BF 0x8F6F      ISB      SY
   \      0x3CA   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_47: (+1)
   \      0x3CC   0xE7FE             B.N      ??sbcSemTimCallBack_47
   2983                    sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \                     ??sbcSemTimCallBack_46: (+1)
   \      0x3CE   0x2004             MOVS     R0,#+4
   \      0x3D0   0x8038             STRH     R0,[R7, #+0]
   2984                    break;
   \      0x3D2   0xE7FF             B.N      ??sbcSemTimCallBack_41
   2985          
   2986                  default:
   2987                    break;
   2988                }
   2989                break;
   \                     ??sbcSemTimCallBack_36: (+1)
   \                     ??sbcSemTimCallBack_41: (+1)
   \      0x3D4   0xE075             B.N      ??sbcSemTimCallBack_31
   2990          
   2991              case TIMER_FOR_TICK_RTC:
   2992                setCurrentDateTimeInSem();
   \                     ??sbcSemTimCallBack_1: (+1)
   \      0x3D6   0x.... 0x....      BL       setCurrentDateTimeInSem
   2993                break;
   \      0x3DA   0xE072             B.N      ??sbcSemTimCallBack_31
   2994          
   2995              case TIMER_FOR_ACK_POLLING:
   2996                switch (sbcSemInfoMng.sbcSemStates)
   \                     ??sbcSemTimCallBack_4: (+1)
   \      0x3DC   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \      0x3E0   0x8800             LDRH     R0,[R0, #+0]
   \      0x3E2   0x2804             CMP      R0,#+4
   \      0x3E4   0xD117             BNE.N    ??sbcSemTimCallBack_48
   2997                {
   2998                  case SBC_SEM_OPERATIVE:
   2999                    /* release the transmitter */
   3000                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0x3E6   0x2005             MOVS     R0,#+5
   \      0x3E8   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   3001                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x3EC   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x3F0   0x2300             MOVS     R3,#+0
   \      0x3F2   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x3F6   0xA902             ADD      R1,SP,#+8
   \      0x3F8   0x.... 0x....      BL       xQueueGenericSend
   \      0x3FC   0x2801             CMP      R0,#+1
   \      0x3FE   0xD009             BEQ.N    ??sbcSemTimCallBack_49
   \      0x400   0xB672             CPSID    I
   \      0x402   0x2050             MOVS     R0,#+80
   \      0x404   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x408   0xF3BF 0x8F4F      DSB      SY
   \      0x40C   0xF3BF 0x8F6F      ISB      SY
   \      0x410   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_50: (+1)
   \      0x412   0xE7FE             B.N      ??sbcSemTimCallBack_50
   3002                    break;
   \                     ??sbcSemTimCallBack_49: (+1)
   \      0x414   0xE7FF             B.N      ??sbcSemTimCallBack_51
   3003          
   3004                  default:
   3005                    break;
   3006                }
   3007                break;
   \                     ??sbcSemTimCallBack_48: (+1)
   \                     ??sbcSemTimCallBack_51: (+1)
   \      0x416   0xE054             B.N      ??sbcSemTimCallBack_31
   3008          
   3009              case TIMER_FOR_REQ_ADDR:
   3010                switch (sbcSemInfoMng.sbcSemStates)
   \                     ??sbcSemTimCallBack_3: (+1)
   \      0x418   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \      0x41C   0x8801             LDRH     R1,[R0, #+0]
   \      0x41E   0x2904             CMP      R1,#+4
   \      0x420   0xD03F             BEQ.N    ??sbcSemTimCallBack_52
   \      0x422   0x2909             CMP      R1,#+9
   \      0x424   0xD14C             BNE.N    ??sbcSemTimCallBack_53
   3011                {
   3012                  case SBC_SEM_WAIT_TO_REGISTER:
   3013                    /* a  slve SCU is present in the chain and requires an address */
   3014                    sbcSemInfoMng.dataVal = (uint16_t)sbcSemInfoMng.random;                 // copy in the tag Id the product SN crc 100....
   \                     ??sbcSemTimCallBack_54: (+1)
   \      0x426   0x69C1             LDR      R1,[R0, #+28]
   \      0x428   0x8081             STRH     R1,[R0, #+4]
   3015                    pScuTmMapReg->tmAddrReq = sbcSemInfoMng.dataVal;                         
   \      0x42A   0x.... 0x....      LDR.W    R7,??DataTable31
   \      0x42E   0x8880             LDRH     R0,[R0, #+4]
   \      0x430   0x6839             LDR      R1,[R7, #+0]
   \      0x432   0x8108             STRH     R0,[R1, #+8]
   3016                    pScuTmMapReg->tmAddrAss = (uint16_t)getPhysicalMdbAddr();               // just for debug put the current address
   \      0x434   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0x438   0xB2C0             UXTB     R0,R0
   \      0x43A   0x6839             LDR      R1,[R7, #+0]
   \      0x43C   0x8148             STRH     R0,[R1, #+10]
   3017                    tmpFrameSbcSem.dataToSend.len = (uint16_t)6;                            /* we send 3 word = 6 bytes starting from ADDR_ADDR_S_CONN_RW */
   \      0x43E   0x2006             MOVS     R0,#+6
   \      0x440   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   3018                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \      0x444   0x2002             MOVS     R0,#+2
   \      0x446   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   3019                    tmpFrameSbcSem.data.index = getPhysicalMdbAddr();                         /* just for debug  rs485SemMsgProcess() */
   \      0x44A   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0x44E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   3020                    tmpFrameSbcSem.data.rAddr = ADDR_ADDR_S_CONN_RW;
   \      0x452   0xF240 0x5013      MOVW     R0,#+1299
   \      0x456   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   3021                    tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&pScuTmMapReg->tmAddrSconnM;
   \      0x45A   0x6838             LDR      R0,[R7, #+0]
   \      0x45C   0x1D80             ADDS     R0,R0,#+6
   \      0x45E   0x9004             STR      R0,[SP, #+16]
   3022                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x460   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x464   0x2300             MOVS     R3,#+0
   \      0x466   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x46A   0xA902             ADD      R1,SP,#+8
   \      0x46C   0x.... 0x....      BL       xQueueGenericSend
   \      0x470   0x2801             CMP      R0,#+1
   \      0x472   0xD009             BEQ.N    ??sbcSemTimCallBack_55
   \      0x474   0xB672             CPSID    I
   \      0x476   0x2050             MOVS     R0,#+80
   \      0x478   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x47C   0xF3BF 0x8F4F      DSB      SY
   \      0x480   0xF3BF 0x8F6F      ISB      SY
   \      0x484   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_56: (+1)
   \      0x486   0xE7FE             B.N      ??sbcSemTimCallBack_56
   3023                    // start ACK timer 
   3024                    xTimerReset (xSbcSemTimers[TIMER_FOR_ACK], 0);
   \                     ??sbcSemTimCallBack_55: (+1)
   \      0x488   0x.... 0x....      BL       xTaskGetTickCount
   \      0x48C   0x0002             MOVS     R2,R0
   \      0x48E   0x2000             MOVS     R0,#+0
   \      0x490   0x9000             STR      R0,[SP, #+0]
   \      0x492   0x2300             MOVS     R3,#+0
   \      0x494   0x2102             MOVS     R1,#+2
   \      0x496   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \      0x49A   0x6840             LDR      R0,[R0, #+4]
   \      0x49C   0x.... 0x....      BL       xTimerGenericCommand
   3025                    break;
   \      0x4A0   0xE00E             B.N      ??sbcSemTimCallBack_57
   3026          
   3027                  case SBC_SEM_OPERATIVE:
   3028                    /* the slave must send eeprom_array info to the master for updating configuration */
   3029                    val = (uint32_t)getLogicalMdbAddrSem();
   \                     ??sbcSemTimCallBack_52: (+1)
   \      0x4A2   0x.... 0x....      BL       getLogicalMdbAddrSem
   \      0x4A6   0x0005             MOVS     R5,R0
   3030                    if (getAndsendAllSlaveParameters((uint8_t)val) == 0)  // 0 means NO_ERROR
   \      0x4A8   0x0028             MOVS     R0,R5
   \      0x4AA   0xB2C0             UXTB     R0,R0
   \      0x4AC   0x.... 0x....      BL       getAndsendAllSlaveParameters
   \      0x4B0   0x2800             CMP      R0,#+0
   \      0x4B2   0xD104             BNE.N    ??sbcSemTimCallBack_58
   3031                    {
   3032                      tPrintf("Sent upgrade eeprom info slave %02d!!\n\r", val + 1);
   \      0x4B4   0x1C69             ADDS     R1,R5,#+1
   \      0x4B6   0x.... 0x....      LDR.W    R0,??DataTable31_2
   \      0x4BA   0x.... 0x....      BL       tPrintf
   3033                    }
   3034                    break;
   \                     ??sbcSemTimCallBack_58: (+1)
   \      0x4BE   0xE7FF             B.N      ??sbcSemTimCallBack_57
   3035          
   3036                  default:
   3037                    break;
   3038                }
   3039                break;
   \                     ??sbcSemTimCallBack_53: (+1)
   \                     ??sbcSemTimCallBack_57: (+1)
   \      0x4C0   0xE7FF             B.N      ??sbcSemTimCallBack_31
   3040          
   3041              default:
   3042                break;
   3043            }
   3044          }
   \                     ??sbcSemTimCallBack_5: (+1)
   \                     ??sbcSemTimCallBack_31: (+1)
   \      0x4C2   0xB007             ADD      SP,SP,#+28
   \      0x4C4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3045          
   3046          /**
   3047          *
   3048          * @brief        send a message in broadcast mode for firmware update   
   3049          *
   3050          * @param [in]   none
   3051          *
   3052          * @retval       none
   3053          *
   3054          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3055          void upgradeFwSlaveBroadcast(uint8_t ixScu)
   3056          {
   \                     upgradeFwSlaveBroadcast: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   3057            scuRwMapRegister_st*    pRwRegs;
   3058            frameSbcSem_st          tmpFrameSbcSem;  
   3059          
   3060            pRwRegs = getRwMdbRegs(SCU_M_P_ADDR_LOG);
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x.... 0x....      BL       getRwMdbRegs
   \        0xC   0x0005             MOVS     R5,R0
   3061            tmpFrameSbcSem.sbcSemEvent = SBC_SEM_EVENT_UART5_SEND_DWLD_CMD;
   \        0xE   0x200D             MOVS     R0,#+13
   \       0x10   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   3062            tmpFrameSbcSem.data.index = (uint16_t)ixScu;                                // physical address 1...31 or broadcast 0
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   3063            tmpFrameSbcSem.data.rAddr = ADDR_FILE_COMMAND_RW; // 
   \       0x1C   0xF44F 0x7080      MOV      R0,#+256
   \       0x20   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   3064            tmpFrameSbcSem.dataToSend.len = LEN_FILE_COMMAND_RW + LEN_FILE_SIZE_RW;           // lenght in word of data to be transmitted over RS485
   \       0x24   0x2003             MOVS     R0,#+3
   \       0x26   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   3065            tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&pRwRegs->scuSetRegFwUpd.fileCommand; // data origin
   \       0x2A   0xF515 0x7080      ADDS     R0,R5,#+256
   \       0x2E   0x9002             STR      R0,[SP, #+8]
   3066            tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \       0x30   0x.... 0x....      BL       getPacketStatusNum
   \       0x34   0xF10D 0x010E      ADD      R1,SP,#+14
   \       0x38   0x6008             STR      R0,[R1, #+0]
   3067             
   3068            configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \       0x3A   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x3E   0x2300             MOVS     R3,#+0
   \       0x40   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0x.... 0x....      BL       xQueueGenericSend
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xD009             BEQ.N    ??upgradeFwSlaveBroadcast_0
   \       0x4E   0xB672             CPSID    I
   \       0x50   0x2050             MOVS     R0,#+80
   \       0x52   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x56   0xF3BF 0x8F4F      DSB      SY
   \       0x5A   0xF3BF 0x8F6F      ISB      SY
   \       0x5E   0xB662             CPSIE    I
   \                     ??upgradeFwSlaveBroadcast_1: (+1)
   \       0x60   0xE7FE             B.N      ??upgradeFwSlaveBroadcast_1
   3069          }
   \                     ??upgradeFwSlaveBroadcast_0: (+1)
   \       0x62   0xB005             ADD      SP,SP,#+20
   \       0x64   0xBD30             POP      {R4,R5,PC}
   3070          
   3071          /**
   3072          *
   3073          * @brief        Creating a node for sem message     
   3074          *
   3075          * @param [in]   node
   3076          *
   3077          * @retval       none
   3078          *
   3079          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3080          nodeMsg createNode()
   3081          {
   \                     createNode: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3082              nodeMsg temp; // declare a node
   3083          
   3084              temp = (nodeMsg)malloc(sizeof(struct semMsgList));  // allocate memory using malloc()
   \        0x2   0x2018             MOVS     R0,#+24
   \        0x4   0x.... 0x....      BL       malloc
   3085              temp->next = NULL;                                  // make next point to NULL
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6141             STR      R1,[R0, #+20]
   3086              return temp;                                        //return the new node
   \        0xC   0xBD02             POP      {R1,PC}
   3087          }
   3088          
   3089          /**
   3090          *
   3091          * @brief        Adding a message on node 
   3092          *
   3093          * @param [in]   node
   3094          *
   3095          * @retval       none
   3096          *
   3097          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3098          static nodeMsg addNode(nodeMsg head, frameSbcSem_st *pMessage)
   3099          {
   \                     addNode: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   3100              nodeMsg temp,p;           // declare three nodes temp, p
   3101          
   3102              temp = createNode();      //createNode will return a new node with data = value and next pointing to NULL.
   \        0x8   0x.... 0x....      BL       createNode
   \        0xC   0x0006             MOVS     R6,R0
   3103              /* add element's value to data part of node */
   3104              /*      destination               source           length */
   3105              memcpy((void*)&temp->inMsg, (void*)pMessage, (size_t)sizeof(frameSbcSem_st));
   \        0xE   0xF05F 0x0812      MOVS     R8,#+18
   \       0x12   0x46A9             MOV      R9,R5
   \       0x14   0x46B2             MOV      R10,R6
   \       0x16   0x4642             MOV      R2,R8
   \       0x18   0x4649             MOV      R1,R9
   \       0x1A   0x4650             MOV      R0,R10
   \       0x1C   0x.... 0x....      BL       __aeabi_memcpy
   3106          
   3107              if(head == NULL)
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD101             BNE.N    ??addNode_0
   3108              {
   3109                head = temp;            //when linked list is empty
   \       0x24   0x0034             MOVS     R4,R6
   \       0x26   0xE006             B.N      ??addNode_1
   3110              }
   3111              else
   3112              {
   3113                p = head;              //assign head to p and pFirst 
   \                     ??addNode_0: (+1)
   \       0x28   0x0027             MOVS     R7,R4
   3114                while(p->next != NULL)
   \                     ??addNode_2: (+1)
   \       0x2A   0x6978             LDR      R0,[R7, #+20]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD001             BEQ.N    ??addNode_3
   3115                {
   3116                  p = p->next;          //traverse the list until p is the last node.The last node always points to NULL.
   \       0x30   0x697F             LDR      R7,[R7, #+20]
   \       0x32   0xE7FA             B.N      ??addNode_2
   3117                }
   3118                p->next = temp;
   \                     ??addNode_3: (+1)
   \       0x34   0x617E             STR      R6,[R7, #+20]
   3119              }
   3120              return head;
   \                     ??addNode_1: (+1)
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0xE8BD 0x87F0      POP      {R4-R10,PC}
   3121          }
   3122          
   3123          /**
   3124          *
   3125          * @brief        Sent the first message waiting in the list 
   3126          *
   3127          * @param [in]   nodeMsg: head of the list 
   3128          *
   3129          * @retval       none
   3130          *
   3131          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3132          static nodeMsg extractSendFirstInList(nodeMsg head)
   3133          {
   \                     extractSendFirstInList: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x0006             MOVS     R6,R0
   3134              frameSbcSem_st        locFrameSbcSem;
   3135              nodeMsg               p, pPrev, pMin, pMinPrev;
   3136              uint32_t              minId;
   3137          
   3138              p = pMinPrev = pMin = head;              //assign head to p and pFirst 
   \        0x8   0x0034             MOVS     R4,R6
   \        0xA   0x46A0             MOV      R8,R4
   \        0xC   0x46A1             MOV      R9,R4
   3139              minId = p->inMsg.timeEntry;
   \        0xE   0xF8D4 0x500E      LDR      R5,[R4, #+14]
   3140              while(p != NULL)
   \                     ??extractSendFirstInList_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD00B             BEQ.N    ??extractSendFirstInList_1
   3141              {
   3142                if (p->inMsg.timeEntry < minId)
   \       0x16   0xF8D4 0x000E      LDR      R0,[R4, #+14]
   \       0x1A   0x42A8             CMP      R0,R5
   \       0x1C   0xD204             BCS.N    ??extractSendFirstInList_2
   3143                {
   3144                  minId = p->inMsg.timeEntry;
   \       0x1E   0xF8D4 0x000E      LDR      R0,[R4, #+14]
   \       0x22   0x0005             MOVS     R5,R0
   3145                  pMin = p;
   \       0x24   0x46A0             MOV      R8,R4
   3146                  pMinPrev = pPrev;
   \       0x26   0x46B9             MOV      R9,R7
   3147                }                     // find the oldest packet --> first to be processed 
   3148                pPrev = p;
   \                     ??extractSendFirstInList_2: (+1)
   \       0x28   0x0027             MOVS     R7,R4
   3149                p = p->next;          //traverse the list until p is the last node.The last node always points to NULL.
   \       0x2A   0x6964             LDR      R4,[R4, #+20]
   \       0x2C   0xE7F1             B.N      ??extractSendFirstInList_0
   3150              }
   3151              pMinPrev->next = pMin->next;  // extract the item and link the previous to the next 
   \                     ??extractSendFirstInList_1: (+1)
   \       0x2E   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x32   0xF8C9 0x0014      STR      R0,[R9, #+20]
   3152          
   3153              /*      destination               source           length */
   3154              memcpy((void*)&locFrameSbcSem, (void*)pMin, (size_t)sizeof(frameSbcSem_st));
   \       0x36   0xF05F 0x0A12      MOVS     R10,#+18
   \       0x3A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x3E   0xF10D 0x0B04      ADD      R11,SP,#+4
   \       0x42   0x4652             MOV      R2,R10
   \       0x44   0x9900             LDR      R1,[SP, #+0]
   \       0x46   0x4658             MOV      R0,R11
   \       0x48   0x.... 0x....      BL       __aeabi_memcpy
   3155              free(pMin);               // free previous allocated area 
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0x.... 0x....      BL       free
   3156              configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&locFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \       0x52   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x56   0x2300             MOVS     R3,#+0
   \       0x58   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x5C   0xA901             ADD      R1,SP,#+4
   \       0x5E   0x.... 0x....      BL       xQueueGenericSend
   \       0x62   0x2801             CMP      R0,#+1
   \       0x64   0xD009             BEQ.N    ??extractSendFirstInList_3
   \       0x66   0xB672             CPSID    I
   \       0x68   0x2050             MOVS     R0,#+80
   \       0x6A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x6E   0xF3BF 0x8F4F      DSB      SY
   \       0x72   0xF3BF 0x8F6F      ISB      SY
   \       0x76   0xB662             CPSIE    I
   \                     ??extractSendFirstInList_4: (+1)
   \       0x78   0xE7FE             B.N      ??extractSendFirstInList_4
   3157              if (pMin != head)
   \                     ??extractSendFirstInList_3: (+1)
   \       0x7A   0x45B0             CMP      R8,R6
   \       0x7C   0xD001             BEQ.N    ??extractSendFirstInList_5
   3158              {
   3159                return(head);
   \       0x7E   0x0030             MOVS     R0,R6
   \       0x80   0xE001             B.N      ??extractSendFirstInList_6
   3160              }
   3161              else
   3162              {
   3163                return(pMin->next);
   \                     ??extractSendFirstInList_5: (+1)
   \       0x82   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \                     ??extractSendFirstInList_6: (+1)
   \       0x86   0xB007             ADD      SP,SP,#+28
   \       0x88   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3164              }
   3165          }
   3166          
   3167          
   3168          /**
   3169          *
   3170          * @brief        Set the load balancing by SEM  
   3171          *
   3172          * @param [in]   none 
   3173          *
   3174          * @retval       none
   3175          *
   3176          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3177          void setNewMaxTempPowerSem(void)
   3178          {
   \                     setNewMaxTempPowerSem: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   3179            uint32_t temp32;
   3180          
   3181            temp32 = getMaxTempPowerAc();
   \        0x2   0x.... 0x....      BL       getMaxTempPowerAc
   \        0x6   0x0004             MOVS     R4,R0
   3182            pmng_sem_power_set((uint16_t)temp32, 1);
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x.... 0x....      BL       pmng_sem_power_set
   3183          }
   \       0x12   0xBD10             POP      {R4,PC}
   3184          
   3185          /**
   3186          *
   3187          * @brief        Set the current date and time in  SEM  
   3188          *
   3189          * @param [in]   none 
   3190          *
   3191          * @retval       none
   3192          *
   3193          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3194          void setCurrentDateTimeInSem(void)
   3195          {
   \                     setCurrentDateTimeInSem: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   3196            time_t                currUT;
   3197            scuRwMapRegister_st*  pRwRegs;
   3198            uint8_t               mdbAddr;
   3199            uint8_t               timezone;
   3200            uint8_t               dst;
   3201            struct tm             *pTimeinfo;
   3202          
   3203            //setUtcDateTimeRegister();
   3204          
   3205            currUT = getCurrentUnixTime();
   \        0x2   0x.... 0x....      BL       getCurrentUnixTime
   \        0x6   0xE9CD 0x0102      STRD     R0,R1,[SP, #+8]
   3206          
   3207            /* update globat date and time structure  **/
   3208            pTimeinfo = localtime (&currUT);
   \        0xA   0xA802             ADD      R0,SP,#+8
   \        0xC   0x.... 0x....      BL       localtime
   \       0x10   0x0006             MOVS     R6,R0
   3209          
   3210          
   3211          
   3212            mdbAddr = getLogicalMdbAddrSem();
   \       0x12   0x.... 0x....      BL       getLogicalMdbAddrSem
   \       0x16   0x0005             MOVS     R5,R0
   3213            pRwRegs = getRwMdbRegs(mdbAddr);
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x.... 0x....      BL       getRwMdbRegs
   \       0x20   0x0004             MOVS     R4,R0
   3214            
   3215            /* Get timezone saved in eeprom */
   3216            eeprom_param_get(TIME_ZONE_EADD, (uint8_t*)&timezone, 1);
   \       0x22   0x2201             MOVS     R2,#+1
   \       0x24   0xF10D 0x0105      ADD      R1,SP,#+5
   \       0x28   0x2030             MOVS     R0,#+48
   \       0x2A   0x.... 0x....      BL       eeprom_param_get
   3217              
   3218            /* Get dst flag saved in eeprom */
   3219            eeprom_param_get(DST_EADD, (uint8_t*)&dst, 1);
   \       0x2E   0x2201             MOVS     R2,#+1
   \       0x30   0xA901             ADD      R1,SP,#+4
   \       0x32   0x2031             MOVS     R0,#+49
   \       0x34   0x.... 0x....      BL       eeprom_param_get
   3220            
   3221            pRwRegs->scuSetRegister.rtcInf[0] = pTimeinfo->tm_sec;
   \       0x38   0x6830             LDR      R0,[R6, #+0]
   \       0x3A   0xF884 0x002C      STRB     R0,[R4, #+44]
   3222            pRwRegs->scuSetRegister.rtcInf[2] = pTimeinfo->tm_min;
   \       0x3E   0x6870             LDR      R0,[R6, #+4]
   \       0x40   0xF884 0x002E      STRB     R0,[R4, #+46]
   3223            pRwRegs->scuSetRegister.rtcInf[4] = pTimeinfo->tm_hour;
   \       0x44   0x68B0             LDR      R0,[R6, #+8]
   \       0x46   0xF884 0x0030      STRB     R0,[R4, #+48]
   3224            pRwRegs->scuSetRegister.rtcInf[6] = pTimeinfo->tm_mday;
   \       0x4A   0x68F0             LDR      R0,[R6, #+12]
   \       0x4C   0xF884 0x0032      STRB     R0,[R4, #+50]
   3225            pRwRegs->scuSetRegister.rtcInf[8] = pTimeinfo->tm_mon;
   \       0x50   0x6930             LDR      R0,[R6, #+16]
   \       0x52   0xF884 0x0034      STRB     R0,[R4, #+52]
   3226            pRwRegs->scuSetRegister.rtcInf[10] = ((pTimeinfo->tm_year) & 0xFF);        /* Fixed ticket SCU-113 */ 
   \       0x56   0x6970             LDR      R0,[R6, #+20]
   \       0x58   0xF884 0x0036      STRB     R0,[R4, #+54]
   3227            pRwRegs->scuSetRegister.rtcInf[11] = ((pTimeinfo->tm_year) & 0xFF00) >> 8; /* Fixed ticket SCU-113 */
   \       0x5C   0x6970             LDR      R0,[R6, #+20]
   \       0x5E   0x1200             ASRS     R0,R0,#+8
   \       0x60   0xF884 0x0037      STRB     R0,[R4, #+55]
   3228            pRwRegs->scuSetRegister.rtcInf[12] = pTimeinfo->tm_wday;
   \       0x64   0x69B0             LDR      R0,[R6, #+24]
   \       0x66   0xF884 0x0038      STRB     R0,[R4, #+56]
   3229            pRwRegs->scuSetRegister.rtcInf[13] = (pTimeinfo->tm_yday & 0xFF);          /* Fixed ticket SCU-113 */
   \       0x6A   0x69F0             LDR      R0,[R6, #+28]
   \       0x6C   0xF884 0x0039      STRB     R0,[R4, #+57]
   3230            pRwRegs->scuSetRegister.rtcInf[14] = (pTimeinfo->tm_yday & 0xFF00) >> 8;   /* Fixed ticket SCU-113 */
   \       0x70   0x69F0             LDR      R0,[R6, #+28]
   \       0x72   0x1200             ASRS     R0,R0,#+8
   \       0x74   0xF884 0x003A      STRB     R0,[R4, #+58]
   3231            pRwRegs->scuSetRegister.rtcInf[16] = dst;
   \       0x78   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x7C   0xF884 0x003C      STRB     R0,[R4, #+60]
   3232            
   3233            pRwRegs->scuSetRegister.rtcTimeZone = timezone * 60;
   \       0x80   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \       0x84   0x213C             MOVS     R1,#+60
   \       0x86   0xFB10 0xF001      SMULBB   R0,R0,R1
   \       0x8A   0xF8A4 0x007E      STRH     R0,[R4, #+126]
   3234          
   3235            // every 10 sec recall RTC for syncronization 
   3236            while ((xTimerChangePeriod (xSbcSemTimers[TIMER_FOR_TICK_RTC], TICK_FOR_RTC_SYNCRO, SBCSEM_TIMER_GARD_TIME) != pdPASS)); 
   \                     ??setCurrentDateTimeInSem_0: (+1)
   \       0x8E   0xF44F 0x70FA      MOV      R0,#+500
   \       0x92   0x9000             STR      R0,[SP, #+0]
   \       0x94   0x2300             MOVS     R3,#+0
   \       0x96   0xF242 0x7210      MOVW     R2,#+10000
   \       0x9A   0x2104             MOVS     R1,#+4
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \       0xA0   0x6880             LDR      R0,[R0, #+8]
   \       0xA2   0x.... 0x....      BL       xTimerGenericCommand
   \       0xA6   0x2801             CMP      R0,#+1
   \       0xA8   0xD1F1             BNE.N    ??setCurrentDateTimeInSem_0
   3237          
   3238          }
   \       0xAA   0xBD7F             POP      {R0-R6,PC}
   3239          
   3240          /**
   3241          *
   3242          * @brief        Save the right key in the structure    
   3243          *
   3244          * @param [in]   uint8: fixed / adjustable address type  
   3245          *
   3246          * @retval       none 
   3247          *
   3248          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3249          void setAddressType(uint8_t type, uint8_t clearPresence)
   3250          {
   \                     setAddressType: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   3251            uint8_t result; 
   3252          
   3253            result = ReadFromEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t));
   \        0x6   0x.... 0x....      LDR.W    R7,??DataTable22
   \        0xA   0x2254             MOVS     R2,#+84
   \        0xC   0x0039             MOVS     R1,R7
   \        0xE   0xF44F 0x50F4      MOV      R0,#+7808
   \       0x12   0x.... 0x....      BL       ReadFromEeprom
   \       0x16   0x0006             MOVS     R6,R0
   3254            if (clearPresence == TRUE)
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD103             BNE.N    ??setAddressType_0
   3255            {
   3256              socketPresence.chainPresence = socketPresence.livePresence = socketPresence.assignedDeviceId = 0;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x6538             STR      R0,[R7, #+80]
   \       0x24   0x6078             STR      R0,[R7, #+4]
   \       0x26   0x6038             STR      R0,[R7, #+0]
   3257            }
   3258          
   3259            if (result == osOK)
   \                     ??setAddressType_0: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD11B             BNE.N    ??setAddressType_1
   3260            {
   3261              if (type == (uint8_t)SCU_FIXED_ADDR)
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD106             BNE.N    ??setAddressType_2
   3262              {
   3263                socketPresence.keyPresence = KEY_FULL_CONFIG;
   \       0x38   0xF64A 0x2055      MOVW     R0,#+43605
   \       0x3C   0x60B8             STR      R0,[R7, #+8]
   3264                setScuAddressTypeMode(SCU_FIXED_ADDR);
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x.... 0x....      BL       setScuAddressTypeMode
   \       0x44   0xE004             B.N      ??setAddressType_3
   3265              }
   3266              else
   3267              {
   3268                socketPresence.keyPresence = (uint16_t)0;
   \                     ??setAddressType_2: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x60B8             STR      R0,[R7, #+8]
   3269                setScuAddressTypeMode(SCU_TEMPORARY_ADDR);
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x.... 0x....      BL       setScuAddressTypeMode
   3270              }
   3271              if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \                     ??setAddressType_3: (+1)
   \       0x50   0x2254             MOVS     R2,#+84
   \       0x52   0x0039             MOVS     R1,R7
   \       0x54   0xF44F 0x50F4      MOV      R0,#+7808
   \       0x58   0x.... 0x....      BL       WriteOnEeprom
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD103             BNE.N    ??setAddressType_1
   3272              {
   3273                tPrintf("Presences Defined\n\r");
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable35
   \       0x64   0x.... 0x....      BL       tPrintf
   3274              }
   3275            }
   3276          }
   \                     ??setAddressType_1: (+1)
   \       0x68   0xBDF1             POP      {R0,R4-R7,PC}
   3277          
   3278          /**
   3279          *
   3280          * @brief        Task to manage the alive polling on present slave     
   3281          *
   3282          * @param [in]   void*: parameters task  
   3283          *
   3284          * @retval       none 
   3285          *
   3286          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3287          static void pollingSlaveTask (void * pvParameters)
   3288          {
   \                     pollingSlaveTask: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   3289            frameSbcSem_st tmpFrameSbcSem;  
   3290            uint32_t       timeTickPoll;
   3291          
   3292            /*-------- Creates an empty mailbox for uart  messages --------------------------*/
   3293            pollingSlaveQueue = xQueueCreate(NUM_BUFF_POLLING, sizeof(frameSbcSem_st));
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable34
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2112             MOVS     R1,#+18
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0x.... 0x....      BL       xQueueGenericCreate
   \       0x14   0x6028             STR      R0,[R5, #+0]
   3294            configASSERT(pollingSlaveQueue != NULL);
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD109             BNE.N    ??pollingSlaveTask_0
   \       0x1C   0xB672             CPSID    I
   \       0x1E   0x2050             MOVS     R0,#+80
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   \       0x2C   0xB662             CPSIE    I
   \                     ??pollingSlaveTask_1: (+1)
   \       0x2E   0xE7FE             B.N      ??pollingSlaveTask_1
   3295            
   3296            /* init structure for management */
   3297            pollingSlaveMng.pollStates = SLAVE_INIT;
   \                     ??pollingSlaveTask_0: (+1)
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x7001             STRB     R1,[R0, #+0]
   3298            pollingSlaveMng.unreachableSlave = (uint16_t)0;
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0xF8A0 0x1011      STRH     R1,[R0, #+17]
   3299          
   3300              
   3301            timeTickPoll = ACTIVITY_PERIOD_CHECK_TIME;
   \       0x3E   0xF44F 0x56FA      MOV      R6,#+8000
   3302          
   3303            for (;;)
   3304            {
   3305              /* Wait for some event from timer or message   */
   3306              if (xQueueReceive(pollingSlaveQueue, (void *)&tmpFrameSbcSem, timeTickPoll) == pdPASS)
   \                     ??pollingSlaveTask_2: (+1)
   \       0x42   0x0032             MOVS     R2,R6
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x.... 0x....      BL       xQueueReceive
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD105             BNE.N    ??pollingSlaveTask_3
   3307              {
   3308                timeTickPoll = pollingSlaveProcess(&frameSbcSem);
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable36
   \       0x54   0x.... 0x....      BL       pollingSlaveProcess
   \       0x58   0x0006             MOVS     R6,R0
   \       0x5A   0xE7F2             B.N      ??pollingSlaveTask_2
   3309              }
   3310              else
   3311              {
   3312                tmpFrameSbcSem.sbcSemEvent = SBC_SEM_TIMEOUT;
   \                     ??pollingSlaveTask_3: (+1)
   \       0x5C   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0x60   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   3313                timeTickPoll = pollingSlaveProcess(&tmpFrameSbcSem);
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x.... 0x....      BL       pollingSlaveProcess
   \       0x6A   0x0006             MOVS     R6,R0
   \       0x6C   0xE7E9             B.N      ??pollingSlaveTask_2
   3314              }
   3315            }
   3316          }
   3317          
   3318          /**
   3319          *
   3320          * @brief        Manage the polling on present slave  
   3321          *
   3322          * @param [in]   frameSbcSem_st*: pointer to incoming message 
   3323          *
   3324          * @retval       uint32_t: new timeout 
   3325          *
   3326          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3327          static uint32_t pollingSlaveProcess(frameSbcSem_st* pMsg)
   3328          {
   \                     pollingSlaveProcess: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   3329            uint32_t              timeTickTmp;
   3330            frameSbcSem_st        tmpFrameSbcSem;  
   3331            scuRoMapRegister_st*  pRoRegs; 
   3332            uint16_t              scuId, maskId, logicId;
   3333          
   3334          
   3335            timeTickTmp = ACTIVITY_PERIOD_CHECK_TIME;
   \        0x6   0xF44F 0x59FA      MOV      R9,#+8000
   \        0xA   0xF8CD 0x9000      STR      R9,[SP, #+0]
   3336          
   3337            if ((getStatusDwnl() == TRUE)  || (getBroadcastDownload() == TRUE))  
   \        0xE   0x.... 0x....      BL       getStatusDwnl
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD003             BEQ.N    ??pollingSlaveProcess_0
   \       0x16   0x.... 0x....      BL       getBroadcastDownload
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD103             BNE.N    ??pollingSlaveProcess_1
   3338              pollingSlaveMng.pollStates = FW_DOWNLOAD;
   \                     ??pollingSlaveProcess_0: (+1)
   \       0x1E   0x2005             MOVS     R0,#+5
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \       0x24   0x7008             STRB     R0,[R1, #+0]
   3339          
   3340            switch (pollingSlaveMng.pollStates)
   \                     ??pollingSlaveProcess_1: (+1)
   \       0x26   0x.... 0x....      LDR.W    R8,??DataTable35_1
   \       0x2A   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD00A             BEQ.N    ??pollingSlaveProcess_2
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD025             BEQ.N    ??pollingSlaveProcess_3
   \       0x36   0x2804             CMP      R0,#+4
   \       0x38   0xD050             BEQ.N    ??pollingSlaveProcess_4
   \       0x3A   0x2805             CMP      R0,#+5
   \       0x3C   0xF000 0x813B      BEQ.W    ??pollingSlaveProcess_5
   \       0x40   0x2807             CMP      R0,#+7
   \       0x42   0xF000 0x810C      BEQ.W    ??pollingSlaveProcess_6
   \       0x46   0xE145             B.N      ??pollingSlaveProcess_7
   3341            {
   3342              case SLAVE_INIT:
   3343                switch (pMsg->sbcSemEvent)
   \                     ??pollingSlaveProcess_2: (+1)
   \       0x48   0x9806             LDR      R0,[SP, #+24]
   \       0x4A   0x8800             LDRH     R0,[R0, #+0]
   \       0x4C   0xF64F 0x71FE      MOVW     R1,#+65534
   \       0x50   0x4288             CMP      R0,R1
   \       0x52   0xD115             BNE.N    ??pollingSlaveProcess_8
   3344                {
   3345                  case SBC_SEM_TIMEOUT:
   3346                    if (sbcSemInfoMng.pollingFlag ==(uint16_t)ENABLED)
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable37
   \       0x58   0x8B41             LDRH     R1,[R0, #+26]
   \       0x5A   0x2901             CMP      R1,#+1
   \       0x5C   0xD10D             BNE.N    ??pollingSlaveProcess_9
   3347                    {
   3348                      pollingSlaveMng.pollStates = SLAVE_IDLE;
   \       0x5E   0x2101             MOVS     R1,#+1
   \       0x60   0xF888 0x1000      STRB     R1,[R8, #+0]
   3349                      pollingSlaveMng.checkMask = (uint16_t)SCU_MASTER_MASK_BIT;     // init with master data 
   \       0x64   0x2101             MOVS     R1,#+1
   \       0x66   0xF8C8 0x1007      STR      R1,[R8, #+7]
   3350                      pollingSlaveMng.phyId = (uint16_t)SCU_M_P_ADDR;                // the master is out of polling periodic check 
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0xF8A8 0x1005      STRH     R1,[R8, #+5]
   3351                      /* starts to check slaves  */
   3352                      pollingSlaveMng.pollStates = SLAVE_IDLE;
   \       0x70   0x2101             MOVS     R1,#+1
   \       0x72   0xF888 0x1000      STRB     R1,[R8, #+0]
   3353                      timeTickTmp = ACTIVITY_PERIOD_CHECK_TIME;
   \       0x76   0xF8CD 0x9000      STR      R9,[SP, #+0]
   3354                    }
   3355                    sbcSemInfoMng.activityStatus = 0;                             // reset all activity bit        
   \                     ??pollingSlaveProcess_9: (+1)
   \       0x7A   0x2100             MOVS     R1,#+0
   \       0x7C   0x6141             STR      R1,[R0, #+20]
   3356                    break;
   \       0x7E   0xE7FF             B.N      ??pollingSlaveProcess_10
   3357          
   3358                  default:
   3359                    break;
   3360                }
   3361                break;
   \                     ??pollingSlaveProcess_8: (+1)
   \                     ??pollingSlaveProcess_10: (+1)
   \       0x80   0xE128             B.N      ??pollingSlaveProcess_11
   3362          
   3363              case SLAVE_IDLE:
   3364                sbcSemInfoMng.dataVal = (uint16_t)SCU_S_PS_LIVE;    // for discovery slave SCU (slave primary, i.e with TFT or slave secondary) 
   \                     ??pollingSlaveProcess_3: (+1)
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable37
   \       0x86   0x2105             MOVS     R1,#+5
   \       0x88   0x8081             STRH     R1,[R0, #+4]
   3365                tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \       0x8A   0x2103             MOVS     R1,#+3
   \       0x8C   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   3366                tmpFrameSbcSem.data.index = MODBUS_BROADCAST_ADDR;
   \       0x90   0x2100             MOVS     R1,#+0
   \       0x92   0xF8AD 0x1006      STRH     R1,[SP, #+6]
   3367                tmpFrameSbcSem.data.rAddr = ADDR_EVSE_TM_RW;        // AUTOCONFIG_FUNCTION_RW = ADDR_EVSE_TM_RW = 0x0022 is the register used for polling 
   \       0x96   0x2122             MOVS     R1,#+34
   \       0x98   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   3368                tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \       0x9C   0x1D00             ADDS     R0,R0,#+4
   \       0x9E   0x9003             STR      R0,[SP, #+12]
   3369                tmpFrameSbcSem.dataToSend.len = LEN_EVSE_TM_MODE_RW;
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   3370                configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \       0xA6   0x.... 0x....      BL       getRs485SemQueueHandle
   \       0xAA   0x2300             MOVS     R3,#+0
   \       0xAC   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0xB0   0xA901             ADD      R1,SP,#+4
   \       0xB2   0x.... 0x....      BL       xQueueGenericSend
   \       0xB6   0x2801             CMP      R0,#+1
   \       0xB8   0xD009             BEQ.N    ??pollingSlaveProcess_12
   \       0xBA   0xB672             CPSID    I
   \       0xBC   0x2050             MOVS     R0,#+80
   \       0xBE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xC2   0xF3BF 0x8F4F      DSB      SY
   \       0xC6   0xF3BF 0x8F6F      ISB      SY
   \       0xCA   0xB662             CPSIE    I
   \                     ??pollingSlaveProcess_13: (+1)
   \       0xCC   0xE7FE             B.N      ??pollingSlaveProcess_13
   3371                /* command is sent: wait next slot */
   3372                pollingSlaveMng.pollStates = CTRL_SLAVE;
   \                     ??pollingSlaveProcess_12: (+1)
   \       0xCE   0x2004             MOVS     R0,#+4
   \       0xD0   0xF888 0x0000      STRB     R0,[R8, #+0]
   3373                timeTickTmp = START_PERIOD_CHECK_LIVE; // timeout for receive responce from all active slaves 1000ms 
   \       0xD4   0xF44F 0x60FA      MOV      R0,#+2000
   \       0xD8   0x9000             STR      R0,[SP, #+0]
   3374                break;
   \       0xDA   0xE0FB             B.N      ??pollingSlaveProcess_11
   3375          
   3376              case CTRL_SLAVE:
   3377                switch (pMsg->sbcSemEvent)
   \                     ??pollingSlaveProcess_4: (+1)
   \       0xDC   0x9806             LDR      R0,[SP, #+24]
   \       0xDE   0x8800             LDRH     R0,[R0, #+0]
   \       0xE0   0xF64F 0x71FE      MOVW     R1,#+65534
   \       0xE4   0x4288             CMP      R0,R1
   \       0xE6   0xF040 0x80B9      BNE.W    ??pollingSlaveProcess_14
   3378                {
   3379                  case SBC_SEM_TIMEOUT:
   3380                    pollingSlaveMng.unactiveSlave = (socketPresence.chainPresence & pScuRoMapReg->scuMapRegNotify.ntfPresences) ^ sbcSemInfoMng.activityStatus;
   \       0xEA   0x.... 0x....      LDR.W    R0,??DataTable42
   \       0xEE   0x6800             LDR      R0,[R0, #+0]
   \       0xF0   0xF8D0 0x10F6      LDR      R1,[R0, #+246]
   \       0xF4   0x.... 0x....      LDR.W    R10,??DataTable22
   \       0xF8   0x.... 0x....      LDR.W    R9,??DataTable37
   \       0xFC   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x100   0x4001             ANDS     R1,R1,R0
   \      0x102   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \      0x106   0x4041             EORS     R1,R0,R1
   \      0x108   0xF8A8 0x100F      STRH     R1,[R8, #+15]
   3381                    if (pollingSlaveMng.unactiveSlave != 0)
   \      0x10C   0xF8B8 0x000F      LDRH     R0,[R8, #+15]
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xF000 0x809C      BEQ.W    ??pollingSlaveProcess_15
   3382                    {
   3383                      if (getScuOpMode() == SCU_M_STAND_ALONE)
   \      0x116   0x.... 0x....      BL       getScuOpMode
   \      0x11A   0x2805             CMP      R0,#+5
   \      0x11C   0xD106             BNE.N    ??pollingSlaveProcess_16
   3384                      {
   3385                        scuId = 1; maskId = 1; logicId = 0;            
   \      0x11E   0x2001             MOVS     R0,#+1
   \      0x120   0x0005             MOVS     R5,R0
   \      0x122   0x2001             MOVS     R0,#+1
   \      0x124   0x0006             MOVS     R6,R0
   \      0x126   0x2000             MOVS     R0,#+0
   \      0x128   0x0007             MOVS     R7,R0
   \      0x12A   0xE005             B.N      ??pollingSlaveProcess_17
   3386                      }
   3387                      else
   3388                      {
   3389                        scuId = 2; maskId = 2; logicId = 1;
   \                     ??pollingSlaveProcess_16: (+1)
   \      0x12C   0x2002             MOVS     R0,#+2
   \      0x12E   0x0005             MOVS     R5,R0
   \      0x130   0x2002             MOVS     R0,#+2
   \      0x132   0x0006             MOVS     R6,R0
   \      0x134   0x2001             MOVS     R0,#+1
   \      0x136   0x0007             MOVS     R7,R0
   3390                      }
   3391          
   3392                      for ( ; scuId < SCU_NUM; scuId++, maskId = maskId << 1, logicId++)
   \                     ??pollingSlaveProcess_17: (+1)
   \      0x138   0x0028             MOVS     R0,R5
   \      0x13A   0xB280             UXTH     R0,R0
   \      0x13C   0x2810             CMP      R0,#+16
   \      0x13E   0xF280 0x8086      BGE.W    ??pollingSlaveProcess_15
   3393                      {
   3394                        /* the check doen't involved the master */
   3395                        pRoRegs = getRoMdbRegs(logicId);
   \      0x142   0x0038             MOVS     R0,R7
   \      0x144   0xB2C0             UXTB     R0,R0
   \      0x146   0x.... 0x....      BL       getRoMdbRegs
   \      0x14A   0x0004             MOVS     R4,R0
   3396                        if ((pollingSlaveMng.unactiveSlave & maskId) != 0)
   \      0x14C   0xF8B8 0x000F      LDRH     R0,[R8, #+15]
   \      0x150   0x4230             TST      R0,R6
   \      0x152   0xD056             BEQ.N    ??pollingSlaveProcess_18
   3397                        {
   3398                          if ((pRoRegs->scuMapRegNotify.ntfErr2 & ERROR2_OFFL) == 0)
   \      0x154   0xF894 0x0100      LDRB     R0,[R4, #+256]
   \      0x158   0x0700             LSLS     R0,R0,#+28
   \      0x15A   0xD474             BMI.N    ??pollingSlaveProcess_19
   3399                          {
   3400                            if (pollingSlaveMng.offLineCounter[logicId] >= NUM_OFF_LINE_RETRY)
   \      0x15C   0x0038             MOVS     R0,R7
   \      0x15E   0xB280             UXTH     R0,R0
   \      0x160   0x4440             ADD      R0,R8,R0
   \      0x162   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \      0x166   0x2800             CMP      R0,#+0
   \      0x168   0xD02A             BEQ.N    ??pollingSlaveProcess_20
   3401                            {
   3402                              /* the current scuId doesn't respond: put it in OFF_L error status Only one time !!! */
   3403                              pRoRegs->scuMapRegNotify.ntfErr2 |= ERROR2_OFFL;
   \      0x16A   0xF8B4 0x0100      LDRH     R0,[R4, #+256]
   \      0x16E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x172   0xF8A4 0x0100      STRH     R0,[R4, #+256]
   3404                              /* set error for SEM communication */
   3405                              tmpFrameSbcSem.data.rAddr = ADDR_EVSE_ERROR2_RO;
   \      0x176   0xF240 0x4005      MOVW     R0,#+1029
   \      0x17A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   3406                              (void)setChangeRegisterBit(scuId, (frameSbcSem_st*)&tmpFrameSbcSem, (uint32_t)maskId, logicId); 
   \      0x17E   0x003B             MOVS     R3,R7
   \      0x180   0xB29B             UXTH     R3,R3
   \      0x182   0x0032             MOVS     R2,R6
   \      0x184   0xB292             UXTH     R2,R2
   \      0x186   0xA901             ADD      R1,SP,#+4
   \      0x188   0x0028             MOVS     R0,R5
   \      0x18A   0xB280             UXTH     R0,R0
   \      0x18C   0x.... 0x....      BL       setChangeRegisterBit
   3407                              tPrintf ("SCU %02d off-line! %s\n\r" , scuId, getHmsStr());
   \      0x190   0x.... 0x....      BL       getHmsStr
   \      0x194   0x0002             MOVS     R2,R0
   \      0x196   0x0029             MOVS     R1,R5
   \      0x198   0xB289             UXTH     R1,R1
   \      0x19A   0x.... 0x....      LDR.W    R0,??DataTable45
   \      0x19E   0x.... 0x....      BL       tPrintf
   3408                              /* remove from discovered list so, when RS485 will be reconnected, a new discovery starts */
   3409                              socketPresence.livePresence &= ~(maskId);
   \      0x1A2   0xF8DA 0x1004      LDR      R1,[R10, #+4]
   \      0x1A6   0x0030             MOVS     R0,R6
   \      0x1A8   0xB280             UXTH     R0,R0
   \      0x1AA   0x4381             BICS     R1,R1,R0
   \      0x1AC   0xF8CA 0x1004      STR      R1,[R10, #+4]
   3410                              sbcSemInfoMng.activeLastDiscovery &= ~(maskId);  
   \      0x1B0   0xF8D9 0x1020      LDR      R1,[R9, #+32]
   \      0x1B4   0x0030             MOVS     R0,R6
   \      0x1B6   0xB280             UXTH     R0,R0
   \      0x1B8   0x4381             BICS     R1,R1,R0
   \      0x1BA   0xF8C9 0x1020      STR      R1,[R9, #+32]
   \      0x1BE   0xE042             B.N      ??pollingSlaveProcess_19
   3411                            }
   3412                            else
   3413                            {
   3414                              pollingSlaveMng.offLineCounter[logicId]++;
   \                     ??pollingSlaveProcess_20: (+1)
   \      0x1C0   0x0038             MOVS     R0,R7
   \      0x1C2   0xB280             UXTH     R0,R0
   \      0x1C4   0x4440             ADD      R0,R8,R0
   \      0x1C6   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \      0x1CA   0x1C40             ADDS     R0,R0,#+1
   \      0x1CC   0x0039             MOVS     R1,R7
   \      0x1CE   0xB289             UXTH     R1,R1
   \      0x1D0   0x4441             ADD      R1,R8,R1
   \      0x1D2   0xF881 0x0023      STRB     R0,[R1, #+35]
   3415                              tPrintf ("SCU %02d off-line! Retry=%d %s\n\r" , getNumSocketLcd(logicId), pollingSlaveMng.offLineCounter[logicId], getHmsStr());
   \      0x1D6   0x.... 0x....      BL       getHmsStr
   \      0x1DA   0x4683             MOV      R11,R0
   \      0x1DC   0x0038             MOVS     R0,R7
   \      0x1DE   0xB2C0             UXTB     R0,R0
   \      0x1E0   0x.... 0x....      BL       getNumSocketLcd
   \      0x1E4   0x0001             MOVS     R1,R0
   \      0x1E6   0x465B             MOV      R3,R11
   \      0x1E8   0x0038             MOVS     R0,R7
   \      0x1EA   0xB280             UXTH     R0,R0
   \      0x1EC   0x4440             ADD      R0,R8,R0
   \      0x1EE   0xF890 0x2023      LDRB     R2,[R0, #+35]
   \      0x1F2   0xB2C9             UXTB     R1,R1
   \      0x1F4   0x.... 0x....      LDR.W    R0,??DataTable45_1
   \      0x1F8   0x.... 0x....      BL       tPrintf
   3416                              /* restore RS485   */
   3417                              uartReintialization(); 
   \      0x1FC   0x.... 0x....      BL       uartReintialization
   \      0x200   0xE021             B.N      ??pollingSlaveProcess_19
   3418                            }
   3419                          }
   3420                          else
   3421                          {
   3422                            ;
   3423                          }
   3424                        }
   3425                        else
   3426                        {
   3427                          if (pollingSlaveMng.offLineCounter[logicId] >= NUM_OFF_LINE_RETRY)
   \                     ??pollingSlaveProcess_18: (+1)
   \      0x202   0x0038             MOVS     R0,R7
   \      0x204   0xB280             UXTH     R0,R0
   \      0x206   0x4440             ADD      R0,R8,R0
   \      0x208   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \      0x20C   0x2800             CMP      R0,#+0
   \      0x20E   0xD014             BEQ.N    ??pollingSlaveProcess_21
   3428                          {
   3429                            /* the current scuId  respond now: put it in ON_LINE  Only one time !!! */
   3430                            pRoRegs->scuMapRegNotify.ntfErr2 &= (~ERROR2_OFFL);
   \      0x210   0xF8B4 0x1100      LDRH     R1,[R4, #+256]
   \      0x214   0xF64F 0x70F7      MOVW     R0,#+65527
   \      0x218   0x4001             ANDS     R1,R0,R1
   \      0x21A   0xF8A4 0x1100      STRH     R1,[R4, #+256]
   3431                            tPrintf ("SCU %02d on-line!! %s\n\r" , getNumSocketLcd(logicId), getHmsStr()); //  HAL_GetTick()
   \      0x21E   0x.... 0x....      BL       getHmsStr
   \      0x222   0x4683             MOV      R11,R0
   \      0x224   0x0038             MOVS     R0,R7
   \      0x226   0xB2C0             UXTB     R0,R0
   \      0x228   0x.... 0x....      BL       getNumSocketLcd
   \      0x22C   0x465A             MOV      R2,R11
   \      0x22E   0xB2C0             UXTB     R0,R0
   \      0x230   0x0001             MOVS     R1,R0
   \      0x232   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \      0x236   0x.... 0x....      BL       tPrintf
   3432                          }
   3433                          pollingSlaveMng.offLineCounter[logicId] = 0;
   \                     ??pollingSlaveProcess_21: (+1)
   \      0x23A   0x2000             MOVS     R0,#+0
   \      0x23C   0x0039             MOVS     R1,R7
   \      0x23E   0xB289             UXTH     R1,R1
   \      0x240   0x4441             ADD      R1,R8,R1
   \      0x242   0xF881 0x0023      STRB     R0,[R1, #+35]
   3434                        }
   3435                      }
   \                     ??pollingSlaveProcess_19: (+1)
   \      0x246   0x1C6D             ADDS     R5,R5,#+1
   \      0x248   0x0076             LSLS     R6,R6,#+1
   \      0x24A   0x1C7F             ADDS     R7,R7,#+1
   \      0x24C   0xE774             B.N      ??pollingSlaveProcess_17
   3436                    }
   3437                    timeTickTmp = START_PERIOD_CHECK_LIVE;  // timeout for receive responce from all active slave 1000ms 
   \                     ??pollingSlaveProcess_15: (+1)
   \      0x24E   0xF44F 0x60FA      MOV      R0,#+2000
   \      0x252   0x9000             STR      R0,[SP, #+0]
   3438                    pollingSlaveMng.pollStates = FIND_NEW_SLAVE;  // 2000ms 
   \      0x254   0x2007             MOVS     R0,#+7
   \      0x256   0xF888 0x0000      STRB     R0,[R8, #+0]
   3439                    break;
   \      0x25A   0xE7FF             B.N      ??pollingSlaveProcess_22
   3440          
   3441                  default:
   3442                    break;
   3443                }
   3444                break;
   \                     ??pollingSlaveProcess_14: (+1)
   \                     ??pollingSlaveProcess_22: (+1)
   \      0x25C   0xE03A             B.N      ??pollingSlaveProcess_11
   3445          
   3446              case FIND_NEW_SLAVE:
   3447                sbcSemInfoMng.dataVal = (uint16_t)SCU_S_PS_NEW;  // for discovery new slave SCU (slave primary, i.e with TFT or slave secondary) 
   \                     ??pollingSlaveProcess_6: (+1)
   \      0x25E   0x.... 0x....      LDR.W    R0,??DataTable37
   \      0x262   0x2106             MOVS     R1,#+6
   \      0x264   0x8081             STRH     R1,[R0, #+4]
   3448                tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \      0x266   0x2103             MOVS     R1,#+3
   \      0x268   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   3449                tmpFrameSbcSem.data.index = MODBUS_BROADCAST_ADDR;
   \      0x26C   0x2100             MOVS     R1,#+0
   \      0x26E   0xF8AD 0x1006      STRH     R1,[SP, #+6]
   3450                tmpFrameSbcSem.data.rAddr = ADDR_EVSE_TM_RW;
   \      0x272   0x2122             MOVS     R1,#+34
   \      0x274   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   3451                tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \      0x278   0x1D00             ADDS     R0,R0,#+4
   \      0x27A   0x9003             STR      R0,[SP, #+12]
   3452                tmpFrameSbcSem.dataToSend.len = LEN_EVSE_TM_MODE_RW;
   \      0x27C   0x2001             MOVS     R0,#+1
   \      0x27E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   3453                configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x282   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x286   0x2300             MOVS     R3,#+0
   \      0x288   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x28C   0xA901             ADD      R1,SP,#+4
   \      0x28E   0x.... 0x....      BL       xQueueGenericSend
   \      0x292   0x2801             CMP      R0,#+1
   \      0x294   0xD009             BEQ.N    ??pollingSlaveProcess_23
   \      0x296   0xB672             CPSID    I
   \      0x298   0x2050             MOVS     R0,#+80
   \      0x29A   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x29E   0xF3BF 0x8F4F      DSB      SY
   \      0x2A2   0xF3BF 0x8F6F      ISB      SY
   \      0x2A6   0xB662             CPSIE    I
   \                     ??pollingSlaveProcess_24: (+1)
   \      0x2A8   0xE7FE             B.N      ??pollingSlaveProcess_24
   3454                /* command is sent: wait next slot */
   3455                pollingSlaveMng.pollStates = SLAVE_INIT;
   \                     ??pollingSlaveProcess_23: (+1)
   \      0x2AA   0x2000             MOVS     R0,#+0
   \      0x2AC   0xF888 0x0000      STRB     R0,[R8, #+0]
   3456                timeTickTmp = ACTIVITY_PERIOD_CHECK_TIME; // next time is 8sec
   \      0x2B0   0xF8CD 0x9000      STR      R9,[SP, #+0]
   3457                break;
   \      0x2B4   0xE00E             B.N      ??pollingSlaveProcess_11
   3458          
   3459              case FW_DOWNLOAD:           /* FW download ongoing */
   3460                 if ((getBroadcastDownload() == TRUE))
   \                     ??pollingSlaveProcess_5: (+1)
   \      0x2B6   0x.... 0x....      BL       getBroadcastDownload
   \      0x2BA   0x2801             CMP      R0,#+1
   \      0x2BC   0xD103             BNE.N    ??pollingSlaveProcess_25
   3461                 {
   3462                   /* the task will be stopped with portMAX_DELAY value. Wait for reset at the end download  */
   3463                   timeTickTmp = portMAX_DELAY;
   \      0x2BE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x2C2   0x9000             STR      R0,[SP, #+0]
   \      0x2C4   0xE005             B.N      ??pollingSlaveProcess_26
   3464                 }
   3465                 else
   3466                 {
   3467                   /* the polling will restart at the end of slave upload */
   3468                   timeTickTmp = SUSPEND_FOR_UPLOAD_TIME;
   \                     ??pollingSlaveProcess_25: (+1)
   \      0x2C6   0x.... 0x....      LDR.W    R0,??DataTable46
   \      0x2CA   0x9000             STR      R0,[SP, #+0]
   3469                   pollingSlaveMng.pollStates = SLAVE_INIT;
   \      0x2CC   0x2000             MOVS     R0,#+0
   \      0x2CE   0xF888 0x0000      STRB     R0,[R8, #+0]
   3470                 }
   3471                break;
   \                     ??pollingSlaveProcess_26: (+1)
   \      0x2D2   0xE7FF             B.N      ??pollingSlaveProcess_11
   3472          
   3473                default:
   3474                  break;
   3475          
   3476            }
   3477            return(timeTickTmp);
   \                     ??pollingSlaveProcess_7: (+1)
   \                     ??pollingSlaveProcess_11: (+1)
   \      0x2D4   0x9800             LDR      R0,[SP, #+0]
   \      0x2D6   0xB007             ADD      SP,SP,#+28
   \      0x2D8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3478          }
   3479          
   3480          /**
   3481          *
   3482          * @brief       get FW version from the slaves
   3483          *
   3484          * @param [in]  None
   3485          *  
   3486          * @retval      none  
   3487          *  
   3488          ****************************************************************/
   3489          

   \                                 In section .text, align 2, keep-with-next
   3490          void Print_Slave_FW_Version (void)
   3491          {
   \                     Print_Slave_FW_Version: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   3492            uint8_t cnt;
   3493            uint32_t mask;
   3494            scuRoMapRegister_st*  pRoRegs;
   3495            
   3496            for (cnt = 0, mask = 1; cnt < SCU_NUM; cnt++, mask <<= 1)
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2501             MOVS     R5,#+1
   \                     ??Print_Slave_FW_Version_0: (+1)
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x2810             CMP      R0,#+16
   \        0xC   0xDA16             BGE.N    ??Print_Slave_FW_Version_1
   3497            {
   3498               pRoRegs = getRoMdbRegs(cnt);
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x.... 0x....      BL       getRoMdbRegs
   \       0x16   0x0006             MOVS     R6,R0
   3499              
   3500               if (socketPresence.livePresence & mask)     
   \       0x18   0x....             LDR.N    R0,??DataTable22
   \       0x1A   0x6840             LDR      R0,[R0, #+4]
   \       0x1C   0x4228             TST      R0,R5
   \       0x1E   0xD007             BEQ.N    ??Print_Slave_FW_Version_2
   3501                 tPrintf ("SCU id%02d --> FW version %s\n\r" , cnt +1, pRoRegs->scuMapRegInfoVer.mfwVer);
   \       0x20   0x0032             MOVS     R2,R6
   \       0x22   0x0021             MOVS     R1,R4
   \       0x24   0xB2C9             UXTB     R1,R1
   \       0x26   0x1C49             ADDS     R1,R1,#+1
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable46_1
   \       0x2C   0x.... 0x....      BL       tPrintf
   3502               osDelay(10);
   \                     ??Print_Slave_FW_Version_2: (+1)
   \       0x30   0x200A             MOVS     R0,#+10
   \       0x32   0x.... 0x....      BL       osDelay
   3503            }
   \       0x36   0x1C64             ADDS     R4,R4,#+1
   \       0x38   0x006D             LSLS     R5,R5,#+1
   \       0x3A   0xE7E4             B.N      ??Print_Slave_FW_Version_0
   3504            
   3505          }
   \                     ??Print_Slave_FW_Version_1: (+1)
   \       0x3C   0xBD70             POP      {R4-R6,PC}
   3506          
   3507          /**
   3508          *
   3509          * @brief       get  slaves with assogned address
   3510          *
   3511          * @param [in]  None
   3512          *  
   3513          * @retval      none  
   3514          *  
   3515          ****************************************************************/
   3516          

   \                                 In section .text, align 2, keep-with-next
   3517          void Print_Slave_Assigned (void)
   3518          {
   \                     Print_Slave_Assigned: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   3519            uint8_t cnt;
   3520            uint32_t mask;
   3521            
   3522            for (cnt = 0, mask = 1; cnt < SCU_NUM; cnt++, mask <<= 1)
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2501             MOVS     R5,#+1
   \                     ??Print_Slave_Assigned_0: (+1)
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x2810             CMP      R0,#+16
   \        0xC   0xDA10             BGE.N    ??Print_Slave_Assigned_1
   3523            {
   3524               if (socketPresence.chainPresence & mask) 
   \        0xE   0x....             LDR.N    R0,??DataTable22
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x4228             TST      R0,R5
   \       0x14   0xD006             BEQ.N    ??Print_Slave_Assigned_2
   3525               {
   3526                 tPrintf ("Address %02d Assigned\n\r" , cnt +1);
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0xB2C9             UXTB     R1,R1
   \       0x1A   0x1C49             ADDS     R1,R1,#+1
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable46_2
   \       0x20   0x.... 0x....      BL       tPrintf
   3527               }
   3528               osDelay(10);
   \                     ??Print_Slave_Assigned_2: (+1)
   \       0x24   0x200A             MOVS     R0,#+10
   \       0x26   0x.... 0x....      BL       osDelay
   3529            }
   \       0x2A   0x1C64             ADDS     R4,R4,#+1
   \       0x2C   0x006D             LSLS     R5,R5,#+1
   \       0x2E   0xE7EA             B.N      ??Print_Slave_Assigned_0
   3530            
   3531          }
   \                     ??Print_Slave_Assigned_1: (+1)
   \       0x30   0xBD31             POP      {R0,R4,R5,PC}
   3532          
   3533          
   3534          
   3535          /**
   3536          *
   3537          * @brief       reset current command sent to EVS for suspend / 
   3538          *              resume function 
   3539          *
   3540          * @param [in]  None
   3541          *  
   3542          * @retval      none  
   3543          *  
   3544          ****************************************************************/
   3545          

   \                                 In section .text, align 2, keep-with-next
   3546          void resetCommandRemote (void)
   3547          {
   3548            //lastCommandSent = EVS_EVENT_NULL;
   3549          }
   \                     resetCommandRemote: (+1)
   \        0x0   0x4770             BX       LR
   3550          
   3551          /**
   3552          *
   3553          * @brief       get socket index inside fake code  
   3554          *
   3555          * @param [in]  uint32_t : mask bit for the socket    
   3556          * @param [in]  sbcSemInfoMng_st* : info for discovery    
   3557          *  
   3558          * @retval      none  
   3559          *  
   3560          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3561          static uint8_t  getSktNumInFakeCode(void) 
   3562          {
   \                     getSktNumInFakeCode: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3563            uint8_t connNum;
   3564          
   3565          	eeprom_param_get(CONNECTOR_NUMBER_EADD, (uint8_t *)&connNum, 1);
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x2042             MOVS     R0,#+66
   \        0x8   0x.... 0x....      BL       eeprom_param_get
   3566            return (connNum);
   \        0xC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x10   0xBD02             POP      {R1,PC}
   3567          }
   3568          
   3569          /**
   3570          *
   3571          * @brief       get tag id from product serial number   
   3572          *
   3573          * @param [in]  none    
   3574          *  
   3575          * @retval      uint16_t: crc on product SN  
   3576          *  
   3577          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3578          static uint16_t  getTagIdFromPrdSn(void) 
   3579          {
   \                     getTagIdFromPrdSn: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   3580            scuRoMapRegister_st*  pRoRegs;
   3581            crcMode_u             crc;
   3582            uint16_t              length;
   3583            uint8_t               mdbAddr;
   3584          
   3585            mdbAddr = getLogicalMdbAddrSem();
   \        0x2   0x.... 0x....      BL       getLogicalMdbAddrSem
   \        0x6   0x0006             MOVS     R6,R0
   3586            pRoRegs = getRoMdbRegs(mdbAddr);
   \        0x8   0x0030             MOVS     R0,R6
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x.... 0x....      BL       getRoMdbRegs
   \       0x10   0x0004             MOVS     R4,R0
   3587          
   3588            length = (uint16_t)strlen((char*)pRoRegs->scuMapRegInfoVer.prodSn);
   \       0x12   0xF114 0x00B4      ADDS     R0,R4,#+180
   \       0x16   0x.... 0x....      BL       strlen
   \       0x1A   0x0005             MOVS     R5,R0
   3589            /* now found the CRC message */
   3590            crc.crcW = crcEvaluation ((uint8_t*)pRoRegs->scuMapRegInfoVer.prodSn, length);
   \       0x1C   0x0029             MOVS     R1,R5
   \       0x1E   0xB289             UXTH     R1,R1
   \       0x20   0xF114 0x00B4      ADDS     R0,R4,#+180
   \       0x24   0x.... 0x....      BL       crcEvaluation
   3591            return(crc.crcW);
   \       0x28   0xB280             UXTH     R0,R0
   \       0x2A   0xBD70             POP      {R4-R6,PC}
   3592          }
   3593          
   3594          /**
   3595          *
   3596          * @brief       get the id for LCD    
   3597          *
   3598          * @param [in]  none    
   3599          *  
   3600          * @retval      uint8_t: id to put on LCD   
   3601          *  
   3602          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3603          uint8_t  getIdNumberForLcd(void) 
   3604          {
   \                     getIdNumberForLcd: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3605            uint8_t                 idLcd;
   3606          
   3607            if (isSemMode() == TRUE)
   \        0x2   0x.... 0x....      BL       isSemMode
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD105             BNE.N    ??getIdNumberForLcd_0
   3608            {
   3609              idLcd = numberOnLcd;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable47
   \        0xE   0x7800             LDRB     R0,[R0, #+0]
   \       0x10   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x14   0xE009             B.N      ??getIdNumberForLcd_1
   3610            }
   3611            else
   3612            {
   3613              /* get SCU address        */
   3614              eeprom_param_get(RS485_ADD_EADD, (uint8_t *)&idLcd, 1);
   \                     ??getIdNumberForLcd_0: (+1)
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x2009             MOVS     R0,#+9
   \       0x1C   0x.... 0x....      BL       eeprom_param_get
   3615              idLcd++;
   \       0x20   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x24   0x1C40             ADDS     R0,R0,#+1
   \       0x26   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3616            }
   3617            return(idLcd);
   \                     ??getIdNumberForLcd_1: (+1)
   \       0x2A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2E   0xBD02             POP      {R1,PC}
   3618          }
   3619          
   3620          /**
   3621          *
   3622          * @brief       get the id LCD from device Id    
   3623          *
   3624          * @param [in]  uint8_t: device Id (0...15)    
   3625          *  
   3626          * @retval      uint8_t: id on LCD  
   3627          *  
   3628          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3629          uint8_t  getNumSocketLcd(uint8_t deviceId) 
   3630          {
   \                     getNumSocketLcd: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3631            scuRwMapRegister_st*  pRwRegs;
   3632            uint8_t               lcdNum;
   3633          
   3634            pRwRegs = getRwMdbRegs(deviceId);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x.... 0x....      BL       getRwMdbRegs
   \        0xC   0x0001             MOVS     R1,R0
   3635            lcdNum = (uint8_t)pRwRegs->scuSetRegister.devAlias;
   \        0xE   0x8908             LDRH     R0,[R1, #+8]
   3636            return(lcdNum);
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0xBD10             POP      {R4,PC}
   3637          }
   3638            
   3639          
   3640          
   3641          /**
   3642          *
   3643          * @brief       set in the modbus map the alias id number
   3644          *
   3645          * @param [in]  uint16_t: station status  
   3646          *  
   3647          * @retval      none 
   3648          *  
   3649          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3650          void  setDevAlias (void) 
   3651          {
   \                     setDevAlias: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   3652            scuRwMapRegister_st*  pRwRegs;
   3653            uint8_t               mdbAddr;
   3654            uint16_t              idDev;
   3655          
   3656            /* get address on modbus and relative modbus pointer area   */
   3657            if (isSemMode() == TRUE)
   \        0x2   0x.... 0x....      BL       isSemMode
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD12B             BNE.N    ??setDevAlias_0
   3658            {
   3659              mdbAddr = getPhysicalMdbAddr();
   \        0xA   0x.... 0x....      BL       getPhysicalMdbAddr
   \        0xE   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3660              idDev = fromRs485ToSem(mdbAddr);
   \       0x12   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x.... 0x....      BL       fromRs485ToSem
   \       0x1C   0x0004             MOVS     R4,R0
   3661              
   3662              // NULL id ? exit
   3663              if (idDev == NULL_ID)
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD028             BEQ.N    ??setDevAlias_1
   3664                return;
   3665              
   3666              pRwRegs = getRwMdbRegs(idDev);
   \                     ??setDevAlias_2: (+1)
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x.... 0x....      BL       getRwMdbRegs
   \       0x32   0x0005             MOVS     R5,R0
   3667              pRwRegs->scuSetRegister.devAlias = socketPresence.matrixIdConn[idDev]; 
   \       0x34   0x....             LDR.N    R0,??DataTable22
   \       0x36   0x0021             MOVS     R1,R4
   \       0x38   0xB289             UXTH     R1,R1
   \       0x3A   0x4408             ADD      R0,R0,R1
   \       0x3C   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \       0x40   0x8128             STRH     R0,[R5, #+8]
   3668              numberOnLcd = (uint8_t)pRwRegs->scuSetRegister.devAlias;
   \       0x42   0x.... 0x....      LDR.W    R6,??DataTable47
   \       0x46   0x8928             LDRH     R0,[R5, #+8]
   \       0x48   0x7030             STRB     R0,[R6, #+0]
   3669          
   3670              eeprom_param_get(RS485_ADD_EADD, &mdbAddr, 1);
   \       0x4A   0x2201             MOVS     R2,#+1
   \       0x4C   0x4669             MOV      R1,SP
   \       0x4E   0x2009             MOVS     R0,#+9
   \       0x50   0x.... 0x....      BL       eeprom_param_get
   3671              if (mdbAddr == (SCU_S_REPL_ADDR - 1))
   \       0x54   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x58   0x2862             CMP      R0,#+98
   \       0x5A   0xD10F             BNE.N    ??setDevAlias_3
   3672              {
   3673                /* this is a board for replacement: its address is 99 but 16 for Firmware  */
   3674                numberOnLcd = SCU_S_REPL_ADDR;
   \       0x5C   0x2063             MOVS     R0,#+99
   \       0x5E   0x7030             STRB     R0,[R6, #+0]
   \       0x60   0xE00C             B.N      ??setDevAlias_3
   3675              }
   3676            }
   3677            else
   3678            {
   3679              mdbAddr = getLogicalMdbAddr();
   \                     ??setDevAlias_0: (+1)
   \       0x62   0x.... 0x....      BL       getLogicalMdbAddr
   \       0x66   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3680              pRwRegs = getRwMdbRegs(mdbAddr);
   \       0x6A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x6E   0x.... 0x....      BL       getRwMdbRegs
   \       0x72   0x0005             MOVS     R5,R0
   3681              pRwRegs->scuSetRegister.devAlias = mdbAddr + 1; 
   \       0x74   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x78   0x1C40             ADDS     R0,R0,#+1
   \       0x7A   0x8128             STRH     R0,[R5, #+8]
   3682            }
   3683          }
   \                     ??setDevAlias_3: (+1)
   \                     ??setDevAlias_1: (+1)
   \       0x7C   0xBD73             POP      {R0,R1,R4-R6,PC}
   3684          
   3685          
   3686          /**
   3687          *
   3688          * @brief       Check if to send to  master a request to receive 
   3689          *              a new modbus address
   3690          *
   3691          * @param [in]  frameSbcSem_st*: pointer to received message    
   3692          *  
   3693          * @retval      sbcSemStates_e: the new state for the process  
   3694          *  
   3695          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3696          static sbcSemStates_e  checkToSendReqAddress(frameSbcSem_st* pMsg) 
   3697          {
   \                     checkToSendReqAddress: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   3698            uint16_t*             pWord;
   3699            sbcSemStates_e        retState;
   3700            uint32_t              reqDelay;
   3701          
   3702            pWord = (uint16_t *)pMsg->dataToSend.pData;
   \        0x6   0x68A5             LDR      R5,[R4, #+8]
   3703            retState = SBC_SEM_WAIT_TO_REGISTER;
   \        0x8   0x2609             MOVS     R6,#+9
   3704            gsy_connected_set((uint8_t)1); // the slave suppose that SEM is present 
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x.... 0x....      BL       gsy_connected_set
   3705          
   3706            if (((uint16_t)SCU_S_PS_STARTUP == *pWord)  || ((uint16_t)SCU_S_PS_NEW == *pWord))  // SCU_S_PS_STARTUP == 4 all slave SCU, secondary or primary 
   \       0x10   0x8828             LDRH     R0,[R5, #+0]
   \       0x12   0x2804             CMP      R0,#+4
   \       0x14   0xD002             BEQ.N    ??checkToSendReqAddress_0
   \       0x16   0x8828             LDRH     R0,[R5, #+0]
   \       0x18   0x2806             CMP      R0,#+6
   \       0x1A   0xD158             BNE.N    ??checkToSendReqAddress_1
   3707            {                                                                                   // SCU_S_PS_NEW == 6 all slave SCU, secondary or primary
   3708              /* the current slave is the same type required from master */
   3709              if (pMsg->data.rAddr == ADDR_EVSE_TM_RW)
   \                     ??checkToSendReqAddress_0: (+1)
   \       0x1C   0x88A0             LDRH     R0,[R4, #+4]
   \       0x1E   0x2822             CMP      R0,#+34
   \       0x20   0xD155             BNE.N    ??checkToSendReqAddress_1
   3710              {
   3711                if ((socketPresence.keyPresence != KEY_FULL_CONFIG)  || 
   3712                    ((socketPresence.keyPresence == KEY_FULL_CONFIG) && socketPresence.chainPresence ==0)) // coming from a factory reset 
   \       0x22   0xF64A 0x2055      MOVW     R0,#+43605
   \       0x26   0x....             LDR.N    R1,??DataTable22
   \       0x28   0x688A             LDR      R2,[R1, #+8]
   \       0x2A   0x4282             CMP      R2,R0
   \       0x2C   0xD105             BNE.N    ??checkToSendReqAddress_2
   \       0x2E   0x688A             LDR      R2,[R1, #+8]
   \       0x30   0x4282             CMP      R2,R0
   \       0x32   0xD14C             BNE.N    ??checkToSendReqAddress_1
   \       0x34   0x6808             LDR      R0,[R1, #+0]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD149             BNE.N    ??checkToSendReqAddress_1
   3713                {
   3714                  if (getSktNumInFakeCode() == 1)
   \                     ??checkToSendReqAddress_2: (+1)
   \       0x3A   0x.... 0x....      BL       getSktNumInFakeCode
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD13E             BNE.N    ??checkToSendReqAddress_3
   3715                  {
   3716                    /* only the first socket slave answer to require the address: the other wait for the assigning  message  */
   3717                    switch (getNumSktInProduct())
   \       0x42   0x.... 0x....      BL       getNumSktInProduct
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD004             BEQ.N    ??checkToSendReqAddress_4
   \       0x4A   0x2802             CMP      R0,#+2
   \       0x4C   0xD008             BEQ.N    ??checkToSendReqAddress_5
   \       0x4E   0x2804             CMP      R0,#+4
   \       0x50   0xD00D             BEQ.N    ??checkToSendReqAddress_6
   \       0x52   0xE013             B.N      ??checkToSendReqAddress_7
   3718                    {
   3719                      case 1:
   3720                        pScuTmMapReg->tmAddrSconnM = (uint16_t)0;
   \                     ??checkToSendReqAddress_4: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x.... 0x....      LDR.W    R1,??DataTable31
   \       0x5A   0x6809             LDR      R1,[R1, #+0]
   \       0x5C   0x80C8             STRH     R0,[R1, #+6]
   3721                        break;
   \       0x5E   0xE013             B.N      ??checkToSendReqAddress_8
   3722                      case 2:
   3723                        pScuTmMapReg->tmAddrSconnM = KEY_SCU_SLAVE_LINKED_2;
   \                     ??checkToSendReqAddress_5: (+1)
   \       0x60   0xF64C 0x4072      MOVW     R0,#+52338
   \       0x64   0x.... 0x....      LDR.W    R1,??DataTable31
   \       0x68   0x6809             LDR      R1,[R1, #+0]
   \       0x6A   0x80C8             STRH     R0,[R1, #+6]
   3724                        break;
   \       0x6C   0xE00C             B.N      ??checkToSendReqAddress_8
   3725                      case 4:
   3726                        pScuTmMapReg->tmAddrSconnM = KEY_SCU_SLAVE_LINKED_4;
   \                     ??checkToSendReqAddress_6: (+1)
   \       0x6E   0xF64C 0x4074      MOVW     R0,#+52340
   \       0x72   0x.... 0x....      LDR.W    R1,??DataTable31
   \       0x76   0x6809             LDR      R1,[R1, #+0]
   \       0x78   0x80C8             STRH     R0,[R1, #+6]
   3727                        break;
   \       0x7A   0xE005             B.N      ??checkToSendReqAddress_8
   3728                      default:
   3729                        pScuTmMapReg->tmAddrSconnM = KEY_SCU_SLAVE_LINKED_2;
   \                     ??checkToSendReqAddress_7: (+1)
   \       0x7C   0xF64C 0x4072      MOVW     R0,#+52338
   \       0x80   0x.... 0x....      LDR.W    R1,??DataTable31
   \       0x84   0x6809             LDR      R1,[R1, #+0]
   \       0x86   0x80C8             STRH     R0,[R1, #+6]
   3730                        break;
   3731                    }
   3732                    sbcSemInfoMng.dataVal = (uint16_t)0xFFFF;  /* set the flag for transmission executed to dummy state */
   \                     ??checkToSendReqAddress_8: (+1)
   \       0x88   0x.... 0x....      LDR.W    R8,??DataTable37
   \       0x8C   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x90   0xF8A8 0x0004      STRH     R0,[R8, #+4]
   3733                    sbcSemInfoMng.random = (uint32_t)getTagIdFromPrdSn();
   \       0x94   0x.... 0x....      BL       getTagIdFromPrdSn
   \       0x98   0xF8C8 0x001C      STR      R0,[R8, #+28]
   3734                    reqDelay =  (uint32_t)(sbcSemInfoMng.random / FACTOR_FOR_RANDOM_DELAY);  //  --> random delay from 0...2048 msec
   \       0x9C   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \       0xA0   0x0980             LSRS     R0,R0,#+6
   \       0xA2   0x0007             MOVS     R7,R0
   3735          
   3736                    /* to avoid possible conflit on first Tx byte a random delay is used  */
   3737                    //osDelay((uint32_t)(random / 100));  /* random delay in the range 0...655 msec depending on LSB CRC Product SN */
   3738                    
   3739                    while ((xTimerChangePeriod (xSbcSemTimers[TIMER_FOR_REQ_ADDR], reqDelay, SBCSEM_TIMER_GARD_TIME) != pdPASS)); 
   \                     ??checkToSendReqAddress_9: (+1)
   \       0xA4   0xF44F 0x70FA      MOV      R0,#+500
   \       0xA8   0x9000             STR      R0,[SP, #+0]
   \       0xAA   0x2300             MOVS     R3,#+0
   \       0xAC   0x003A             MOVS     R2,R7
   \       0xAE   0x2104             MOVS     R1,#+4
   \       0xB0   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \       0xB4   0x6900             LDR      R0,[R0, #+16]
   \       0xB6   0x.... 0x....      BL       xTimerGenericCommand
   \       0xBA   0x2801             CMP      R0,#+1
   \       0xBC   0xD1F2             BNE.N    ??checkToSendReqAddress_9
   \       0xBE   0xE006             B.N      ??checkToSendReqAddress_1
   3740                  }
   3741                  else
   3742                  {
   3743                    sbcSemInfoMng.dataVal = getTagIdFromPrdSn();  // copy in the tag Id the product SN crc  
   \                     ??checkToSendReqAddress_3: (+1)
   \       0xC0   0x.... 0x....      BL       getTagIdFromPrdSn
   \       0xC4   0x.... 0x....      LDR.W    R1,??DataTable37
   \       0xC8   0x8088             STRH     R0,[R1, #+4]
   3744                    /* the slave SCU wait for address */
   3745                    retState = SBC_SEM_WAIT_RS485_ADDR;
   \       0xCA   0x200A             MOVS     R0,#+10
   \       0xCC   0x0006             MOVS     R6,R0
   3746                  }
   3747                }
   3748              }
   3749            }
   3750            return(retState);
   \                     ??checkToSendReqAddress_1: (+1)
   \       0xCE   0x0030             MOVS     R0,R6
   \       0xD0   0xB280             UXTH     R0,R0
   \       0xD2   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   3751          }
   3752          
   3753          /**
   3754          *
   3755          * @brief       Check the assigned address received from master 
   3756          *
   3757          * @param [in]  frameSbcSem_st*: pointer to received message    
   3758          *  
   3759          * @retval      uint8_t: error code (0 = no error)  
   3760          *  
   3761          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3762          static uint8_t  checkAssignNewAddress(frameSbcSem_st* pMsg) 
   3763          {
   \                     checkAssignNewAddress: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   3764            uint16_t*             pWord;
   3765            uint16_t              ixScu, maskBit, idLogic;
   3766            uint8_t               modbusAddr, error, deviceId1, deviceId2;
   3767          
   3768            pWord = (uint16_t *)pMsg->dataToSend.pData;
   \        0x6   0x68A5             LDR      R5,[R4, #+8]
   3769            error = osOK;
   \        0x8   0xF05F 0x0800      MOVS     R8,#+0
   3770          
   3771            /* the received message from master (word sequence): tag id - modbusAddress - device Id 1 - device Id 2 */
   3772            if (sbcSemInfoMng.dataVal == *pWord) // check if it is my tag id (crc SN)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable37
   \       0x10   0x8880             LDRH     R0,[R0, #+4]
   \       0x12   0x8829             LDRH     R1,[R5, #+0]
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD166             BNE.N    ??checkAssignNewAddress_0
   3773            {
   3774              /* recovery the modbusAddress  */
   3775              pWord++;
   \       0x18   0x1CAD             ADDS     R5,R5,#+2
   3776              ixScu = modbusAddr = (uint8_t)(*pWord);
   \       0x1A   0x8828             LDRH     R0,[R5, #+0]
   \       0x1C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x20   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x24   0x0006             MOVS     R6,R0
   3777              modbusAddr--;                                    // for hystoryc reason we stored modbusAddr - 1
   \       0x26   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2A   0x1E40             SUBS     R0,R0,#+1
   \       0x2C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3778              if (pMsg->data.rAddr == ADDR_TM_ADDR_REQ_RW)
   \       0x30   0x88A0             LDRH     R0,[R4, #+4]
   \       0x32   0xF240 0x5114      MOVW     R1,#+1300
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD157             BNE.N    ??checkAssignNewAddress_1
   3779              {
   3780                socketPresence.keyPresence = KEY_FULL_CONFIG;
   \       0x3A   0x.... 0x....      LDR.W    R11,??DataTable53
   \       0x3E   0xF64A 0x2055      MOVW     R0,#+43605
   \       0x42   0xF8CB 0x0008      STR      R0,[R11, #+8]
   3781                pWord++;
   \       0x46   0x1CA8             ADDS     R0,R5,#+2
   3782                deviceId1 = (uint8_t)(*pWord);                 // the master assign the address at the first socket i.e. the socket with SocketNumber = 1
   \       0x48   0x8801             LDRH     R1,[R0, #+0]
   \       0x4A   0x4689             MOV      R9,R1
   3783                pWord++;
   \       0x4C   0x1C85             ADDS     R5,R0,#+2
   3784                deviceId2 = (uint8_t)(*pWord);                 // the second device Id assigned from master  
   \       0x4E   0x8828             LDRH     R0,[R5, #+0]
   \       0x50   0x4682             MOV      R10,R0
   3785                if (getSktNumInFakeCode() == 1)
   \       0x52   0x.... 0x....      BL       getSktNumInFakeCode
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD103             BNE.N    ??checkAssignNewAddress_2
   3786                {
   3787                  idLogic = deviceId1;
   \       0x5A   0x4648             MOV      R0,R9
   \       0x5C   0xB2C0             UXTB     R0,R0
   \       0x5E   0x0007             MOVS     R7,R0
   \       0x60   0xE008             B.N      ??checkAssignNewAddress_3
   3788                }
   3789                else
   3790                {
   3791                  idLogic = deviceId2;
   \                     ??checkAssignNewAddress_2: (+1)
   \       0x62   0x4650             MOV      R0,R10
   \       0x64   0xB2C0             UXTB     R0,R0
   \       0x66   0x0007             MOVS     R7,R0
   3792                  modbusAddr++;                               // the linked SCU has address + 1 from the original SCU
   \       0x68   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x6C   0x1C40             ADDS     R0,R0,#+1
   \       0x6E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3793                  ixScu++;
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   3794                }
   3795                maskBit = sbcSemMaskBit[idLogic];
   \                     ??checkAssignNewAddress_3: (+1)
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \       0x78   0x0039             MOVS     R1,R7
   \       0x7A   0xB289             UXTH     R1,R1
   \       0x7C   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \       0x80   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   3796                socketPresence.livePresence |= maskBit;
   \       0x84   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \       0x88   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \       0x8C   0x4301             ORRS     R1,R0,R1
   \       0x8E   0xF8CB 0x1004      STR      R1,[R11, #+4]
   3797                socketPresence.matrixConv[idLogic] = ixScu;           // update matrix deviceId with physical Modbus Address
   \       0x92   0x0038             MOVS     R0,R7
   \       0x94   0xB280             UXTH     R0,R0
   \       0x96   0x4458             ADD      R0,R11,R0
   \       0x98   0x7406             STRB     R6,[R0, #+16]
   3798                socketPresence.matrixIdConn[idLogic] = idLogic + 1;   // update matrix idConn: default is device id + 1 (number on LCD)
   \       0x9A   0x1C78             ADDS     R0,R7,#+1
   \       0x9C   0x0039             MOVS     R1,R7
   \       0x9E   0xB289             UXTH     R1,R1
   \       0xA0   0x4459             ADD      R1,R11,R1
   \       0xA2   0xF881 0x0030      STRB     R0,[R1, #+48]
   3799          
   3800                /* a new address must be set */
   3801                eeprom_array_set(RS485_ADD_EADD, (uint8_t*)&modbusAddr, 1);
   \       0xA6   0x2201             MOVS     R2,#+1
   \       0xA8   0x4669             MOV      R1,SP
   \       0xAA   0x2009             MOVS     R0,#+9
   \       0xAC   0x.... 0x....      BL       eeprom_array_set
   3802                if (WriteOnEeprom(RS485_ADD_EADD, (uint8_t*)&modbusAddr, 1) == osOK)
   \       0xB0   0x2201             MOVS     R2,#+1
   \       0xB2   0x4669             MOV      R1,SP
   \       0xB4   0x2009             MOVS     R0,#+9
   \       0xB6   0x.... 0x....      BL       WriteOnEeprom
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD101             BNE.N    ??checkAssignNewAddress_4
   3803                {
   3804                  /* it necessary to change current SCU modbus address */
   3805                  updateScuModbusAddrr();
   \       0xBE   0x.... 0x....      BL       updateScuModbusAddrr
   3806                }
   3807                if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \                     ??checkAssignNewAddress_4: (+1)
   \       0xC2   0x2254             MOVS     R2,#+84
   \       0xC4   0x4659             MOV      R1,R11
   \       0xC6   0xF44F 0x50F4      MOV      R0,#+7808
   \       0xCA   0x.... 0x....      BL       WriteOnEeprom
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD106             BNE.N    ??checkAssignNewAddress_5
   3808                {
   3809                  tPrintf("Assigned Physical address %d\n\r", ixScu);
   \       0xD2   0x0031             MOVS     R1,R6
   \       0xD4   0xB289             UXTH     R1,R1
   \       0xD6   0x.... 0x....      LDR.W    R0,??DataTable53_2
   \       0xDA   0x.... 0x....      BL       tPrintf
   \       0xDE   0xE004             B.N      ??checkAssignNewAddress_1
   3810                }
   3811                else
   3812                {
   3813                  error = (uint8_t)1;
   \                     ??checkAssignNewAddress_5: (+1)
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0x4680             MOV      R8,R0
   \       0xE4   0xE001             B.N      ??checkAssignNewAddress_1
   3814                }
   3815              }
   3816            }
   3817            else
   3818            {
   3819              error = (uint8_t)2;
   \                     ??checkAssignNewAddress_0: (+1)
   \       0xE6   0x2002             MOVS     R0,#+2
   \       0xE8   0x4680             MOV      R8,R0
   3820            }
   3821            return(error);
   \                     ??checkAssignNewAddress_1: (+1)
   \       0xEA   0x4640             MOV      R0,R8
   \       0xEC   0xB2C0             UXTB     R0,R0
   \       0xEE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   3822          }
   3823          
   3824          /**
   3825          *
   3826          * @brief       Manager the new modbus address request from a 
   3827          *              slave
   3828          *
   3829          * @param [in]  frameSbcSem_st*: pointer to received message    
   3830          *  
   3831          * @retval      none  
   3832          *  
   3833          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3834          static void  mngReqAddress(frameSbcSem_st* pMsg) 
   3835          {
   \                     mngReqAddress: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x0004             MOVS     R4,R0
   3836            uint16_t*             pWord;
   3837            frameSbcSem_st        tmpFrameSbcSem;  
   3838            uint32_t              maskBit;
   3839          
   3840            sbcSemInfoMng.firstIdFree = getFirstFreeLogicId();
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable37
   \        0xC   0x.... 0x....      BL       getFirstFreeLogicId
   \       0x10   0x8078             STRH     R0,[R7, #+2]
   3841          #ifdef TRANSLATE_ID_LOGIC
   3842            sbcSemInfoMng.addrModFree = setModbusAddress();
   3843          #else
   3844            /* default relation is: address on modbus is logic Id (sbcSemInfoMng.firstIdFree) + 1 */
   3845            sbcSemInfoMng.addrModFree = sbcSemInfoMng.firstIdFree + 1;
   \       0x12   0x8878             LDRH     R0,[R7, #+2]
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \       0x16   0xF887 0x0026      STRB     R0,[R7, #+38]
   3846          #endif
   3847          
   3848            /* a  secondary slave SCU is present in the chain and requires an address */
   3849            pWord = (uint16_t *)pMsg->dataToSend.pData;
   \       0x1A   0x68A0             LDR      R0,[R4, #+8]
   3850            /* a  secondary master SCU is present in the chain and requires an address */
   3851            pScuTmMapReg->tmAddrSconnM = *pWord;                      // copy the flag for slave linked
   \       0x1C   0x.... 0x....      LDR.W    R8,??DataTable31
   \       0x20   0x8801             LDRH     R1,[R0, #+0]
   \       0x22   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x26   0x80D1             STRH     R1,[R2, #+6]
   3852            pWord++;
   \       0x28   0x1C81             ADDS     R1,R0,#+2
   3853            pScuTmMapReg->tmAddrReq = *pWord;                         // copy the tag Id 
   \       0x2A   0x8808             LDRH     R0,[R1, #+0]
   \       0x2C   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x30   0x8110             STRH     R0,[R2, #+8]
   3854             
   3855            pScuTmMapReg->tmAddrAss = (uint16_t)sbcSemInfoMng.addrModFree;          // assign the first free modbus address (LSB) 
   \       0x32   0xF897 0x0026      LDRB     R0,[R7, #+38]
   \       0x36   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x3A   0x8150             STRH     R0,[R2, #+10]
   3856            pScuTmMapReg->tmError1InTest = (uint16_t)sbcSemInfoMng.firstIdFree;     // assign the logic Id to be used for the slave in MSB
   \       0x3C   0x8878             LDRH     R0,[R7, #+2]
   \       0x3E   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x42   0x8190             STRH     R0,[R2, #+12]
   3857            pWord = (uint16_t*)&pScuTmMapReg->tmError1InTest;
   \       0x44   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x48   0xF110 0x050C      ADDS     R5,R0,#+12
   3858            tmpFrameSbcSem.dataToSend.len = (uint16_t)3;                            /* we send 3 word starting from ADDR_TM_ADDR_REQ_RW */
   \       0x4C   0x2003             MOVS     R0,#+3
   \       0x4E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   3859            tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \       0x52   0x2003             MOVS     R0,#+3
   \       0x54   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   3860            tmpFrameSbcSem.data.index = MODBUS_BROADCAST_ADDR;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   3861            tmpFrameSbcSem.data.rAddr = ADDR_TM_ADDR_REQ_RW;
   \       0x5E   0xF240 0x5014      MOVW     R0,#+1300
   \       0x62   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   3862            tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&pScuTmMapReg->tmAddrReq;
   \       0x66   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x6A   0x3008             ADDS     R0,R0,#+8
   \       0x6C   0x9002             STR      R0,[SP, #+8]
   3863          
   3864            maskBit = sbcSemMaskBit[sbcSemInfoMng.firstIdFree];
   \       0x6E   0x.... 0x....      LDR.W    R9,??DataTable53_1
   \       0x72   0x8878             LDRH     R0,[R7, #+2]
   \       0x74   0xF859 0x6020      LDR      R6,[R9, R0, LSL #+2]
   3865            socketPresence.livePresence |= maskBit;
   \       0x78   0x.... 0x....      LDR.W    R10,??DataTable53
   \       0x7C   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x80   0x4330             ORRS     R0,R6,R0
   \       0x82   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3866            socketPresence.chainPresence |= maskBit;
   \       0x86   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x8A   0x4330             ORRS     R0,R6,R0
   \       0x8C   0xF8CA 0x0000      STR      R0,[R10, #+0]
   3867            sbcSemInfoMng.activityStatus |= maskBit;
   \       0x90   0x6978             LDR      R0,[R7, #+20]
   \       0x92   0x4330             ORRS     R0,R6,R0
   \       0x94   0x6178             STR      R0,[R7, #+20]
   3868            socketPresence.matrixConv[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.addrModFree;
   \       0x96   0xF897 0x0026      LDRB     R0,[R7, #+38]
   \       0x9A   0x887A             LDRH     R2,[R7, #+2]
   \       0x9C   0x4452             ADD      R2,R10,R2
   \       0x9E   0x7410             STRB     R0,[R2, #+16]
   3869            socketPresence.matrixIdConn[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.firstIdFree + 1;
   \       0xA0   0x8878             LDRH     R0,[R7, #+2]
   \       0xA2   0x1C40             ADDS     R0,R0,#+1
   \       0xA4   0x887A             LDRH     R2,[R7, #+2]
   \       0xA6   0x4452             ADD      R2,R10,R2
   \       0xA8   0xF882 0x0030      STRB     R0,[R2, #+48]
   3870            if (sbcSemInfoMng.discoveryMask == 0)
   \       0xAC   0xF117 0x020A      ADDS     R2,R7,#+10
   \       0xB0   0x6810             LDR      R0,[R2, #+0]
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD102             BNE.N    ??mngReqAddress_0
   3871            {
   3872              sbcSemInfoMng.discoveryMask = maskBit;                        // set the mask to start the next info request phase 
   \       0xB6   0x6016             STR      R6,[R2, #+0]
   3873              sbcSemInfoMng.logicIdSocket = sbcSemInfoMng.firstIdFree;      // set the logic address for the first new assigned socket 
   \       0xB8   0x8878             LDRH     R0,[R7, #+2]
   \       0xBA   0x8138             STRH     R0,[R7, #+8]
   3874            }
   3875            if ((pScuTmMapReg->tmAddrSconnM == KEY_SCU_SLAVE_LINKED_2) || (pScuTmMapReg->tmAddrSconnM == KEY_SCU_SLAVE_LINKED_4))
   \                     ??mngReqAddress_0: (+1)
   \       0xBC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xC0   0x88C0             LDRH     R0,[R0, #+6]
   \       0xC2   0xF64C 0x4172      MOVW     R1,#+52338
   \       0xC6   0x4288             CMP      R0,R1
   \       0xC8   0xD007             BEQ.N    ??mngReqAddress_1
   \       0xCA   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xCE   0x88C0             LDRH     R0,[R0, #+6]
   \       0xD0   0xF64C 0x4174      MOVW     R1,#+52340
   \       0xD4   0x4288             CMP      R0,R1
   \       0xD6   0xF040 0x808A      BNE.W    ??mngReqAddress_2
   3876            {
   3877              sbcSemInfoMng.firstIdFree = getFirstFreeLogicId();
   \                     ??mngReqAddress_1: (+1)
   \       0xDA   0x.... 0x....      BL       getFirstFreeLogicId
   \       0xDE   0x8078             STRH     R0,[R7, #+2]
   3878          #ifdef TRANSLATE_ID_LOGIC
   3879              sbcSemInfoMng.addrModFree = setModbusAddress();
   3880          #else
   3881              /* default relation is: address on modbus is logic Id (sbcSemInfoMng.firstIdFree) + 1 */
   3882              sbcSemInfoMng.addrModFree = sbcSemInfoMng.firstIdFree + 1;
   \       0xE0   0x8878             LDRH     R0,[R7, #+2]
   \       0xE2   0x1C40             ADDS     R0,R0,#+1
   \       0xE4   0xF887 0x0026      STRB     R0,[R7, #+38]
   3883          #endif
   3884              /* this secondary slave  has a SCU slave linked the next id is assigned using same tagId*/
   3885              maskBit = sbcSemMaskBit[sbcSemInfoMng.firstIdFree];
   \       0xE8   0x8878             LDRH     R0,[R7, #+2]
   \       0xEA   0xF859 0x0020      LDR      R0,[R9, R0, LSL #+2]
   \       0xEE   0x0006             MOVS     R6,R0
   3886              socketPresence.livePresence |= maskBit;
   \       0xF0   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0xF4   0x4330             ORRS     R0,R6,R0
   \       0xF6   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3887              socketPresence.chainPresence |= maskBit;
   \       0xFA   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xFE   0x4330             ORRS     R0,R6,R0
   \      0x100   0xF8CA 0x0000      STR      R0,[R10, #+0]
   3888              sbcSemInfoMng.activityStatus |= maskBit;
   \      0x104   0x6978             LDR      R0,[R7, #+20]
   \      0x106   0x4330             ORRS     R0,R6,R0
   \      0x108   0x6178             STR      R0,[R7, #+20]
   3889              socketPresence.matrixConv[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.addrModFree;
   \      0x10A   0xF897 0x0026      LDRB     R0,[R7, #+38]
   \      0x10E   0x8879             LDRH     R1,[R7, #+2]
   \      0x110   0x4451             ADD      R1,R10,R1
   \      0x112   0x7408             STRB     R0,[R1, #+16]
   3890              socketPresence.matrixIdConn[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.firstIdFree + 1;
   \      0x114   0x8878             LDRH     R0,[R7, #+2]
   \      0x116   0x1C40             ADDS     R0,R0,#+1
   \      0x118   0x8879             LDRH     R1,[R7, #+2]
   \      0x11A   0x4451             ADD      R1,R10,R1
   \      0x11C   0xF881 0x0030      STRB     R0,[R1, #+48]
   3891              /* update info for the slave */
   3892              tmpFrameSbcSem.dataToSend.len++;                                        /* we send 4 word starting from ADDR_TM_ADDR_REQ_RW */
   \      0x120   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x124   0x1C40             ADDS     R0,R0,#+1
   \      0x126   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   3893              pWord++;
   \      0x12A   0x1CAD             ADDS     R5,R5,#+2
   3894              *pWord = (uint16_t)sbcSemInfoMng.firstIdFree;
   \      0x12C   0x8878             LDRH     R0,[R7, #+2]
   \      0x12E   0x8028             STRH     R0,[R5, #+0]
   3895          
   3896              if (pScuTmMapReg->tmAddrSconnM == KEY_SCU_SLAVE_LINKED_4)
   \      0x130   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x134   0x88C0             LDRH     R0,[R0, #+6]
   \      0x136   0xF64C 0x4174      MOVW     R1,#+52340
   \      0x13A   0x4288             CMP      R0,R1
   \      0x13C   0xD157             BNE.N    ??mngReqAddress_2
   3897              {
   3898                sbcSemInfoMng.firstIdFree = getFirstFreeLogicId();
   \      0x13E   0x.... 0x....      BL       getFirstFreeLogicId
   \      0x142   0x8078             STRH     R0,[R7, #+2]
   3899          #ifdef TRANSLATE_ID_LOGIC
   3900                sbcSemInfoMng.addrModFree = setModbusAddress();
   3901          #else
   3902                /* default relation is: address on modbus is logic Id (sbcSemInfoMng.firstIdFree) + 1 */
   3903                sbcSemInfoMng.addrModFree = sbcSemInfoMng.firstIdFree + 1;
   \      0x144   0x8878             LDRH     R0,[R7, #+2]
   \      0x146   0x1C40             ADDS     R0,R0,#+1
   \      0x148   0xF887 0x0026      STRB     R0,[R7, #+38]
   3904          #endif
   3905                /* this secondary master has a 3 SCU slave linked the next id is assigned using same tagId*/
   3906                maskBit = sbcSemMaskBit[sbcSemInfoMng.firstIdFree];
   \      0x14C   0x8878             LDRH     R0,[R7, #+2]
   \      0x14E   0xF859 0x8020      LDR      R8,[R9, R0, LSL #+2]
   3907                socketPresence.livePresence |= maskBit;
   \      0x152   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x156   0xEA58 0x0000      ORRS     R0,R8,R0
   \      0x15A   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3908                socketPresence.chainPresence |= maskBit;
   \      0x15E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x162   0xEA58 0x0000      ORRS     R0,R8,R0
   \      0x166   0xF8CA 0x0000      STR      R0,[R10, #+0]
   3909                sbcSemInfoMng.activityStatus |= maskBit;
   \      0x16A   0x6978             LDR      R0,[R7, #+20]
   \      0x16C   0xEA58 0x0000      ORRS     R0,R8,R0
   \      0x170   0x6178             STR      R0,[R7, #+20]
   3910                socketPresence.matrixConv[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.addrModFree;
   \      0x172   0xF897 0x0026      LDRB     R0,[R7, #+38]
   \      0x176   0x8879             LDRH     R1,[R7, #+2]
   \      0x178   0x4451             ADD      R1,R10,R1
   \      0x17A   0x7408             STRB     R0,[R1, #+16]
   3911                socketPresence.matrixIdConn[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.firstIdFree + 1;
   \      0x17C   0x8878             LDRH     R0,[R7, #+2]
   \      0x17E   0x1C40             ADDS     R0,R0,#+1
   \      0x180   0x8879             LDRH     R1,[R7, #+2]
   \      0x182   0x4451             ADD      R1,R10,R1
   \      0x184   0xF881 0x0030      STRB     R0,[R1, #+48]
   3912                /* update info for the slave */
   3913                tmpFrameSbcSem.dataToSend.len++;                                        /* we send 5 word starting from ADDR_TM_ADDR_REQ_RW */
   \      0x188   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x18C   0x1C40             ADDS     R0,R0,#+1
   \      0x18E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   3914                pWord++;
   \      0x192   0x1CAD             ADDS     R5,R5,#+2
   3915                *pWord = (uint16_t)sbcSemInfoMng.firstIdFree;
   \      0x194   0x8878             LDRH     R0,[R7, #+2]
   \      0x196   0x8028             STRH     R0,[R5, #+0]
   3916          
   3917                /* set the 4th socket */
   3918                sbcSemInfoMng.firstIdFree = getFirstFreeLogicId();
   \      0x198   0x.... 0x....      BL       getFirstFreeLogicId
   \      0x19C   0x8078             STRH     R0,[R7, #+2]
   3919          #ifdef TRANSLATE_ID_LOGIC
   3920                sbcSemInfoMng.addrModFree = setModbusAddress();
   3921          #else
   3922                /* default relation is: address on modbus is logic Id (sbcSemInfoMng.firstIdFree) + 1 */
   3923                sbcSemInfoMng.addrModFree = sbcSemInfoMng.firstIdFree + 1;
   \      0x19E   0x8878             LDRH     R0,[R7, #+2]
   \      0x1A0   0x1C40             ADDS     R0,R0,#+1
   \      0x1A2   0xF887 0x0026      STRB     R0,[R7, #+38]
   3924          #endif
   3925                maskBit = sbcSemMaskBit[sbcSemInfoMng.firstIdFree];
   \      0x1A6   0x8878             LDRH     R0,[R7, #+2]
   \      0x1A8   0xF859 0x0020      LDR      R0,[R9, R0, LSL #+2]
   \      0x1AC   0x0006             MOVS     R6,R0
   3926                socketPresence.livePresence |= maskBit;
   \      0x1AE   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x1B2   0x4330             ORRS     R0,R6,R0
   \      0x1B4   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3927                socketPresence.chainPresence |= maskBit;
   \      0x1B8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1BC   0x4330             ORRS     R0,R6,R0
   \      0x1BE   0xF8CA 0x0000      STR      R0,[R10, #+0]
   3928                sbcSemInfoMng.activityStatus |= maskBit;
   \      0x1C2   0x6978             LDR      R0,[R7, #+20]
   \      0x1C4   0x4330             ORRS     R0,R6,R0
   \      0x1C6   0x6178             STR      R0,[R7, #+20]
   3929                socketPresence.matrixConv[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.addrModFree;
   \      0x1C8   0xF897 0x0026      LDRB     R0,[R7, #+38]
   \      0x1CC   0x8879             LDRH     R1,[R7, #+2]
   \      0x1CE   0x4451             ADD      R1,R10,R1
   \      0x1D0   0x7408             STRB     R0,[R1, #+16]
   3930                socketPresence.matrixIdConn[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.firstIdFree + 1;
   \      0x1D2   0x8878             LDRH     R0,[R7, #+2]
   \      0x1D4   0x1C40             ADDS     R0,R0,#+1
   \      0x1D6   0x8879             LDRH     R1,[R7, #+2]
   \      0x1D8   0x4451             ADD      R1,R10,R1
   \      0x1DA   0xF881 0x0030      STRB     R0,[R1, #+48]
   3931                /* update info for the slave */
   3932                tmpFrameSbcSem.dataToSend.len++;                                        /* we send 6 word starting from ADDR_TM_ADDR_REQ_RW */
   \      0x1DE   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x1E2   0x1C40             ADDS     R0,R0,#+1
   \      0x1E4   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   3933                pWord++;
   \      0x1E8   0x1CAD             ADDS     R5,R5,#+2
   3934                *pWord = (uint16_t)sbcSemInfoMng.firstIdFree;
   \      0x1EA   0x8878             LDRH     R0,[R7, #+2]
   \      0x1EC   0x8028             STRH     R0,[R5, #+0]
   3935              }
   3936            }
   3937            configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \                     ??mngReqAddress_2: (+1)
   \      0x1EE   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x1F2   0x2300             MOVS     R3,#+0
   \      0x1F4   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x1F8   0x4669             MOV      R1,SP
   \      0x1FA   0x.... 0x....      BL       xQueueGenericSend
   \      0x1FE   0x2801             CMP      R0,#+1
   \      0x200   0xD009             BEQ.N    ??mngReqAddress_3
   \      0x202   0xB672             CPSID    I
   \      0x204   0x2050             MOVS     R0,#+80
   \      0x206   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x20A   0xF3BF 0x8F4F      DSB      SY
   \      0x20E   0xF3BF 0x8F6F      ISB      SY
   \      0x212   0xB662             CPSIE    I
   \                     ??mngReqAddress_4: (+1)
   \      0x214   0xE7FE             B.N      ??mngReqAddress_4
   3938            restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_NEXT_DISCOVERY); // the master restart the timeout 2500msec
   \                     ??mngReqAddress_3: (+1)
   \      0x216   0xF640 0x11C4      MOVW     R1,#+2500
   \      0x21A   0x2000             MOVS     R0,#+0
   \      0x21C   0x.... 0x....      BL       restartSbcSemTimer
   3939          }
   \      0x220   0xB006             ADD      SP,SP,#+24
   \      0x222   0xE8BD 0x87F0      POP      {R4-R10,PC}
   3940          
   3941          /**
   3942          *
   3943          * @brief       get pointer to socket info  
   3944          *
   3945          * @param [in]  none    
   3946          *  
   3947          * @retval      none  
   3948          *  
   3949          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3950          socketPresence_t* getDefSocketInfoPtr(void) 
   3951          {
   3952          
   3953            return((socketPresence_t*)&Default_Socket_Presence);
   \                     getDefSocketInfoPtr: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53_3
   \        0x4   0x4770             BX       LR
   3954          }
   3955          
   3956          /**
   3957          *
   3958          * @brief       get the number of discovered socket (could be > 
   3959          *              then socketPresence.livePresence
   3960          *
   3961          * @param [in]  none    
   3962          *  
   3963          * @retval      uint16_t: bit position discovered sockets  
   3964          *  
   3965          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3966          uint32_t getSocketDiscovered(void) 
   3967          {
   3968          
   3969            return(socketPresence.chainPresence);
   \                     getSocketDiscovered: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR
   3970          }
   3971          
   3972          /**
   3973          *
   3974          * @brief       save the number of effective socket 
   3975          *
   3976          * @param [in]  uint16_t: bit mask for present sockets    
   3977          *  
   3978          * @retval      none  
   3979          *  
   3980          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3981          void setSocketDiscovered(uint16_t maskPresence) 
   3982          {
   \                     setSocketDiscovered: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3983          
   3984            socketPresence.chainPresence = maskPresence;
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable53
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0xB280             UXTH     R0,R0
   \        0xC   0x6028             STR      R0,[R5, #+0]
   3985            /* save in EEPROM also  */
   3986            if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \        0xE   0x2254             MOVS     R2,#+84
   \       0x10   0x0029             MOVS     R1,R5
   \       0x12   0xF44F 0x50F4      MOV      R0,#+7808
   \       0x16   0x.... 0x....      BL       WriteOnEeprom
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD104             BNE.N    ??setSocketDiscovered_0
   3987            {
   3988              tPrintf("Presences confirmed --> 0x%x\n\r", socketPresence.chainPresence);
   \       0x1E   0x6829             LDR      R1,[R5, #+0]
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable53_4
   \       0x24   0x.... 0x....      BL       tPrintf
   3989            }
   3990          }
   \                     ??setSocketDiscovered_0: (+1)
   \       0x28   0xBD31             POP      {R0,R4,R5,PC}
   3991          
   3992          /**
   3993          *
   3994          * @brief       Restore all SCU to factory parameters  
   3995          *
   3996          * @param [in]  none    
   3997          *  
   3998          * @retval      none  
   3999          *  
   4000          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4001          void restoreFactoryDefaultForAll(void) 
   4002          {
   \                     restoreFactoryDefaultForAll: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   4003            frameSbcSem_st        tmpFrameSbcSem;  
   4004          
   4005            if (isSemMasterFz() == TRUE)
   \        0x4   0x.... 0x....      BL       isSemMasterFz
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD12E             BNE.N    ??restoreFactoryDefaultForAll_0
   4006            {
   4007              sbcSemInfoMng.dataVal = (uint16_t)SCU_ALL_FACTORY_PARAM;   
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable53_5
   \       0x10   0xF64F 0x71EC      MOVW     R1,#+65516
   \       0x14   0x8081             STRH     R1,[R0, #+4]
   4008              tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \       0x16   0x2103             MOVS     R1,#+3
   \       0x18   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   4009              tmpFrameSbcSem.data.index = MODBUS_BROADCAST_ADDR;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0xF8AD 0x1002      STRH     R1,[SP, #+2]
   4010              tmpFrameSbcSem.data.rAddr = ADDR_EVSE_TM_RW;
   \       0x22   0x2122             MOVS     R1,#+34
   \       0x24   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   4011              tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \       0x28   0x1D00             ADDS     R0,R0,#+4
   \       0x2A   0x9002             STR      R0,[SP, #+8]
   4012              tmpFrameSbcSem.dataToSend.len = LEN_EVSE_TM_MODE_RW;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   4013              configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \       0x32   0x.... 0x....      BL       getRs485SemQueueHandle
   \       0x36   0x2300             MOVS     R3,#+0
   \       0x38   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x3C   0x4669             MOV      R1,SP
   \       0x3E   0x.... 0x....      BL       xQueueGenericSend
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD009             BEQ.N    ??restoreFactoryDefaultForAll_1
   \       0x46   0xB672             CPSID    I
   \       0x48   0x2050             MOVS     R0,#+80
   \       0x4A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x4E   0xF3BF 0x8F4F      DSB      SY
   \       0x52   0xF3BF 0x8F6F      ISB      SY
   \       0x56   0xB662             CPSIE    I
   \                     ??restoreFactoryDefaultForAll_2: (+1)
   \       0x58   0xE7FE             B.N      ??restoreFactoryDefaultForAll_2
   4014              osDelay(500);
   \                     ??restoreFactoryDefaultForAll_1: (+1)
   \       0x5A   0xF44F 0x70FA      MOV      R0,#+500
   \       0x5E   0x.... 0x....      BL       osDelay
   4015              eraseAllBoardInfoEeprom();
   \       0x62   0x.... 0x....      BL       eraseAllBoardInfoEeprom
   4016              restoreFactoryDefault();
   \       0x66   0x.... 0x....      BL       restoreFactoryDefault
   4017            }
   4018          }
   \                     ??restoreFactoryDefaultForAll_0: (+1)
   \       0x6A   0xB005             ADD      SP,SP,#+20
   \       0x6C   0xBD00             POP      {PC}
   4019          
   4020          /**
   4021          *
   4022          * @brief       Get the modbus control manager status   
   4023          *
   4024          * @param [in]  none    
   4025          *  
   4026          * @retval      uint8_t: TRUE if operative   
   4027          *  
   4028          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4029          uint8_t isModbusManagerActive (void) 
   4030          {
   4031            if (sbcSemInfoMng.sbcSemStates == SBC_SEM_OPERATIVE) return(TRUE); else return(FALSE);
   \                     isModbusManagerActive: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53_5
   \        0x4   0x8800             LDRH     R0,[R0, #+0]
   \        0x6   0x2804             CMP      R0,#+4
   \        0x8   0xD101             BNE.N    ??isModbusManagerActive_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??isModbusManagerActive_1
   \                     ??isModbusManagerActive_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??isModbusManagerActive_1: (+1)
   \       0x10   0x4770             BX       LR
   4032          }
   4033          
   4034          /**
   4035          *
   4036          * @brief       Get the slave status operative   
   4037          *
   4038          * @param [in]  none    
   4039          *  
   4040          * @retval      uint8_t: TRUE if the slave in a no transmission 
   4041          *              window (wait to be operative, typically a little
   4042          *              time after the address has been assigned)
   4043          *  
   4044          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4045          uint8_t isSlaveWaitToBeOperative (void) 
   4046          {
   4047            if (sbcSemInfoMng.sbcSemStates == SBC_SEM_BLANK_AFTER_ASS_ADDR) return(TRUE); else return(FALSE);
   \                     isSlaveWaitToBeOperative: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53_5
   \        0x4   0x8800             LDRH     R0,[R0, #+0]
   \        0x6   0x280F             CMP      R0,#+15
   \        0x8   0xD101             BNE.N    ??isSlaveWaitToBeOperative_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??isSlaveWaitToBeOperative_1
   \                     ??isSlaveWaitToBeOperative_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??isSlaveWaitToBeOperative_1: (+1)
   \       0x10   0x4770             BX       LR
   4048          }
   4049          
   4050          
   4051          /**
   4052          *
   4053          * @brief        Task to manage the the remote suspend / release  command    
   4054          *
   4055          * @param [in]   void*: parameters task  
   4056          *
   4057          * @retval       none 
   4058          *
   4059          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4060          static void remoteMngTask (void * pvParameters)
   4061          {
   \                     remoteMngTask: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4062            frameRemote_st frameRemote;  
   4063            uint32_t       timeTickRemote;
   4064          
   4065            /*-------- Creates an empty mailbox for uart  messages --------------------------*/
   4066            remoteMngQueue = xQueueCreate(NUM_BUFF_REMOTE, sizeof(frameRemote_st));
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable53_6
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x2103             MOVS     R1,#+3
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0x.... 0x....      BL       xQueueGenericCreate
   \       0x12   0x6028             STR      R0,[R5, #+0]
   4067            configASSERT(remoteMngQueue != NULL);
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD109             BNE.N    ??remoteMngTask_0
   \       0x1A   0xB672             CPSID    I
   \       0x1C   0x2050             MOVS     R0,#+80
   \       0x1E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x22   0xF3BF 0x8F4F      DSB      SY
   \       0x26   0xF3BF 0x8F6F      ISB      SY
   \       0x2A   0xB662             CPSIE    I
   \                     ??remoteMngTask_1: (+1)
   \       0x2C   0xE7FE             B.N      ??remoteMngTask_1
   4068            
   4069            /* init structure for management */
   4070            remoteMng.remoteStates = REMOTE_INIT;
   \                     ??remoteMngTask_0: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x.... 0x....      LDR.W    R1,??DataTable53_7
   \       0x34   0x7008             STRB     R0,[R1, #+0]
   4071          
   4072            timeTickRemote = TIMER_ACTION_AT_START;
   \       0x36   0x26C8             MOVS     R6,#+200
   4073          
   4074            for (;;)
   4075            {
   4076              /* Wait for some event from timer or message   */
   4077              if (xQueueReceive(remoteMngQueue, (void *)&frameRemote, timeTickRemote) == pdPASS)
   \                     ??remoteMngTask_2: (+1)
   \       0x38   0x0032             MOVS     R2,R6
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x.... 0x....      BL       xQueueReceive
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD104             BNE.N    ??remoteMngTask_3
   4078              {
   4079                timeTickRemote = remoteSuspRelProcess(&frameRemote);
   \       0x46   0x4668             MOV      R0,SP
   \       0x48   0x.... 0x....      BL       remoteSuspRelProcess
   \       0x4C   0x0006             MOVS     R6,R0
   \       0x4E   0xE7F3             B.N      ??remoteMngTask_2
   4080              }
   4081              else
   4082              {
   4083                frameRemote.currentEvent = REMOTE_TIMEOUT;
   \                     ??remoteMngTask_3: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xF88D 0x0000      STRB     R0,[SP, #+0]
   4084                timeTickRemote = remoteSuspRelProcess(&frameRemote);
   \       0x56   0x4668             MOV      R0,SP
   \       0x58   0x.... 0x....      BL       remoteSuspRelProcess
   \       0x5C   0x0006             MOVS     R6,R0
   \       0x5E   0xE7EB             B.N      ??remoteMngTask_2
   4085              }
   4086            }
   4087          }
   4088          
   4089          /**
   4090          *
   4091          * @brief        Manage the polling on present slave  
   4092          *
   4093          * @param [in]   frameSbcSem_st*: pointer to incoming message 
   4094          *
   4095          * @retval       uint32_t: new timeout 
   4096          *
   4097          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4098          static uint32_t remoteSuspRelProcess(frameRemote_st* pMsg)
   4099          {
   \                     remoteSuspRelProcess: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   4100            uint32_t              timeTickTmp, temp32;
   4101          
   4102          
   4103            timeTickTmp = portMAX_DELAY;
   \        0x4   0xF05F 0x36FF      MOVS     R6,#+4294967295
   4104          
   4105            if (pMsg->currentEvent == RETURN_TO_OPERATIVE) 
   \        0x8   0x7828             LDRB     R0,[R5, #+0]
   \        0xA   0x2810             CMP      R0,#+16
   \        0xC   0xD105             BNE.N    ??remoteSuspRelProcess_0
   4106            {
   4107              remoteMng.remoteStates = REMOTE_OPERATIVE;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable53_7
   \       0x14   0x7008             STRB     R0,[R1, #+0]
   4108              return(timeTickTmp);
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xE097             B.N      ??remoteSuspRelProcess_1
   4109           }
   4110          
   4111            switch (remoteMng.remoteStates)
   \                     ??remoteSuspRelProcess_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R7,??DataTable53_7
   \       0x1E   0x7838             LDRB     R0,[R7, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD009             BEQ.N    ??remoteSuspRelProcess_2
   \       0x24   0x2802             CMP      R0,#+2
   \       0x26   0xD045             BEQ.N    ??remoteSuspRelProcess_3
   \       0x28   0xD319             BCC.N    ??remoteSuspRelProcess_4
   \       0x2A   0x2804             CMP      R0,#+4
   \       0x2C   0xD068             BEQ.N    ??remoteSuspRelProcess_5
   \       0x2E   0xD341             BCC.N    ??remoteSuspRelProcess_3
   \       0x30   0x2805             CMP      R0,#+5
   \       0x32   0xF000 0x807F      BEQ.W    ??remoteSuspRelProcess_6
   \       0x36   0xE087             B.N      ??remoteSuspRelProcess_7
   4112            {
   4113              case REMOTE_INIT:
   4114                switch (pMsg->currentEvent)
   \                     ??remoteSuspRelProcess_2: (+1)
   \       0x38   0x7828             LDRB     R0,[R5, #+0]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD10E             BNE.N    ??remoteSuspRelProcess_8
   4115                {
   4116                  case REMOTE_TIMEOUT:
   4117                    if (getRemotePmFlag() == TRUE)
   \       0x3E   0x.... 0x....      BL       getRemotePmFlag
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD107             BNE.N    ??remoteSuspRelProcess_9
   4118                    {
   4119                      /* to inform Vania's world to use current max power defined by SEM or default */
   4120                      temp32 = getMaxTempPowerAc();
   \       0x46   0x.... 0x....      BL       getMaxTempPowerAc
   \       0x4A   0x0004             MOVS     R4,R0
   4121                      pmng_sem_power_set((uint16_t)temp32, 0xFF);
   \       0x4C   0x21FF             MOVS     R1,#+255
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0xB280             UXTH     R0,R0
   \       0x52   0x.... 0x....      BL       pmng_sem_power_set
   4122                    }
   4123                    /* no action on timeout after task is started */
   4124                    remoteMng.remoteStates = REMOTE_OPERATIVE;
   \                     ??remoteSuspRelProcess_9: (+1)
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0x7038             STRB     R0,[R7, #+0]
   4125                    break;
   \       0x5A   0xE7FF             B.N      ??remoteSuspRelProcess_10
   4126          
   4127                  default:
   4128                    break;
   4129                }
   4130                break;
   \                     ??remoteSuspRelProcess_8: (+1)
   \                     ??remoteSuspRelProcess_10: (+1)
   \       0x5C   0xE074             B.N      ??remoteSuspRelProcess_11
   4131          
   4132              case REMOTE_OPERATIVE:
   4133                switch (pMsg->currentEvent)
   \                     ??remoteSuspRelProcess_4: (+1)
   \       0x5E   0x7828             LDRB     R0,[R5, #+0]
   \       0x60   0x280F             CMP      R0,#+15
   \       0x62   0xD012             BEQ.N    ??remoteSuspRelProcess_12
   \       0x64   0x2817             CMP      R0,#+23
   \       0x66   0xD124             BNE.N    ??remoteSuspRelProcess_13
   4134                {
   4135                  case REMOTE_EVS_AUTH_START:
   4136                    temp32 = getMaxTempPowerAc();
   \                     ??remoteSuspRelProcess_14: (+1)
   \       0x68   0x.... 0x....      BL       getMaxTempPowerAc
   \       0x6C   0x0004             MOVS     R4,R0
   4137                    if (temp32 != 0)
   \       0x6E   0x2C00             CMP      R4,#+0
   \       0x70   0xD005             BEQ.N    ??remoteSuspRelProcess_15
   4138                    {
   4139                      /* SBC has written a non null power --> remove remote suspend if present  */
   4140                      send_to_evs(EVS_REMOTE_RELEASE);
   \       0x72   0x200E             MOVS     R0,#+14
   \       0x74   0x.... 0x....      BL       send_to_evs
   4141                      osDelay(100);
   \       0x78   0x2064             MOVS     R0,#+100
   \       0x7A   0x.... 0x....      BL       osDelay
   4142                    }
   4143                    send_to_evs(EVS_AUTH_START);
   \                     ??remoteSuspRelProcess_15: (+1)
   \       0x7E   0x2017             MOVS     R0,#+23
   \       0x80   0x.... 0x....      BL       send_to_evs
   4144                    remoteMng.remoteStates = REMOTE_EVS_AUTH;
   \       0x84   0x2002             MOVS     R0,#+2
   \       0x86   0x7038             STRB     R0,[R7, #+0]
   4145                    break;
   \       0x88   0xE013             B.N      ??remoteSuspRelProcess_16
   4146          
   4147                  case REMOTE_MAX_POWER_CHANGE:
   4148                    temp32 = getMaxTempPowerAc();
   \                     ??remoteSuspRelProcess_12: (+1)
   \       0x8A   0x.... 0x....      BL       getMaxTempPowerAc
   \       0x8E   0x0004             MOVS     R4,R0
   4149                    pmng_sem_power_set((uint16_t)temp32, 1);
   \       0x90   0x2101             MOVS     R1,#+1
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0xB280             UXTH     R0,R0
   \       0x96   0x.... 0x....      BL       pmng_sem_power_set
   4150          /*          if (evs_mode_get() == EVS_FREE_MODE)
   4151                    {
   4152                      if ((evs_state_get() == EVSTATE_CHARGING) && (temp32 == (uint32_t)0))
   4153                      {
   4154                        remoteMng.remoteStates = REMOTE_EVS_SUSPENDING;
   4155                        send_to_evs(EVS_REMOTE_SUSPENDING);
   4156                      }
   4157                      else
   4158                      {
   4159                        if ((evs_state_get() == EVSTATE_SUSPENDING) && (temp32 != (uint32_t)0))
   4160                        {
   4161                          remoteMng.remoteStates = REMOTE_EVS_RELEASE;
   4162                          send_to_evs(EVS_REMOTE_RELEASE);
   4163                        }
   4164                      }
   4165                    }
   4166                    else*/
   4167                    {
   4168                      if (temp32 == 0)
   \       0x9A   0x2C00             CMP      R4,#+0
   \       0x9C   0xD105             BNE.N    ??remoteSuspRelProcess_17
   4169                      {
   4170                        remoteMng.remoteStates = REMOTE_EVS_SUSPENDING;
   \       0x9E   0x2004             MOVS     R0,#+4
   \       0xA0   0x7038             STRB     R0,[R7, #+0]
   4171                        send_to_evs(EVS_REMOTE_SUSPENDING);
   \       0xA2   0x200D             MOVS     R0,#+13
   \       0xA4   0x.... 0x....      BL       send_to_evs
   \       0xA8   0xE002             B.N      ??remoteSuspRelProcess_18
   4172                      }
   4173                      else
   4174                      {
   4175                        /* SBC has written a non null power --> remove remote suspend if present  */
   4176                        send_to_evs(EVS_REMOTE_RELEASE);
   \                     ??remoteSuspRelProcess_17: (+1)
   \       0xAA   0x200E             MOVS     R0,#+14
   \       0xAC   0x.... 0x....      BL       send_to_evs
   4177                      }
   4178                    }
   4179                    break;
   \                     ??remoteSuspRelProcess_18: (+1)
   \       0xB0   0xE7FF             B.N      ??remoteSuspRelProcess_16
   4180          
   4181                  default:
   4182                    break;
   4183                }
   4184                break;
   \                     ??remoteSuspRelProcess_13: (+1)
   \                     ??remoteSuspRelProcess_16: (+1)
   \       0xB2   0xE049             B.N      ??remoteSuspRelProcess_11
   4185          
   4186              case REMOTE_EVS_AUTH:
   4187              case REMOTE_EVS_RELEASE:
   4188                switch (pMsg->currentEvent)
   \                     ??remoteSuspRelProcess_3: (+1)
   \       0xB4   0x7828             LDRB     R0,[R5, #+0]
   \       0xB6   0x280F             CMP      R0,#+15
   \       0xB8   0xD004             BEQ.N    ??remoteSuspRelProcess_19
   \       0xBA   0x2817             CMP      R0,#+23
   \       0xBC   0xD016             BEQ.N    ??remoteSuspRelProcess_20
   \       0xBE   0x2819             CMP      R0,#+25
   \       0xC0   0xD017             BEQ.N    ??remoteSuspRelProcess_21
   \       0xC2   0xE01C             B.N      ??remoteSuspRelProcess_22
   4189                {
   4190                  case REMOTE_MAX_POWER_CHANGE:
   4191                    temp32 = getMaxTempPowerAc();
   \                     ??remoteSuspRelProcess_19: (+1)
   \       0xC4   0x.... 0x....      BL       getMaxTempPowerAc
   \       0xC8   0x0004             MOVS     R4,R0
   4192                    pmng_sem_power_set((uint16_t)temp32, 1);
   \       0xCA   0x2101             MOVS     R1,#+1
   \       0xCC   0x0020             MOVS     R0,R4
   \       0xCE   0xB280             UXTH     R0,R0
   \       0xD0   0x.... 0x....      BL       pmng_sem_power_set
   4193                    /* SEM sent a new value for MAX_TEMPORARY_POWER_AC_RW */
   4194                    if (temp32 == (uint32_t)0)
   \       0xD4   0x2C00             CMP      R4,#+0
   \       0xD6   0xD105             BNE.N    ??remoteSuspRelProcess_23
   4195                    {
   4196                      remoteMng.remoteStates = REMOTE_EVS_SUSPENDING;
   \       0xD8   0x2004             MOVS     R0,#+4
   \       0xDA   0x7038             STRB     R0,[R7, #+0]
   4197                      send_to_evs(EVS_REMOTE_SUSPENDING);
   \       0xDC   0x200D             MOVS     R0,#+13
   \       0xDE   0x.... 0x....      BL       send_to_evs
   \       0xE2   0xE002             B.N      ??remoteSuspRelProcess_24
   4198                    }
   4199                    else // if (temp32 != (uint32_t)0)
   4200                    {
   4201                      send_to_evs(EVS_REMOTE_RELEASE);
   \                     ??remoteSuspRelProcess_23: (+1)
   \       0xE4   0x200E             MOVS     R0,#+14
   \       0xE6   0x.... 0x....      BL       send_to_evs
   4202                    }
   4203                    break;
   \                     ??remoteSuspRelProcess_24: (+1)
   \       0xEA   0xE008             B.N      ??remoteSuspRelProcess_25
   4204          
   4205                  case REMOTE_EVS_AUTH_START:
   4206                    /* da remoto su chiusura carica (inizia con questo messaggio  */
   4207                    remoteMng.remoteStates = REMOTE_EVS_WAIT_TO_STOP;
   \                     ??remoteSuspRelProcess_20: (+1)
   \       0xEC   0x2005             MOVS     R0,#+5
   \       0xEE   0x7038             STRB     R0,[R7, #+0]
   4208                    break;
   \       0xF0   0xE005             B.N      ??remoteSuspRelProcess_25
   4209          
   4210                  case REMOTE_EVS_AUTH_STOP:
   4211                    send_to_evs(EVS_AUTH_STOP);
   \                     ??remoteSuspRelProcess_21: (+1)
   \       0xF2   0x2019             MOVS     R0,#+25
   \       0xF4   0x.... 0x....      BL       send_to_evs
   4212                    remoteMng.remoteStates = REMOTE_OPERATIVE;
   \       0xF8   0x2001             MOVS     R0,#+1
   \       0xFA   0x7038             STRB     R0,[R7, #+0]
   4213                    break;
   \       0xFC   0xE7FF             B.N      ??remoteSuspRelProcess_25
   4214          
   4215                  default:
   4216                    break;
   4217                }
   4218                break;
   \                     ??remoteSuspRelProcess_22: (+1)
   \                     ??remoteSuspRelProcess_25: (+1)
   \       0xFE   0xE023             B.N      ??remoteSuspRelProcess_11
   4219          
   4220              case REMOTE_EVS_SUSPENDING:
   4221                switch (pMsg->currentEvent)
   \                     ??remoteSuspRelProcess_5: (+1)
   \      0x100   0x7828             LDRB     R0,[R5, #+0]
   \      0x102   0x280F             CMP      R0,#+15
   \      0x104   0xD002             BEQ.N    ??remoteSuspRelProcess_26
   \      0x106   0x2817             CMP      R0,#+23
   \      0x108   0xD010             BEQ.N    ??remoteSuspRelProcess_27
   \      0x10A   0xE012             B.N      ??remoteSuspRelProcess_28
   4222                {
   4223                  case REMOTE_MAX_POWER_CHANGE:
   4224                    temp32 = getMaxTempPowerAc();
   \                     ??remoteSuspRelProcess_26: (+1)
   \      0x10C   0x.... 0x....      BL       getMaxTempPowerAc
   \      0x110   0x0004             MOVS     R4,R0
   4225                    pmng_sem_power_set((uint16_t)temp32, 1);
   \      0x112   0x2101             MOVS     R1,#+1
   \      0x114   0x0020             MOVS     R0,R4
   \      0x116   0xB280             UXTH     R0,R0
   \      0x118   0x.... 0x....      BL       pmng_sem_power_set
   4226                    /* SEM sent a new value for MAX_TEMPORARY_POWER_AC_RW */
   4227                    if (temp32 != (uint32_t)0)
   \      0x11C   0x2C00             CMP      R4,#+0
   \      0x11E   0xD004             BEQ.N    ??remoteSuspRelProcess_29
   4228                    {
   4229                      send_to_evs(EVS_REMOTE_RELEASE);
   \      0x120   0x200E             MOVS     R0,#+14
   \      0x122   0x.... 0x....      BL       send_to_evs
   4230                      remoteMng.remoteStates = REMOTE_EVS_AUTH;
   \      0x126   0x2002             MOVS     R0,#+2
   \      0x128   0x7038             STRB     R0,[R7, #+0]
   4231                    }
   4232                    break;
   \                     ??remoteSuspRelProcess_29: (+1)
   \      0x12A   0xE002             B.N      ??remoteSuspRelProcess_30
   4233          
   4234                  case REMOTE_EVS_AUTH_START:
   4235                    /* da remoto su chiusura carica (inizia con questo messaggio  */
   4236                    remoteMng.remoteStates = REMOTE_EVS_WAIT_TO_STOP;
   \                     ??remoteSuspRelProcess_27: (+1)
   \      0x12C   0x2005             MOVS     R0,#+5
   \      0x12E   0x7038             STRB     R0,[R7, #+0]
   4237                    break;
   \      0x130   0xE7FF             B.N      ??remoteSuspRelProcess_30
   4238          
   4239                  default:
   4240                    break;
   4241                }
   4242                break;
   \                     ??remoteSuspRelProcess_28: (+1)
   \                     ??remoteSuspRelProcess_30: (+1)
   \      0x132   0xE009             B.N      ??remoteSuspRelProcess_11
   4243          
   4244              case REMOTE_EVS_WAIT_TO_STOP:
   4245                switch (pMsg->currentEvent)
   \                     ??remoteSuspRelProcess_6: (+1)
   \      0x134   0x7828             LDRB     R0,[R5, #+0]
   \      0x136   0x2819             CMP      R0,#+25
   \      0x138   0xD105             BNE.N    ??remoteSuspRelProcess_31
   4246                {
   4247                  case REMOTE_EVS_AUTH_STOP:
   4248                    send_to_evs(EVS_AUTH_STOP);
   \      0x13A   0x2019             MOVS     R0,#+25
   \      0x13C   0x.... 0x....      BL       send_to_evs
   4249                    remoteMng.remoteStates = REMOTE_OPERATIVE;
   \      0x140   0x2001             MOVS     R0,#+1
   \      0x142   0x7038             STRB     R0,[R7, #+0]
   4250                    break;
   \      0x144   0xE7FF             B.N      ??remoteSuspRelProcess_32
   4251          
   4252                  default:
   4253                    break;
   4254                }
   4255                break;
   \                     ??remoteSuspRelProcess_31: (+1)
   \                     ??remoteSuspRelProcess_32: (+1)
   \      0x146   0xE7FF             B.N      ??remoteSuspRelProcess_11
   4256          
   4257              default:
   4258                break;
   4259          
   4260            }
   4261            return(timeTickTmp);
   \                     ??remoteSuspRelProcess_7: (+1)
   \                     ??remoteSuspRelProcess_11: (+1)
   \      0x148   0x0030             MOVS     R0,R6
   \                     ??remoteSuspRelProcess_1: (+1)
   \      0x14A   0xBDF2             POP      {R1,R4-R7,PC}
   4262          }
   4263          
   4264          /**
   4265          *
   4266          * @brief       Get the remote PM flag status   
   4267          *
   4268          * @param [in]  none    
   4269          *  
   4270          * @retval      uint8_t: TRUE / FALSE   
   4271          *  
   4272          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4273          uint8_t getRemotePmFlag (void) 
   4274          {
   \                     getRemotePmFlag: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4275            uint8_t               pmng_enable;
   4276          
   4277            eeprom_param_get(HIDDEN_MENU_ENB_EADD, &pmng_enable, 1);     // legge power management enable
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x2036             MOVS     R0,#+54
   \        0x8   0x.... 0x....      BL       eeprom_param_get
   4278            if ((pmng_enable & HIDDEN_MENU_SEM_ENB) == 0) return(FALSE); else return(TRUE);
   \        0xC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x10   0x0700             LSLS     R0,R0,#+28
   \       0x12   0xD401             BMI.N    ??getRemotePmFlag_0
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE000             B.N      ??getRemotePmFlag_1
   \                     ??getRemotePmFlag_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \                     ??getRemotePmFlag_1: (+1)
   \       0x1A   0xBD02             POP      {R1,PC}
   4279          }
   4280          
   4281          /**
   4282          *
   4283          * @brief       Send a restore mesage    
   4284          *
   4285          * @param [in]  none    
   4286          *  
   4287          * @retval      none   
   4288          *  
   4289          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4290          void restoreOperativeState (void) 
   4291          {
   \                     restoreOperativeState: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   4292            frameRemote_st  frameRemote;
   4293            
   4294            if (remoteMngQueue != NULL)
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable53_6
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD015             BEQ.N    ??restoreOperativeState_0
   4295            {
   4296              frameRemote.currentEvent = RETURN_TO_OPERATIVE;
   \        0xC   0x2010             MOVS     R0,#+16
   \        0xE   0xF88D 0x0000      STRB     R0,[SP, #+0]
   4297              configASSERT(xQueueSendToBack(remoteMngQueue, (void *)&frameRemote, portMAX_DELAY) == pdPASS); // remoteSuspRelProcess()
   \       0x12   0x2300             MOVS     R3,#+0
   \       0x14   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      BL       xQueueGenericSend
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD009             BEQ.N    ??restoreOperativeState_0
   \       0x24   0xB672             CPSID    I
   \       0x26   0x2050             MOVS     R0,#+80
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \       0x34   0xB662             CPSIE    I
   \                     ??restoreOperativeState_1: (+1)
   \       0x36   0xE7FE             B.N      ??restoreOperativeState_1
   4298            }
   4299            /* end of charge: reset all current and power value */
   4300            resetPowerCurrentValues();
   \                     ??restoreOperativeState_0: (+1)
   \       0x38   0x.... 0x....      BL       resetPowerCurrentValues
   4301          }
   \       0x3C   0xBD13             POP      {R0,R1,R4,PC}
   4302          
   4303          /**
   4304          *
   4305          * @brief       restart a timer with new period     
   4306          *
   4307          * @param [in]  uint16_t: timerid    
   4308          * @param [in]  uint32_t: new period    
   4309          *  
   4310          * @retval      none   
   4311          *  
   4312          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4313          static void restartSbcSemTimer (uint16_t timerId, uint32_t period) 
   4314          {
   \                     restartSbcSemTimer: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   4315          
   4316            while ((xTimerChangePeriod (xSbcSemTimers[timerId], period, SBCSEM_TIMER_GARD_TIME) != pdPASS)); 
   \                     ??restartSbcSemTimer_0: (+1)
   \        0x6   0x.... 0x....      LDR.W    R6,??DataTable53_8
   \        0xA   0xF44F 0x70FA      MOV      R0,#+500
   \        0xE   0x9000             STR      R0,[SP, #+0]
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x002A             MOVS     R2,R5
   \       0x14   0x2104             MOVS     R1,#+4
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0xB280             UXTH     R0,R0
   \       0x1A   0xF856 0x0020      LDR      R0,[R6, R0, LSL #+2]
   \       0x1E   0x.... 0x....      BL       xTimerGenericCommand
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD1EF             BNE.N    ??restartSbcSemTimer_0
   4317            xTimerReset (xSbcSemTimers[timerId], 0);     // the master restart the timeout  
   \       0x26   0x.... 0x....      BL       xTaskGetTickCount
   \       0x2A   0x0002             MOVS     R2,R0
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   \       0x30   0x2300             MOVS     R3,#+0
   \       0x32   0x2102             MOVS     R1,#+2
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0xB280             UXTH     R0,R0
   \       0x38   0xF856 0x0020      LDR      R0,[R6, R0, LSL #+2]
   \       0x3C   0x.... 0x....      BL       xTimerGenericCommand
   4318          }
   \       0x40   0xBD73             POP      {R0,R1,R4-R6,PC}
   4319          
   4320          /**
   4321          *
   4322          * @brief       set all bit in Scu map for active SCU to force a 
   4323          *              read from SBC
   4324          *
   4325          * @param [in]  uint32_t: bit position active SCU     
   4326          *  
   4327          * @retval      none   
   4328          *  
   4329          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4330          static void forceSBCreadScu (uint32_t activityMask) 
   4331          {
   \                     forceSBCreadScu: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   4332            uint16_t              idScu;
   4333            uint32_t              maskId, changeRo;
   4334            scuRoMapRegister_st*  pRoRegs; 
   4335          
   4336            /* first of all update the live presence register */
   4337            socketPresence.livePresence |= activityMask;
   \        0x6   0x.... 0x....      LDR.W    R9,??DataTable53
   \        0xA   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \        0xE   0x4320             ORRS     R0,R4,R0
   \       0x10   0xF8C9 0x0004      STR      R0,[R9, #+4]
   4338          
   4339            for (idScu = 0, maskId = (uint32_t)0x1, changeRo = 0; idScu <= SCU_NUM; idScu++, maskId = maskId << 1) // SCU_M_P_ADDR -> logic address = 0
   \       0x14   0x2500             MOVS     R5,#+0
   \       0x16   0x2601             MOVS     R6,#+1
   \       0x18   0x2700             MOVS     R7,#+0
   \                     ??forceSBCreadScu_0: (+1)
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0x2811             CMP      R0,#+17
   \       0x20   0xDA43             BGE.N    ??forceSBCreadScu_1
   4340            {
   4341              if ((activityMask & maskId) != 0)
   \       0x22   0x4234             TST      R4,R6
   \       0x24   0xD009             BEQ.N    ??forceSBCreadScu_2
   4342              {
   4343                /* this SCU is present: set the flags change for this SCU */
   4344                changeRo |= maskId;   
   \       0x26   0x4337             ORRS     R7,R6,R7
   4345                /* force update to SBC for connector status and errors  */       
   4346                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[idScu] = ((uint16_t)EVSE_CONNECTOR_STATUS_BIT_RO | (uint16_t)EVSE_ERROR2_BIT_RO) | (uint16_t)EVSE_ERROR1_BIT_RO;
   \       0x28   0x201C             MOVS     R0,#+28
   \       0x2A   0x....             LDR.N    R1,??DataTable42
   \       0x2C   0x6809             LDR      R1,[R1, #+0]
   \       0x2E   0x002A             MOVS     R2,R5
   \       0x30   0xB292             UXTH     R2,R2
   \       0x32   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \       0x36   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   4347              }
   4348              /* remove current OFF_L alarm  */
   4349              pRoRegs = getRoMdbRegs(idScu);
   \                     ??forceSBCreadScu_2: (+1)
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x.... 0x....      BL       getRoMdbRegs
   \       0x42   0x4680             MOV      R8,R0
   4350              if (((pRoRegs->scuMapRegNotify.ntfErr2 & ERROR2_OFFL) != 0) || (pollingSlaveMng.offLineCounter[idScu] != 0) ||
   4351                  ((getScuOpMode() == SCU_M_STAND_ALONE) && (pollingSlaveMng.offLineCounter[idScu] >= NUM_OFF_LINE_RETRY)))
   \       0x44   0xF898 0x0100      LDRB     R0,[R8, #+256]
   \       0x48   0x0700             LSLS     R0,R0,#+28
   \       0x4A   0xD413             BMI.N    ??forceSBCreadScu_3
   \       0x4C   0x.... 0x....      LDR.W    R10,??DataTable35_1
   \       0x50   0x0028             MOVS     R0,R5
   \       0x52   0xB280             UXTH     R0,R0
   \       0x54   0x4450             ADD      R0,R10,R0
   \       0x56   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD10A             BNE.N    ??forceSBCreadScu_3
   \       0x5E   0x.... 0x....      BL       getScuOpMode
   \       0x62   0x2805             CMP      R0,#+5
   \       0x64   0xD11E             BNE.N    ??forceSBCreadScu_4
   \       0x66   0x0028             MOVS     R0,R5
   \       0x68   0xB280             UXTH     R0,R0
   \       0x6A   0x4450             ADD      R0,R10,R0
   \       0x6C   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD017             BEQ.N    ??forceSBCreadScu_4
   4352          
   4353              {
   4354                pollingSlaveMng.offLineCounter[idScu] = 0;
   \                     ??forceSBCreadScu_3: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x....             LDR.N    R1,??DataTable35_1
   \       0x78   0x002A             MOVS     R2,R5
   \       0x7A   0xB292             UXTH     R2,R2
   \       0x7C   0x4411             ADD      R1,R1,R2
   \       0x7E   0xF881 0x0023      STRB     R0,[R1, #+35]
   4355                /* the current scuId  respond now: put it in ON_LINE  Only one time !!! */
   4356                pRoRegs->scuMapRegNotify.ntfErr2 &= (~ERROR2_OFFL);
   \       0x82   0xF8B8 0x1100      LDRH     R1,[R8, #+256]
   \       0x86   0xF64F 0x70F7      MOVW     R0,#+65527
   \       0x8A   0x4001             ANDS     R1,R0,R1
   \       0x8C   0xF8A8 0x1100      STRH     R1,[R8, #+256]
   4357                tPrintf ("SCU %02d on-line! %s\n\r" , idScu + 1, getHmsStr()); //  HAL_GetTick()
   \       0x90   0x.... 0x....      BL       getHmsStr
   \       0x94   0x0002             MOVS     R2,R0
   \       0x96   0x0029             MOVS     R1,R5
   \       0x98   0xB289             UXTH     R1,R1
   \       0x9A   0x1C49             ADDS     R1,R1,#+1
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable53_9
   \       0xA0   0x.... 0x....      BL       tPrintf
   4358              }
   4359            }
   \                     ??forceSBCreadScu_4: (+1)
   \       0xA4   0x1C6D             ADDS     R5,R5,#+1
   \       0xA6   0x0076             LSLS     R6,R6,#+1
   \       0xA8   0xE7B7             B.N      ??forceSBCreadScu_0
   4360            /* flags to invite a reading by SBC */
   4361            pScuRoMapReg->scuMapRegNotify.ntfPresences = (uint32_t)socketPresence.livePresence; // now the map of the precence on RS485 bus is complete
   \                     ??forceSBCreadScu_1: (+1)
   \       0xAA   0x....             LDR.N    R0,??DataTable42
   \       0xAC   0x6801             LDR      R1,[R0, #+0]
   \       0xAE   0xF8D9 0x2004      LDR      R2,[R9, #+4]
   \       0xB2   0xF8C1 0x20F6      STR      R2,[R1, #+246]
   4362            pScuRoMapReg->scuMapRegNotify.ntfChangeRo |= changeRo;
   \       0xB6   0x6802             LDR      R2,[R0, #+0]
   \       0xB8   0xF8D2 0x10FA      LDR      R1,[R2, #+250]
   \       0xBC   0x6800             LDR      R0,[R0, #+0]
   \       0xBE   0x4339             ORRS     R1,R7,R1
   \       0xC0   0xF8C0 0x10FA      STR      R1,[R0, #+250]
   4363            sbcSemInfoMng.discoveryMask = 0;
   \       0xC4   0x....             LDR.N    R0,??DataTable37
   \       0xC6   0x2100             MOVS     R1,#+0
   \       0xC8   0xF8C0 0x100A      STR      R1,[R0, #+10]
   4364          }
   \       0xCC   0xE8BD 0x87F0      POP      {R4-R10,PC}
   4365          
   4366          /**
   4367          *
   4368          * @brief       set all bit in Scu map for active SCU to force a 
   4369          *              read from SBC
   4370          *
   4371          * @param [in]  uint16_t: address on RS485    
   4372          * @param [in]  uint16_t: pointer where store the device Id
   4373          *        linked to incoming address on RS485
   4374          *  
   4375          * @retval      none   
   4376          *  
   4377          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4378           uint16_t fromRs485ToSem (uint16_t addrRS485) 
   4379          {
   \                     fromRs485ToSem: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   4380            uint16_t    idx;
   4381          
   4382            if (addrRS485 == 0)   /* in case of broadcast */
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD102             BNE.N    ??fromRs485ToSem_0
   4383              return addrRS485;
   \        0xA   0x0008             MOVS     R0,R1
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0xE015             B.N      ??fromRs485ToSem_1
   4384              
   4385            for (idx = 0; idx < SCU_NUM; idx++)
   \                     ??fromRs485ToSem_0: (+1)
   \       0x10   0x2200             MOVS     R2,#+0
   \                     ??fromRs485ToSem_2: (+1)
   \       0x12   0x0010             MOVS     R0,R2
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x2810             CMP      R0,#+16
   \       0x18   0xDA0E             BGE.N    ??fromRs485ToSem_3
   4386            {
   4387              if (socketPresence.matrixConv[idx] == (uint8_t)addrRS485)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable53
   \       0x1E   0x0013             MOVS     R3,R2
   \       0x20   0xB29B             UXTH     R3,R3
   \       0x22   0x4418             ADD      R0,R0,R3
   \       0x24   0x7C00             LDRB     R0,[R0, #+16]
   \       0x26   0x000B             MOVS     R3,R1
   \       0x28   0xB2DB             UXTB     R3,R3
   \       0x2A   0x4298             CMP      R0,R3
   \       0x2C   0xD102             BNE.N    ??fromRs485ToSem_4
   4388              {
   4389                return idx;
   \       0x2E   0x0010             MOVS     R0,R2
   \       0x30   0xB280             UXTH     R0,R0
   \       0x32   0xE003             B.N      ??fromRs485ToSem_1
   4390              }
   4391            }
   \                     ??fromRs485ToSem_4: (+1)
   \       0x34   0x1C52             ADDS     R2,R2,#+1
   \       0x36   0xE7EC             B.N      ??fromRs485ToSem_2
   4392            
   4393            return NULL_ID;
   \                     ??fromRs485ToSem_3: (+1)
   \       0x38   0xF64F 0x70FF      MOVW     R0,#+65535
   \                     ??fromRs485ToSem_1: (+1)
   \       0x3C   0x4770             BX       LR
   4394            
   4395          }
   4396          
   4397          /**
   4398          *
   4399          * @brief       set all bit in Scu map for active SCU to force a 
   4400          *              read from SBC
   4401          *
   4402          * @param [in]  uint8_t: logic socket id 0...15    
   4403          *  
   4404          * @retval      none   
   4405          *  
   4406          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4407          static void removeSocketFromList (uint8_t skId) 
   4408          {
   \                     removeSocketFromList: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4409            uint32_t              maskBit;
   4410             
   4411            maskBit = (uint32_t)sbcSemMaskBit[skId];
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \        0x8   0x0021             MOVS     R1,R4
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0xF850 0x5021      LDR      R5,[R0, R1, LSL #+2]
   4412          
   4413            pScuRoMapReg->scuMapRegNotify.ntfPresences &= (uint32_t)(~maskBit);
   \       0x10   0x....             LDR.N    R0,??DataTable42
   \       0x12   0x6802             LDR      R2,[R0, #+0]
   \       0x14   0xF8D2 0x10F6      LDR      R1,[R2, #+246]
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x43A9             BICS     R1,R1,R5
   \       0x1C   0xF8C0 0x10F6      STR      R1,[R0, #+246]
   4414            socketPresence.livePresence &= (uint16_t)(~maskBit);
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable53
   \       0x24   0x684A             LDR      R2,[R1, #+4]
   \       0x26   0x43E8             MVNS     R0,R5
   \       0x28   0xB280             UXTH     R0,R0
   \       0x2A   0x4002             ANDS     R2,R0,R2
   \       0x2C   0x604A             STR      R2,[R1, #+4]
   4415            socketPresence.chainPresence &= (uint16_t)(~maskBit);
   \       0x2E   0x680A             LDR      R2,[R1, #+0]
   \       0x30   0x43E8             MVNS     R0,R5
   \       0x32   0xB280             UXTH     R0,R0
   \       0x34   0x4002             ANDS     R2,R0,R2
   \       0x36   0x600A             STR      R2,[R1, #+0]
   4416            sbcSemInfoMng.activeLastDiscovery &= (uint16_t)(~maskBit);
   \       0x38   0x....             LDR.N    R2,??DataTable37
   \       0x3A   0x6A13             LDR      R3,[R2, #+32]
   \       0x3C   0x43E8             MVNS     R0,R5
   \       0x3E   0xB280             UXTH     R0,R0
   \       0x40   0x4003             ANDS     R3,R0,R3
   \       0x42   0x6213             STR      R3,[R2, #+32]
   4417            /* la matrice di conversione per il momento non la tocchiamo. Resta fissa la corrispondenza uno a uno: [0]->1, [1]->2, [2]-> 3, .... [31] -*/
   4418            //socketPresence.matrixConv[skId] = (uint8_t)0; 
   4419            if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \       0x44   0x2254             MOVS     R2,#+84
   \       0x46   0xF44F 0x50F4      MOV      R0,#+7808
   \       0x4A   0x.... 0x....      BL       WriteOnEeprom
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD108             BNE.N    ??removeSocketFromList_0
   4420            {
   4421              tPrintf("Socket Id %2d removed!\n\r", (skId + 1));
   \       0x52   0x0021             MOVS     R1,R4
   \       0x54   0xB2C9             UXTB     R1,R1
   \       0x56   0x1C49             ADDS     R1,R1,#+1
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable53_10
   \       0x5C   0x.... 0x....      BL       tPrintf
   4422              /* a change on configuration has been made */
   4423              activeImmediateResetFromRemove();
   \       0x60   0x.... 0x....      BL       activeImmediateResetFromRemove
   4424            }
   4425          }
   \                     ??removeSocketFromList_0: (+1)
   \       0x64   0xBD31             POP      {R0,R4,R5,PC}
   4426          
   4427          #ifdef TRANSLATE_ID_LOGIC
   4428          /**
   4429          *
   4430          * @brief       set the first addres modbus free
   4431          *
   4432          * @param [in]  none    
   4433          *  
   4434          * @retval      none   
   4435          *  
   4436          ****************************************************************/
   4437          static uint8_t setModbusAddress (void) 
   4438          {
   4439            uint32_t    maskId;
   4440            uint8_t     maxAddrVal, ix;
   4441          
   4442            maxAddrVal = 0; maskId = 1;
   4443            if (!((getScuOpMode() == SCU_M_STAND_ALONE) && ((socketPresence.assignedDeviceId & SCU_MASTER_MASK_BIT) == 0)))  // in stand alone mode address 1 not assigned 
   4444            {
   4445              for (ix = 0; ix < SCU_NUM; ix++, maskId = maskId << 1)
   4446              {
   4447                if ((socketPresence.chainPresence & maskId) == maskId)
   4448                {
   4449                  if (socketPresence.matrixConv[ix] > maxAddrVal)
   4450                  {
   4451                    maxAddrVal = socketPresence.matrixConv[ix];
   4452                  }
   4453                }
   4454              }
   4455            }
   4456            socketPresence.assignedDeviceId |= maskId;
   4457            return(maxAddrVal + (uint8_t)1);
   4458          }
   4459          #endif
   4460          /**
   4461          *
   4462          * @brief       get the first id connector free 1..15 
   4463          *
   4464          * @param [in]  none    
   4465          *  
   4466          * @retval      uint8_t: the first free position in the presence word 1..15 (position 0 is reserved for master)  
   4467          *  
   4468          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4469          static uint8_t getFirstFreeLogicId (void) 
   4470          {
   \                     getFirstFreeLogicId: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   4471            uint32_t    maskId;
   4472            uint8_t     ix;
   4473          
   4474            ix = 0; maskId = 1;
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x2401             MOVS     R4,#+1
   4475            if (!((getScuOpMode() == SCU_M_STAND_ALONE) && ((socketPresence.assignedDeviceId & SCU_MASTER_MASK_BIT) == 0)))
   \        0x6   0x.... 0x....      BL       getScuOpMode
   \        0xA   0x2805             CMP      R0,#+5
   \        0xC   0xD105             BNE.N    ??getFirstFreeLogicId_0
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable53
   \       0x12   0xF890 0x0050      LDRB     R0,[R0, #+80]
   \       0x16   0x07C0             LSLS     R0,R0,#+31
   \       0x18   0xD50E             BPL.N    ??getFirstFreeLogicId_1
   4476            {
   4477              for (; ix < SCU_NUM; ix++, maskId = maskId << 1)
   \                     ??getFirstFreeLogicId_0: (+1)
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x2810             CMP      R0,#+16
   \       0x20   0xDA0A             BGE.N    ??getFirstFreeLogicId_1
   4478              {
   4479                if (((socketPresence.chainPresence & maskId) == (uint16_t)0) && ((socketPresence.livePresence & maskId) == (uint16_t)0))
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable53
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x4221             TST      R1,R4
   \       0x2A   0xD102             BNE.N    ??getFirstFreeLogicId_2
   \       0x2C   0x6840             LDR      R0,[R0, #+4]
   \       0x2E   0x4220             TST      R0,R4
   \       0x30   0xD002             BEQ.N    ??getFirstFreeLogicId_1
   4480                {
   4481                  break;
   4482                }
   4483              }
   \                     ??getFirstFreeLogicId_2: (+1)
   \       0x32   0x1C6D             ADDS     R5,R5,#+1
   \       0x34   0x0064             LSLS     R4,R4,#+1
   \       0x36   0xE7F0             B.N      ??getFirstFreeLogicId_0
   4484            }
   4485            return(ix);
   \                     ??getFirstFreeLogicId_1: (+1)
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0xB2C0             UXTB     R0,R0
   \       0x3C   0xBD32             POP      {R1,R4,R5,PC}
   4486          }
   4487          /**
   4488          *
   4489          * @brief       set  status polling flag  
   4490          *
   4491          * @param [in]  uint8_t: status flag     
   4492          *  
   4493          * @retval      none   
   4494          *  
   4495          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4496          void setPollingFlag (uint8_t flagStatus) 
   4497          {
   4498            sbcSemInfoMng.pollingFlag = (uint16_t)flagStatus;
   \                     setPollingFlag: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x.... 0x....      LDR.W    R2,??DataTable53_5
   \        0x8   0x8351             STRH     R1,[R2, #+26]
   4499          }
   \        0xA   0x4770             BX       LR
   4500          
   4501          /**
   4502          *
   4503          * @brief       read socket presence information from eeprom   
   4504          *
   4505          * @param [in]  none     
   4506          *  
   4507          * @retval      uint8_t:  osOK if successfull  
   4508          *  
   4509          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4510          uint8_t readSocketPresence (void) 
   4511          {
   \                     readSocketPresence: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4512            uint8_t   result;
   4513          
   4514            result = ReadFromEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t));
   \        0x2   0x2254             MOVS     R2,#+84
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable53
   \        0x8   0xF44F 0x50F4      MOV      R0,#+7808
   \        0xC   0x.... 0x....      BL       ReadFromEeprom
   4515            return (result);
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0xBD02             POP      {R1,PC}
   4516          }
   4517          
   4518          /**
   4519          *
   4520          * @brief       get new packet status identifier    
   4521          *
   4522          * @param [in]  none     
   4523          *  
   4524          * @retval      uint32_t:  the packet status identifier   
   4525          *  
   4526          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4527          uint32_t getPacketStatusNum (void) 
   4528          {
   4529            uint32_t   packNum;
   4530          
   4531            packNum = packetStatsCounter;
   \                     getPacketStatusNum: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable53_11
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   4532            packetStatsCounter++;
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x1C52             ADDS     R2,R2,#+1
   \        0xA   0x600A             STR      R2,[R1, #+0]
   4533          
   4534            return (packNum);
   \        0xC   0x4770             BX       LR
   4535          }
   4536          
   4537          /**
   4538          *
   4539          * @brief       reset packet counter    
   4540          *
   4541          * @param [in]  none     
   4542          *  
   4543          * @retval      uint32_t:  the packet status identifier   
   4544          *  
   4545          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4546          static void resetPacketStatusNum (void) 
   4547          {
   4548            packetStatsCounter = (uint32_t)0;
   \                     resetPacketStatusNum: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable53_11
   \        0x6   0x6008             STR      R0,[R1, #+0]
   4549          }
   \        0x8   0x4770             BX       LR
   4550          
   4551          /**
   4552          *
   4553          * @brief        check if all task involved in SBC SEM communication are in the operative state  
   4554          *
   4555          * @param [in]   none
   4556          *
   4557          * @retval       uint8_t: TRUE if all OK, i.e. operative 
   4558          *
   4559          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4560          uint8_t allTaskAreOperative (void)
   4561          {
   4562            if ((sbcSemInfoMng.sbcSemStates == SBC_SEM_OPERATIVE) && (rs485SemInfoMng.rs485SemStates == RS485_SEM_OPERATIVE))
   \                     allTaskAreOperative: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53_5
   \        0x4   0x8800             LDRH     R0,[R0, #+0]
   \        0x6   0x2804             CMP      R0,#+4
   \        0x8   0xD106             BNE.N    ??allTaskAreOperative_0
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable53_12
   \        0xE   0x8800             LDRH     R0,[R0, #+0]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD101             BNE.N    ??allTaskAreOperative_0
   4563            {
   4564              return(TRUE);
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xE000             B.N      ??allTaskAreOperative_1
   4565            }
   4566            else
   4567            {
   4568              return(FALSE);
   \                     ??allTaskAreOperative_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \                     ??allTaskAreOperative_1: (+1)
   \       0x1A   0x4770             BX       LR
   4569            }
   4570          }
   4571          
   4572          /**
   4573          *
   4574          * @brief        reset the SEM task  in the operative state  
   4575          *
   4576          * @param [in]   none
   4577          *
   4578          * @retval       none 
   4579          *
   4580          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4581          void resetInOperative (void)
   4582          {
   \                     resetInOperative: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   4583            tPrintf( "Error on Sbc Task! St = %d St = %d\r\n", sbcSemInfoMng.sbcSemStates, rs485SemInfoMng.rs485SemStates);
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable53_5
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable53_12
   \        0xA   0x882A             LDRH     R2,[R5, #+0]
   \        0xC   0x8821             LDRH     R1,[R4, #+0]
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable53_13
   \       0x12   0x.... 0x....      BL       tPrintf
   4584            sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0x8020             STRH     R0,[R4, #+0]
   4585            rs485SemInfoMng.rs485SemStates = RS485_SEM_OPERATIVE;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x8028             STRH     R0,[R5, #+0]
   4586            /* restore RS485   */
   4587            uartReintialization(); 
   \       0x1E   0x.... 0x....      BL       uartReintialization
   4588          }
   \       0x22   0xBD31             POP      {R0,R4,R5,PC}
   4589          
   4590          /**
   4591          *
   4592          * @brief       get modbus address from device id 
   4593          *
   4594          * @param [in]  uint8_t: device id 0..31    
   4595          *  
   4596          * @retval      uint8_t: modbus Address on RS485 for this device 
   4597          *              ID
   4598          *  
   4599          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4600          uint8_t getModbusAddrFromDevId (uint8_t devId) 
   4601          {
   4602            return((uint8_t)socketPresence.matrixConv[devId]);
   \                     getModbusAddrFromDevId: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable53
   \        0x4   0xB2C0             UXTB     R0,R0
   \        0x6   0x4408             ADD      R0,R1,R0
   \        0x8   0x7C00             LDRB     R0,[R0, #+16]
   \        0xA   0x4770             BX       LR
   4603          }
   4604          
   4605          
   4606          /**
   4607          *
   4608          * @brief       save all slave parameter in the external flah 
   4609          *              area 
   4610          *
   4611          * @param [in]  none:     
   4612          *  
   4613          * @retval      uint8_t: number of saved slave  
   4614          *              
   4615          *  
   4616          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4617          static void saveAllSlaveParameters(void)
   4618          {
   4619          #ifdef BOARD_REPAIR
   4620            uint8_t*          pData;
   4621            uint16_t          cnt;
   4622            uint32_t          cks;
   4623            FRESULT           ferr;
   4624            areaConfPar_st*   pConfPar; 
   4625            uint8_t           newEntryFound;    
   4626          
   4627          
   4628            if (ptrAreaConfPar == NULL)
   4629            {
   4630              return;
   4631            }
   4632            pConfPar = (areaConfPar_st*)malloc(sizeof(areaConfPar_st));
   4633            if (pConfPar != NULL)
   4634            {
   4635              ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)pConfPar, sizeof(areaConfPar_st));
   4636              /* in the heap there is the area with all slave EEPROM info: save it in the external SPI flash */
   4637              for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   4638              {
   4639                cks += pData[cnt];
   4640              }
   4641              if ((ferr == FR_OK) && ((cks == pConfPar->globalCkecksumControl) || (pConfPar->globalCkecksumControl == 0xFFFFFFFF)))
   4642              {
   4643                if (pConfPar->globalCkecksumControl == 0xFFFFFFFF)
   4644                {
   4645                  /*             destination                                  source                                   len         */
   4646                  memcpy((uint8_t *)&pConfPar->blockConfPar[0], (uint8_t *)&ptrAreaConfPar->blockConfPar[0], sizeof(areaConfPar_st));    
   4647                  newEntryFound = TRUE;    
   4648                }
   4649                else
   4650                {
   4651                  for (cnt = 0, newEntryFound = FALSE; cnt < SCU_NUM; cnt++)
   4652                  {
   4653                    if ((cnt == 0) || (ptrAreaConfPar->blockConfPar[cnt].idLogicScu > (uint16_t)SCU_NUM))continue;
   4654                    /* save only the new entry */
   4655                    /*             destination                                  source                                   len         */
   4656                    memcpy((uint8_t *)&pConfPar->blockConfPar[cnt], (uint8_t *)&ptrAreaConfPar->blockConfPar[cnt], sizeof(blockConfPar_st));
   4657                    newEntryFound = TRUE;    
   4658                  }
   4659                }
   4660                if (newEntryFound == TRUE)
   4661                {
   4662                  /* now in the heap, pointer pConfPar, we have the info eeprom updated */
   4663                  /* in the heap there is the area with all slave EEPROM info: save it in the external SPI flash */
   4664                  for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   4665                  {
   4666                    cks += pData[cnt];
   4667                  }
   4668                  pConfPar->globalCkecksumControl = cks;
   4669                  /* write all eeprom data received from all slave in the SPI flash whit checksum at the end */
   4670                  ferr = (FRESULT)FlashWrite(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)pConfPar, sizeof(areaConfPar_st), sizeof(areaConfPar_st));
   4671                  /* readback the data and check if the alla data is OK */
   4672                  if (ferr == FR_OK)
   4673                  {
   4674                    ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)ptrAreaConfPar, sizeof(areaConfPar_st));
   4675                    for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   4676                    {
   4677                      cks += pData[cnt];
   4678                    }
   4679                    if (ptrAreaConfPar->globalCkecksumControl != cks)
   4680                    {
   4681                      ferr = FR_DISK_ERR;
   4682                    }
   4683                    if (ferr == FR_OK)
   4684                    {
   4685                      tPrintf("All eeprom slave info saved in SPI flash!!\n\r");
   4686                    }
   4687                    else
   4688                    {
   4689                      tPrintf("Error on write eeprom slave info in SPI flash!!\n\r");
   4690                    }
   4691                  }
   4692                }
   4693              }
   4694            }
   4695            if (pConfPar != NULL)
   4696            {
   4697              free((void*)pConfPar);
   4698            }
   4699            if (ptrAreaConfPar != NULL)
   4700            {
   4701              free((void*)ptrAreaConfPar);
   4702              ptrAreaConfPar = NULL;
   4703            }
   4704          #endif
   4705          }
   \                     saveAllSlaveParameters: (+1)
   \        0x0   0x4770             BX       LR
   4706          
   4707          /**
   4708          *
   4709          * @brief       save  slave parameter in the external flah 
   4710          *              area 
   4711          *
   4712          * @param [in]  uint8_t: slave logic id     
   4713          *  
   4714          * @retval      uint8_t: 0 if no errors occured  
   4715          *              
   4716          *  
   4717          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4718          uint8_t saveSlaveParameters(void)
   4719          {
   \                     saveSlaveParameters: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   4720            uint8_t*          pData;
   4721            uint16_t          cnt;
   4722            uint32_t          cks;
   4723            FRESULT           ferr;
   4724            areaConfPar_st*   pConfPar; 
   4725            uint8_t           newEntryFound, idLogic;    
   4726          
   4727          
   4728            ferr = FR_NOT_READY;
   \        0x4   0xF05F 0x0803      MOVS     R8,#+3
   4729          
   4730            if (ptrAreaConfPar == NULL)
   \        0x8   0x.... 0x....      LDR.W    R9,??DataTable53_14
   \        0xC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??saveSlaveParameters_0
   4731            {
   4732              return(ferr);
   \       0x14   0x4640             MOV      R0,R8
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0xE0CA             B.N      ??saveSlaveParameters_1
   4733            }
   4734            pConfPar = (areaConfPar_st*)malloc(sizeof(areaConfPar_st));
   \                     ??saveSlaveParameters_0: (+1)
   \       0x1A   0xF643 0x6AC4      MOVW     R10,#+16068
   \       0x1E   0x4650             MOV      R0,R10
   \       0x20   0x.... 0x....      BL       malloc
   \       0x24   0x0004             MOVS     R4,R0
   4735            if (pConfPar != NULL)
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xF000 0x80B0      BEQ.W    ??saveSlaveParameters_2
   4736            {
   4737              ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)pConfPar, sizeof(areaConfPar_st));
   \       0x2C   0x4652             MOV      R2,R10
   \       0x2E   0x0021             MOVS     R1,R4
   \       0x30   0xF45F 0x10A0      MOVS     R0,#+1310720
   \       0x34   0x.... 0x....      BL       FlashRead
   \       0x38   0x4680             MOV      R8,R0
   4738              /* in the heap there is the area with all slave EEPROM info: save it in the external SPI flash */
   4739              for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x0006             MOVS     R6,R0
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x0007             MOVS     R7,R0
   \       0x42   0x0025             MOVS     R5,R4
   \                     ??saveSlaveParameters_3: (+1)
   \       0x44   0x0030             MOVS     R0,R6
   \       0x46   0xB280             UXTH     R0,R0
   \       0x48   0xF5B0 0x5F7B      CMP      R0,#+16064
   \       0x4C   0xD205             BCS.N    ??saveSlaveParameters_4
   4740              {
   4741                cks += pData[cnt];
   \       0x4E   0x0030             MOVS     R0,R6
   \       0x50   0xB280             UXTH     R0,R0
   \       0x52   0x5C28             LDRB     R0,[R5, R0]
   \       0x54   0x183F             ADDS     R7,R7,R0
   4742              }
   \       0x56   0x1C76             ADDS     R6,R6,#+1
   \       0x58   0xE7F4             B.N      ??saveSlaveParameters_3
   4743              if ((ferr == FR_OK) && (cks == pConfPar->globalCkecksumControl))
   \                     ??saveSlaveParameters_4: (+1)
   \       0x5A   0x4640             MOV      R0,R8
   \       0x5C   0xB2C0             UXTB     R0,R0
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xF040 0x8094      BNE.W    ??saveSlaveParameters_2
   \       0x64   0xF514 0x507B      ADDS     R0,R4,#+16064
   \       0x68   0x6800             LDR      R0,[R0, #+0]
   \       0x6A   0x4287             CMP      R7,R0
   \       0x6C   0xF040 0x808E      BNE.W    ??saveSlaveParameters_2
   4744              {
   4745                for (cnt = 0, newEntryFound = FALSE; cnt < SCU_NUM; cnt++)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x0006             MOVS     R6,R0
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??saveSlaveParameters_5: (+1)
   \       0x7A   0x0030             MOVS     R0,R6
   \       0x7C   0xB280             UXTH     R0,R0
   \       0x7E   0x2810             CMP      R0,#+16
   \       0x80   0xDA2D             BGE.N    ??saveSlaveParameters_6
   4746                {
   4747                  if (cnt == 0) continue;
   \       0x82   0x0030             MOVS     R0,R6
   \       0x84   0xB280             UXTH     R0,R0
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD027             BEQ.N    ??saveSlaveParameters_7
   4748                  /* save only the new entry */
   4749                  if (pConfPar->blockConfPar[cnt].idLogicScu == ptrAreaConfPar->blockConfPar[cnt].idLogicScu)
   \                     ??saveSlaveParameters_8: (+1)
   \       0x8A   0xF44F 0x707B      MOV      R0,#+1004
   \       0x8E   0x0031             MOVS     R1,R6
   \       0x90   0xB289             UXTH     R1,R1
   \       0x92   0x4341             MULS     R1,R0,R1
   \       0x94   0x5A61             LDRH     R1,[R4, R1]
   \       0x96   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \       0x9A   0x0033             MOVS     R3,R6
   \       0x9C   0xB29B             UXTH     R3,R3
   \       0x9E   0x4343             MULS     R3,R0,R3
   \       0xA0   0x5AD2             LDRH     R2,[R2, R3]
   \       0xA2   0x4291             CMP      R1,R2
   \       0xA4   0xD119             BNE.N    ??saveSlaveParameters_7
   4750                  {
   4751                    /*             destination                                  source                                   len         */
   4752                    memcpy((uint8_t *)&pConfPar->blockConfPar[cnt], (uint8_t *)&ptrAreaConfPar->blockConfPar[cnt], sizeof(blockConfPar_st));
   \       0xA6   0x9001             STR      R0,[SP, #+4]
   \       0xA8   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0xAC   0x0032             MOVS     R2,R6
   \       0xAE   0xB292             UXTH     R2,R2
   \       0xB0   0x4342             MULS     R2,R0,R2
   \       0xB2   0xEB01 0x0A02      ADD      R10,R1,R2
   \       0xB6   0x0031             MOVS     R1,R6
   \       0xB8   0xB289             UXTH     R1,R1
   \       0xBA   0xFB00 0xF001      MUL      R0,R0,R1
   \       0xBE   0xEB04 0x0B00      ADD      R11,R4,R0
   \       0xC2   0x9A01             LDR      R2,[SP, #+4]
   \       0xC4   0x4651             MOV      R1,R10
   \       0xC6   0x4658             MOV      R0,R11
   \       0xC8   0x.... 0x....      BL       __aeabi_memcpy
   4753                    idLogic = (uint8_t)cnt;
   \       0xCC   0x0030             MOVS     R0,R6
   \       0xCE   0xF88D 0x0001      STRB     R0,[SP, #+1]
   4754                    newEntryFound = TRUE;    
   \       0xD2   0x2001             MOVS     R0,#+1
   \       0xD4   0xF88D 0x0000      STRB     R0,[SP, #+0]
   4755                    break;
   \       0xD8   0xE001             B.N      ??saveSlaveParameters_6
   4756                  }
   4757                }
   \                     ??saveSlaveParameters_7: (+1)
   \       0xDA   0x1C76             ADDS     R6,R6,#+1
   \       0xDC   0xE7CD             B.N      ??saveSlaveParameters_5
   4758                if (newEntryFound == TRUE)
   \                     ??saveSlaveParameters_6: (+1)
   \       0xDE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xE2   0x2801             CMP      R0,#+1
   \       0xE4   0xD150             BNE.N    ??saveSlaveParameters_9
   4759                {
   4760                  /* now in the heap, pointer pConfPar, we have the info eeprom updated */
   4761                  /* in the heap there is the area with all slave EEPROM info: save it in the external SPI flash */
   4762                  for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0x0006             MOVS     R6,R0
   \       0xEA   0x2000             MOVS     R0,#+0
   \       0xEC   0x0007             MOVS     R7,R0
   \       0xEE   0x0025             MOVS     R5,R4
   \                     ??saveSlaveParameters_10: (+1)
   \       0xF0   0x0030             MOVS     R0,R6
   \       0xF2   0xB280             UXTH     R0,R0
   \       0xF4   0xF5B0 0x5F7B      CMP      R0,#+16064
   \       0xF8   0xD205             BCS.N    ??saveSlaveParameters_11
   4763                  {
   4764                    cks += pData[cnt];
   \       0xFA   0x0030             MOVS     R0,R6
   \       0xFC   0xB280             UXTH     R0,R0
   \       0xFE   0x5C28             LDRB     R0,[R5, R0]
   \      0x100   0x183F             ADDS     R7,R7,R0
   4765                  }
   \      0x102   0x1C76             ADDS     R6,R6,#+1
   \      0x104   0xE7F4             B.N      ??saveSlaveParameters_10
   4766                  pConfPar->globalCkecksumControl = cks;
   \                     ??saveSlaveParameters_11: (+1)
   \      0x106   0xF44F 0x5B7B      MOV      R11,#+16064
   \      0x10A   0xF844 0x700B      STR      R7,[R4, R11]
   4767                  /* write all eeprom data received from all slave in the SPI flash whit checksum at the end */
   4768                  ferr = (FRESULT)FlashWrite(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)pConfPar, sizeof(areaConfPar_st), sizeof(areaConfPar_st));
   \      0x10E   0xF643 0x6AC4      MOVW     R10,#+16068
   \      0x112   0x4653             MOV      R3,R10
   \      0x114   0x4652             MOV      R2,R10
   \      0x116   0x0021             MOVS     R1,R4
   \      0x118   0xF45F 0x10A0      MOVS     R0,#+1310720
   \      0x11C   0x.... 0x....      BL       FlashWrite
   \      0x120   0x4680             MOV      R8,R0
   4769                  /* readback the data and check if the alla data is OK */
   4770                  if (ferr == FR_OK)
   \      0x122   0x4640             MOV      R0,R8
   \      0x124   0xB2C0             UXTB     R0,R0
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD130             BNE.N    ??saveSlaveParameters_2
   4771                  {
   4772                    ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)ptrAreaConfPar, sizeof(areaConfPar_st));
   \      0x12A   0x4652             MOV      R2,R10
   \      0x12C   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x130   0xF45F 0x10A0      MOVS     R0,#+1310720
   \      0x134   0x.... 0x....      BL       FlashRead
   \      0x138   0x4680             MOV      R8,R0
   4773                    for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   \      0x13A   0x2000             MOVS     R0,#+0
   \      0x13C   0x0006             MOVS     R6,R0
   \      0x13E   0x2000             MOVS     R0,#+0
   \      0x140   0x0007             MOVS     R7,R0
   \      0x142   0x0025             MOVS     R5,R4
   \                     ??saveSlaveParameters_12: (+1)
   \      0x144   0x0030             MOVS     R0,R6
   \      0x146   0xB280             UXTH     R0,R0
   \      0x148   0xF5B0 0x5F7B      CMP      R0,#+16064
   \      0x14C   0xD205             BCS.N    ??saveSlaveParameters_13
   4774                    {
   4775                      cks += pData[cnt];
   \      0x14E   0x0030             MOVS     R0,R6
   \      0x150   0xB280             UXTH     R0,R0
   \      0x152   0x5C28             LDRB     R0,[R5, R0]
   \      0x154   0x183F             ADDS     R7,R7,R0
   4776                    }
   \      0x156   0x1C76             ADDS     R6,R6,#+1
   \      0x158   0xE7F4             B.N      ??saveSlaveParameters_12
   4777                    if (ptrAreaConfPar->globalCkecksumControl != cks)
   \                     ??saveSlaveParameters_13: (+1)
   \      0x15A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x15E   0xF850 0x000B      LDR      R0,[R0, R11]
   \      0x162   0x42B8             CMP      R0,R7
   \      0x164   0xD001             BEQ.N    ??saveSlaveParameters_14
   4778                    {
   4779                      ferr = FR_DISK_ERR;
   \      0x166   0x2001             MOVS     R0,#+1
   \      0x168   0x4680             MOV      R8,R0
   4780                    }
   4781                    if (ferr == FR_OK)
   \                     ??saveSlaveParameters_14: (+1)
   \      0x16A   0x4640             MOV      R0,R8
   \      0x16C   0xB2C0             UXTB     R0,R0
   \      0x16E   0x2800             CMP      R0,#+0
   \      0x170   0xD106             BNE.N    ??saveSlaveParameters_15
   4782                    {
   4783                      tPrintf("eeprom slave info %2d saved in SPI flash!!\n\r", idLogic + 1);
   \      0x172   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \      0x176   0x1C49             ADDS     R1,R1,#+1
   \      0x178   0x....             LDR.N    R0,??DataTable53_15
   \      0x17A   0x.... 0x....      BL       tPrintf
   \      0x17E   0xE005             B.N      ??saveSlaveParameters_2
   4784                    }
   4785                    else
   4786                    {
   4787                      tPrintf("Error on write eeprom slave info in SPI flash!!\n\r");
   \                     ??saveSlaveParameters_15: (+1)
   \      0x180   0x....             LDR.N    R0,??DataTable53_16
   \      0x182   0x.... 0x....      BL       tPrintf
   \      0x186   0xE001             B.N      ??saveSlaveParameters_2
   4788                    }
   4789                  }
   4790                }
   4791                else
   4792                {
   4793                  ferr = FR_NOT_READY;
   \                     ??saveSlaveParameters_9: (+1)
   \      0x188   0x2003             MOVS     R0,#+3
   \      0x18A   0x4680             MOV      R8,R0
   4794                }
   4795              }
   4796            }
   4797            if (pConfPar != NULL)
   \                     ??saveSlaveParameters_2: (+1)
   \      0x18C   0x2C00             CMP      R4,#+0
   \      0x18E   0xD002             BEQ.N    ??saveSlaveParameters_16
   4798            {
   4799              free((void*)pConfPar);
   \      0x190   0x0020             MOVS     R0,R4
   \      0x192   0x.... 0x....      BL       free
   4800            }
   4801            if (ptrAreaConfPar != NULL)
   \                     ??saveSlaveParameters_16: (+1)
   \      0x196   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x19A   0x2800             CMP      R0,#+0
   \      0x19C   0xD006             BEQ.N    ??saveSlaveParameters_17
   4802            {
   4803              free((void*)ptrAreaConfPar);
   \      0x19E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x1A2   0x.... 0x....      BL       free
   4804              ptrAreaConfPar = NULL;
   \      0x1A6   0x2000             MOVS     R0,#+0
   \      0x1A8   0xF8C9 0x0000      STR      R0,[R9, #+0]
   4805            }
   4806            return ((uint8_t)ferr);
   \                     ??saveSlaveParameters_17: (+1)
   \      0x1AC   0x4640             MOV      R0,R8
   \      0x1AE   0xB2C0             UXTB     R0,R0
   \                     ??saveSlaveParameters_1: (+1)
   \      0x1B0   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   4807          }
   4808          
   4809          
   4810          /**
   4811          *
   4812          * @brief       get and send to master all slave parameters in 
   4813          *              stored in EEPROM area 
   4814          *
   4815          * @param [in]  uint8_t: slave logic address     
   4816          *  
   4817          * @retval      uint8_t: number of saved slave  
   4818          *              
   4819          *  
   4820          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4821          uint8_t getAndsendAllSlaveParameters(uint8_t idLogic)
   4822          {
   \                     getAndsendAllSlaveParameters: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   4823            uint16_t          cnt;
   4824            blockConfPar_st*  pConfPar;
   4825            uint8_t*          pData;
   4826            uint8_t           result;
   4827          
   4828            pConfPar = (blockConfPar_st*)malloc(sizeof(blockConfPar_st));
   \        0x6   0xF44F 0x707B      MOV      R0,#+1004
   \        0xA   0x.... 0x....      BL       malloc
   \        0xE   0x0005             MOVS     R5,R0
   4829          
   4830            /*             Start to set logic SCU id [0..15]                                                                 */
   4831            pConfPar->idLogicScu = (uint16_t)idLogic;
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0x8028             STRH     R0,[R5, #+0]
   4832            /*             Start to copy eeprom array area                                                                   */
   4833            /*             destination                                  source                           len                 */
   4834            memcpy((uint8_t *)pConfPar->confEepromParamArray, (uint8_t *)getEepromArray(), EEPROM_PARAM_NUM);                             
   \       0x16   0x.... 0x....      BL       getEepromArray
   \       0x1A   0xF05F 0x0944      MOVS     R9,#+68
   \       0x1E   0x9001             STR      R0,[SP, #+4]
   \       0x20   0x1CAE             ADDS     R6,R5,#+2
   \       0x22   0x464A             MOV      R2,R9
   \       0x24   0x9901             LDR      R1,[SP, #+4]
   \       0x26   0x0030             MOVS     R0,R6
   \       0x28   0x.... 0x....      BL       __aeabi_memcpy
   4835            /*             Copy infostation           area                                                                   */
   4836            /*             destination                                  source                           len                 */
   4837            memcpy((uint8_t *)&pConfPar->confInfoStation, (uint8_t *)getStationName(), sizeof (infoStation_t));                             
   \       0x2C   0x.... 0x....      BL       getStationName
   \       0x30   0xF44F 0x7ABE      MOV      R10,#+380
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0xF115 0x0648      ADDS     R6,R5,#+72
   \       0x3A   0x4652             MOV      R2,R10
   \       0x3C   0x9900             LDR      R1,[SP, #+0]
   \       0x3E   0x0030             MOVS     R0,R6
   \       0x40   0x.... 0x....      BL       __aeabi_memcpy
   4838            /*             Copy backup infostation           area                                                            */
   4839            /*                           data origin                         buffer destination                    len       */
   4840            result = ReadFromEeprom (EDATA_BKP_SCU_EE_ADDRESS, (uint8_t *)&pConfPar->confBackupInfoStation, sizeof (infoStation_t));     
   \       0x44   0xF44F 0x72BE      MOV      R2,#+380
   \       0x48   0xF515 0x71E2      ADDS     R1,R5,#+452
   \       0x4C   0xF44F 0x5080      MOV      R0,#+4096
   \       0x50   0x.... 0x....      BL       ReadFromEeprom
   \       0x54   0x0006             MOVS     R6,R0
   4841            /*             Copy product code    area                                                                         */
   4842            /*                          data origin                         buffer destination                    len        */
   4843            result |= ReadFromEeprom (PRD_CODE_EE_ADDRES, (uint8_t *)&pConfPar->confSerialCode, sizeof (pConfPar->confSerialCode));     
   \       0x56   0x2260             MOVS     R2,#+96
   \       0x58   0xF515 0x7150      ADDS     R1,R5,#+832
   \       0x5C   0xF44F 0x50FD      MOV      R0,#+8096
   \       0x60   0x.... 0x....      BL       ReadFromEeprom
   \       0x64   0x0007             MOVS     R7,R0
   \       0x66   0x4337             ORRS     R7,R7,R6
   4844            /*             Copy Serial Number codes  area                                                                    */
   4845            /*                              data origin                         buffer destination                    len    */
   4846            result |= ReadFromEeprom (EDATA_DEFAULT_ID_CODES, (uint8_t *)&pConfPar->confSerialFactoryCode, sizeof (pConfPar->confSerialFactoryCode));     
   \       0x68   0x223C             MOVS     R2,#+60
   \       0x6A   0xF515 0x7168      ADDS     R1,R5,#+928
   \       0x6E   0xF44F 0x6030      MOV      R0,#+2816
   \       0x72   0x.... 0x....      BL       ReadFromEeprom
   \       0x76   0x4680             MOV      R8,R0
   \       0x78   0xEA58 0x0807      ORRS     R8,R8,R7
   4847          
   4848            pConfPar->confRtcBackup[0] =  HAL_RTCEx_BKUPRead((RTC_HandleTypeDef*)getHandleRtc(), BACKUP_EM_MODEL);
   \       0x7C   0x.... 0x....      BL       getHandleRtc
   \       0x80   0x2107             MOVS     R1,#+7
   \       0x82   0x.... 0x....      BL       HAL_RTCEx_BKUPRead
   \       0x86   0xF8C5 0x03DC      STR      R0,[R5, #+988]
   4849            pConfPar->confRtcBackup[1] =  HAL_RTCEx_BKUPRead((RTC_HandleTypeDef*)getHandleRtc(), BACKUP_EM_ENRG_ACT);
   \       0x8A   0x.... 0x....      BL       getHandleRtc
   \       0x8E   0x2108             MOVS     R1,#+8
   \       0x90   0x.... 0x....      BL       HAL_RTCEx_BKUPRead
   \       0x94   0xF8C5 0x03E0      STR      R0,[R5, #+992]
   4850            pConfPar->confRtcBackup[2] =  HAL_RTCEx_BKUPRead((RTC_HandleTypeDef*)getHandleRtc(), BACKUP_HW_INFO);
   \       0x98   0x.... 0x....      BL       getHandleRtc
   \       0x9C   0x2109             MOVS     R1,#+9
   \       0x9E   0x.... 0x....      BL       HAL_RTCEx_BKUPRead
   \       0xA2   0xF8C5 0x03E4      STR      R0,[R5, #+996]
   4851          
   4852            /* set the checksum */
   4853            for (cnt = 0, pConfPar->ckecksumControl = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(blockConfPar_st) - sizeof(pConfPar->ckecksumControl); cnt++)
   \       0xA6   0xF05F 0x0B00      MOVS     R11,#+0
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xF8C5 0x03E8      STR      R0,[R5, #+1000]
   \       0xB0   0x9502             STR      R5,[SP, #+8]
   \                     ??getAndsendAllSlaveParameters_0: (+1)
   \       0xB2   0x4658             MOV      R0,R11
   \       0xB4   0xB280             UXTH     R0,R0
   \       0xB6   0xF5B0 0x7F7A      CMP      R0,#+1000
   \       0xBA   0xD20B             BCS.N    ??getAndsendAllSlaveParameters_1
   4854            {
   4855              pConfPar->ckecksumControl += (uint32_t)pData[cnt];
   \       0xBC   0xF8D5 0x03E8      LDR      R0,[R5, #+1000]
   \       0xC0   0x9902             LDR      R1,[SP, #+8]
   \       0xC2   0x465A             MOV      R2,R11
   \       0xC4   0xB292             UXTH     R2,R2
   \       0xC6   0x5C89             LDRB     R1,[R1, R2]
   \       0xC8   0x1840             ADDS     R0,R0,R1
   \       0xCA   0xF8C5 0x03E8      STR      R0,[R5, #+1000]
   4856            }
   \       0xCE   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \       0xD2   0xE7EE             B.N      ??getAndsendAllSlaveParameters_0
   4857            osDelay(10); // leave 10ms to give the transmitter the time to repositioning in Rx mode
   \                     ??getAndsendAllSlaveParameters_1: (+1)
   \       0xD4   0x200A             MOVS     R0,#+10
   \       0xD6   0x.... 0x....      BL       osDelay
   4858            /* start transmission on UART RS485 to SCU RS485 Bus using DMA */
   4859            setMallocTx485((uint8_t*)pConfPar);
   \       0xDA   0x0028             MOVS     R0,R5
   \       0xDC   0x.... 0x....      BL       setMallocTx485
   4860            txOnRs485Bus((uint8_t*)pConfPar, (uint16_t)sizeof(blockConfPar_st)); 
   \       0xE0   0xF44F 0x717B      MOV      R1,#+1004
   \       0xE4   0x0028             MOVS     R0,R5
   \       0xE6   0x.... 0x....      BL       txOnRs485Bus
   4861          
   4862            return(result);
   \       0xEA   0x4640             MOV      R0,R8
   \       0xEC   0xB2C0             UXTB     R0,R0
   \       0xEE   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   4863          }
   4864          
   4865          /**
   4866          *
   4867          * @brief       get the pointer to configuration parameter area 
   4868          *
   4869          * @param [in]  none    
   4870          *  
   4871          * @retval      areaConfPar_st*: pointer to area for conf 
   4872          *              parameters
   4873          *  
   4874          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4875          areaConfPar_st* getPtrToConfParam (void) 
   4876          {
   4877            return(ptrAreaConfPar);
   \                     getPtrToConfParam: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_14
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
   4878          }
   4879          
   4880          /**
   4881          *
   4882          * @brief       set the pointer to configuration parameter area 
   4883          *
   4884          * @param [in]  uint8_t*: pointer to block area    
   4885          *  
   4886          * @retval      none 
   4887          *  
   4888          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4889          void setPtrToConfParam (uint8_t* ptr) 
   4890          {
   4891            ptrAreaConfPar = (areaConfPar_st*)ptr;
   \                     setPtrToConfParam: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_14
   \        0x2   0x6008             STR      R0,[R1, #+0]
   4892          }
   \        0x4   0x4770             BX       LR
   4893          
   4894          /**
   4895          *
   4896          * @brief       get, from external SPI flash, the status on 
   4897          *              slave configuration parameter area
   4898          *
   4899          * @param [in]  uint16_t: mask for last detected slave     
   4900          *  
   4901          * @retval      none  
   4902          *  
   4903          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4904          static void setInfoEepromSlaveDone(uint16_t lastDetected)
   4905          {
   4906          #ifdef BOARD_REPAIR
   4907            areaConfPar_st*   pConfPar;
   4908            uint8_t*          pData;
   4909            FRESULT           ferr;
   4910            uint16_t          cnt, mask;
   4911            uint32_t          cks;
   4912          
   4913            pConfPar = (areaConfPar_st*)malloc(sizeof(areaConfPar_st));
   4914            sbcSemInfoMng.infoEepromSlaveToDo = (uint16_t)0;
   4915          
   4916            /* read from external SPI flash the info slave eeprom parameters */
   4917            ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)pConfPar, sizeof(areaConfPar_st));
   4918            /* check if the alla data is OK */
   4919            if (ferr == FR_OK)
   4920            {
   4921              for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   4922              {
   4923                cks += pData[cnt];
   4924              }
   4925              if (pConfPar->globalCkecksumControl == cks)
   4926              {
   4927                /* the data is valid and the info on slave eeprom parameters are in the malloc area  */
   4928                for (cnt = 0, mask = (uint16_t)1; cnt < SCU_NUM; cnt++, mask = mask << 1)
   4929                {
   4930                  if (cnt == 0) continue;
   4931                  if (pConfPar->blockConfPar[cnt].idLogicScu != cnt)
   4932                  {
   4933                    /* the info for this slave isn't present so must be request */
   4934                    sbcSemInfoMng.infoEepromSlaveToDo |= mask;
   4935                  }
   4936                }
   4937              }
   4938              else
   4939              {
   4940                /* the SPI flash area is empty so the info eeprom must be request for all slaves detected */
   4941                sbcSemInfoMng.infoEepromSlaveToDo = (uint16_t)0xFFFE;
   4942              }
   4943            }
   4944            free(pConfPar);
   4945          #else
   4946            sbcSemInfoMng.infoEepromSlaveToDo = (uint16_t)0;
   \                     setInfoEepromSlaveDone: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             LDR.N    R2,??DataTable53_5
   \        0x4   0x8491             STRH     R1,[R2, #+36]
   4947          #endif
   4948          }
   \        0x6   0x4770             BX       LR
   4949          
   4950          /**
   4951          *
   4952          * @brief       get and send to slave all previuos eeprom 
   4953          *              parameters stored in SPI flash area
   4954          *
   4955          * @param [in]  uint8_t: slave logic address     
   4956          *  
   4957          * @retval      uint8_t: 0 for no errors   
   4958          *              
   4959          *  
   4960          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4961          static uint8_t sendEeepromInfoForCloning(uint8_t idLogic)
   4962          {
   \                     sendEeepromInfoForCloning: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   4963            uint16_t          cnt;
   4964            blockConfPar_st*  pConfPar;
   4965            uint8_t*          pData;
   4966            uint32_t          cks;
   4967            FRESULT           ferr;
   4968          
   4969            ptrAreaConfPar = (areaConfPar_st*)malloc(sizeof(areaConfPar_st));
   \        0x6   0x.... 0x....      LDR.W    R10,??DataTable53_14
   \        0xA   0xF643 0x69C4      MOVW     R9,#+16068
   \        0xE   0x4648             MOV      R0,R9
   \       0x10   0x.... 0x....      BL       malloc
   \       0x14   0xF8CA 0x0000      STR      R0,[R10, #+0]
   4970            sbcSemInfoMng.infoEepromSlaveToDo = (uint16_t)0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x....             LDR.N    R1,??DataTable53_5
   \       0x1C   0x8488             STRH     R0,[R1, #+36]
   4971          
   4972            /* read from external SPI flash the info slave eeprom parameters */
   4973            ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)ptrAreaConfPar, sizeof(areaConfPar_st));
   \       0x1E   0x464A             MOV      R2,R9
   \       0x20   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \       0x24   0xF45F 0x10A0      MOVS     R0,#+1310720
   \       0x28   0x.... 0x....      BL       FlashRead
   \       0x2C   0x4681             MOV      R9,R0
   4974            /* check if the alla data is OK */
   4975            if (ferr == FR_OK)
   \       0x2E   0x4648             MOV      R0,R9
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD143             BNE.N    ??sendEeepromInfoForCloning_0
   4976            {
   4977              for (cnt = 0, cks = 0, pData = (uint8_t*)ptrAreaConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x0005             MOVS     R5,R0
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x4680             MOV      R8,R0
   \       0x3E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x42   0x0007             MOVS     R7,R0
   \                     ??sendEeepromInfoForCloning_1: (+1)
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0xB280             UXTH     R0,R0
   \       0x48   0xF5B0 0x5F7B      CMP      R0,#+16064
   \       0x4C   0xD206             BCS.N    ??sendEeepromInfoForCloning_2
   4978              {
   4979                cks += pData[cnt];
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0xB280             UXTH     R0,R0
   \       0x52   0x5C38             LDRB     R0,[R7, R0]
   \       0x54   0xEB18 0x0800      ADDS     R8,R8,R0
   4980              }
   \       0x58   0x1C6D             ADDS     R5,R5,#+1
   \       0x5A   0xE7F3             B.N      ??sendEeepromInfoForCloning_1
   4981              if (ptrAreaConfPar->globalCkecksumControl == cks)
   \                     ??sendEeepromInfoForCloning_2: (+1)
   \       0x5C   0x....             LDR.N    R0,??DataTable53_14
   \       0x5E   0x6801             LDR      R1,[R0, #+0]
   \       0x60   0xF511 0x517B      ADDS     R1,R1,#+16064
   \       0x64   0x6809             LDR      R1,[R1, #+0]
   \       0x66   0x4541             CMP      R1,R8
   \       0x68   0xD127             BNE.N    ??sendEeepromInfoForCloning_3
   4982              {
   4983                if (ptrAreaConfPar->blockConfPar[idLogic].idLogicScu == idLogic)
   \       0x6A   0xF44F 0x717B      MOV      R1,#+1004
   \       0x6E   0x6802             LDR      R2,[R0, #+0]
   \       0x70   0x0023             MOVS     R3,R4
   \       0x72   0xB2DB             UXTB     R3,R3
   \       0x74   0x434B             MULS     R3,R1,R3
   \       0x76   0x5AD2             LDRH     R2,[R2, R3]
   \       0x78   0x0023             MOVS     R3,R4
   \       0x7A   0xB2DB             UXTB     R3,R3
   \       0x7C   0xB29B             UXTH     R3,R3
   \       0x7E   0x429A             CMP      R2,R3
   \       0x80   0xD118             BNE.N    ??sendEeepromInfoForCloning_4
   4984                {
   4985                  pConfPar = &ptrAreaConfPar->blockConfPar[idLogic];
   \       0x82   0x6802             LDR      R2,[R0, #+0]
   \       0x84   0x0023             MOVS     R3,R4
   \       0x86   0xB2DB             UXTB     R3,R3
   \       0x88   0xFB01 0xF103      MUL      R1,R1,R3
   \       0x8C   0x4411             ADD      R1,R2,R1
   \       0x8E   0x000E             MOVS     R6,R1
   4986                  /* start transmission on UART RS485 to SCU RS485 Bus using DMA */
   4987                  setMallocTx485((uint8_t*)ptrAreaConfPar);
   \       0x90   0x6800             LDR      R0,[R0, #+0]
   \       0x92   0x.... 0x....      BL       setMallocTx485
   4988                  txOnRs485Bus((uint8_t*)pConfPar, (uint16_t)sizeof(blockConfPar_st)); 
   \       0x96   0xF44F 0x717B      MOV      R1,#+1004
   \       0x9A   0x0030             MOVS     R0,R6
   \       0x9C   0x.... 0x....      BL       txOnRs485Bus
   4989                  tPrintf("Restored eeprom slave %02d info from SPI flash!!\n\r", idLogic + 1);
   \       0xA0   0x0021             MOVS     R1,R4
   \       0xA2   0xB2C9             UXTB     R1,R1
   \       0xA4   0x1C49             ADDS     R1,R1,#+1
   \       0xA6   0x....             LDR.N    R0,??DataTable53_17
   \       0xA8   0x.... 0x....      BL       tPrintf
   4990                  osDelay(100);
   \       0xAC   0x2064             MOVS     R0,#+100
   \       0xAE   0x.... 0x....      BL       osDelay
   \       0xB2   0xE004             B.N      ??sendEeepromInfoForCloning_0
   4991                }
   4992                else
   4993                {
   4994                  ferr = FR_INT_ERR;
   \                     ??sendEeepromInfoForCloning_4: (+1)
   \       0xB4   0x2002             MOVS     R0,#+2
   \       0xB6   0x4681             MOV      R9,R0
   \       0xB8   0xE001             B.N      ??sendEeepromInfoForCloning_0
   4995                }
   4996              }
   4997              else
   4998              {
   4999                ferr = FR_DISK_ERR;
   \                     ??sendEeepromInfoForCloning_3: (+1)
   \       0xBA   0x2001             MOVS     R0,#+1
   \       0xBC   0x4681             MOV      R9,R0
   5000              }
   5001            }
   5002            return((uint8_t)ferr);
   \                     ??sendEeepromInfoForCloning_0: (+1)
   \       0xBE   0x4648             MOV      R0,R9
   \       0xC0   0xB2C0             UXTB     R0,R0
   \       0xC2   0xE8BD 0x87F0      POP      {R4-R10,PC}
   5003          }
   5004          
   5005          /**
   5006          *
   5007          * @brief       get discovery status  
   5008          *
   5009          * @param [in]  none    
   5010          *  
   5011          * @retval      uint32_t: 0 if the discovery phase isn't active 
   5012          *  
   5013          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   5014          uint32_t getDiscoveryStatus (void) 
   5015          {
   5016            return(sbcSemInfoMng.discoveryMask);
   \                     getDiscoveryStatus: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_5
   \        0x2   0xF8D1 0x000A      LDR      R0,[R1, #+10]
   \        0x6   0x4770             BX       LR
   5017          }
   5018          
   5019          /**
   5020          *
   5021          * @brief       get info eeprom for slave  status  
   5022          *
   5023          * @param [in]  none    
   5024          *  
   5025          * @retval      uint16_t: bit mask for slave eeprom info 
   5026          *  
   5027          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   5028          uint16_t getInfoEepromSlaveStatus (void) 
   5029          {
   5030            return(sbcSemInfoMng.infoEepromSlaveToDo);
   \                     getInfoEepromSlaveStatus: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_5
   \        0x2   0x8C80             LDRH     R0,[R0, #+36]
   \        0x4   0x4770             BX       LR
   5031          }
   5032          
   5033          /**
   5034          *
   5035          * @brief       set info eeprom for slave  status  
   5036          *
   5037          * @param [in]  uint16_t: bit mask for slave eeprom info    
   5038          *  
   5039          * @retval      none 
   5040          *  
   5041          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   5042          void setInfoEepromSlaveStatus (uint16_t logicSlave) 
   5043          {
   5044            uint16_t              maskBit;
   5045          
   5046            maskBit = (uint16_t)sbcSemMaskBit[logicSlave];
   \                     setInfoEepromSlaveStatus: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_1
   \        0x2   0x0002             MOVS     R2,R0
   \        0x4   0xB292             UXTH     R2,R2
   \        0x6   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   5047            sbcSemInfoMng.infoEepromSlaveToDo &= (~maskBit);
   \        0xA   0x....             LDR.N    R2,??DataTable53_5
   \        0xC   0x8C93             LDRH     R3,[R2, #+36]
   \        0xE   0x438B             BICS     R3,R3,R1
   \       0x10   0x8493             STRH     R3,[R2, #+36]
   5048          }
   \       0x12   0x4770             BX       LR
   5049          
   5050                                
   5051          
   5052          
   5053          #ifdef MODBUS_TCP_EM_LOVATO
   5054          /**
   5055          *
   5056          * @brief        Ask to master for active power for all the socket   
   5057          *
   5058          * @param [in]   none 
   5059          *
   5060          * @retval       none:  
   5061          *
   5062          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   5063          void  readEmValuesFromMaster (void)
   5064          {
   \                     readEmValuesFromMaster: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   5065            uint8_t*                pEnd;
   5066            headerRHR_t*            pMsg;
   5067            uint8_t*                pMallocTx;
   5068            uint16_t                length;
   5069            crcMode_u               crc;
   5070          
   5071            pMallocTx = (uint8_t*)malloc(sizeof(headerRHR_t) + (uint16_t)sizeof(crc)); // remember + 2 for checksum 
   \        0x2   0x2008             MOVS     R0,#+8
   \        0x4   0x.... 0x....      BL       malloc
   \        0x8   0x0005             MOVS     R5,R0
   5072            pMsg = (headerRHR_t*)pMallocTx;
   \        0xA   0x002C             MOVS     R4,R5
   5073            /* the command must be executed    */
   5074            length = (uint16_t)sizeof(headerRHR_t);
   \        0xC   0x2606             MOVS     R6,#+6
   5075            pMsg->unitId = SCU_M_P_ADDR; 
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x7020             STRB     R0,[R4, #+0]
   5076            pMsg->function = FUNCTION_READ_INPUT_REG;
   \       0x12   0x2004             MOVS     R0,#+4
   \       0x14   0x7060             STRB     R0,[R4, #+1]
   5077            pMsg->regAdd = swapW(ADDR_EM_LOVATO_V_SYS);
   \       0x16   0xF44F 0x60AA      MOV      R0,#+1360
   \       0x1A   0x.... 0x....      BL       swapW
   \       0x1E   0x8060             STRH     R0,[R4, #+2]
   5078            pMsg->numBytes = swapW(sizeof(scuMapRegLovatoEmSim_st) / 2);
   \       0x20   0x2031             MOVS     R0,#+49
   \       0x22   0x.... 0x....      BL       swapW
   \       0x26   0x80A0             STRH     R0,[R4, #+4]
   5079          
   5080            /* now found the CRC message */
   5081            crc.crcW = crcEvaluation ((uint8_t*)pMsg, length);
   \       0x28   0x0031             MOVS     R1,R6
   \       0x2A   0xB289             UXTH     R1,R1
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       crcEvaluation
   \       0x32   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   5082            /* position pEnd pointer on crc field */
   5083            pEnd =  (uint8_t*)((uint32_t)pMsg + (uint32_t)length);
   \       0x36   0xFA14 0xF086      UXTAH    R0,R4,R6
   5084            *pEnd = crc.crcLH_st.crcL;
   \       0x3A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x3E   0x7001             STRB     R1,[R0, #+0]
   5085            pEnd++;
   \       0x40   0x1C47             ADDS     R7,R0,#+1
   5086            *pEnd = crc.crcLH_st.crcH;
   \       0x42   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x46   0x7038             STRB     R0,[R7, #+0]
   5087            length += sizeof(crc.crcW);
   \       0x48   0x1CB6             ADDS     R6,R6,#+2
   5088          
   5089            if (xSemaphoreTake(getScuSinapsiTxUartSemaphoreHandle(), portMAX_DELAY) == pdTRUE)
   \       0x4A   0x.... 0x....      BL       getScuSinapsiTxUartSemaphoreHandle
   \       0x4E   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0x52   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD107             BNE.N    ??readEmValuesFromMaster_0
   5090            {
   5091              setMallocTx485(pMallocTx);
   \       0x5A   0x0028             MOVS     R0,R5
   \       0x5C   0x.... 0x....      BL       setMallocTx485
   5092              /* start transmission on UART RS485 to SCU RS485 Bus using DMA */
   5093              txOnRs485Bus((uint8_t*)pMsg, (uint16_t)length); 
   \       0x60   0x0031             MOVS     R1,R6
   \       0x62   0xB289             UXTH     R1,R1
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       txOnRs485Bus
   5094            }
   5095          }
   \                     ??readEmValuesFromMaster_0: (+1)
   \       0x6A   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     socketPresence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     sbcSemQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x....'....        DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x....'....        DC32     sbcSemTimCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0x....'....        DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x....'....        DC32     packetStatsCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \        0x0   0x....'....        DC32     ptrAreaConfPar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \        0x0   0x....'....        DC32     frameSbcSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x....'....        DC32     pollingSlaveTask_attributes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     pollingSlaveTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     pollingSlaveTaskHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     headMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     xSbcSemTimers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     sbcSemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     ?_23

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     pScuRoMapReg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     sbcSemMaskBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x....'....        DC32     currFrameSbcSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x....'....        DC32     ?_24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     sbcSemQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x....'....        DC32     rs485SemQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     rs485SemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x....'....        DC32     framers485Sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x....'....        DC32     socketPresence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0x....'....        DC32     ?_25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     `HW_CHECKS_ACTUATORS_EEprom_Save::temp`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x....'....        DC32     remoteMngQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     lastCommandSent

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x....'....        DC32     `semUpdateConfig::temp`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     numberOnLcd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x....'....        DC32     pScuRoMapReg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x....'....        DC32     AddrUidStr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x....'....        DC32     AddrEventFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x....'....        DC32     prevState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x....'....        DC32     AddrChargStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x....'....        DC32     nameState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x....'....        DC32     AddrErr1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0x....'....        DC32     AddrErr2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x....'....        DC32     AddrConnType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0x....'....        DC32     AddrSessId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x....'....        DC32     AddrEm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0x....'....        DC32     AddrMeasure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \        0x0   0x....'....        DC32     sbcSemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \        0x0   0x....'....        DC32     ?_26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     sbcSemMaskBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     socketPresence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     currFrameSbcSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     ?_27

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \        0x0   0x....'....        DC32     ?_28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0x....'....        DC32     pScuTmMapReg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \        0x0   0x....'....        DC32     xSbcSemTimers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \        0x0   0x....'....        DC32     ?_29

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \        0x0   0x....'....        DC32     pollingSlaveQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \        0x0   0x....'....        DC32     ?_30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \        0x0   0x....'....        DC32     pollingSlaveMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \        0x0   0x....'....        DC32     frameSbcSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0x....'....        DC32     sbcSemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \        0x0   0x....'....        DC32     pScuRoMapReg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \        0x0   0x....'....        DC32     ?_31

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_1:
   \        0x0   0x....'....        DC32     ?_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_2:
   \        0x0   0x....'....        DC32     ?_33

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \        0x0   0x0001'D4C0        DC32     0x1d4c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_1:
   \        0x0   0x....'....        DC32     ?_34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_2:
   \        0x0   0x....'....        DC32     ?_35

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47:
   \        0x0   0x....'....        DC32     numberOnLcd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \        0x0   0x....'....        DC32     socketPresence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_1:
   \        0x0   0x....'....        DC32     sbcSemMaskBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_2:
   \        0x0   0x....'....        DC32     ?_36

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_3:
   \        0x0   0x....'....        DC32     Default_Socket_Presence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_4:
   \        0x0   0x....'....        DC32     ?_37

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_5:
   \        0x0   0x....'....        DC32     sbcSemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_6:
   \        0x0   0x....'....        DC32     remoteMngQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_7:
   \        0x0   0x....'....        DC32     remoteMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_8:
   \        0x0   0x....'....        DC32     xSbcSemTimers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_9:
   \        0x0   0x....'....        DC32     ?_38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_10:
   \        0x0   0x....'....        DC32     ?_39

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_11:
   \        0x0   0x....'....        DC32     packetStatsCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_12:
   \        0x0   0x....'....        DC32     rs485SemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_13:
   \        0x0   0x....'....        DC32     ?_40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_14:
   \        0x0   0x....'....        DC32     ptrAreaConfPar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_15:
   \        0x0   0x....'....        DC32     ?_41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_16:
   \        0x0   0x....'....        DC32     ?_42

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_17:
   \        0x0   0x....'....        DC32     ?_43

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x20 0x49          DC8 " Initial"
   \              0x6E 0x69    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x20 0x49          DC8 " Idle"
   \              0x64 0x6C    
   \              0x65 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x20 0x50          DC8 " Preparing"
   \              0x72 0x65    
   \              0x70 0x61    
   \              0x72 0x69    
   \              0x6E 0x67    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x20 0x45          DC8 " Ev Connected"
   \              0x76 0x20    
   \              0x43 0x6F    
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x00
   \        0xE                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x20 0x43          DC8 " Charging"
   \              0x68 0x61    
   \              0x72 0x67    
   \              0x69 0x6E    
   \              0x67 0x00
   \        0xA                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x20 0x53          DC8 " Suspended Ev"
   \              0x75 0x73    
   \              0x70 0x65    
   \              0x6E 0x64    
   \              0x65 0x64    
   \              0x20 0x45    
   \              0x76 0x00
   \        0xE                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x20 0x53          DC8 " Suspended EvSe"
   \              0x75 0x73    
   \              0x70 0x65    
   \              0x6E 0x64    
   \              0x65 0x64    
   \              0x20 0x45    
   \              0x76 0x53    
   \              0x65 0x00

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x20 0x45          DC8 " End Charge"
   \              0x6E 0x64    
   \              0x20 0x43    
   \              0x68 0x61    
   \              0x72 0x67    
   \              0x65 0x00

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x20 0x46          DC8 " Faulted"
   \              0x61 0x75    
   \              0x6C 0x74    
   \              0x65 0x64    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x20 0x55          DC8 " Unavailable"
   \              0x6E 0x61    
   \              0x76 0x61    
   \              0x69 0x6C    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x20 0x52          DC8 " Reserved"
   \              0x65 0x73    
   \              0x65 0x72    
   \              0x76 0x65    
   \              0x64 0x00
   \        0xA                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x20 0x42          DC8 " Bootloader"
   \              0x6F 0x6F    
   \              0x74 0x6C    
   \              0x6F 0x61    
   \              0x64 0x65    
   \              0x72 0x00

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x53 0x68          DC8 "Shutdown"
   \              0x75 0x74    
   \              0x64 0x6F    
   \              0x77 0x6E    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x20 0x52          DC8 " Rebooting"
   \              0x65 0x62    
   \              0x6F 0x6F    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x20 0x53          DC8 " Suspended NoPower"
   \              0x75 0x73    
   \              0x70 0x65    
   \              0x6E 0x64    
   \              0x65 0x64    
   \              0x20 0x4E    
   \              0x6F 0x50    
   \              0x6F 0x77    
   \              0x65 0x72    
   \              0x00
   \       0x13                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x50 0x4F          DC8 "POLLING_SLAVE"
   \              0x4C 0x4C    
   \              0x49 0x4E    
   \              0x47 0x5F    
   \              0x53 0x4C    
   \              0x41 0x56    
   \              0x45 0x00
   \        0xE                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x53 0x55          DC8 "SUSP_REL_TASK"
   \              0x53 0x50    
   \              0x5F 0x52    
   \              0x45 0x4C    
   \              0x5F 0x54    
   \              0x41 0x53    
   \              0x4B 0x00
   \        0xE                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x73 0x62          DC8 "sbcSemQueue"
   \              0x63 0x53    
   \              0x65 0x6D    
   \              0x51 0x75    
   \              0x65 0x75    
   \              0x65 0x00

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x54 0x69          DC8 "TimSbcSem"
   \              0x6D 0x53    
   \              0x62 0x63    
   \              0x53 0x65    
   \              0x6D 0x00
   \        0xA                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x4D 0x61          DC8 "Matrix Initializated\012\015"
   \              0x74 0x72    
   \              0x69 0x78    
   \              0x20 0x49    
   \              0x6E 0x69    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x69 0x7A    
   \              0x61 0x74    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00
   \       0x17                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x53 0x6F          DC8 0x53, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x20, 0x70
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x70
   \        0x8   0x72 0x65          DC8 0x72, 0x65, 0x73, 0x65, 0x6E, 0x63, 0x65, 0x20
   \              0x73 0x65    
   \              0x6E 0x63    
   \              0x65 0x20
   \       0x10   0x69 0x6E          DC8 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74
   \              0x66 0x6F    
   \              0x72 0x6D    
   \              0x61 0x74
   \       0x18   0x69 0x6F          DC8 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x70, 0x72, 0x6F
   \              0x6E 0x73    
   \              0x20 0x70    
   \              0x72 0x6F
   \       0x20   0x67 0x72          DC8 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x65, 0x64, 0x20
   \              0x61 0x6D    
   \              0x6D 0x65    
   \              0x64 0x20
   \       0x28   0x74 0x6F          DC8 0x74, 0x6F, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75
   \              0x20 0x64    
   \              0x65 0x66    
   \              0x61 0x75
   \       0x30   0x6C 0x74          DC8 0x6C, 0x74, 0x20, 0x0A, 0x0D, 0
   \              0x20 0x0A    
   \              0x0D 0x00
   \       0x36                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x50 0x72          DC8 "Presences detected at reset --> 0x%x\012\015"
   \              0x65 0x73    
   \              0x65 0x6E    
   \              0x63 0x65    
   \              0x73 0x20    
   \              0x64 0x65    
   \              0x74 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x61    
   \              0x74 0x20    
   \              0x72 0x65    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x2D 0x2D    
   \              0x3E 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0A 0x0D    
   \              0x00
   \       0x27                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x41 0x62          DC8 "Abort: No info received from Addr = %d!\012\015"
   \              0x6F 0x72    
   \              0x74 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x69 0x6E    
   \              0x66 0x6F    
   \              0x20 0x72    
   \              0x65 0x63    
   \              0x65 0x69    
   \              0x76 0x65    
   \              0x64 0x20    
   \              0x66 0x72    
   \              0x6F 0x6D    
   \              0x20 0x41    
   \              0x64 0x64    
   \              0x72 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x21 0x0A    
   \              0x0D 0x00
   \       0x2A                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_23:
   \        0x0   0x50 0x72          DC8 "Presences detected --> 0x%x\012\015"
   \              0x65 0x73    
   \              0x65 0x6E    
   \              0x63 0x65    
   \              0x73 0x20    
   \              0x64 0x65    
   \              0x74 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x2D    
   \              0x2D 0x3E    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x78 0x0A    
   \              0x0D 0x00
   \       0x1E                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_24:
   \        0x0   0x53 0x6F          DC8 "Socket %d Event 0x%X sent!\012\015"
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x25    
   \              0x64 0x20    
   \              0x45 0x76    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x30 0x78    
   \              0x25 0x58    
   \              0x20 0x73    
   \              0x65 0x6E    
   \              0x74 0x21    
   \              0x0A 0x0D    
   \              0x00
   \       0x1D                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_25:
   \        0x0   0x53 0x6F          DC8 "Socket %d retrasmission!\012\015"
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x25    
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x74 0x72    
   \              0x61 0x73    
   \              0x6D 0x69    
   \              0x73 0x73    
   \              0x69 0x6F    
   \              0x6E 0x21    
   \              0x0A 0x0D    
   \              0x00
   \       0x1B                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_26:
   \        0x0   0x53 0x6F          DC8 "Socket %d Reg=0x%X %s Value= 0x%X at %s N=0x%X\012\015"
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x25    
   \              0x64 0x20    
   \              0x52 0x65    
   \              0x67 0x3D    
   \              0x30 0x78    
   \              0x25 0x58    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x56 0x61    
   \              0x6C 0x75    
   \              0x65 0x3D    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x58 0x20    
   \              0x61 0x74    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x4E 0x3D    
   \              0x30 0x78    
   \              0x25 0x58    
   \              0x0A 0x0D    
   \              0x00
   \       0x31                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_27:
   \        0x0   0x41 0x73          DC8 "Assigned address %d\012\015"
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x65 0x64    
   \              0x20 0x61    
   \              0x64 0x64    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x20 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00
   \       0x16                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_28:
   \        0x0   0x4D 0x61          DC8 "Master unavailable!\012\015"
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x20 0x75    
   \              0x6E 0x61    
   \              0x76 0x61    
   \              0x69 0x6C    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x21 0x0A    
   \              0x0D 0x00
   \       0x16                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_29:
   \        0x0   0x53 0x65          DC8 "Sent upgrade eeprom info slave %02d!!\012\015"
   \              0x6E 0x74    
   \              0x20 0x75    
   \              0x70 0x67    
   \              0x72 0x61    
   \              0x64 0x65    
   \              0x20 0x65    
   \              0x65 0x70    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x69 0x6E    
   \              0x66 0x6F    
   \              0x20 0x73    
   \              0x6C 0x61    
   \              0x76 0x65    
   \              0x20 0x25    
   \              0x30 0x32    
   \              0x64 0x21    
   \              0x21 0x0A    
   \              0x0D 0x00

   \                                 In section .rodata, align 4
   \                     ?_30:
   \        0x0   0x50 0x72          DC8 "Presences Defined\012\015"
   \              0x65 0x73    
   \              0x65 0x6E    
   \              0x63 0x65    
   \              0x73 0x20    
   \              0x44 0x65    
   \              0x66 0x69    
   \              0x6E 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00

   \                                 In section .rodata, align 4
   \                     ?_31:
   \        0x0   0x53 0x43          DC8 "SCU %02d off-line! %s\012\015"
   \              0x55 0x20    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x6F    
   \              0x66 0x66    
   \              0x2D 0x6C    
   \              0x69 0x6E    
   \              0x65 0x21    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x0D 0x00

   \                                 In section .rodata, align 4
   \                     ?_32:
   \        0x0   0x53 0x43          DC8 "SCU %02d off-line! Retry=%d %s\012\015"
   \              0x55 0x20    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x6F    
   \              0x66 0x66    
   \              0x2D 0x6C    
   \              0x69 0x6E    
   \              0x65 0x21    
   \              0x20 0x52    
   \              0x65 0x74    
   \              0x72 0x79    
   \              0x3D 0x25    
   \              0x64 0x20    
   \              0x25 0x73    
   \              0x0A 0x0D    
   \              0x00
   \       0x21                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_33:
   \        0x0   0x53 0x43          DC8 "SCU %02d on-line!! %s\012\015"
   \              0x55 0x20    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x6F    
   \              0x6E 0x2D    
   \              0x6C 0x69    
   \              0x6E 0x65    
   \              0x21 0x21    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x0D 0x00

   \                                 In section .rodata, align 4
   \                     ?_34:
   \        0x0   0x53 0x43          DC8 "SCU id%02d --> FW version %s\012\015"
   \              0x55 0x20    
   \              0x69 0x64    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x2D    
   \              0x2D 0x3E    
   \              0x20 0x46    
   \              0x57 0x20    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x25 0x73    
   \              0x0A 0x0D    
   \              0x00
   \       0x1F                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_35:
   \        0x0   0x41 0x64          DC8 "Address %02d Assigned\012\015"
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x41    
   \              0x73 0x73    
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00

   \                                 In section .rodata, align 4
   \                     ?_36:
   \        0x0   0x41 0x73          DC8 "Assigned Physical address %d\012\015"
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x65 0x64    
   \              0x20 0x50    
   \              0x68 0x79    
   \              0x73 0x69    
   \              0x63 0x61    
   \              0x6C 0x20    
   \              0x61 0x64    
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00
   \       0x1F                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_37:
   \        0x0   0x50 0x72          DC8 "Presences confirmed --> 0x%x\012\015"
   \              0x65 0x73    
   \              0x65 0x6E    
   \              0x63 0x65    
   \              0x73 0x20    
   \              0x63 0x6F    
   \              0x6E 0x66    
   \              0x69 0x72    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x2D 0x2D    
   \              0x3E 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0A 0x0D    
   \              0x00
   \       0x1F                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_38:
   \        0x0   0x53 0x43          DC8 "SCU %02d on-line! %s\012\015"
   \              0x55 0x20    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x6F    
   \              0x6E 0x2D    
   \              0x6C 0x69    
   \              0x6E 0x65    
   \              0x21 0x20    
   \              0x25 0x73    
   \              0x0A 0x0D    
   \              0x00
   \       0x17                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_39:
   \        0x0   0x53 0x6F          DC8 "Socket Id %2d removed!\012\015"
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x49    
   \              0x64 0x20    
   \              0x25 0x32    
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x6D 0x6F    
   \              0x76 0x65    
   \              0x64 0x21    
   \              0x0A 0x0D    
   \              0x00
   \       0x19                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_40:
   \        0x0   0x45 0x72          DC8 "Error on Sbc Task! St = %d St = %d\015\012"
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x6F 0x6E    
   \              0x20 0x53    
   \              0x62 0x63    
   \              0x20 0x54    
   \              0x61 0x73    
   \              0x6B 0x21    
   \              0x20 0x53    
   \              0x74 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x20 0x53    
   \              0x74 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x0D 0x0A    
   \              0x00
   \       0x25                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_41:
   \        0x0   0x65 0x65          DC8 "eeprom slave info %2d saved in SPI flash!!\012\015"
   \              0x70 0x72    
   \              0x6F 0x6D    
   \              0x20 0x73    
   \              0x6C 0x61    
   \              0x76 0x65    
   \              0x20 0x69    
   \              0x6E 0x66    
   \              0x6F 0x20    
   \              0x25 0x32    
   \              0x64 0x20    
   \              0x73 0x61    
   \              0x76 0x65    
   \              0x64 0x20    
   \              0x69 0x6E    
   \              0x20 0x53    
   \              0x50 0x49    
   \              0x20 0x66    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x21 0x21    
   \              0x0A 0x0D    
   \              0x00
   \       0x2D                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_42:
   \        0x0   0x45 0x72          DC8 "Error on write eeprom slave info in SPI flash!!\012\015"
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x6F 0x6E    
   \              0x20 0x77    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x20 0x65    
   \              0x65 0x70    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x73 0x6C    
   \              0x61 0x76    
   \              0x65 0x20    
   \              0x69 0x6E    
   \              0x66 0x6F    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x53 0x50    
   \              0x49 0x20    
   \              0x66 0x6C    
   \              0x61 0x73    
   \              0x68 0x21    
   \              0x21 0x0A    
   \              0x0D 0x00
   \       0x32                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_43:
   \        0x0   0x52 0x65          DC8 0x52, 0x65, 0x73, 0x74, 0x6F, 0x72, 0x65, 0x64
   \              0x73 0x74    
   \              0x6F 0x72    
   \              0x65 0x64
   \        0x8   0x20 0x65          DC8 0x20, 0x65, 0x65, 0x70, 0x72, 0x6F, 0x6D, 0x20
   \              0x65 0x70    
   \              0x72 0x6F    
   \              0x6D 0x20
   \       0x10   0x73 0x6C          DC8 0x73, 0x6C, 0x61, 0x76, 0x65, 0x20, 0x25, 0x30
   \              0x61 0x76    
   \              0x65 0x20    
   \              0x25 0x30
   \       0x18   0x32 0x64          DC8 0x32, 0x64, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x20
   \              0x20 0x69    
   \              0x6E 0x66    
   \              0x6F 0x20
   \       0x20   0x66 0x72          DC8 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x53, 0x50, 0x49
   \              0x6F 0x6D    
   \              0x20 0x53    
   \              0x50 0x49
   \       0x28   0x20 0x66          DC8 0x20, 0x66, 0x6C, 0x61, 0x73, 0x68, 0x21, 0x21
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x21 0x21
   \       0x30   0x0A 0x0D          DC8 0x0A, 0x0D, 0
   \              0x00
   \       0x33                      DS8 1
   5096          #endif
   5097          
   5098          /*************** END OF FILE ******************************************************************************************/
   5099          
   5100          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Actuators_Mdb_to_Eeprom_Translate
        16   -> EEPROM_Save_Config
        16   -> eeprom_array_set
        16   -> eeprom_param_get
        16   -> getHwChecks2
      16   CONN_ID_Set_New
        16   -> WriteOnEeprom
        16   -> getLogicalMdbAddrSem
      24   HW_CHECKS_ACTUATORS_EEprom_Save
        24   -> Actuators_Mdb_to_Eeprom_Translate
        24   -> EEPROM_Save_Config
        24   -> activeImmediateReset
        24   -> eeprom_param_get
        24   -> getCollaudoRunning
        24   -> getHwActuators
        24   -> getHwChecks1
        24   -> getHwChecks2
      16   HW_PRESENCE_FLAG_EEprom_Save
        16   -> EEPROM_Save_Config
        16   -> eeprom_param_get
        16   -> getHwFlags
      16   Print_Slave_Assigned
        16   -> osDelay
        16   -> tPrintf
      16   Print_Slave_FW_Version
        16   -> getRoMdbRegs
        16   -> osDelay
        16   -> tPrintf
      32   addNode
        32   -> __aeabi_memcpy
        32   -> createNode
       0   allTaskAreOperative
      40   checkAssignNewAddress
        40   -> WriteOnEeprom
        40   -> eeprom_array_set
        40   -> getSktNumInFakeCode
        40   -> tPrintf
        40   -> updateScuModbusAddrr
      32   checkToSendReqAddress
        32   -> getNumSktInProduct
        32   -> getSktNumInFakeCode
        32   -> getTagIdFromPrdSn
        32   -> gsy_connected_set
        32   -> xTimerGenericCommand
       8   createNode
         8   -> malloc
      64   extractSendFirstInList
        64   -> __aeabi_memcpy
        64   -> free
        64   -> getSbcSemQueueHandle
        64   -> xQueueGenericSend
      32   forceSBCreadScu
        32   -> getHmsStr
        32   -> getRoMdbRegs
        32   -> getScuOpMode
        32   -> tPrintf
       0   fromRs485ToSem
      48   getAndsendAllSlaveParameters
        48   -> HAL_RTCEx_BKUPRead
        48   -> ReadFromEeprom
        48   -> __aeabi_memcpy
        48   -> getEepromArray
        48   -> getHandleRtc
        48   -> getStationName
        48   -> malloc
        48   -> osDelay
        48   -> setMallocTx485
        48   -> txOnRs485Bus
       0   getDefSocketInfoPtr
       0   getDiscoveryStatus
      16   getFirstFreeLogicId
        16   -> getScuOpMode
       8   getIdNumberForLcd
         8   -> eeprom_param_get
         8   -> isSemMode
       0   getInfoEepromSlaveStatus
      48   getInfoSocket
        48   -> getRoMdbRegs
        48   -> getRs485SemQueueHandle
        48   -> getRwMdbRegs
        48   -> getTmMdbRegs
        48   -> xQueueGenericSend
       0   getModbusAddrFromDevId
       8   getNumSocketLcd
         8   -> getRwMdbRegs
       0   getPacketStatusNum
       0   getPtrToConfParam
       8   getRemotePmFlag
         8   -> eeprom_param_get
       0   getRs485SemQueueHandle
       0   getSbcSemQueueHandle
       8   getSktNumInFakeCode
         8   -> eeprom_param_get
       0   getSocketDiscovered
      16   getTagIdFromPrdSn
        16   -> crcEvaluation
        16   -> getLogicalMdbAddrSem
        16   -> getRoMdbRegs
        16   -> strlen
       0   isModbusManagerActive
       0   isSlaveWaitToBeOperative
       0   is_socketPresence_Programmed
      56   mngReqAddress
        56   -> getFirstFreeLogicId
        56   -> getRs485SemQueueHandle
        56   -> restartSbcSemTimer
        56   -> xQueueGenericSend
      64   pollingSlaveProcess
        64   -> getBroadcastDownload
        64   -> getHmsStr
        64   -> getNumSocketLcd
        64   -> getRoMdbRegs
        64   -> getRs485SemQueueHandle
        64   -> getScuOpMode
        64   -> getStatusDwnl
        64   -> setChangeRegisterBit
        64   -> tPrintf
        64   -> uartReintialization
        64   -> xQueueGenericSend
      40   pollingSlaveTask
        40   -> pollingSlaveProcess
        40   -> xQueueGenericCreate
        40   -> xQueueReceive
      24   readEmValuesFromMaster
        24   -> crcEvaluation
        24   -> getScuSinapsiTxUartSemaphoreHandle
        24   -> malloc
        24   -> setMallocTx485
        24   -> swapW
        24   -> txOnRs485Bus
        24   -> xQueueSemaphoreTake
      32   readMasterModbusRegister
        32   -> crcEvaluation
        32   -> getScuSinapsiTxUartSemaphoreHandle
        32   -> malloc
        32   -> setMallocTx485
        32   -> swapW
        32   -> txOnRs485Bus
        32   -> xQueueSemaphoreTake
       8   readSocketPresence
         8   -> ReadFromEeprom
      24   remoteMngTask
        24   -> remoteSuspRelProcess
        24   -> xQueueGenericCreate
        24   -> xQueueReceive
      24   remoteSuspRelProcess
        24   -> getMaxTempPowerAc
        24   -> getRemotePmFlag
        24   -> osDelay
        24   -> pmng_sem_power_set
        24   -> send_to_evs
      16   removeSocketFromList
        16   -> WriteOnEeprom
        16   -> activeImmediateResetFromRemove
        16   -> tPrintf
      32   resetChangeRegisterBit
        32   -> getRoMdbRegs
        32   -> gsy_quick_polling_update
       0   resetCommandRemote
      16   resetInOperative
        16   -> tPrintf
        16   -> uartReintialization
       0   resetPacketStatusNum
      24   restartSbcSemTimer
        24   -> xTaskGetTickCount
        24   -> xTimerGenericCommand
      24   restoreFactoryDefaultForAll
        24   -> eraseAllBoardInfoEeprom
        24   -> getRs485SemQueueHandle
        24   -> isSemMasterFz
        24   -> osDelay
        24   -> restoreFactoryDefault
        24   -> xQueueGenericSend
      16   restoreOperativeState
        16   -> resetPowerCurrentValues
        16   -> xQueueGenericSend
      40   rs485SemGestTask
        40   -> rs485SemMsgProcess
        40   -> xQueueGenericCreate
        40   -> xQueueReceive
      40   rs485SemMsgProcess
        40   -> getNumSocketLcd
        40   -> getRoMdbRegs
        40   -> getRwMdbRegs
        40   -> getTmMdbRegs
        40   -> readMasterModbusRegister
        40   -> tPrintf
        40   -> writeMasterModbusRegister
       0   saveAllSlaveParameters
      48   saveSlaveParameters
        48   -> FlashRead
        48   -> FlashWrite
        48   -> __aeabi_memcpy
        48   -> free
        48   -> malloc
        48   -> tPrintf
      48   sbcSemGestTask
        48   -> sbcSemMsgProcess
        48   -> vQueueAddToRegistry
        48   -> xQueueGenericCreate
        48   -> xQueueReceive
        48   -> xTimerCreate
      72   sbcSemMsgProcess
        72   -> Print_Slave_FW_Version
        72   -> WriteOnEeprom
        72   -> __aeabi_memcpy
        72   -> activeImmediateReset
        72   -> addNode
        72   -> checkAssignNewAddress
        72   -> checkToSendReqAddress
        72   -> evs_error_get
        72   -> extractSendFirstInList
        72   -> forceSBCreadScu
        72   -> free
        72   -> fromRs485ToSem
        72   -> getInfoSocket
        72   -> getLogicalMdbAddrSem
        72   -> getPhysicalMdbAddr
        72   -> getRoMdbRegs
        72   -> getRs485SemQueueHandle
        72   -> getScuAddressTypeMode
        72   -> getScuOpMode
        72   -> getStationId
        72   -> getStatusDwnl
        72   -> getTmMdbRegs
        72   -> isSemMasterFz
        72   -> is_socketPresence_Programmed
        72   -> mngReqAddress
        72   -> osDelay
        72   -> osThreadNew
        72   -> reInitSbcUart
        72   -> resetChangeRegisterBit
        72   -> resetPacketStatusNum
        72   -> restartSbcSemTimer
        72   -> restoreFactoryDefault
        72   -> saveAllSlaveParameters
        72   -> semSlaveSendActEnrg
        72   -> semUpdateConfig
        72   -> sendAnswToSem
        72   -> sendEeepromInfoForCloning
        72   -> sendMonMngMsg
        72   -> setChangeRegisterBit
        72   -> setCurrentDateTimeInSem
        72   -> setDevAlias
        72   -> setInfoEepromSlaveDone
        72   -> setParamFromAssignedAddr
        72   -> setScuAddressTypeMode
        72   -> tPrintf
        72   -> toggleHeartLed
        72   -> txRS485Available
        72   -> updateModbusErrorRegisters
        72   -> xQueueGenericSend
        72   -> xTaskGetTickCount
        72   -> xTimerGenericCommand
      64   sbcSemTimCallBack
        64   -> HAL_RTCEx_BKUPRead
        64   -> HAL_RTCEx_BKUPWrite
        64   -> WriteOnEeprom
        64   -> activeImmediateReset
        64   -> eeprom_array_set
        64   -> getAndsendAllSlaveParameters
        64   -> getHandleRtc
        64   -> getLogicalMdbAddrSem
        64   -> getPacketStatusNum
        64   -> getPhysicalMdbAddr
        64   -> getRandomDelay
        64   -> getRemotePmFlag
        64   -> getRs485SemQueueHandle
        64   -> getSbcSemQueueHandle
        64   -> getScuOpMode
        64   -> isSemMasterFz
        64   -> osDelay
        64   -> pvTimerGetTimerID
        64   -> restartSbcSemTimer
        64   -> sendEventToSemMng
        64   -> send_to_eeprom
        64   -> setCurrentDateTimeInSem
        64   -> setPmRemoteSemFlag
        64   -> tPrintf
        64   -> xQueueGenericSend
        64   -> xTaskGetTickCount
        64   -> xTimerGenericCommand
      24   semUpdateConfig
        24   -> CONN_ID_Set_New
        24   -> EEPROM_Save_Config
        24   -> HW_CHECKS_ACTUATORS_EEprom_Save
        24   -> HW_PRESENCE_FLAG_EEprom_Save
        24   -> LANG_Available_Mdb_to_EEprom_Translate
        24   -> LANG_Modbus_to_EEprom_Translate
        24   -> PM_Mdb_to_EEprom_Translate
        24   -> activeImmediateReset
        24   -> evs_reserved_set
        24   -> getAvailableLanguages
        24   -> getChargeByEnergy
        24   -> getChargeByTime
        24   -> getConnectorId
        24   -> getDefaultLanguage
        24   -> getMaxSimplifiedCurrent
        24   -> getMaxTypicalCurrent
        24   -> getOperationMode
        24   -> getPmMenuVisibility
        24   -> isSemMasterFz
        24   -> removeSocketFromList
        24   -> restartSbcSemTimer
        24   -> saveTimeoutRange1
        24   -> send_to_evs
        24   -> setWaitTimeValue
        24   -> xQueueGenericSend
      32   sendEeepromInfoForCloning
        32   -> FlashRead
        32   -> malloc
        32   -> osDelay
        32   -> setMallocTx485
        32   -> tPrintf
        32   -> txOnRs485Bus
      24   setAddressType
        24   -> ReadFromEeprom
        24   -> WriteOnEeprom
        24   -> setScuAddressTypeMode
        24   -> tPrintf
     104   setChangeRegisterBit
       104   -> getHmsStr
       104   -> getNumSocketLcd
       104   -> getRoMdbRegs
       104   -> getRwMdbRegs
       104   -> getScuOpMode
       104   -> isSemMasterFz
       104   -> strcat
       104   -> strcpy
       104   -> tPrintf
      32   setCurrentDateTimeInSem
        32   -> eeprom_param_get
        32   -> getCurrentUnixTime
        32   -> getLogicalMdbAddrSem
        32   -> getRwMdbRegs
        32   -> localtime
        32   -> xTimerGenericCommand
      24   setDevAlias
        24   -> eeprom_param_get
        24   -> fromRs485ToSem
        24   -> getLogicalMdbAddr
        24   -> getPhysicalMdbAddr
        24   -> getRwMdbRegs
        24   -> isSemMode
       0   setInfoEepromSlaveDone
       0   setInfoEepromSlaveStatus
       8   setNewMaxTempPowerSem
         8   -> getMaxTempPowerAc
         8   -> pmng_sem_power_set
       0   setPollingFlag
       0   setPtrToConfParam
      16   setSocketDiscovered
        16   -> WriteOnEeprom
        16   -> tPrintf
      16   setUIDinfoROmap
        16   -> getLogicalMdbAddrSem
        16   -> getRoMdbRegs
        16   -> rfid_uid_get
      24   startSbcSemProcess
        24   -> getPacketStatusNum
        24   -> getPhysicalMdbAddr
        24   -> getSbcSemQueueHandle
        24   -> xQueueGenericSend
       0   txRS485Available
      32   upgradeFwSlaveBroadcast
        32   -> getPacketStatusNum
        32   -> getRwMdbRegs
        32   -> getSbcSemQueueHandle
        32   -> xQueueGenericSend
      32   upgradeModbusHwConfig
        32   -> fromRs485ToSem
        32   -> getPacketStatusNum
        32   -> getPhysicalMdbAddr
        32   -> getSbcSemQueueHandle
        32   -> initModbusRegisters
        32   -> isSemMode
        32   -> xQueueGenericSend
      32   upgradeModbusReg
        32   -> getLogicalMdbAddrSem
        32   -> getPacketStatusNum
        32   -> getSbcSemQueueHandle
        32   -> isSemMode
        32   -> xQueueGenericSend
      40   writeMasterModbusRegister
        40   -> __aeabi_memcpy
        40   -> crcEvaluation
        40   -> getScuSinapsiTxUartSemaphoreHandle
        40   -> malloc
        40   -> setMallocTx485
        40   -> swapW
        40   -> txOnRs485Bus
        40   -> xQueueSemaphoreTake


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable13
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable22
       4  ??DataTable24
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_2
       4  ??DataTable34
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable4
       4  ??DataTable42
       4  ??DataTable45
       4  ??DataTable45_1
       4  ??DataTable45_2
       4  ??DataTable46
       4  ??DataTable46_1
       4  ??DataTable46_2
       4  ??DataTable47
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable53
       4  ??DataTable53_1
       4  ??DataTable53_10
       4  ??DataTable53_11
       4  ??DataTable53_12
       4  ??DataTable53_13
       4  ??DataTable53_14
       4  ??DataTable53_15
       4  ??DataTable53_16
       4  ??DataTable53_17
       4  ??DataTable53_2
       4  ??DataTable53_3
       4  ??DataTable53_4
       4  ??DataTable53_5
       4  ??DataTable53_6
       4  ??DataTable53_7
       4  ??DataTable53_8
       4  ??DataTable53_9
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
      12  ?_0
       8  ?_1
      12  ?_10
      12  ?_11
      12  ?_12
      12  ?_13
      20  ?_14
      16  ?_15
      16  ?_16
      12  ?_17
      12  ?_18
      24  ?_19
      12  ?_2
      56  ?_20
      40  ?_21
      44  ?_22
      32  ?_23
      32  ?_24
      28  ?_25
      52  ?_26
      24  ?_27
      24  ?_28
      40  ?_29
      16  ?_3
      20  ?_30
      24  ?_31
      36  ?_32
      24  ?_33
      32  ?_34
      24  ?_35
      32  ?_36
      32  ?_37
      24  ?_38
      28  ?_39
      12  ?_4
      40  ?_40
      48  ?_41
      52  ?_42
      52  ?_43
      16  ?_5
      16  ?_6
      12  ?_7
      12  ?_8
      16  ?_9
     150  Actuators_Mdb_to_Eeprom_Translate
       8  AddrChargStatus
      16  AddrConnType
      16  AddrEm
       8  AddrErr1
       8  AddrErr2
      12  AddrEventFlag
       8  AddrMeasure
      12  AddrSessId
      20  AddrUidStr
      36  CONN_ID_Set_New
      84  Default_Socket_Presence
     170  HW_CHECKS_ACTUATORS_EEprom_Save
     120  HW_PRESENCE_FLAG_EEprom_Save
      50  Print_Slave_Assigned
      62  Print_Slave_FW_Version
      60  addNode
      28  allTaskAreOperative
     242  checkAssignNewAddress
     214  checkToSendReqAddress
      14  createNode
      20  currFrameSbcSem
     140  extractSendFirstInList
     208  forceSBCreadScu
      20  frameSbcSem
      20  framers485Sem
      62  fromRs485ToSem
     242  getAndsendAllSlaveParameters
       6  getDefSocketInfoPtr
       8  getDiscoveryStatus
      62  getFirstFreeLogicId
      48  getIdNumberForLcd
       6  getInfoEepromSlaveStatus
     628  getInfoSocket
      12  getModbusAddrFromDevId
      20  getNumSocketLcd
      14  getPacketStatusNum
       6  getPtrToConfParam
      28  getRemotePmFlag
       8  getRs485SemQueueHandle
       8  getSbcSemQueueHandle
      18  getSktNumInFakeCode
       8  getSocketDiscovered
      44  getTagIdFromPrdSn
       4  headMsg
      18  isModbusManagerActive
      18  isSlaveWaitToBeOperative
      18  is_socketPresence_Programmed
       1  lastCommandSent
     550  mngReqAddress
      60  nameState
       1  numberOnLcd
       4  pScuRoMapReg
       4  pScuTmMapReg
       4  packetStatsCounter
      52  pollingSlaveMng
     732  pollingSlaveProcess
       4  pollingSlaveQueue
     110  pollingSlaveTask
       4  pollingSlaveTaskHandle
      36  pollingSlaveTask_attributes
      32  prevState
       4  ptrAreaConfPar
     108  readEmValuesFromMaster
     116  readMasterModbusRegister
      20  readSocketPresence
       4  remoteMng
       4  remoteMngQueue
      96  remoteMngTask
       4  remoteMngTaskHandle
      36  remoteMngTask_attributes
     332  remoteSuspRelProcess
     102  removeSocketFromList
     662  resetChangeRegisterBit
       2  resetCommandRemote
      36  resetInOperative
      10  resetPacketStatusNum
      66  restartSbcSemTimer
     110  restoreFactoryDefaultForAll
      62  restoreOperativeState
     106  rs485SemGestTask
      24  rs485SemInfoMng
     830  rs485SemMsgProcess
       4  rs485SemQueue
       2  saveAllSlaveParameters
     436  saveSlaveParameters
     262  sbcSemGestTask
      44  sbcSemInfoMng
      64  sbcSemMaskBit
   4'286  sbcSemMsgProcess
       4  sbcSemQueue
   1'224  sbcSemTimCallBack
     832  semUpdateConfig
     198  sendEeepromInfoForCloning
     106  setAddressType
     850  setChangeRegisterBit
     172  setCurrentDateTimeInSem
     126  setDevAlias
       8  setInfoEepromSlaveDone
      20  setInfoEepromSlaveStatus
      20  setNewMaxTempPowerSem
      12  setPollingFlag
       6  setPtrToConfParam
      42  setSocketDiscovered
      78  setUIDinfoROmap
      84  socketPresence
      72  startSbcSemProcess
       8  temp
       8  temp
      18  txRS485Available
     102  upgradeFwSlaveBroadcast
     108  upgradeModbusHwConfig
     108  upgradeModbusReg
     162  writeMasterModbusRegister
      20  xSbcSemTimers

 
    382 bytes in section .bss
     60 bytes in section .data
  1'448 bytes in section .rodata
 16'416 bytes in section .text
 
 16'416 bytes of CODE  memory
  1'448 bytes of CONST memory
    442 bytes of DATA  memory

Errors: none
Warnings: none
