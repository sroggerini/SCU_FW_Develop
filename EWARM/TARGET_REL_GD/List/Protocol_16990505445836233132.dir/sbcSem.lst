###############################################################################
#
# IAR ANSI C/C++ Compiler V9.60.3.422/W64 for ARM         21/Oct/2025  12:37:32
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\Src\Protocol\sbcSem.c
#    Command line                 =
#        -f
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_REL_GD\Obj\Protocol_16990505445836233132.dir\sbcSem.o.rsp
#        (C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\Src\Protocol\sbcSem.c
#        -D USE_HAL_DRIVER -D STM32F427xx -D PWM_ACTIVE -D RFID_PWR_AS_LOW_PWR
#        -D CLIENTS_2 -D V230_MON_ACTIVE -D GD32F4xx -D DEBUG_TRACE_PIN -D
#        USE_SLEEP_MODE_WHEN_VOLTAGE_IS_ABSENT -D HTS_IMQ -D no_NTC_GAIN_1P5 -D
#        NTC_GAIN_6 -D MODBUS_TCP_EM_LOVATO -lC
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_REL_GD\List\Protocol_16990505445836233132.dir
#        -o
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_REL_GD\Obj\Protocol_16990505445836233132.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 --no_path_in_file_macros -e --fpu=VFPv4_sp
#        --dlib_config C:\iar\ewarm-9.60.3\arm\inc\c\DLib_Config_Full.h -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Inc\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/system\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Drivers/STM32F7xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM7/r0p1\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/netif/ppp\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Drivers/CMSIS/Device/ST/STM32F7xx/Include\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/lwip\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/lwip/apps\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/lwip/priv\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/lwip/prot\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/netif\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/compat/posix\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/compat/posix/arpa\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/compat/posix/net\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/compat/posix/sys\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/src/include/compat/stdc\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Middlewares/Third_Party/LwIP/system/arch\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\LIB\uartDbg\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\protocol\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\Device\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\coreApp\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\LIB\BSP\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\LIB\ftp\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\stationMng\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\LIB\uartEm\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\LIB\rfid\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\webserver\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\webserver\httpd\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Middlewares\BlueNRG-MS\includes\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Middlewares\BlueNRG-MS\utils\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Middlewares\BlueNRG-MS\hci\hci_tl_patterns\Basic\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Src\BlueTooth\Target\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Src\BlueTooth\Application\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Src\BlueTooth\Core\Inc\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Src\BlueTooth\BSP\Nucleo\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Inc\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Inc\Legacy\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\protocol\modbus\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Inc\protocol\wifi\
#        -I
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\..\Middlewares\ST\STM32_Cryptographic\include\
#        -On) --dependencies=n
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_REL_GD\Obj\Protocol_16990505445836233132.dir\sbcSem.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_REL_GD\List\Protocol_16990505445836233132.dir\sbcSem.lst
#    Object file                  =
#        C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\EWARM\TARGET_REL_GD\Obj\Protocol_16990505445836233132.dir\sbcSem.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  1
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Progetti\SVN_Repos\SCAME_GD_RED\SCAME_CONTROL_UNIT\trunk\Src\Protocol\sbcSem.c
      1          /**
      2          * @file        sbcSEM.c
      3          *
      4          * @brief       manager upgrade notify MDB register for SEM   - Implementation -
      5          *
      6          * @author      Nick
      7          *
      8          * @riskClass   C
      9          *
     10          * @moduleID
     11          *
     12          * @vcsInfo
     13          *     $Id: scuMdb.c 334 2023-11-06 11:11:45Z luca $
     14          *
     15          *     $Revision: 334 $
     16          *
     17          *     $Author: luca $
     18          *
     19          *     $Date: 2023-11-06 12:11:45 +0100 (lun, 06 nov 2023) $
     20          *
     21          *
     22          * @copyright
     23          *       Copyright (C) 2016 SCAME S.p.A. All rights reserved.
     24          *       This file is copyrighted and the property of Aesys S.p.A.. It contains confidential and proprietary
     25          *       information. Any copies of this file (in whole or in part) made by any method must also include a copy of this
     26          *       legend.
     27          *       Developed by:  SCAME S.p.A.
     28          ***********************************************************************************************************************/
     29          
     30          /************************************************************
     31           * Include
     32           ************************************************************/
     33          //#include <main.h>
     34          #include <stddef.h>
     35          #include <string.h>
     36          #include <stdlib.h>
     37          #include <stdio.h>
     38          #include <math.h>
     39          #ifdef GD32F4xx
     40          #include "stm32f4xx_hal.h"
     41          #include "stm32f4xx_ll_rcc.h"
     42          #else
     43          #include "stm32h5xx_hal.h"
     44          #include "stm32h5xx_ll_rcc.h"
     45          #endif
     46          #include "cmsis_os.h"
     47          #include "prot_OnUsart.h"
     48          #include "wrapper.h"
     49          #include "sbcUart.h"
     50          #include "scuMdb.h"
     51          #include "eeprom.h"
     52          #include "telnet.h"
     53          #include "sbcGsy.h"
     54          #include "uart_Legacy.h"
     55          #include "inputsMng.h"
     56          #include "rtcApi.h"
     57          #include "scheduleMng.h"   
     58          #include "httpserver-socket.h"
     59          #include "ExtInpMng.h"
     60          #include "RfidMng.h"
     61          #include "scuMdb.h"
     62          #include "sbcSem.h"
     63          #include "ioExp.h"
     64          #include "PwmMng.h"
     65          #include "LcdMng.h"
     66          #include "monitorMng.h"
     67          #include "telnet.h"
     68          
     69          /*
     70          ***********************************SCAME**************************************
     71          **                                                                          **
     72          **           LOCAL MACROS, TYPEDEF, STRUCTURE, ENUM                         **
     73          **                                                                          **
     74          ******************************************************************************
     75          */
     76          
     77          #define   DEFAULT_SBCSEM_TIME             pdMS_TO_TICKS((uint16_t)1000)
     78          #define   SBCSEM_TIMER_GARD_TIME          pdMS_TO_TICKS((uint16_t)500)
     79          
     80          #define   KEY_FULL_CONFIG                 ((uint16_t)0xAA55)
     81          #define   KEY_LOCAL_CONFIG                ((uint16_t)0xBB66)
     82          #define   KEY_SCU_SLAVE_LINKED_2          ((uint16_t)0xCC72)
     83          #define   KEY_SCU_SLAVE_LINKED_4          ((uint16_t)0xCC74)
     84          #define   KEY_FULL_MASTER_P_S             ((uint16_t)0xDD88)
     85          #define   KEY_FULL_MASTER_P               ((uint16_t)0x0088)
     86          #define   KEY_FULL_MASTER_S               ((uint16_t)0xDD00)
     87          
     88          #define   FACTOR_FOR_RANDOM_DELAY         ((uint16_t)64)
     89          // --------------------------------------------------------------------------------------------------------------------------- //
     90          
     91          /*
     92          ***********************************SCAME**************************************
     93          **                                                                          **
     94          **                            Local Const                                   **
     95          **                                                                          **
     96          ****************************************************************************** 
     97          */ 
     98          

   \                                 In section .rodata, align 4
     99          static const uint32_t   sbcSemMaskBit[SCU_NUM] = {
   \                     sbcSemMaskBit:
   \        0x0   0x0000'0001        DC32 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1'024, 2'048, 4'096, 8'192
   \              0x0000'0002  
   \              0x0000'0004  
   \              0x0000'0008  
   \              0x0000'0010  
   \              0x0000'0020  
   \              0x0000'0040  
   \              0x0000'0080  
   \              0x0000'0100  
   \              0x0000'0200  
   \              0x0000'0400  
   \              0x0000'0800  
   \              0x0000'1000  
   \              0x0000'2000
   \       0x38   0x0000'4000        DC32 16'384, 32'768
   \              0x0000'8000
    100            0x0001,    0x0002,    0x0004,    0x0008,    0x0010,     0x0020,     0x0040,     0x0080, 
    101            0x0100,    0x0200,    0x0400,    0x0800,    0x1000,     0x2000,     0x4000,     0x8000
    102          };
    103          

   \                                 In section .rodata, align 4
    104          static const char AddrUidStr[]       = "UID Athorization";
   \                     AddrUidStr:
   \        0x0   0x55 0x49          DC8 "UID Athorization"
   \              0x44 0x20    
   \              0x41 0x74    
   \              0x68 0x6F    
   \              0x72 0x69    
   \              0x7A 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x00
   \       0x11                      DS8 3

   \                                 In section .rodata, align 4
    105          static const char AddrEventFlag[]    = "Event Flag";
   \                     AddrEventFlag:
   \        0x0   0x45 0x76          DC8 "Event Flag"
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x46 0x6C    
   \              0x61 0x67    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
    106          static const char AddrChargStatus[]  = "Stato->";
   \                     AddrChargStatus:
   \        0x0   0x53 0x74          DC8 "Stato->"
   \              0x61 0x74    
   \              0x6F 0x2D    
   \              0x3E 0x00

   \                                 In section .rodata, align 4
    107          static const char AddrErr1[]         = "Error1";
   \                     AddrErr1:
   \        0x0   0x45 0x72          DC8 "Error1"
   \              0x72 0x6F    
   \              0x72 0x31    
   \              0x00
   \        0x7                      DS8 1

   \                                 In section .rodata, align 4
    108          static const char AddrErr2[]         = "Error2";
   \                     AddrErr2:
   \        0x0   0x45 0x72          DC8 "Error2"
   \              0x72 0x6F    
   \              0x72 0x32    
   \              0x00
   \        0x7                      DS8 1

   \                                 In section .rodata, align 4
    109          static const char AddrConnType[]     = "Connector Type";
   \                     AddrConnType:
   \        0x0   0x43 0x6F          DC8 "Connector Type"
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x6F    
   \              0x72 0x20    
   \              0x54 0x79    
   \              0x70 0x65    
   \              0x00
   \        0xF                      DS8 1

   \                                 In section .rodata, align 4
    110          static const char AddrSessId[]       = "Session Id";
   \                     AddrSessId:
   \        0x0   0x53 0x65          DC8 "Session Id"
   \              0x73 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x49 0x64    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
    111          static const char AddrEm[]           = "Energy Meter";
   \                     AddrEm:
   \        0x0   0x45 0x6E          DC8 "Energy Meter"
   \              0x65 0x72    
   \              0x67 0x79    
   \              0x20 0x4D    
   \              0x65 0x74    
   \              0x65 0x72    
   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
    112          static const char AddrMeasure[]      = "Measure";
   \                     AddrMeasure:
   \        0x0   0x4D 0x65          DC8 "Measure"
   \              0x61 0x73    
   \              0x75 0x72    
   \              0x65 0x00

   \                                 In section .data, align 4
    113          static const char *nameState[]       = {" Initial", " Idle",        " Preparing", " Ev Connected", " Charging", " Suspended Ev", " Suspended EvSe",   " End Charge",
   \                     nameState:
   \        0x0   0x....'....        DC32 ?_0, ?_1, ?_2, ?_3, ?_4, ?_5, ?_6, ?_7, ?_8, ?_9, ?_10, ?_11, ?_12
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....  
   \              0x....'....
   \       0x34   0x....'....        DC32 ?_13, ?_14
   \              0x....'....
    114                                                  " Faulted", " Unavailable", " Reserved",  " Bootloader",   "Shutdown",  " Rebooting",    " Suspended NoPower"};
    115          

   \                                 In section .rodata, align 4
    116          static const socketPresence_t Default_Socket_Presence = {.chainPresence = 0, .livePresence = 0, .keyPresence = KEY_FULL_CONFIG, .activityStatus = 0, 
   \                     Default_Socket_Presence:
   \        0x0   0x0000'0000        DC32 0, 0, 43'605, 0
   \              0x0000'0000  
   \              0x0000'AA55  
   \              0x0000'0000
   \       0x10   0x01 0x02          DC8 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
   \              0x03 0x04    
   \              0x05 0x06    
   \              0x07 0x08    
   \              0x09 0x0A    
   \              0x0B 0x0C    
   \              0x0D 0x0E    
   \              0x0F 0x10    
   \              0x11 0x12    
   \              0x13
   \       0x23   0x14 0x15          DC8 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 1, 2, 3, 4, 5
   \              0x16 0x17    
   \              0x18 0x19    
   \              0x1A 0x1B    
   \              0x1C 0x1D    
   \              0x1E 0x1F    
   \              0x20 0x01    
   \              0x02 0x03    
   \              0x04 0x05
   \       0x35   0x06 0x07          DC8 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23
   \              0x08 0x09    
   \              0x0A 0x0B    
   \              0x0C 0x0D    
   \              0x0E 0x0F    
   \              0x10 0x11    
   \              0x12 0x13    
   \              0x14 0x15    
   \              0x16 0x17
   \       0x47   0x18 0x19          DC8 24, 25, 26, 27, 28, 29, 30, 31, 32
   \              0x1A 0x1B    
   \              0x1C 0x1D    
   \              0x1E 0x1F    
   \              0x20
   \       0x50   0x0000'0000        DC32 0
    117                                                                  { 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 
    118                                                                   17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32},
    119                                                                  { 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
    120                                                                   17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32}, 
    121                                                                  .assignedDeviceId = 0};
    122          #ifdef NON_SERVE
    123          /* define a fixed structure where to find the configuration parameters */
    124          static const allConfPar_st allConfParDef = {
    125            (uint16_t)0x0,
    126            {(uint32_t)START_EE_ADDRES,             (uint32_t)EEPROM_PARAM_NUM},
    127            {(uint32_t)SCU_GENERAL_INFO_EE_ADDRES,  (uint32_t)sizeof(infoStation_t)},
    128            {(uint32_t)EDATA_BKP_SCU_EE_ADDRESS,    (uint32_t)sizeof(infoStation_t)},
    129            {(uint32_t)PRD_CODE_EE_ADDRES,          (uint32_t)(END_SN_EE_ADDRES - PRD_CODE_EE_ADDRES + 1)},
    130            {(uint32_t)EDATA_DEFAULT_ID_CODES,      (uint32_t)(PRODUCT_SN_LENGTH + PRODUCT_CODE_LENGTH + FAKE_CODE_LENGTH)},
    131            (uint32_t)0
    132          };
    133          #endif                                                    
    134          
    135          /* Definitions for SCB (SEM) modbus upgrade register Task   */

   \                                 In section .rodata, align 4
    136          const osThreadAttr_t pollingSlaveTask_attributes = {
   \                     pollingSlaveTask_attributes:
   \        0x0   0x....'....        DC32 ?_15, 0, 0x0, 0, 0x0, 512, 24
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0200  
   \              0x0000'0018
   \       0x1C                      DS8 8
    137            .name = "POLLING_SLAVE",
    138            .priority = (osPriority_t) osPriorityNormal,
    139            .stack_size = configMINIMAL_STACK_SIZE * 4     // 
    140          };
    141          
    142          /* Definitions for supend / release Task Manager  remoteMngTaskHandle  */

   \                                 In section .rodata, align 4
    143          const osThreadAttr_t remoteMngTask_attributes = {
   \                     remoteMngTask_attributes:
   \        0x0   0x....'....        DC32 ?_16, 0, 0x0, 0, 0x0, 256, 24
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0100  
   \              0x0000'0018
   \       0x1C                      DS8 8
    144            .name = "SUSP_REL_TASK",
    145            .priority = (osPriority_t) osPriorityNormal,
    146            .stack_size = configMINIMAL_STACK_SIZE * 2     // 
    147          };
    148          
    149          
    150          /*
    151          ***********************************SCAME**************************************
    152          **                                                                          **
    153          **                            Local Variables                               **
    154          **                                                                          **
    155          ****************************************************************************** 
    156          */ 

   \                                 In section .bss, align 1
    157          EvsMngEvent_en    lastCommandSent;
   \                     lastCommandSent:
   \        0x0                      DS8 1
    158          
    159          /*
    160          ***********************************SCAME**************************************
    161          **                                                                          **
    162          **                            Local  Variables                              **
    163          **                                                                          **
    164          ****************************************************************************** 
    165          */ 

   \                                 In section .bss, align 4
    166          static    TimerHandle_t     xSbcSemTimers[NUM_SBCSEM_TIMER];
   \                     xSbcSemTimers:
   \        0x0                      DS8 20

   \                                 In section .bss, align 1
    167          static    uint8_t           numberOnLcd;
   \                     numberOnLcd:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
    168          static    uint16_t          prevState[SCU_NUM];
   \                     prevState:
   \        0x0                      DS8 32

   \                                 In section .bss, align 4
    169          static    uint32_t          packetStatsCounter;
   \                     packetStatsCounter:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    170          static    areaConfPar_st*   ptrAreaConfPar;
   \                     ptrAreaConfPar:
   \        0x0                      DS8 4
    171          
    172          
    173          // --------------------------------------------------------------------------------------------------------------------------- //
    174          
    175          
    176          // --------------------------------------------------------------------------------------------------------------------------- //
    177          
    178          /*
    179          ***********************************SCAME**************************************
    180          **                                                                          **
    181          **                            Internal Function prototype                   **
    182          **                                                                          **
    183          ******************************************************************************
    184          */
    185          
    186          static  uint32_t          sbcSemMsgProcess          (frameSbcSem_st* pMsg, uint32_t currTick);
    187          static  uint32_t          rs485SemMsgProcess        (frameSbcSem_st* pMsg);
    188          static  void              writeMasterModbusRegister (uint8_t* pOriginData, headerReqRWMR_st* pScuRWmR);
    189          static  uint8_t           getInfoSocket             (uint32_t presenceMask, sbcSemInfoMng_st* pInfo); 
    190          static  void              readMasterModbusRegister  (headerRHR_t* pScuRIR);
    191          static  void              semUpdateConfig           (frameSbcSem_st* pMsg); 
    192          static  bitNotifyResult_e setChangeRegisterBit      (uint16_t ixScu, frameSbcSem_st* pMsg, uint32_t mskBit, uint16_t deviceId); 
    193          static  uint8_t           resetChangeRegisterBit    (uint16_t ixScu, uint16_t regChanged, uint16_t lenRd); 
    194          static  void              sbcSemTimCallBack         (TimerHandle_t pxTimer);
    195          static  nodeMsg           extractSendFirstInList    (nodeMsg head);
    196          static  nodeMsg           addNode                   (nodeMsg head, frameSbcSem_st *pMessage);
    197          static  uint32_t          pollingSlaveProcess       (frameSbcSem_st* pMsg);
    198          static  void              pollingSlaveTask          (void * pvParameters);
    199          static  uint8_t           getSktNumInFakeCode       (void); 
    200          static  uint16_t          getTagIdFromPrdSn         (void);
    201          static  uint8_t           checkAssignNewAddress     (frameSbcSem_st* pMsg); 
    202          static  sbcSemStates_e    checkToSendReqAddress     (frameSbcSem_st* pMsg); 
    203          static  void              mngReqAddress             (frameSbcSem_st* pMsg); 
    204          static  uint32_t          remoteSuspRelProcess      (frameRemote_st* pMsg);
    205          static  void              remoteMngTask             (void * pvParameters);
    206          static  void              restartSbcSemTimer        (uint16_t timerId, uint32_t period);
    207          static  void              forceSBCreadScu           (uint32_t activityMask); 
    208          static  void              removeSocketFromList      (uint8_t skId); 
    209          static  uint8_t           getFirstFreeLogicId       (void); 
    210          static  void              resetPacketStatusNum      (void); 
    211          #ifdef TRANSLATE_ID_LOGIC
    212          static  uint8_t           setModbusAddress          (void); 
    213          #endif
    214          static  void              saveAllSlaveParameters    (void);
    215          static  void              setInfoEepromSlaveDone    (uint16_t lastDetected);
    216          static  uint8_t           sendEeepromInfoForCloning (uint8_t idLogic);
    217          
    218          // --------------------------------------------------------------------------------------------------------------------------- //
    219          
    220          /*
    221          ***********************************SCAME**************************************
    222          **                                                                          **
    223          **                            Global Variables                              **
    224          **                                                                          **
    225          ****************************************************************************** 
    226          */ 
    227          /*  queue  declaration */

   \                                 In section .bss, align 4
    228          xQueueHandle          sbcSemQueue = NULL;
   \                     sbcSemQueue:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    229          frameSbcSem_st        frameSbcSem;
   \                     frameSbcSem:
   \        0x0                      DS8 20

   \                                 In section .bss, align 4
    230          scuRoMapRegister_st*  pScuRoMapReg;
   \                     pScuRoMapReg:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    231          sbcSemInfoMng_st      sbcSemInfoMng;
   \                     sbcSemInfoMng:
   \        0x0                      DS8 44

   \                                 In section .bss, align 4
    232          tmMapRegister_st*     pScuTmMapReg;
   \                     pScuTmMapReg:
   \        0x0                      DS8 4
    233          

   \                                 In section .bss, align 4
    234          xQueueHandle          rs485SemQueue = NULL;
   \                     rs485SemQueue:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    235          frameSbcSem_st        framers485Sem;
   \                     framers485Sem:
   \        0x0                      DS8 20

   \                                 In section .bss, align 4
    236          rs485SemInfoMng_st    rs485SemInfoMng;
   \                     rs485SemInfoMng:
   \        0x0                      DS8 24

   \                                 In section .bss, align 4
    237          socketPresence_t      socketPresence;
   \                     socketPresence:
   \        0x0                      DS8 84

   \                                 In section .bss, align 4
    238          frameSbcSem_st        currFrameSbcSem;
   \                     currFrameSbcSem:
   \        0x0                      DS8 20
    239          

   \                                 In section .bss, align 4
    240          nodeMsg               headMsg;
   \                     headMsg:
   \        0x0                      DS8 4
    241          

   \                                 In section .bss, align 4
    242          osThreadId_t          pollingSlaveTaskHandle;
   \                     pollingSlaveTaskHandle:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    243          xQueueHandle          pollingSlaveQueue = NULL;
   \                     pollingSlaveQueue:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    244          pollingSlaveMng_st    pollingSlaveMng;
   \                     pollingSlaveMng:
   \        0x0                      DS8 52
    245          

   \                                 In section .bss, align 4
    246          osThreadId_t          remoteMngTaskHandle;
   \                     remoteMngTaskHandle:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    247          xQueueHandle          remoteMngQueue = NULL;
   \                     remoteMngQueue:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    248          remoteMng_st          remoteMng;
   \                     remoteMng:
   \        0x0                      DS8 4
    249          
    250          // --------------------------------------------------------------------------------------------------------------------------- //
    251          
    252          /*
    253          *********************************** SCAME ************************************
    254          **                                                                          **
    255          **                            External Variables                            **
    256          **                                                                          **
    257          ******************************************************************************
    258          */
    259          extern osThreadId_t sbcMngTaskHandle;
    260          
    261          // --------------------------------------------------------------------------------------------------------------------------- //
    262          
    263          /*
    264          ***********************************SCAME**************************************
    265          **                                                                          **
    266          **                            Function Definition                           **
    267          **                                                                          **
    268          ******************************************************************************
    269          */
    270          
    271          /**
    272          *
    273          * @brief        Check if socket presence informations are programmed in the right location
    274          *
    275          * @param [in]   none
    276          *
    277          * @retval       uint8_t: TRUE, if an answer must be sent
    278          *
    279          ***********************************************************************************************************************/
    280          

   \                                 In section .text, align 2, keep-with-next
    281          uint8_t is_socketPresence_Programmed (void)
    282          {
    283              
    284            /* Check if structure is not initialized: all values to 0xFF */
    285            if (socketPresence.keyPresence == 0xFFFFFFFF) 
   \                     is_socketPresence_Programmed: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable1
   \        0x2   0x6880             LDR      R0,[R0, #+8]
   \        0x4   0xF110 0x0F01      CMN      R0,#+1
   \        0x8   0xD101             BNE.N    ??is_socketPresence_Programmed_0
    286              /* structure NOT initialized */
    287              return FALSE;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xE000             B.N      ??is_socketPresence_Programmed_1
    288            
    289            /* structure initialized */
    290            return TRUE;
   \                     ??is_socketPresence_Programmed_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \                     ??is_socketPresence_Programmed_1: (+1)
   \       0x10   0x4770             BX       LR
    291          }
    292          

   \                                 In section .text, align 2, keep-with-next
    293          void sbcSemGestTask (void * pvParameters)
    294          {
   \                     sbcSemGestTask: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x0004             MOVS     R4,R0
    295            frameSbcSem_st tmpFrameSbcSem;  
    296            uint32_t       timeTickSem;
    297            uint8_t        ix;
    298          
    299            /*-------- Creates an empty mailbox for uart  messages --------------------------*/
    300            sbcSemQueue = xQueueCreate(NUM_BUFF_SEM_SCU, sizeof(frameSbcSem_st));
   \        0x8   0x....             LDR.N    R5,??DataTable1_1
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2112             MOVS     R1,#+18
   \        0xE   0x2010             MOVS     R0,#+16
   \       0x10   0x.... 0x....      BL       xQueueGenericCreate
   \       0x14   0x6028             STR      R0,[R5, #+0]
    301            configASSERT(sbcSemQueue != NULL);
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD109             BNE.N    ??sbcSemGestTask_0
   \       0x1C   0xB672             CPSID    I
   \       0x1E   0x2050             MOVS     R0,#+80
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   \       0x2C   0xB662             CPSIE    I
   \                     ??sbcSemGestTask_1: (+1)
   \       0x2E   0xE7FE             B.N      ??sbcSemGestTask_1
    302            vQueueAddToRegistry(sbcSemQueue, "sbcSemQueue" );
   \                     ??sbcSemGestTask_0: (+1)
   \       0x30   0x....             LDR.N    R1,??DataTable1_2
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0x.... 0x....      BL       vQueueAddToRegistry
    303            
    304            /*-------- Creates all timer for the led task  --------------------------*/
    305            for (ix = (uint8_t)0; ix < (uint8_t)NUM_SBCSEM_TIMER; ix++)
   \       0x38   0x2600             MOVS     R6,#+0
   \                     ??sbcSemGestTask_2: (+1)
   \       0x3A   0x0030             MOVS     R0,R6
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x2805             CMP      R0,#+5
   \       0x40   0xDA38             BGE.N    ??sbcSemGestTask_3
    306            {
    307              if (ix == (uint8_t)TIMER_FOR_ACK)
   \       0x42   0x0030             MOVS     R0,R6
   \       0x44   0xB2C0             UXTB     R0,R0
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD110             BNE.N    ??sbcSemGestTask_4
    308              {
    309                xSbcSemTimers[ix] = xTimerCreate("TimSbcSem", TIMEOUT_ACK_RESP, pdFALSE, (void*)(ix), sbcSemTimCallBack);
   \       0x4A   0x....             LDR.N    R0,??DataTable1_3
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0x0033             MOVS     R3,R6
   \       0x50   0xB2DB             UXTB     R3,R3
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0xF44F 0x71FA      MOV      R1,#+500
   \       0x58   0x....             LDR.N    R0,??DataTable1_4
   \       0x5A   0x.... 0x....      BL       xTimerCreate
   \       0x5E   0x.... 0x....      LDR.W    R1,??sbcSemMsgProcess_0
   \       0x62   0x0032             MOVS     R2,R6
   \       0x64   0xB2D2             UXTB     R2,R2
   \       0x66   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   \       0x6A   0xE00F             B.N      ??sbcSemGestTask_5
    310              }
    311              else
    312              {
    313                /* in this case we dont use the auto-reload features */
    314                xSbcSemTimers[ix] = xTimerCreate("TimSbcSem", DEFAULT_SBCSEM_TIME, pdFALSE, (void*)(ix), sbcSemTimCallBack);
   \                     ??sbcSemGestTask_4: (+1)
   \       0x6C   0x....             LDR.N    R0,??DataTable1_3
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   \       0x70   0x0033             MOVS     R3,R6
   \       0x72   0xB2DB             UXTB     R3,R3
   \       0x74   0x2200             MOVS     R2,#+0
   \       0x76   0xF44F 0x717A      MOV      R1,#+1000
   \       0x7A   0x....             LDR.N    R0,??DataTable1_4
   \       0x7C   0x.... 0x....      BL       xTimerCreate
   \       0x80   0x.... 0x....      LDR.W    R1,??sbcSemMsgProcess_0
   \       0x84   0x0032             MOVS     R2,R6
   \       0x86   0xB2D2             UXTB     R2,R2
   \       0x88   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
    315              }
    316              configASSERT(xSbcSemTimers[ix] != NULL);
   \                     ??sbcSemGestTask_5: (+1)
   \       0x8C   0x.... 0x....      LDR.W    R0,??sbcSemMsgProcess_0
   \       0x90   0x0031             MOVS     R1,R6
   \       0x92   0xB2C9             UXTB     R1,R1
   \       0x94   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD109             BNE.N    ??sbcSemGestTask_6
   \       0x9C   0xB672             CPSID    I
   \       0x9E   0x2050             MOVS     R0,#+80
   \       0xA0   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xA4   0xF3BF 0x8F4F      DSB      SY
   \       0xA8   0xF3BF 0x8F6F      ISB      SY
   \       0xAC   0xB662             CPSIE    I
   \                     ??sbcSemGestTask_7: (+1)
   \       0xAE   0xE7FE             B.N      ??sbcSemGestTask_7
    317            }
   \                     ??sbcSemGestTask_6: (+1)
   \       0xB0   0x1C76             ADDS     R6,R6,#+1
   \       0xB2   0xE7C2             B.N      ??sbcSemGestTask_2
    318          
    319            /* init structure for management */
    320            sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_START;
   \                     ??sbcSemGestTask_3: (+1)
   \       0xB4   0x2008             MOVS     R0,#+8
   \       0xB6   0x.... 0x....      LDR.W    R1,??sbcSemMsgProcess_0+4
   \       0xBA   0x8008             STRH     R0,[R1, #+0]
    321          
    322            packetStatsCounter = (uint32_t)0;
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0x....             LDR.N    R1,??DataTable1_5
   \       0xC0   0x6008             STR      R0,[R1, #+0]
    323          
    324            headMsg = NULL;
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x.... 0x....      LDR.W    R1,??sbcSemMsgProcess_0+8
   \       0xC8   0x6008             STR      R0,[R1, #+0]
    325            ptrAreaConfPar = NULL;
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0x....             LDR.N    R1,??DataTable1_6
   \       0xCE   0x6008             STR      R0,[R1, #+0]
    326              
    327            timeTickSem = portMAX_DELAY;
   \       0xD0   0xF05F 0x37FF      MOVS     R7,#+4294967295
    328          
    329            for (;;)
    330            {
    331              /* Wait for some event from Rx/Tx uart SBC (typically UART5)  */
    332              if (xQueueReceive(sbcSemQueue, (void *)&frameSbcSem, timeTickSem) == pdPASS)
   \                     ??sbcSemGestTask_8: (+1)
   \       0xD4   0x.... 0x....      LDR.W    R8,??DataTable1_7
   \       0xD8   0x003A             MOVS     R2,R7
   \       0xDA   0x4641             MOV      R1,R8
   \       0xDC   0x6828             LDR      R0,[R5, #+0]
   \       0xDE   0x.... 0x....      BL       xQueueReceive
   \       0xE2   0x2801             CMP      R0,#+1
   \       0xE4   0xD105             BNE.N    ??sbcSemGestTask_9
    333              {
    334                timeTickSem = sbcSemMsgProcess(&frameSbcSem, timeTickSem);
   \       0xE6   0x0039             MOVS     R1,R7
   \       0xE8   0x4640             MOV      R0,R8
   \       0xEA   0x.... 0x....      BL       sbcSemMsgProcess
   \       0xEE   0x0007             MOVS     R7,R0
   \       0xF0   0xE7F0             B.N      ??sbcSemGestTask_8
    335              }
    336              else
    337              {
    338                tmpFrameSbcSem.sbcSemEvent = SBC_SEM_TIMEOUT;
   \                     ??sbcSemGestTask_9: (+1)
   \       0xF2   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0xF6   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    339                timeTickSem = sbcSemMsgProcess(&tmpFrameSbcSem, timeTickSem);
   \       0xFA   0x0039             MOVS     R1,R7
   \       0xFC   0xA801             ADD      R0,SP,#+4
   \       0xFE   0x.... 0x....      BL       sbcSemMsgProcess
   \      0x102   0x0007             MOVS     R7,R0
   \      0x104   0xE7E6             B.N      ??sbcSemGestTask_8
    340              }
    341            }
    342          }
    343          
    344          /**
    345          *
    346          * @brief        Decoder message coming from SBC on UART5, or for internal task as debug 
    347          *
    348          * @param [in]   none
    349          *
    350          * @retval       uint8_t: TRUE, if an answer must be sent
    351          *
    352          ***********************************************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    353          static uint32_t sbcSemMsgProcess(frameSbcSem_st* pMsg, uint32_t currTick)
    354          {
   \                     sbcSemMsgProcess: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x0004             MOVS     R4,R0
    355            uint16_t              ixScu, ixLogic;
    356            uint32_t              maskBit;
    357            uint32_t              timeTickTmp;
    358            uint16_t*             pWord;
    359            uint8_t               error_array[EVS_ERROR_ARRAY_SIZE];
    360            scuOpModes_e          locScuMode;
    361            scuRoMapRegister_st*  pScuRoMapRegSlave;
    362            uint8_t               result, cnt;
    363          
    364            
    365            if (pMsg->sbcSemEvent != SBC_SEM_TIMEOUT)
   \        0x8   0xF64F 0x7BFE      MOVW     R11,#+65534
   \        0xC   0x8820             LDRH     R0,[R4, #+0]
   \        0xE   0x4558             CMP      R0,R11
   \       0x10   0xD015             BEQ.N    ??sbcSemMsgProcess_4
    366            {
    367              ixScu = pMsg->data.index; // get modbus address from incoming message 
   \       0x12   0x8860             LDRH     R0,[R4, #+2]
   \       0x14   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    368              
    369              if (ixScu > (uint16_t)MODBUS_BROADCAST_ADDR) 
   \       0x18   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD005             BEQ.N    ??sbcSemMsgProcess_5
    370                ixLogic = fromRs485ToSem(ixScu); 
   \       0x20   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \       0x24   0x.... 0x....      BL       fromRs485ToSem
   \       0x28   0x0005             MOVS     R5,R0
   \       0x2A   0xE001             B.N      ??sbcSemMsgProcess_6
    371              else 
    372                ixLogic = 0;
   \                     ??sbcSemMsgProcess_5: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x0005             MOVS     R5,R0
    373              maskBit = sbcSemMaskBit[ixLogic];
   \                     ??sbcSemMsgProcess_6: (+1)
   \       0x30   0xF8DF 0x0A80      LDR.W    R0,??sbcSemMsgProcess_0+12
   \       0x34   0x0029             MOVS     R1,R5
   \       0x36   0xB289             UXTH     R1,R1
   \       0x38   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \       0x3C   0x0006             MOVS     R6,R0
    374            }
    375          
    376            timeTickTmp = currTick;
   \                     ??sbcSemMsgProcess_4: (+1)
   \       0x3E   0x9F08             LDR      R7,[SP, #+32]
    377          
    378            switch (sbcSemInfoMng.sbcSemStates)
   \       0x40   0xF8DF 0xAA68      LDR.W    R10,??sbcSemMsgProcess_0+4
   \       0x44   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xF000 0x81BC      BEQ.W    ??sbcSemMsgProcess_7
   \       0x4E   0x2801             CMP      R0,#+1
   \       0x50   0xF000 0x81CA      BEQ.W    ??sbcSemMsgProcess_8
   \       0x54   0x2802             CMP      R0,#+2
   \       0x56   0xF000 0x8204      BEQ.W    ??sbcSemMsgProcess_9
   \       0x5A   0x2803             CMP      R0,#+3
   \       0x5C   0xF000 0x8294      BEQ.W    ??sbcSemMsgProcess_10
   \       0x60   0x2804             CMP      R0,#+4
   \       0x62   0xF000 0x83D2      BEQ.W    ??sbcSemMsgProcess_11
   \       0x66   0x2805             CMP      R0,#+5
   \       0x68   0xF000 0x86E3      BEQ.W    ??sbcSemMsgProcess_12
   \       0x6C   0x2806             CMP      R0,#+6
   \       0x6E   0xF000 0x878E      BEQ.W    ??sbcSemMsgProcess_13
   \       0x72   0x2807             CMP      R0,#+7
   \       0x74   0xF000 0x878B      BEQ.W    ??sbcSemMsgProcess_13
   \       0x78   0x2808             CMP      R0,#+8
   \       0x7A   0xD013             BEQ.N    ??sbcSemMsgProcess_14
   \       0x7C   0x2809             CMP      R0,#+9
   \       0x7E   0xF000 0x80F7      BEQ.W    ??sbcSemMsgProcess_15
   \       0x82   0x280A             CMP      R0,#+10
   \       0x84   0xF000 0x8150      BEQ.W    ??sbcSemMsgProcess_16
   \       0x88   0x280C             CMP      R0,#+12
   \       0x8A   0xF000 0x82F8      BEQ.W    ??sbcSemMsgProcess_17
   \       0x8E   0x280D             CMP      R0,#+13
   \       0x90   0xF000 0x877D      BEQ.W    ??sbcSemMsgProcess_13
   \       0x94   0x280E             CMP      R0,#+14
   \       0x96   0xF000 0x839F      BEQ.W    ??sbcSemMsgProcess_18
   \       0x9A   0x280F             CMP      R0,#+15
   \       0x9C   0xF000 0x8177      BEQ.W    ??sbcSemMsgProcess_19
   \       0xA0   0xF001 0xB805      B.W      ??sbcSemMsgProcess_20
    379            {
    380              case SBC_SEM_WAIT_TO_START:
    381                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_14: (+1)
   \       0xA4   0x8820             LDRH     R0,[R4, #+0]
   \       0xA6   0x2802             CMP      R0,#+2
   \       0xA8   0xF000 0x80D6      BEQ.W    ??sbcSemMsgProcess_21
   \       0xAC   0x2809             CMP      R0,#+9
   \       0xAE   0xF040 0x80DD      BNE.W    ??sbcSemMsgProcess_22
    382                {
    383                  case NOTIFY_START_TASK:
    384           
    385                    pScuRoMapReg = getRoMdbRegs(0);
   \                     ??sbcSemMsgProcess_23: (+1)
   \       0xB2   0xF8DF 0xBCB8      LDR.W    R11,??sbcSemMsgProcess_1
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0x.... 0x....      BL       getRoMdbRegs
   \       0xBC   0xF8CB 0x0000      STR      R0,[R11, #+0]
    386                    pScuTmMapReg = getTmMdbRegs(ixLogic);
   \       0xC0   0x0028             MOVS     R0,R5
   \       0xC2   0xB2C0             UXTB     R0,R0
   \       0xC4   0x.... 0x....      BL       getTmMdbRegs
   \       0xC8   0xF8DF 0x1CA4      LDR.W    R1,??sbcSemMsgProcess_1+4
   \       0xCC   0x6008             STR      R0,[R1, #+0]
    387          
    388                    pScuRoMapReg->scuMapRegNotify.ntfPresences = (uint32_t)0;
   \       0xCE   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0xD2   0x2100             MOVS     R1,#+0
   \       0xD4   0xF8C0 0x10F6      STR      R1,[R0, #+246]
    389                    /* socketPresence structure has been read already in eeprom_read_all() Nick 24/06/2024 */
    390                    if ((socketPresence.matrixConv[0] != 1) || (socketPresence.matrixIdConn[0] != 1) || (socketPresence.matrixIdConn[15] == 0xFF))
   \       0xD8   0xF8DF 0xBC98      LDR.W    R11,??sbcSemMsgProcess_1+8
   \       0xDC   0xF89B 0x0010      LDRB     R0,[R11, #+16]
   \       0xE0   0x2801             CMP      R0,#+1
   \       0xE2   0xD107             BNE.N    ??sbcSemMsgProcess_24
   \       0xE4   0xF89B 0x0030      LDRB     R0,[R11, #+48]
   \       0xE8   0x2801             CMP      R0,#+1
   \       0xEA   0xD103             BNE.N    ??sbcSemMsgProcess_24
   \       0xEC   0xF89B 0x003F      LDRB     R0,[R11, #+63]
   \       0xF0   0x28FF             CMP      R0,#+255
   \       0xF2   0xD133             BNE.N    ??sbcSemMsgProcess_25
    391                    {
    392                      /* put in the matrix the default config */
    393                      if (socketPresence.matrixConv[0] != 1)
   \                     ??sbcSemMsgProcess_24: (+1)
   \       0xF4   0xF89B 0x0010      LDRB     R0,[R11, #+16]
   \       0xF8   0x2801             CMP      R0,#+1
   \       0xFA   0xD00D             BEQ.N    ??sbcSemMsgProcess_26
    394                      {
    395                        /*      destination                                         source                       length */
    396                        memcpy((uint8_t *)&socketPresence.matrixConv, (uint8_t *)&Default_Socket_Presence.matrixConv, (size_t)SCU_NUM);
   \       0xFC   0x2010             MOVS     R0,#+16
   \       0xFE   0x9006             STR      R0,[SP, #+24]
   \      0x100   0xF8DF 0x0C74      LDR.W    R0,??sbcSemMsgProcess_1+12
   \      0x104   0x9001             STR      R0,[SP, #+4]
   \      0x106   0xF11B 0x0010      ADDS     R0,R11,#+16
   \      0x10A   0x9000             STR      R0,[SP, #+0]
   \      0x10C   0x9A06             LDR      R2,[SP, #+24]
   \      0x10E   0x9901             LDR      R1,[SP, #+4]
   \      0x110   0x9800             LDR      R0,[SP, #+0]
   \      0x112   0x.... 0x....      BL       __aeabi_memcpy
   \      0x116   0x9800             LDR      R0,[SP, #+0]
    397                      }
    398                      if ((socketPresence.matrixIdConn[0] != 1) || (socketPresence.matrixIdConn[15] == 0xFF))
   \                     ??sbcSemMsgProcess_26: (+1)
   \      0x118   0xF89B 0x0030      LDRB     R0,[R11, #+48]
   \      0x11C   0x2801             CMP      R0,#+1
   \      0x11E   0xD103             BNE.N    ??sbcSemMsgProcess_27
   \      0x120   0xF89B 0x003F      LDRB     R0,[R11, #+63]
   \      0x124   0x28FF             CMP      R0,#+255
   \      0x126   0xD10D             BNE.N    ??sbcSemMsgProcess_28
    399                      {
    400                        /*      destination                                         source                       length */
    401                        memcpy((uint8_t *)&socketPresence.matrixIdConn, (uint8_t *)&Default_Socket_Presence.matrixIdConn, (size_t)SCU_NUM);
   \                     ??sbcSemMsgProcess_27: (+1)
   \      0x128   0x2010             MOVS     R0,#+16
   \      0x12A   0x9006             STR      R0,[SP, #+24]
   \      0x12C   0xF8DF 0x0C4C      LDR.W    R0,??sbcSemMsgProcess_1+16
   \      0x130   0x9001             STR      R0,[SP, #+4]
   \      0x132   0xF11B 0x0030      ADDS     R0,R11,#+48
   \      0x136   0x9000             STR      R0,[SP, #+0]
   \      0x138   0x9A06             LDR      R2,[SP, #+24]
   \      0x13A   0x9901             LDR      R1,[SP, #+4]
   \      0x13C   0x9800             LDR      R0,[SP, #+0]
   \      0x13E   0x.... 0x....      BL       __aeabi_memcpy
   \      0x142   0x9800             LDR      R0,[SP, #+0]
    402                      }
    403                      if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \                     ??sbcSemMsgProcess_28: (+1)
   \      0x144   0x2254             MOVS     R2,#+84
   \      0x146   0x4659             MOV      R1,R11
   \      0x148   0xF44F 0x50F4      MOV      R0,#+7808
   \      0x14C   0x.... 0x....      BL       WriteOnEeprom
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD103             BNE.N    ??sbcSemMsgProcess_25
    404                      {
    405                        tPrintf("Matrix Initializated\n\r");
   \      0x154   0xF8DF 0x0C28      LDR.W    R0,??sbcSemMsgProcess_1+20
   \      0x158   0x.... 0x....      BL       tPrintf
    406                      }
    407                    }
    408                    setDevAlias();  /* set the number on LCD in according with matrix */
   \                     ??sbcSemMsgProcess_25: (+1)
   \      0x15C   0x.... 0x....      BL       setDevAlias
    409                    socketPresence.livePresence = socketPresence.activityStatus = sbcSemInfoMng.offLine = sbcSemInfoMng.sbcActive = 0;
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0xF88A 0x0028      STRB     R0,[R10, #+40]
   \      0x166   0xF88A 0x0027      STRB     R0,[R10, #+39]
   \      0x16A   0xB2C0             UXTB     R0,R0
   \      0x16C   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \      0x170   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \      0x174   0xF8CB 0x0004      STR      R0,[R11, #+4]
    410                    if (isSemMasterFz() == TRUE)
   \      0x178   0x.... 0x....      BL       isSemMasterFz
   \      0x17C   0x2801             CMP      R0,#+1
   \      0x17E   0xD148             BNE.N    ??sbcSemMsgProcess_29
    411                    {
    412                      socketPresence.assignedDeviceId |= (uint32_t)0x01; // the first device Id is reserverd for SCU  master Principale  
   \      0x180   0xF8DB 0x0050      LDR      R0,[R11, #+80]
   \      0x184   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x188   0xF8CB 0x0050      STR      R0,[R11, #+80]
    413                      socketPresence.livePresence |= (uint32_t)0x01;  /* the master, bit 0, address 1 is always present*/
   \      0x18C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0x190   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x194   0xF8CB 0x0004      STR      R0,[R11, #+4]
    414                      socketPresence.chainPresence |= (uint32_t)0x01; /* the master, bit 0, address 1 is always present*/
   \      0x198   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x19C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x1A0   0xF8CB 0x0000      STR      R0,[R11, #+0]
    415                      setInfoEepromSlaveDone((uint16_t)socketPresence.chainPresence);
   \      0x1A4   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x1A8   0xB280             UXTH     R0,R0
   \      0x1AA   0x.... 0x....      BL       setInfoEepromSlaveDone
    416                      switch (socketPresence.keyPresence)
   \      0x1AE   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \      0x1B2   0xF64A 0x2155      MOVW     R1,#+43605
   \      0x1B6   0x4288             CMP      R0,R1
   \      0x1B8   0xD004             BEQ.N    ??sbcSemMsgProcess_30
   \      0x1BA   0xF64B 0x3166      MOVW     R1,#+47974
   \      0x1BE   0x4288             CMP      R0,R1
   \      0x1C0   0xD009             BEQ.N    ??sbcSemMsgProcess_31
   \      0x1C2   0xE014             B.N      ??sbcSemMsgProcess_32
    417                      {
    418                        case KEY_FULL_CONFIG:
    419          
    420                          // wait 5 sec before master starts with discovery procedure
    421                          restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_START_DISCOVERY);
   \                     ??sbcSemMsgProcess_30: (+1)
   \      0x1C4   0xF242 0x7110      MOVW     R1,#+10000
   \      0x1C8   0x2000             MOVS     R0,#+0
   \      0x1CA   0x.... 0x....      BL       restartSbcSemTimer
    422                         /* master starts discovery phase cheking the presence of secondary master SCU using broadcast address  */
    423                          sbcSemInfoMng.sbcSemStates = SBC_SEM_INIT_DISCOVERY;
   \      0x1CE   0x2000             MOVS     R0,#+0
   \      0x1D0   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    424                          break;
   \      0x1D4   0xE03F             B.N      ??sbcSemMsgProcess_33
    425          
    426                        case KEY_LOCAL_CONFIG:
    427                          sbcSemInfoMng.firstIdFree = 3;  // first address available for master and slave. Bit 0 = addr 1 is reserved primary master Bit 1 = addr 2 for linked slave
   \                     ??sbcSemMsgProcess_31: (+1)
   \      0x1D6   0x2003             MOVS     R0,#+3
   \      0x1D8   0xF8AA 0x0002      STRH     R0,[R10, #+2]
    428                          // wait 100m sec before master starts with discovery procedure
    429                          restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_START_DISCOVERY);
   \      0x1DC   0xF242 0x7110      MOVW     R1,#+10000
   \      0x1E0   0x2000             MOVS     R0,#+0
   \      0x1E2   0x.... 0x....      BL       restartSbcSemTimer
    430                         /* master starts discovery phase cheking the presence of secondary master SCU using broadcast address  */
    431                          sbcSemInfoMng.sbcSemStates = SBC_SEM_INIT_DISCOVERY;
   \      0x1E6   0x2000             MOVS     R0,#+0
   \      0x1E8   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    432                          break;
   \      0x1EC   0xE033             B.N      ??sbcSemMsgProcess_33
    433          
    434                        default:
    435                          
    436                          /* If socket presence structure is not programmed --> in some fw version (< 4.3.2o),
    437                             these informations are in eeprom in another location (0x1F60)*/
    438                          if (is_socketPresence_Programmed() == FALSE)
   \                     ??sbcSemMsgProcess_32: (+1)
   \      0x1EE   0x.... 0x....      BL       is_socketPresence_Programmed
   \      0x1F2   0x2800             CMP      R0,#+0
   \      0x1F4   0xD10C             BNE.N    ??sbcSemMsgProcess_34
    439                              if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&Default_Socket_Presence, sizeof(socketPresence_t)) == osOK)
   \      0x1F6   0x2254             MOVS     R2,#+84
   \      0x1F8   0xF8DF 0x1B88      LDR.W    R1,??sbcSemMsgProcess_1+24
   \      0x1FC   0xF44F 0x50F4      MOV      R0,#+7808
   \      0x200   0x.... 0x....      BL       WriteOnEeprom
   \      0x204   0x2800             CMP      R0,#+0
   \      0x206   0xD103             BNE.N    ??sbcSemMsgProcess_34
    440                                tPrintf("Socket presence informations programmed to default \n\r");
   \      0x208   0xF8DF 0x0CFC      LDR.W    R0,??sbcSemMsgProcess_2
   \      0x20C   0x.... 0x....      BL       tPrintf
    441          
    442                          break;
   \                     ??sbcSemMsgProcess_34: (+1)
   \      0x210   0xE021             B.N      ??sbcSemMsgProcess_33
    443                      }          
    444                    }
    445                    else
    446                    {
    447                      if (getScuAddressTypeMode() == SCU_FIXED_ADDR)
   \                     ??sbcSemMsgProcess_29: (+1)
   \      0x212   0x.... 0x....      BL       getScuAddressTypeMode
   \      0x216   0x2801             CMP      R0,#+1
   \      0x218   0xD116             BNE.N    ??sbcSemMsgProcess_35
    448                      {
    449                        /* Fixed address on RS485: just wait 3 sec before entering in operative mode That avoid to send info to Master during power-up phase*/
    450                        restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_OPERATING_STATE);
   \      0x21A   0xF640 0x31B8      MOVW     R1,#+3000
   \      0x21E   0x2000             MOVS     R0,#+0
   \      0x220   0x.... 0x....      BL       restartSbcSemTimer
    451                        /* the slave has been already configured */
    452                        socketPresence.keyPresence = KEY_FULL_CONFIG;
   \      0x224   0xF64A 0x2055      MOVW     R0,#+43605
   \      0x228   0xF8CB 0x0008      STR      R0,[R11, #+8]
    453                        sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_BE_OPERATIVE;
   \      0x22C   0x200C             MOVS     R0,#+12
   \      0x22E   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    454          
    455                        /* starts the task to manager suspend / release function   */
    456                        remoteMngTaskHandle = osThreadNew(remoteMngTask, NULL, &remoteMngTask_attributes);  
   \      0x232   0xF8DF 0x2CD8      LDR.W    R2,??sbcSemMsgProcess_2+4
   \      0x236   0x2100             MOVS     R1,#+0
   \      0x238   0xF8DF 0x0CD4      LDR.W    R0,??sbcSemMsgProcess_2+8
   \      0x23C   0x.... 0x....      BL       osThreadNew
   \      0x240   0xF8DF 0x1CD0      LDR.W    R1,??sbcSemMsgProcess_2+12
   \      0x244   0x6008             STR      R0,[R1, #+0]
   \      0x246   0xE006             B.N      ??sbcSemMsgProcess_33
    457                      }
    458                      else
    459                      {
    460                        sbcSemInfoMng.random = NULL_RANDOM;
   \                     ??sbcSemMsgProcess_35: (+1)
   \      0x248   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x24C   0xF8CA 0x001C      STR      R0,[R10, #+28]
    461                        /* the slave SCU was not registered from the master so its modbus address it is virtual */
    462                        sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_REGISTER;
   \      0x250   0x2009             MOVS     R0,#+9
   \      0x252   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    463                      }
    464                    }
    465                    break;
   \                     ??sbcSemMsgProcess_33: (+1)
   \      0x256   0xE009             B.N      ??sbcSemMsgProcess_36
    466          
    467                  case NOTIFY_TO_MASTER_TX:
    468                    /* save the message for future use  */
    469                    headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_21: (+1)
   \      0x258   0xF8DF 0xA854      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x25C   0x0021             MOVS     R1,R4
   \      0x25E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x262   0x.... 0x....      BL       addNode
   \      0x266   0xF8CA 0x0000      STR      R0,[R10, #+0]
    470                    break;
   \      0x26A   0xE7FF             B.N      ??sbcSemMsgProcess_36
    471          
    472                  default:
    473                    break;
    474                }
    475                break;
   \                     ??sbcSemMsgProcess_22: (+1)
   \                     ??sbcSemMsgProcess_36: (+1)
   \      0x26C   0xF000 0xBF2C      B.W      ??sbcSemMsgProcess_37
    476          
    477              case SBC_SEM_WAIT_TO_REGISTER:
    478                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_15: (+1)
   \      0x270   0x8820             LDRH     R0,[R4, #+0]
   \      0x272   0x2800             CMP      R0,#+0
   \      0x274   0xD004             BEQ.N    ??sbcSemMsgProcess_38
   \      0x276   0x2802             CMP      R0,#+2
   \      0x278   0xD04B             BEQ.N    ??sbcSemMsgProcess_39
   \      0x27A   0x2808             CMP      R0,#+8
   \      0x27C   0xD016             BEQ.N    ??sbcSemMsgProcess_40
   \      0x27E   0xE051             B.N      ??sbcSemMsgProcess_41
    479                {
    480                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    481                    /* a master start the addressing procedure  */
    482                    if (ixScu == MODBUS_BROADCAST_ADDR)
   \                     ??sbcSemMsgProcess_38: (+1)
   \      0x280   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0x284   0x2800             CMP      R0,#+0
   \      0x286   0xD105             BNE.N    ??sbcSemMsgProcess_42
    483                    {
    484                      sbcSemInfoMng.sbcSemStates = checkToSendReqAddress(pMsg);
   \      0x288   0x0020             MOVS     R0,R4
   \      0x28A   0x.... 0x....      BL       checkToSendReqAddress
   \      0x28E   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \      0x292   0xE00A             B.N      ??sbcSemMsgProcess_43
    485                    }
    486                    else
    487                    {
    488                      if (pMsg->data.rAddr == ADDR_ADDR_S_CONN_RW)
   \                     ??sbcSemMsgProcess_42: (+1)
   \      0x294   0x88A0             LDRH     R0,[R4, #+4]
   \      0x296   0xF240 0x5113      MOVW     R1,#+1299
   \      0x29A   0x4288             CMP      R0,R1
   \      0x29C   0xD105             BNE.N    ??sbcSemMsgProcess_43
    489                      {          
    490                        /* another slave request the address:  restart random delay */
    491                        restartSbcSemTimer(TIMER_FOR_REQ_ADDR, (uint32_t)(sbcSemInfoMng.random / FACTOR_FOR_RANDOM_DELAY));
   \      0x29E   0xF8DA 0x101C      LDR      R1,[R10, #+28]
   \      0x2A2   0x0989             LSRS     R1,R1,#+6
   \      0x2A4   0x2004             MOVS     R0,#+4
   \      0x2A6   0x.... 0x....      BL       restartSbcSemTimer
    492                      }
    493                    }
    494                    break;
   \                     ??sbcSemMsgProcess_43: (+1)
   \      0x2AA   0xE03B             B.N      ??sbcSemMsgProcess_44
    495          
    496                  case NOTIFY_MODBUS_WR_ACK:
    497                    if ((pMsg->data.index == currFrameSbcSem.data.index) &&         // phisical address 1...16 
    498                        (sbcSemInfoMng.random == (uint32_t)sbcSemInfoMng.dataVal))  // it is the ACK referred at our transmssion 
   \                     ??sbcSemMsgProcess_40: (+1)
   \      0x2AC   0xF8DF 0xBCC4      LDR.W    R11,??sbcSemMsgProcess_3
   \      0x2B0   0x8860             LDRH     R0,[R4, #+2]
   \      0x2B2   0xF8BB 0x1002      LDRH     R1,[R11, #+2]
   \      0x2B6   0x4288             CMP      R0,R1
   \      0x2B8   0xD12A             BNE.N    ??sbcSemMsgProcess_45
   \      0x2BA   0xF8DA 0x001C      LDR      R0,[R10, #+28]
   \      0x2BE   0xF8BA 0x1004      LDRH     R1,[R10, #+4]
   \      0x2C2   0x4288             CMP      R0,R1
   \      0x2C4   0xD124             BNE.N    ??sbcSemMsgProcess_45
    499                    {
    500                      /* release the transmitter */
    501                      currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0x2C6   0x2005             MOVS     R0,#+5
   \      0x2C8   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    502                      configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x2CC   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x2D0   0x2300             MOVS     R3,#+0
   \      0x2D2   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x2D6   0x4659             MOV      R1,R11
   \      0x2D8   0x.... 0x....      BL       xQueueGenericSend
   \      0x2DC   0x2801             CMP      R0,#+1
   \      0x2DE   0xD009             BEQ.N    ??sbcSemMsgProcess_46
   \      0x2E0   0xB672             CPSID    I
   \      0x2E2   0x2050             MOVS     R0,#+80
   \      0x2E4   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x2E8   0xF3BF 0x8F4F      DSB      SY
   \      0x2EC   0xF3BF 0x8F6F      ISB      SY
   \      0x2F0   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_47: (+1)
   \      0x2F2   0xE7FE             B.N      ??sbcSemMsgProcess_47
    503                      /* stop ACK gard  timer */
    504                      xTimerStop(xSbcSemTimers[TIMER_FOR_ACK], SBCSEM_TIMER_GARD_TIME);
   \                     ??sbcSemMsgProcess_46: (+1)
   \      0x2F4   0xF44F 0x70FA      MOV      R0,#+500
   \      0x2F8   0x9000             STR      R0,[SP, #+0]
   \      0x2FA   0x2300             MOVS     R3,#+0
   \      0x2FC   0x2200             MOVS     R2,#+0
   \      0x2FE   0x2103             MOVS     R1,#+3
   \      0x300   0xF8DF 0x07A4      LDR.W    R0,??sbcSemMsgProcess_0
   \      0x304   0x6840             LDR      R0,[R0, #+4]
   \      0x306   0x.... 0x....      BL       xTimerGenericCommand
    505                      /* the slave SCU wait for address */
    506                      sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_RS485_ADDR; 
   \      0x30A   0x200A             MOVS     R0,#+10
   \      0x30C   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    507                    }
    508                    break;
   \                     ??sbcSemMsgProcess_45: (+1)
   \      0x310   0xE008             B.N      ??sbcSemMsgProcess_44
    509          
    510                  case NOTIFY_TO_MASTER_TX:
    511                    if (pMsg->data.rAddr == ADDR_TM_EVSE_READY_RO)  // 0x512 Testing machine starts test
   \                     ??sbcSemMsgProcess_39: (+1)
   \      0x312   0x88A0             LDRH     R0,[R4, #+4]
   \      0x314   0xF240 0x5112      MOVW     R1,#+1298
   \      0x318   0x4288             CMP      R0,R1
   \      0x31A   0xD102             BNE.N    ??sbcSemMsgProcess_48
    512                    {
    513                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE_COLLAUDO;
   \      0x31C   0x200E             MOVS     R0,#+14
   \      0x31E   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    514                    }
    515                    break;
   \                     ??sbcSemMsgProcess_48: (+1)
   \      0x322   0xE7FF             B.N      ??sbcSemMsgProcess_44
    516          
    517                  default:
    518                    /* Message or ACK from other skave are discarded */
    519                    break;
    520                }
    521                break;
   \                     ??sbcSemMsgProcess_41: (+1)
   \                     ??sbcSemMsgProcess_44: (+1)
   \      0x324   0xF000 0xBED0      B.W      ??sbcSemMsgProcess_37
    522          
    523              case SBC_SEM_WAIT_RS485_ADDR:
    524                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_16: (+1)
   \      0x328   0x8820             LDRH     R0,[R4, #+0]
   \      0x32A   0x2800             CMP      R0,#+0
   \      0x32C   0xD007             BEQ.N    ??sbcSemMsgProcess_49
   \      0x32E   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x332   0x4288             CMP      R0,R1
   \      0x334   0xD129             BNE.N    ??sbcSemMsgProcess_50
    525                {
    526                  case SBC_SEM_TIMEOUT:
    527                    /* address not received wait for next tentative */
    528                    sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_REGISTER; 
   \                     ??sbcSemMsgProcess_51: (+1)
   \      0x336   0x2009             MOVS     R0,#+9
   \      0x338   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    529                    break;
   \      0x33C   0xE025             B.N      ??sbcSemMsgProcess_52
    530          
    531                  case SBC_SEM_EVENT_RS485: 
    532                    /* a master ended the addressing procedure  */
    533                    if (ixScu == MODBUS_BROADCAST_ADDR)
   \                     ??sbcSemMsgProcess_49: (+1)
   \      0x33E   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0x342   0x2800             CMP      R0,#+0
   \      0x344   0xD120             BNE.N    ??sbcSemMsgProcess_53
    534                    {
    535                      result = checkAssignNewAddress(pMsg);
   \      0x346   0x0020             MOVS     R0,R4
   \      0x348   0x.... 0x....      BL       checkAssignNewAddress
   \      0x34C   0x4680             MOV      R8,R0
    536                      if (result == 0)
   \      0x34E   0x4640             MOV      R0,R8
   \      0x350   0xB2C0             UXTB     R0,R0
   \      0x352   0x2800             CMP      R0,#+0
   \      0x354   0xD111             BNE.N    ??sbcSemMsgProcess_54
    537                      {
    538                        if (setScuAddressTypeMode(SCU_FIXED_ADDR) == 0) // try to set the flag to confirm adrress fixed 
   \      0x356   0x2001             MOVS     R0,#+1
   \      0x358   0x.... 0x....      BL       setScuAddressTypeMode
   \      0x35C   0x2800             CMP      R0,#+0
   \      0x35E   0xD108             BNE.N    ??sbcSemMsgProcess_55
    539                        {
    540                          setParamFromAssignedAddr();     // set status, ... before master read info parameters
   \      0x360   0x.... 0x....      BL       setParamFromAssignedAddr
    541                          /* Blank state: to avoid transmission while other SCU are on going phase assignement address  */
    542                          sbcSemInfoMng.sbcSemStates = SBC_SEM_BLANK_AFTER_ASS_ADDR;
   \      0x364   0x200F             MOVS     R0,#+15
   \      0x366   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    543                          /* timeout 100ms for receive address  */
    544                          timeTickTmp = pdMS_TO_TICKS(WAIT_TO_OPERATIVE_POST_ASS_ADDR);  
   \      0x36A   0xF241 0x3088      MOVW     R0,#+5000
   \      0x36E   0x0007             MOVS     R7,R0
   \      0x370   0xE00A             B.N      ??sbcSemMsgProcess_53
    545                        }
    546                        else
    547                        {
    548                          sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_REGISTER;              
   \                     ??sbcSemMsgProcess_55: (+1)
   \      0x372   0x2009             MOVS     R0,#+9
   \      0x374   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \      0x378   0xE006             B.N      ??sbcSemMsgProcess_53
    549                        }
    550                      }
    551                      else
    552                      {
    553                        if (result == 1) sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_REGISTER;
   \                     ??sbcSemMsgProcess_54: (+1)
   \      0x37A   0x4640             MOV      R0,R8
   \      0x37C   0xB2C0             UXTB     R0,R0
   \      0x37E   0x2801             CMP      R0,#+1
   \      0x380   0xD102             BNE.N    ??sbcSemMsgProcess_53
   \      0x382   0x2009             MOVS     R0,#+9
   \      0x384   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    554                      }
    555                    }
    556                    break;
   \                     ??sbcSemMsgProcess_53: (+1)
   \      0x388   0xE7FF             B.N      ??sbcSemMsgProcess_52
    557          
    558                  default:
    559                    break;
    560                }
    561                break;
   \                     ??sbcSemMsgProcess_50: (+1)
   \                     ??sbcSemMsgProcess_52: (+1)
   \      0x38A   0xF000 0xBE9D      B.W      ??sbcSemMsgProcess_37
    562          
    563              case SBC_SEM_BLANK_AFTER_ASS_ADDR:
    564                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_19: (+1)
   \      0x38E   0x8820             LDRH     R0,[R4, #+0]
   \      0x390   0x4558             CMP      R0,R11
   \      0x392   0xD116             BNE.N    ??sbcSemMsgProcess_56
    565                {
    566                  case SBC_SEM_TIMEOUT:
    567                    sendMonMngMsg(MON_SEM_TASK, MON_START);      // activation task for monitor  
   \      0x394   0x2100             MOVS     R1,#+0
   \      0x396   0x2001             MOVS     R0,#+1
   \      0x398   0x.... 0x....      BL       sendMonMngMsg
    568                    /* starts the task to manager suspend / release function   */
    569                    remoteMngTaskHandle = osThreadNew(remoteMngTask, NULL, &remoteMngTask_attributes);  
   \      0x39C   0xF8DF 0x2B6C      LDR.W    R2,??sbcSemMsgProcess_2+4
   \      0x3A0   0x2100             MOVS     R1,#+0
   \      0x3A2   0xF8DF 0x0B6C      LDR.W    R0,??sbcSemMsgProcess_2+8
   \      0x3A6   0x.... 0x....      BL       osThreadNew
   \      0x3AA   0xF8DF 0x1B68      LDR.W    R1,??sbcSemMsgProcess_2+12
   \      0x3AE   0x6008             STR      R0,[R1, #+0]
    570                    semSlaveSendActEnrg();                       // ask to send master active energy value 
   \      0x3B0   0x.... 0x....      BL       semSlaveSendActEnrg
    571                    /* now wait a request info from master */
    572                    sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \      0x3B4   0x2004             MOVS     R0,#+4
   \      0x3B6   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    573                    timeTickTmp = portMAX_DELAY;
   \      0x3BA   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x3BE   0x0007             MOVS     R7,R0
    574                    break;
   \      0x3C0   0xE7FF             B.N      ??sbcSemMsgProcess_57
    575          
    576                  default:
    577                    break;
    578                }
    579                break;
   \                     ??sbcSemMsgProcess_56: (+1)
   \                     ??sbcSemMsgProcess_57: (+1)
   \      0x3C2   0xF000 0xBE81      B.W      ??sbcSemMsgProcess_37
    580          
    581          
    582              case SBC_SEM_INIT_DISCOVERY:
    583                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_7: (+1)
   \      0x3C6   0x8820             LDRH     R0,[R4, #+0]
   \      0x3C8   0x2800             CMP      R0,#+0
   \      0x3CA   0xD001             BEQ.N    ??sbcSemMsgProcess_58
   \      0x3CC   0x2802             CMP      R0,#+2
   \      0x3CE   0xD109             BNE.N    ??sbcSemMsgProcess_59
    584                {
    585                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    586                  case NOTIFY_TO_MASTER_TX:
    587                    /* save the message for future use  */
    588                    headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_58: (+1)
   \      0x3D0   0xF8DF 0xA6DC      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x3D4   0x0021             MOVS     R1,R4
   \      0x3D6   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x3DA   0x.... 0x....      BL       addNode
   \      0x3DE   0xF8CA 0x0000      STR      R0,[R10, #+0]
    589                    break;
   \      0x3E2   0xE7FF             B.N      ??sbcSemMsgProcess_60
    590          
    591                  default:
    592                    break;
    593                }
    594                break;
   \                     ??sbcSemMsgProcess_59: (+1)
   \                     ??sbcSemMsgProcess_60: (+1)
   \      0x3E4   0xF000 0xBE70      B.W      ??sbcSemMsgProcess_37
    595          
    596              case SBC_SEM_DISCOVERY_S:
    597                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_8: (+1)
   \      0x3E8   0x8820             LDRH     R0,[R4, #+0]
   \      0x3EA   0x2800             CMP      R0,#+0
   \      0x3EC   0xD008             BEQ.N    ??sbcSemMsgProcess_61
   \      0x3EE   0x2802             CMP      R0,#+2
   \      0x3F0   0xD02B             BEQ.N    ??sbcSemMsgProcess_62
   \      0x3F2   0x280A             CMP      R0,#+10
   \      0x3F4   0xD028             BEQ.N    ??sbcSemMsgProcess_63
   \      0x3F6   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x3FA   0x4288             CMP      R0,R1
   \      0x3FC   0xD12F             BNE.N    ??sbcSemMsgProcess_64
    598                {
    599                  case SBC_SEM_TIMEOUT:
    600          
    601                    break;
   \                     ??sbcSemMsgProcess_65: (+1)
   \      0x3FE   0xE02E             B.N      ??sbcSemMsgProcess_66
    602          
    603                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    604                    if ((pMsg->data.rAddr == ADDR_CONNECTOR_IDS_RW)  || (pMsg->data.rAddr == ADDR_EVSE_TM_RW))// 0x0004 or 0x0022
   \                     ??sbcSemMsgProcess_61: (+1)
   \      0x400   0x88A0             LDRH     R0,[R4, #+4]
   \      0x402   0x2804             CMP      R0,#+4
   \      0x404   0xD002             BEQ.N    ??sbcSemMsgProcess_67
   \      0x406   0x88A0             LDRH     R0,[R4, #+4]
   \      0x408   0x2822             CMP      R0,#+34
   \      0x40A   0xD10A             BNE.N    ??sbcSemMsgProcess_68
    605                    {
    606                      /* this is a slave answer where the address has been assigned already */
    607                      socketPresence.livePresence |= maskBit;
   \                     ??sbcSemMsgProcess_67: (+1)
   \      0x40C   0xF8DF 0x0964      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x410   0x6841             LDR      R1,[R0, #+4]
   \      0x412   0x4331             ORRS     R1,R6,R1
   \      0x414   0x6041             STR      R1,[R0, #+4]
    608                      restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_DISCOVERY_SLAVE); // the master restart the timeout
   \      0x416   0xF44F 0x717A      MOV      R1,#+1000
   \      0x41A   0x2000             MOVS     R0,#+0
   \      0x41C   0x.... 0x....      BL       restartSbcSemTimer
   \      0x420   0xE011             B.N      ??sbcSemMsgProcess_69
    609                    }
    610                    else
    611                    {
    612                      if (pMsg->data.rAddr == ADDR_ADDR_S_CONN_RW)
   \                     ??sbcSemMsgProcess_68: (+1)
   \      0x422   0x88A0             LDRH     R0,[R4, #+4]
   \      0x424   0xF240 0x5113      MOVW     R1,#+1299
   \      0x428   0x4288             CMP      R0,R1
   \      0x42A   0xD103             BNE.N    ??sbcSemMsgProcess_70
    613                      {
    614                        mngReqAddress(pMsg);
   \      0x42C   0x0020             MOVS     R0,R4
   \      0x42E   0x.... 0x....      BL       mngReqAddress
   \      0x432   0xE008             B.N      ??sbcSemMsgProcess_69
    615                      }
    616                      else
    617                      {
    618                        /* save the message for future use  */
    619                        headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_70: (+1)
   \      0x434   0xF8DF 0xA678      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x438   0x0021             MOVS     R1,R4
   \      0x43A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x43E   0x.... 0x....      BL       addNode
   \      0x442   0xF8CA 0x0000      STR      R0,[R10, #+0]
    620                      }
    621                    }
    622                    break;
   \                     ??sbcSemMsgProcess_69: (+1)
   \      0x446   0xE00A             B.N      ??sbcSemMsgProcess_66
    623          
    624                  case SCU_EVENT_MSG_FROM_SBC_RD:
    625                    break;
   \                     ??sbcSemMsgProcess_63: (+1)
   \      0x448   0xE009             B.N      ??sbcSemMsgProcess_66
    626          
    627                  case NOTIFY_TO_MASTER_TX:
    628                    /* save the message for future use  */
    629                    headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_62: (+1)
   \      0x44A   0xF8DF 0xA664      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x44E   0x0021             MOVS     R1,R4
   \      0x450   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x454   0x.... 0x....      BL       addNode
   \      0x458   0xF8CA 0x0000      STR      R0,[R10, #+0]
    630                    break;
   \      0x45C   0xE7FF             B.N      ??sbcSemMsgProcess_66
    631          
    632                  default:
    633                    break;
    634                }
    635                break;
   \                     ??sbcSemMsgProcess_64: (+1)
   \                     ??sbcSemMsgProcess_66: (+1)
   \      0x45E   0xF000 0xBE33      B.W      ??sbcSemMsgProcess_37
    636          
    637              case SBC_SEM_RECOVERY_INFO:
    638                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_9: (+1)
   \      0x462   0x8820             LDRH     R0,[R4, #+0]
   \      0x464   0x2802             CMP      R0,#+2
   \      0x466   0xF000 0x8083      BEQ.W    ??sbcSemMsgProcess_71
   \      0x46A   0x2804             CMP      R0,#+4
   \      0x46C   0xD004             BEQ.N    ??sbcSemMsgProcess_72
   \      0x46E   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x472   0x4288             CMP      R0,R1
   \      0x474   0xF040 0x8086      BNE.W    ??sbcSemMsgProcess_73
    639                {
    640                  case SBC_SEM_TIMEOUT:
    641                  case RECOVERY_INFO:
    642                    while (txRS485Available() == (uint8_t)FALSE) osDelay(100);
   \                     ??sbcSemMsgProcess_72: (+1)
   \      0x478   0x.... 0x....      BL       txRS485Available
   \      0x47C   0x2800             CMP      R0,#+0
   \      0x47E   0xD103             BNE.N    ??sbcSemMsgProcess_74
   \      0x480   0x2064             MOVS     R0,#+100
   \      0x482   0x.... 0x....      BL       osDelay
   \      0x486   0xE7F7             B.N      ??sbcSemMsgProcess_72
    643                    if (getInfoSocket(sbcSemInfoMng.activityStatus, &sbcSemInfoMng) == FALSE)
   \                     ??sbcSemMsgProcess_74: (+1)
   \      0x488   0xF8DF 0xA620      LDR.W    R10,??sbcSemMsgProcess_0+4
   \      0x48C   0x4651             MOV      R1,R10
   \      0x48E   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0x492   0x.... 0x....      BL       getInfoSocket
   \      0x496   0x2800             CMP      R0,#+0
   \      0x498   0xD163             BNE.N    ??sbcSemMsgProcess_75
    644                    {
    645                      setCurrentDateTimeInSem();
   \      0x49A   0x.... 0x....      BL       setCurrentDateTimeInSem
    646                      /* all the socket has been discovered */
    647                      if (socketPresence.livePresence > socketPresence.chainPresence)
   \      0x49E   0xF8DF 0xB8D4      LDR.W    R11,??sbcSemMsgProcess_1+8
   \      0x4A2   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x4A6   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \      0x4AA   0x4288             CMP      R0,R1
   \      0x4AC   0xD203             BCS.N    ??sbcSemMsgProcess_76
    648                      {
    649                        socketPresence.chainPresence = socketPresence.livePresence;
   \      0x4AE   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0x4B2   0xF8CB 0x0000      STR      R0,[R11, #+0]
    650                      }
    651                      sbcSemInfoMng.activeLastDiscovery = socketPresence.livePresence;
   \                     ??sbcSemMsgProcess_76: (+1)
   \      0x4B6   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0x4BA   0xF8CA 0x0020      STR      R0,[R10, #+32]
    652                      /* save in EEPROM also  */
    653                      if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \      0x4BE   0x2254             MOVS     R2,#+84
   \      0x4C0   0x4659             MOV      R1,R11
   \      0x4C2   0xF44F 0x50F4      MOV      R0,#+7808
   \      0x4C6   0x.... 0x....      BL       WriteOnEeprom
   \      0x4CA   0x2800             CMP      R0,#+0
   \      0x4CC   0xD105             BNE.N    ??sbcSemMsgProcess_77
    654                      {
    655                        tPrintf("Presences detected at reset --> 0x%x\n\r", socketPresence.livePresence);
   \      0x4CE   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \      0x4D2   0x.... 0x....      LDR.W    R0,??DataTable4
   \      0x4D6   0x.... 0x....      BL       tPrintf
    656                      }
    657          
    658                      timeTickTmp = portMAX_DELAY;
   \                     ??sbcSemMsgProcess_77: (+1)
   \      0x4DA   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x4DE   0x0007             MOVS     R7,R0
    659                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \      0x4E0   0x2004             MOVS     R0,#+4
   \      0x4E2   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    660          
    661                      forceSBCreadScu(sbcSemInfoMng.activityStatus);
   \      0x4E6   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0x4EA   0x.... 0x....      BL       forceSBCreadScu
    662          
    663                      sbcSemInfoMng.pollingFlag = (uint16_t)ENABLED;
   \      0x4EE   0x2001             MOVS     R0,#+1
   \      0x4F0   0xF8AA 0x001A      STRH     R0,[R10, #+26]
    664                      /* the alive task must be started to check slave connection periodically  */
    665                      pollingSlaveTaskHandle = osThreadNew(pollingSlaveTask, NULL, &pollingSlaveTask_attributes);  
   \      0x4F4   0x.... 0x....      LDR.W    R2,??DataTable4_1
   \      0x4F8   0x2100             MOVS     R1,#+0
   \      0x4FA   0x.... 0x....      LDR.W    R0,??DataTable4_2
   \      0x4FE   0x.... 0x....      BL       osThreadNew
   \      0x502   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \      0x506   0x6008             STR      R0,[R1, #+0]
    666                      Print_Slave_FW_Version();
   \      0x508   0x.... 0x....      BL       Print_Slave_FW_Version
    667                      if (getScuOpMode() != SCU_M_STAND_ALONE)
   \      0x50C   0x.... 0x....      BL       getScuOpMode
   \      0x510   0x2805             CMP      R0,#+5
   \      0x512   0xD009             BEQ.N    ??sbcSemMsgProcess_78
    668                      {
    669                        /* starts the task to manager suspend / release function   */
    670                        remoteMngTaskHandle = osThreadNew(remoteMngTask, NULL, &remoteMngTask_attributes);  
   \      0x514   0xF8DF 0x29F4      LDR.W    R2,??sbcSemMsgProcess_2+4
   \      0x518   0x2100             MOVS     R1,#+0
   \      0x51A   0xF8DF 0x09F4      LDR.W    R0,??sbcSemMsgProcess_2+8
   \      0x51E   0x.... 0x....      BL       osThreadNew
   \      0x522   0xF8DF 0x19F0      LDR.W    R1,??sbcSemMsgProcess_2+12
   \      0x526   0x6008             STR      R0,[R1, #+0]
    671                      }
    672                      if (socketPresence.livePresence == sbcSemInfoMng.activityStatus)
   \                     ??sbcSemMsgProcess_78: (+1)
   \      0x528   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0x52C   0xF8DA 0x1014      LDR      R1,[R10, #+20]
   \      0x530   0x4288             CMP      R0,R1
   \      0x532   0xD101             BNE.N    ??sbcSemMsgProcess_79
    673                      {
    674                        /* active the UART5 for communication with SBC only the first time after startup */
    675                        reInitSbcUart();
   \      0x534   0x.... 0x....      BL       reInitSbcUart
    676                      }
    677          
    678                      /* save all the slave parameters in external flash mememory to restore it in the future */
    679                      saveAllSlaveParameters();
   \                     ??sbcSemMsgProcess_79: (+1)
   \      0x538   0x.... 0x....      BL       saveAllSlaveParameters
    680          
    681                      /* check if there are message to manage in the list */
    682                      if (headMsg != NULL)
   \      0x53C   0xF8DF 0xB570      LDR.W    R11,??sbcSemMsgProcess_0+8
   \      0x540   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x544   0x2800             CMP      R0,#+0
   \      0x546   0xD006             BEQ.N    ??sbcSemMsgProcess_80
    683                      {
    684                        /* re-send the message in the queue list  */
    685                        headMsg = extractSendFirstInList(headMsg);
   \      0x548   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x54C   0x.... 0x....      BL       extractSendFirstInList
   \      0x550   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \      0x554   0xE001             B.N      ??sbcSemMsgProcess_81
    686                      }
    687                      else
    688                      {
    689                        resetPacketStatusNum();
   \                     ??sbcSemMsgProcess_80: (+1)
   \      0x556   0x.... 0x....      BL       resetPacketStatusNum
    690                      }
    691                      sbcSemInfoMng.discoveryMask = 0;
   \                     ??sbcSemMsgProcess_81: (+1)
   \      0x55A   0x2000             MOVS     R0,#+0
   \      0x55C   0xF8CA 0x000A      STR      R0,[R10, #+10]
   \      0x560   0xE005             B.N      ??sbcSemMsgProcess_82
    692                    }
    693                    else
    694                    {
    695                      timeTickTmp = TIMEOUT_ACK_RESP;
   \                     ??sbcSemMsgProcess_75: (+1)
   \      0x562   0xF44F 0x70FA      MOV      R0,#+500
   \      0x566   0x0007             MOVS     R7,R0
    696                      sbcSemInfoMng.sbcSemStates = SBC_SEM_ACK_RECOVERY_INFO;
   \      0x568   0x2003             MOVS     R0,#+3
   \      0x56A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    697                    }
    698                    break;
   \                     ??sbcSemMsgProcess_82: (+1)
   \      0x56E   0xE009             B.N      ??sbcSemMsgProcess_83
    699          
    700                  case NOTIFY_TO_MASTER_TX:
    701                    /* save the message for future use  */
    702                    headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_71: (+1)
   \      0x570   0xF8DF 0xA53C      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x574   0x0021             MOVS     R1,R4
   \      0x576   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x57A   0x.... 0x....      BL       addNode
   \      0x57E   0xF8CA 0x0000      STR      R0,[R10, #+0]
    703                    break;
   \      0x582   0xE7FF             B.N      ??sbcSemMsgProcess_83
    704          
    705                  default:
    706                    break;
    707                }
    708                break;
   \                     ??sbcSemMsgProcess_73: (+1)
   \                     ??sbcSemMsgProcess_83: (+1)
   \      0x584   0xF000 0xBDA0      B.W      ??sbcSemMsgProcess_37
    709          
    710              case SBC_SEM_ACK_RECOVERY_INFO:
    711                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_10: (+1)
   \      0x588   0x8820             LDRH     R0,[R4, #+0]
   \      0x58A   0x2807             CMP      R0,#+7
   \      0x58C   0xD004             BEQ.N    ??sbcSemMsgProcess_84
   \      0x58E   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x592   0x4288             CMP      R0,R1
   \      0x594   0xD04F             BEQ.N    ??sbcSemMsgProcess_85
   \      0x596   0xE070             B.N      ??sbcSemMsgProcess_86
    712                {
    713                  case NOTIFY_MODBUS_RD_ACK:
    714                    if (((sbcSemInfoMng.logicIdSocket + 1) == pMsg->data.index) && (sbcSemInfoMng.dataVal == pMsg->dataToSend.len))
   \                     ??sbcSemMsgProcess_84: (+1)
   \      0x598   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0x59C   0x1C40             ADDS     R0,R0,#+1
   \      0x59E   0x8861             LDRH     R1,[R4, #+2]
   \      0x5A0   0x4288             CMP      R0,R1
   \      0x5A2   0xD112             BNE.N    ??sbcSemMsgProcess_87
   \      0x5A4   0xF8BA 0x0004      LDRH     R0,[R10, #+4]
   \      0x5A8   0x88E1             LDRH     R1,[R4, #+6]
   \      0x5AA   0x4288             CMP      R0,R1
   \      0x5AC   0xD10D             BNE.N    ??sbcSemMsgProcess_87
    715                    {
    716                      /* a previous request to read has been accepted and new data are arrived so store it in the map */
    717                      void* pSrc = (void*)((uint32_t)pMsg->dataToSend.pData + (uint32_t)sizeof(headerAnswRHR_t));
   \      0x5AE   0x68A0             LDR      R0,[R4, #+8]
   \      0x5B0   0x1CC0             ADDS     R0,R0,#+3
   \      0x5B2   0x9006             STR      R0,[SP, #+24]
    718                      /*      destination                  source                         length */
    719                      memcpy((void*)sbcSemInfoMng.pDataRd, pSrc, (size_t)(pMsg->dataToSend.len));
   \      0x5B4   0xF8DA 0xB00E      LDR      R11,[R10, #+14]
   \      0x5B8   0x88E0             LDRH     R0,[R4, #+6]
   \      0x5BA   0x9001             STR      R0,[SP, #+4]
   \      0x5BC   0x9806             LDR      R0,[SP, #+24]
   \      0x5BE   0x9000             STR      R0,[SP, #+0]
   \      0x5C0   0x9A01             LDR      R2,[SP, #+4]
   \      0x5C2   0x9900             LDR      R1,[SP, #+0]
   \      0x5C4   0x4658             MOV      R0,R11
   \      0x5C6   0x.... 0x....      BL       __aeabi_memcpy
    720                    }
    721                    if (sbcSemInfoMng.addrVal == ADDR_START_RDD)
   \                     ??sbcSemMsgProcess_87: (+1)
   \      0x5CA   0xF8BA 0x0006      LDRH     R0,[R10, #+6]
   \      0x5CE   0xF5B0 0x7F40      CMP      R0,#+768
   \      0x5D2   0xD109             BNE.N    ??sbcSemMsgProcess_88
    722                    {
    723                      /* point to next possible slave */
    724                      sbcSemInfoMng.discoveryMask = sbcSemInfoMng.discoveryMask << 1;
   \      0x5D4   0xF11A 0x000A      ADDS     R0,R10,#+10
   \      0x5D8   0x6801             LDR      R1,[R0, #+0]
   \      0x5DA   0x0049             LSLS     R1,R1,#+1
   \      0x5DC   0x6001             STR      R1,[R0, #+0]
    725                      sbcSemInfoMng.logicIdSocket++;
   \      0x5DE   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0x5E2   0x1C40             ADDS     R0,R0,#+1
   \      0x5E4   0xF8AA 0x0008      STRH     R0,[R10, #+8]
    726                    }
    727                    /* release the transmitter */
    728                    currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \                     ??sbcSemMsgProcess_88: (+1)
   \      0x5E8   0xF8DF 0xB988      LDR.W    R11,??sbcSemMsgProcess_3
   \      0x5EC   0x2005             MOVS     R0,#+5
   \      0x5EE   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    729                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x5F2   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x5F6   0x2300             MOVS     R3,#+0
   \      0x5F8   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x5FC   0x4659             MOV      R1,R11
   \      0x5FE   0x.... 0x....      BL       xQueueGenericSend
   \      0x602   0x2801             CMP      R0,#+1
   \      0x604   0xD009             BEQ.N    ??sbcSemMsgProcess_89
   \      0x606   0xB672             CPSID    I
   \      0x608   0x2050             MOVS     R0,#+80
   \      0x60A   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x60E   0xF3BF 0x8F4F      DSB      SY
   \      0x612   0xF3BF 0x8F6F      ISB      SY
   \      0x616   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_90: (+1)
   \      0x618   0xE7FE             B.N      ??sbcSemMsgProcess_90
    730                    /* release the buffer  */
    731                    if (pMsg->dataToSend.pData != NULL) 
   \                     ??sbcSemMsgProcess_89: (+1)
   \      0x61A   0x68A0             LDR      R0,[R4, #+8]
   \      0x61C   0x2800             CMP      R0,#+0
   \      0x61E   0xD004             BEQ.N    ??sbcSemMsgProcess_91
    732                    {
    733                      free((void*)pMsg->dataToSend.pData);
   \      0x620   0x68A0             LDR      R0,[R4, #+8]
   \      0x622   0x.... 0x....      BL       free
    734                      pMsg->dataToSend.pData = NULL;
   \      0x626   0x2000             MOVS     R0,#+0
   \      0x628   0x60A0             STR      R0,[R4, #+8]
    735                    }
    736                    /* timeout 20ms for next reading   */
    737                    timeTickTmp = pdMS_TO_TICKS(TIMEOUT_RD_REQ);  
   \                     ??sbcSemMsgProcess_91: (+1)
   \      0x62A   0x2014             MOVS     R0,#+20
   \      0x62C   0x0007             MOVS     R7,R0
    738                    sbcSemInfoMng.sbcSemStates = SBC_SEM_RECOVERY_INFO;
   \      0x62E   0x2002             MOVS     R0,#+2
   \      0x630   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    739                    break;
   \      0x634   0xE021             B.N      ??sbcSemMsgProcess_92
    740          
    741                  case SBC_SEM_TIMEOUT:
    742                    tPrintf("Abort: No info received from Addr = %d!\n\r", sbcSemInfoMng.logicIdSocket + 1);
   \                     ??sbcSemMsgProcess_85: (+1)
   \      0x636   0xF8BA 0x1008      LDRH     R1,[R10, #+8]
   \      0x63A   0x1C49             ADDS     R1,R1,#+1
   \      0x63C   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \      0x640   0x.... 0x....      BL       tPrintf
    743                    socketPresence.livePresence &= (~sbcSemInfoMng.discoveryMask);
   \      0x644   0xF11A 0x010A      ADDS     R1,R10,#+10
   \      0x648   0x680A             LDR      R2,[R1, #+0]
   \      0x64A   0xF8DF 0x0728      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x64E   0x6843             LDR      R3,[R0, #+4]
   \      0x650   0xEA33 0x0202      BICS     R2,R3,R2
   \      0x654   0x6042             STR      R2,[R0, #+4]
    744                    /* timeout 20ms for next reading   */
    745                    if (sbcSemInfoMng.logicIdSocket < SCU_NUM)
   \      0x656   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0x65A   0x2810             CMP      R0,#+16
   \      0x65C   0xDA07             BGE.N    ??sbcSemMsgProcess_93
    746                    {
    747                      sbcSemInfoMng.logicIdSocket++;
   \      0x65E   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0x662   0x1C40             ADDS     R0,R0,#+1
   \      0x664   0xF8AA 0x0008      STRH     R0,[R10, #+8]
    748                      sbcSemInfoMng.discoveryMask = sbcSemInfoMng.discoveryMask << 1;
   \      0x668   0x6808             LDR      R0,[R1, #+0]
   \      0x66A   0x0040             LSLS     R0,R0,#+1
   \      0x66C   0x6008             STR      R0,[R1, #+0]
    749                    }
    750                    timeTickTmp = pdMS_TO_TICKS(TIMEOUT_RD_REQ);  
   \                     ??sbcSemMsgProcess_93: (+1)
   \      0x66E   0x2014             MOVS     R0,#+20
   \      0x670   0x0007             MOVS     R7,R0
    751                    sbcSemInfoMng.sbcSemStates = SBC_SEM_RECOVERY_INFO;
   \      0x672   0x2002             MOVS     R0,#+2
   \      0x674   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    752                    break;
   \      0x678   0xE7FF             B.N      ??sbcSemMsgProcess_92
    753          
    754                  default:
    755                    break;
    756                }
    757                break;
   \                     ??sbcSemMsgProcess_86: (+1)
   \                     ??sbcSemMsgProcess_92: (+1)
   \      0x67A   0xF000 0xBD25      B.W      ??sbcSemMsgProcess_37
    758          
    759              case SBC_SEM_WAIT_TO_BE_OPERATIVE:
    760                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_17: (+1)
   \      0x67E   0x8820             LDRH     R0,[R4, #+0]
   \      0x680   0x2800             CMP      R0,#+0
   \      0x682   0xD003             BEQ.N    ??sbcSemMsgProcess_94
   \      0x684   0x2802             CMP      R0,#+2
   \      0x686   0xF000 0x808E      BEQ.W    ??sbcSemMsgProcess_95
   \      0x68A   0xE0A3             B.N      ??sbcSemMsgProcess_96
    761                {
    762                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    763                    if (ixScu == MODBUS_BROADCAST_ADDR)
   \                     ??sbcSemMsgProcess_94: (+1)
   \      0x68C   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0x690   0x2800             CMP      R0,#+0
   \      0x692   0xF040 0x8087      BNE.W    ??sbcSemMsgProcess_97
    764                    {
    765                      if (pMsg->data.rAddr == ADDR_EVSE_TM_RW)
   \      0x696   0x88A0             LDRH     R0,[R4, #+4]
   \      0x698   0x2822             CMP      R0,#+34
   \      0x69A   0xF040 0x8083      BNE.W    ??sbcSemMsgProcess_97
    766                      {
    767                        pWord = (uint16_t *)pMsg->dataToSend.pData;
   \      0x69E   0x68A0             LDR      R0,[R4, #+8]
   \      0x6A0   0x9003             STR      R0,[SP, #+12]
    768                        if (SCU_S_REPL_ADDR != getStationId()) /* board with address = 99 is for replacement */
   \      0x6A2   0x.... 0x....      BL       getStationId
   \      0x6A6   0x2863             CMP      R0,#+99
   \      0x6A8   0xD049             BEQ.N    ??sbcSemMsgProcess_98
    769                        {
    770                          if (((uint16_t)SCU_S_PS_LIVE == *pWord) || ((uint16_t)SCU_S_PS_STARTUP == *pWord) ||
    771                              ((uint16_t)SCU_S_PS_NEW == *pWord))               // SCU_S_PS_NEW = 6 or SCU_S_PS_LIVE=5  or SCU_S_PS_STARTUP=4
   \      0x6AA   0x9803             LDR      R0,[SP, #+12]
   \      0x6AC   0x8800             LDRH     R0,[R0, #+0]
   \      0x6AE   0x2805             CMP      R0,#+5
   \      0x6B0   0xD007             BEQ.N    ??sbcSemMsgProcess_99
   \      0x6B2   0x9803             LDR      R0,[SP, #+12]
   \      0x6B4   0x8800             LDRH     R0,[R0, #+0]
   \      0x6B6   0x2804             CMP      R0,#+4
   \      0x6B8   0xD003             BEQ.N    ??sbcSemMsgProcess_99
   \      0x6BA   0x9803             LDR      R0,[SP, #+12]
   \      0x6BC   0x8800             LDRH     R0,[R0, #+0]
   \      0x6BE   0x2806             CMP      R0,#+6
   \      0x6C0   0xD170             BNE.N    ??sbcSemMsgProcess_97
    772                          {
    773                            /* a master starts a broadcast request: this is the case when the slave starts long time after master reset  */
    774                            if (socketPresence.keyPresence == KEY_FULL_CONFIG)
   \                     ??sbcSemMsgProcess_99: (+1)
   \      0x6C2   0xF8DF 0x06B0      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x6C6   0x6880             LDR      R0,[R0, #+8]
   \      0x6C8   0xF64A 0x2155      MOVW     R1,#+43605
   \      0x6CC   0x4288             CMP      R0,R1
   \      0x6CE   0xD169             BNE.N    ??sbcSemMsgProcess_97
    775                            {
    776                              /* the address in ADDR_CONNECTOR_IDS_RW has been already assigned by master */
    777                              currFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \      0x6D0   0xF8DF 0xB8A0      LDR.W    R11,??sbcSemMsgProcess_3
   \      0x6D4   0x2002             MOVS     R0,#+2
   \      0x6D6   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    778                              currFrameSbcSem.data.index = getPhysicalMdbAddr();  /* rs485SemMsgProcess() use physical address = modbus address   1...247 */
   \      0x6DA   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0x6DE   0xF8AB 0x0002      STRH     R0,[R11, #+2]
    779                              currFrameSbcSem.data.rAddr = ADDR_CONNECTOR_IDS_RW;  // 0x0004
   \      0x6E2   0x2004             MOVS     R0,#+4
   \      0x6E4   0xF8AB 0x0004      STRH     R0,[R11, #+4]
    780                              currFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \      0x6E8   0xF11A 0x0004      ADDS     R0,R10,#+4
   \      0x6EC   0xF8CB 0x0008      STR      R0,[R11, #+8]
    781                              /* to avoid possible conflit on first Tx byte a random delay is used  */
    782                              osDelay((uint32_t)10 * (uint32_t)currFrameSbcSem.data.index);  /* delay in the range 2...50 msec */
   \      0x6F0   0xF8BB 0x0002      LDRH     R0,[R11, #+2]
   \      0x6F4   0x210A             MOVS     R1,#+10
   \      0x6F6   0x4348             MULS     R0,R1,R0
   \      0x6F8   0x.... 0x....      BL       osDelay
    783                              configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x6FC   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x700   0x2300             MOVS     R3,#+0
   \      0x702   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x706   0x4659             MOV      R1,R11
   \      0x708   0x.... 0x....      BL       xQueueGenericSend
   \      0x70C   0x2801             CMP      R0,#+1
   \      0x70E   0xD009             BEQ.N    ??sbcSemMsgProcess_100
   \      0x710   0xB672             CPSID    I
   \      0x712   0x2050             MOVS     R0,#+80
   \      0x714   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x718   0xF3BF 0x8F4F      DSB      SY
   \      0x71C   0xF3BF 0x8F6F      ISB      SY
   \      0x720   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_101: (+1)
   \      0x722   0xE7FE             B.N      ??sbcSemMsgProcess_101
    784                              sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_WR_MASTER_ACK_STARTUP; 
   \                     ??sbcSemMsgProcess_100: (+1)
   \      0x724   0x200D             MOVS     R0,#+13
   \      0x726   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    785                              // start ACK timer 
    786                              timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_RESP); 
   \      0x72A   0xF44F 0x70FA      MOV      R0,#+500
   \      0x72E   0x0007             MOVS     R7,R0
    787                              sendMonMngMsg(MON_SEM_TASK, MON_START);      // activation task for monitor  
   \      0x730   0x2100             MOVS     R1,#+0
   \      0x732   0x2001             MOVS     R0,#+1
   \      0x734   0x.... 0x....      BL       sendMonMngMsg
    788                              semSlaveSendActEnrg();                       // ask to send master active energy value 
   \      0x738   0x.... 0x....      BL       semSlaveSendActEnrg
   \      0x73C   0xE032             B.N      ??sbcSemMsgProcess_97
    789                            }
    790                          }        /* no action in this state: wait time out */
    791                        }
    792                        else
    793                        {
    794                          if ((uint16_t)SCU_S_PS_NEW == *pWord)               // SCU_S_PS_NEW = 6 
   \                     ??sbcSemMsgProcess_98: (+1)
   \      0x73E   0x9803             LDR      R0,[SP, #+12]
   \      0x740   0x8800             LDRH     R0,[R0, #+0]
   \      0x742   0x2806             CMP      R0,#+6
   \      0x744   0xD12E             BNE.N    ??sbcSemMsgProcess_97
    795                          {
    796                            /* ask the master to send eeprom configuration data: This is made writing at address ADDR_GET_EEPROM_RW */
    797                            currFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \      0x746   0xF8DF 0xB82C      LDR.W    R11,??sbcSemMsgProcess_3
   \      0x74A   0x2002             MOVS     R0,#+2
   \      0x74C   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    798                            currFrameSbcSem.data.index = getPhysicalMdbAddr();  /* rs485SemMsgProcess() use physical address = modbus address   1...247 */
   \      0x750   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0x754   0xF8AB 0x0002      STRH     R0,[R11, #+2]
    799                            currFrameSbcSem.data.rAddr = ADDR_GET_EEPROM_RW;    // 0x0523
   \      0x758   0xF240 0x5023      MOVW     R0,#+1315
   \      0x75C   0xF8AB 0x0004      STRH     R0,[R11, #+4]
    800                            sbcSemInfoMng.dataVal = (uint16_t)1099;
   \      0x760   0xF240 0x404B      MOVW     R0,#+1099
   \      0x764   0xF8AA 0x0004      STRH     R0,[R10, #+4]
    801                            currFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \      0x768   0xF11A 0x0004      ADDS     R0,R10,#+4
   \      0x76C   0xF8CB 0x0008      STR      R0,[R11, #+8]
    802                            configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x770   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x774   0x2300             MOVS     R3,#+0
   \      0x776   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x77A   0x4659             MOV      R1,R11
   \      0x77C   0x.... 0x....      BL       xQueueGenericSend
   \      0x780   0x2801             CMP      R0,#+1
   \      0x782   0xD009             BEQ.N    ??sbcSemMsgProcess_102
   \      0x784   0xB672             CPSID    I
   \      0x786   0x2050             MOVS     R0,#+80
   \      0x788   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x78C   0xF3BF 0x8F4F      DSB      SY
   \      0x790   0xF3BF 0x8F6F      ISB      SY
   \      0x794   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_103: (+1)
   \      0x796   0xE7FE             B.N      ??sbcSemMsgProcess_103
    803                            sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_WR_MASTER_ACK_STARTUP; 
   \                     ??sbcSemMsgProcess_102: (+1)
   \      0x798   0x200D             MOVS     R0,#+13
   \      0x79A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    804                            // start ACK timer 
    805                            timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_RESP); 
   \      0x79E   0xF44F 0x70FA      MOV      R0,#+500
   \      0x7A2   0x0007             MOVS     R7,R0
    806                          }
    807                        }
    808                      }
    809                    }
    810                    break;
   \                     ??sbcSemMsgProcess_97: (+1)
   \      0x7A4   0xE016             B.N      ??sbcSemMsgProcess_104
    811          
    812                  case NOTIFY_TO_MASTER_TX:
    813                    if (pMsg->data.rAddr == ADDR_TM_EVSE_READY_RO)  // 0x512 Testing machine starts test
   \                     ??sbcSemMsgProcess_95: (+1)
   \      0x7A6   0x88A0             LDRH     R0,[R4, #+4]
   \      0x7A8   0xF240 0x5112      MOVW     R1,#+1298
   \      0x7AC   0x4288             CMP      R0,R1
   \      0x7AE   0xD103             BNE.N    ??sbcSemMsgProcess_105
    814                    {
    815                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE_COLLAUDO;
   \      0x7B0   0x200E             MOVS     R0,#+14
   \      0x7B2   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \      0x7B6   0xE00C             B.N      ??sbcSemMsgProcess_106
    816                    }
    817                    else
    818                    {
    819                      if (SCU_S_REPL_ADDR != getStationId()) /* board with address = 99 is for replacement, so no message storing is need */
   \                     ??sbcSemMsgProcess_105: (+1)
   \      0x7B8   0x.... 0x....      BL       getStationId
   \      0x7BC   0x2863             CMP      R0,#+99
   \      0x7BE   0xD008             BEQ.N    ??sbcSemMsgProcess_106
    820                      {
    821                        /* a previous message is sending, so the current is put in the list */
    822                        headMsg = addNode(headMsg, pMsg);
   \      0x7C0   0xF8DF 0xA2EC      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x7C4   0x0021             MOVS     R1,R4
   \      0x7C6   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x7CA   0x.... 0x....      BL       addNode
   \      0x7CE   0xF8CA 0x0000      STR      R0,[R10, #+0]
    823                      }
    824                    }
    825                    break;
   \                     ??sbcSemMsgProcess_106: (+1)
   \      0x7D2   0xE7FF             B.N      ??sbcSemMsgProcess_104
    826          
    827                  default:
    828                    break;
    829          
    830                }
    831                break;
   \                     ??sbcSemMsgProcess_96: (+1)
   \                     ??sbcSemMsgProcess_104: (+1)
   \      0x7D4   0xF000 0xBC78      B.W      ??sbcSemMsgProcess_37
    832          
    833              case SBC_SEM_OPERATIVE_COLLAUDO:
    834                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_18: (+1)
   \      0x7D8   0x8820             LDRH     R0,[R4, #+0]
   \      0x7DA   0x2800             CMP      R0,#+0
   \      0x7DC   0xD002             BEQ.N    ??sbcSemMsgProcess_107
   \      0x7DE   0x2802             CMP      R0,#+2
   \      0x7E0   0xD009             BEQ.N    ??sbcSemMsgProcess_108
   \      0x7E2   0xE010             B.N      ??sbcSemMsgProcess_109
    835                {
    836                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    837                    /* upgrade the register */
    838                    (void)setChangeRegisterBit(ixScu, pMsg, (uint32_t)maskBit, ixLogic);
   \                     ??sbcSemMsgProcess_107: (+1)
   \      0x7E4   0x002B             MOVS     R3,R5
   \      0x7E6   0xB29B             UXTH     R3,R3
   \      0x7E8   0x0032             MOVS     R2,R6
   \      0x7EA   0x0021             MOVS     R1,R4
   \      0x7EC   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0x7F0   0x.... 0x....      BL       setChangeRegisterBit
    839                    break;
   \      0x7F4   0xE007             B.N      ??sbcSemMsgProcess_110
    840          
    841                  case NOTIFY_TO_MASTER_TX:
    842                    (void)setChangeRegisterBit(SCU_M_P_ADDR, pMsg, (uint32_t)maskBit, ixLogic);
   \                     ??sbcSemMsgProcess_108: (+1)
   \      0x7F6   0x002B             MOVS     R3,R5
   \      0x7F8   0xB29B             UXTH     R3,R3
   \      0x7FA   0x0032             MOVS     R2,R6
   \      0x7FC   0x0021             MOVS     R1,R4
   \      0x7FE   0x2001             MOVS     R0,#+1
   \      0x800   0x.... 0x....      BL       setChangeRegisterBit
    843                    break;
   \      0x804   0xE7FF             B.N      ??sbcSemMsgProcess_110
    844          
    845                  default:
    846                    break;
    847                }
    848                break;
   \                     ??sbcSemMsgProcess_109: (+1)
   \                     ??sbcSemMsgProcess_110: (+1)
   \      0x806   0xF000 0xBC5F      B.W      ??sbcSemMsgProcess_37
    849          
    850          
    851              case SBC_SEM_OPERATIVE:
    852                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_11: (+1)
   \      0x80A   0x8820             LDRH     R0,[R4, #+0]
   \      0x80C   0x2800             CMP      R0,#+0
   \      0x80E   0xD01C             BEQ.N    ??sbcSemMsgProcess_111
   \      0x810   0x2801             CMP      R0,#+1
   \      0x812   0xF000 0x8165      BEQ.W    ??sbcSemMsgProcess_112
   \      0x816   0x2802             CMP      R0,#+2
   \      0x818   0xF000 0x81CA      BEQ.W    ??sbcSemMsgProcess_113
   \      0x81C   0x2804             CMP      R0,#+4
   \      0x81E   0xF000 0x8266      BEQ.W    ??sbcSemMsgProcess_114
   \      0x822   0x2807             CMP      R0,#+7
   \      0x824   0xF000 0x82B4      BEQ.W    ??sbcSemMsgProcess_115
   \      0x828   0x280A             CMP      R0,#+10
   \      0x82A   0xF000 0x8242      BEQ.W    ??sbcSemMsgProcess_116
   \      0x82E   0x280B             CMP      R0,#+11
   \      0x830   0xF000 0x825A      BEQ.W    ??sbcSemMsgProcess_117
   \      0x834   0x280C             CMP      R0,#+12
   \      0x836   0xD008             BEQ.N    ??sbcSemMsgProcess_111
   \      0x838   0x280D             CMP      R0,#+13
   \      0x83A   0xF000 0x8151      BEQ.W    ??sbcSemMsgProcess_112
   \      0x83E   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x842   0x4288             CMP      R0,R1
   \      0x844   0xF000 0x8253      BEQ.W    ??sbcSemMsgProcess_114
   \      0x848   0xE2F2             B.N      ??sbcSemMsgProcess_118
    853                {
    854                  case POLLING_CHANGE_INFO:
    855                  case SBC_SEM_EVENT_RS485: // ex SCU_EVENT_RD_ANSW_WR_REQ
    856                    toggleHeartLed();
   \                     ??sbcSemMsgProcess_111: (+1)
   \      0x84A   0x.... 0x....      BL       toggleHeartLed
    857                    if (isSemMasterFz() == TRUE) 
   \      0x84E   0x.... 0x....      BL       isSemMasterFz
   \      0x852   0x2801             CMP      R0,#+1
   \      0x854   0xF040 0x80CB      BNE.W    ??sbcSemMsgProcess_119
    858                    {
    859                      if (pMsg->data.rAddr == ADDR_ADDR_S_CONN_RW)  // 0x513
   \      0x858   0x88A0             LDRH     R0,[R4, #+4]
   \      0x85A   0xF240 0x5113      MOVW     R1,#+1299
   \      0x85E   0x4288             CMP      R0,R1
   \      0x860   0xD103             BNE.N    ??sbcSemMsgProcess_120
    860                      {
    861                        /* a new slave (socket) has been inserted in the chain and ask its address */
    862                        mngReqAddress(pMsg);
   \      0x862   0x0020             MOVS     R0,R4
   \      0x864   0x.... 0x....      BL       mngReqAddress
   \      0x868   0xE139             B.N      ??sbcSemMsgProcess_121
    863                      }
    864                      else
    865                      {
    866                        if ((pMsg->data.rAddr == ADDR_CONNECTOR_IDS_RW) || (pMsg->data.rAddr == ADDR_EVSE_TM_RW)) // 0x0004 or 0x0022  ADDR_EVSE_TM_RW
   \                     ??sbcSemMsgProcess_120: (+1)
   \      0x86A   0x88A0             LDRH     R0,[R4, #+4]
   \      0x86C   0x2804             CMP      R0,#+4
   \      0x86E   0xD002             BEQ.N    ??sbcSemMsgProcess_122
   \      0x870   0x88A0             LDRH     R0,[R4, #+4]
   \      0x872   0x2822             CMP      R0,#+34
   \      0x874   0xD136             BNE.N    ??sbcSemMsgProcess_123
    867                        {
    868                          /* this is a slave answer where the address has been assigned already: this is the case the socket has RS485 off-line and we reconnect its later  */
    869                          /* update activity status */                               
    870                          sbcSemInfoMng.activityStatus |= maskBit;
   \                     ??sbcSemMsgProcess_122: (+1)
   \      0x876   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0x87A   0x4330             ORRS     R0,R6,R0
   \      0x87C   0xF8CA 0x0014      STR      R0,[R10, #+20]
    871                          if ((socketPresence.livePresence & maskBit) == 0)
   \      0x880   0xF8DF 0x04F0      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x884   0x6840             LDR      R0,[R0, #+4]
   \      0x886   0x4230             TST      R0,R6
   \      0x888   0xD105             BNE.N    ??sbcSemMsgProcess_124
    872                          {
    873                            /* recover all info */
    874          #ifdef COME_ERA
    875                            /* the live presence bit will be update at the end of recovery info phase Nick 30/07/2024 */
    876                            socketPresence.livePresence |= maskBit; 
    877          #endif
    878                            restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_NEXT_DISCOVERY); // the master restart the timeout 500msec
   \      0x88A   0xF640 0x11C4      MOVW     R1,#+2500
   \      0x88E   0x2000             MOVS     R0,#+0
   \      0x890   0x.... 0x....      BL       restartSbcSemTimer
   \      0x894   0xE123             B.N      ??sbcSemMsgProcess_121
    879                          }
    880                          else
    881                          {
    882                            if (pMsg->data.rAddr == ADDR_EVSE_TM_RW) // 0x0022 ADDR_EVSE_TM_RW
   \                     ??sbcSemMsgProcess_124: (+1)
   \      0x896   0x88A0             LDRH     R0,[R4, #+4]
   \      0x898   0x2822             CMP      R0,#+34
   \      0x89A   0xF040 0x8120      BNE.W    ??sbcSemMsgProcess_121
    883                            {
    884                              pWord = (uint16_t *)pMsg->dataToSend.pData;
   \      0x89E   0x68A0             LDR      R0,[R4, #+8]
   \      0x8A0   0x9003             STR      R0,[SP, #+12]
    885                              pScuRoMapRegSlave = getRoMdbRegs(ixLogic);
   \      0x8A2   0x0028             MOVS     R0,R5
   \      0x8A4   0xB2C0             UXTB     R0,R0
   \      0x8A6   0x.... 0x....      BL       getRoMdbRegs
   \      0x8AA   0x9004             STR      R0,[SP, #+16]
    886                              if  (pScuRoMapRegSlave->scuMapRegStatusMeas.ntfChgStat != *pWord)
   \      0x8AC   0x9804             LDR      R0,[SP, #+16]
   \      0x8AE   0xF8B0 0x0124      LDRH     R0,[R0, #+292]
   \      0x8B2   0x9903             LDR      R1,[SP, #+12]
   \      0x8B4   0x8809             LDRH     R1,[R1, #+0]
   \      0x8B6   0x4288             CMP      R0,R1
   \      0x8B8   0xF000 0x8111      BEQ.W    ??sbcSemMsgProcess_121
    887                              {
    888                                /* the current state stored in the slave map, isn't the same coming from polling */
    889                                /* so update the map and notify to SEM                                           */
    890                                pScuRoMapRegSlave->scuMapRegStatusMeas.ntfChgStat = pMsg->status = *pWord;
   \      0x8BC   0x9803             LDR      R0,[SP, #+12]
   \      0x8BE   0x8800             LDRH     R0,[R0, #+0]
   \      0x8C0   0x81A0             STRH     R0,[R4, #+12]
   \      0x8C2   0x89A0             LDRH     R0,[R4, #+12]
   \      0x8C4   0x9904             LDR      R1,[SP, #+16]
   \      0x8C6   0xF8A1 0x0124      STRH     R0,[R1, #+292]
    891                                /* upgrade the register */
    892                                pMsg->data.rAddr = ADDR_EVSE_CHARGE_STATUS_RO;
   \      0x8CA   0xF240 0x6001      MOVW     R0,#+1537
   \      0x8CE   0x80A0             STRH     R0,[R4, #+4]
    893                                result = (uint8_t)setChangeRegisterBit(ixScu, pMsg, (uint32_t)maskBit, ixLogic);
   \      0x8D0   0x002B             MOVS     R3,R5
   \      0x8D2   0xB29B             UXTH     R3,R3
   \      0x8D4   0x0032             MOVS     R2,R6
   \      0x8D6   0x0021             MOVS     R1,R4
   \      0x8D8   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0x8DC   0x.... 0x....      BL       setChangeRegisterBit
   \      0x8E0   0x4680             MOV      R8,R0
   \      0x8E2   0xE0FC             B.N      ??sbcSemMsgProcess_121
    894                              }
    895                            }
    896                          }
    897                        }
    898                        else
    899                        {
    900                          if (pMsg->data.rAddr == ADDR_GET_EEPROM_RW)
   \                     ??sbcSemMsgProcess_123: (+1)
   \      0x8E4   0x88A0             LDRH     R0,[R4, #+4]
   \      0x8E6   0xF240 0x5123      MOVW     R1,#+1315
   \      0x8EA   0x4288             CMP      R0,R1
   \      0x8EC   0xD13E             BNE.N    ??sbcSemMsgProcess_125
    901                          {
    902                            /* this is a slave SCU board used as replacement for first address fail. First of all we find first address fail */
    903                            for (cnt = 0, maskBit = (uint32_t)1, result = SCU_NUM; cnt < SCU_NUM; cnt++, maskBit = maskBit << 1)
   \      0x8EE   0x2000             MOVS     R0,#+0
   \      0x8F0   0x4681             MOV      R9,R0
   \      0x8F2   0x2001             MOVS     R0,#+1
   \      0x8F4   0x0006             MOVS     R6,R0
   \      0x8F6   0x2010             MOVS     R0,#+16
   \      0x8F8   0x4680             MOV      R8,R0
   \                     ??sbcSemMsgProcess_126: (+1)
   \      0x8FA   0x4648             MOV      R0,R9
   \      0x8FC   0xB2C0             UXTB     R0,R0
   \      0x8FE   0x2810             CMP      R0,#+16
   \      0x900   0xDA1E             BGE.N    ??sbcSemMsgProcess_127
    904                            {
    905                              if (cnt == 0) continue;
   \      0x902   0x4648             MOV      R0,R9
   \      0x904   0xB2C0             UXTB     R0,R0
   \      0x906   0x2800             CMP      R0,#+0
   \      0x908   0xD016             BEQ.N    ??sbcSemMsgProcess_128
    906                              if (((socketPresence.chainPresence & maskBit) != 0) && ((socketPresence.livePresence & maskBit) == 0)) 
   \                     ??sbcSemMsgProcess_129: (+1)
   \      0x90A   0xF8DF 0x0468      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x90E   0x6801             LDR      R1,[R0, #+0]
   \      0x910   0x4231             TST      R1,R6
   \      0x912   0xD011             BEQ.N    ??sbcSemMsgProcess_128
   \      0x914   0x6841             LDR      R1,[R0, #+4]
   \      0x916   0x4231             TST      R1,R6
   \      0x918   0xD10E             BNE.N    ??sbcSemMsgProcess_128
    907                              {
    908                                /* this is the index of a fail board. The jolly SCU is placed at the lower number diplayed on LCD, i.e. minimum connector Id  */
    909                                if (socketPresence.matrixIdConn[cnt] < result) result = socketPresence.matrixIdConn[cnt];
   \      0x91A   0x4649             MOV      R1,R9
   \      0x91C   0xB2C9             UXTB     R1,R1
   \      0x91E   0x4401             ADD      R1,R0,R1
   \      0x920   0xF891 0x1030      LDRB     R1,[R1, #+48]
   \      0x924   0x4642             MOV      R2,R8
   \      0x926   0xB2D2             UXTB     R2,R2
   \      0x928   0x4291             CMP      R1,R2
   \      0x92A   0xD205             BCS.N    ??sbcSemMsgProcess_128
   \      0x92C   0x4649             MOV      R1,R9
   \      0x92E   0xB2C9             UXTB     R1,R1
   \      0x930   0x4408             ADD      R0,R0,R1
   \      0x932   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \      0x936   0x4680             MOV      R8,R0
    910                              }
    911                            }
   \                     ??sbcSemMsgProcess_128: (+1)
   \      0x938   0xF119 0x0901      ADDS     R9,R9,#+1
   \      0x93C   0x0076             LSLS     R6,R6,#+1
   \      0x93E   0xE7DC             B.N      ??sbcSemMsgProcess_126
    912                            if (result < SCU_NUM)
   \                     ??sbcSemMsgProcess_127: (+1)
   \      0x940   0x4640             MOV      R0,R8
   \      0x942   0xB2C0             UXTB     R0,R0
   \      0x944   0x2810             CMP      R0,#+16
   \      0x946   0xF280 0x80CA      BGE.W    ??sbcSemMsgProcess_121
    913                            {
    914                              /* recovery the address on RS485 for first fail board to be cloned */
    915                              cnt = socketPresence.matrixConv[result]; 
   \      0x94A   0xF8DF 0x0428      LDR.W    R0,??sbcSemMsgProcess_1+8
   \      0x94E   0x4641             MOV      R1,R8
   \      0x950   0xB2C9             UXTB     R1,R1
   \      0x952   0x4408             ADD      R0,R0,R1
   \      0x954   0x7C00             LDRB     R0,[R0, #+16]
   \      0x956   0x4681             MOV      R9,R0
    916                              /* we have found the address of replaced slave SCU */
    917                              if (sendEeepromInfoForCloning(cnt) == 0)
   \      0x958   0x4648             MOV      R0,R9
   \      0x95A   0xB2C0             UXTB     R0,R0
   \      0x95C   0x.... 0x....      BL       sendEeepromInfoForCloning
   \      0x960   0x2800             CMP      R0,#+0
   \      0x962   0xF000 0x8265      BEQ.W    ??sbcSemMsgProcess_130
    918                              {
    919                                break;
    920                              }
    921                              /* restart the master to check if cloned SCU works properly (detected with all info) */
    922                              activeImmediateReset(); 
   \                     ??sbcSemMsgProcess_131: (+1)
   \      0x966   0x.... 0x....      BL       activeImmediateReset
   \      0x96A   0xE0B8             B.N      ??sbcSemMsgProcess_121
    923                            }
    924                          }
    925                          else
    926                          {
    927                            /* upgrade the register */
    928                            result = (uint8_t)setChangeRegisterBit(ixScu, pMsg, (uint32_t)maskBit, ixLogic);
   \                     ??sbcSemMsgProcess_125: (+1)
   \      0x96C   0x002B             MOVS     R3,R5
   \      0x96E   0xB29B             UXTH     R3,R3
   \      0x970   0x0032             MOVS     R2,R6
   \      0x972   0x0021             MOVS     R1,R4
   \      0x974   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0x978   0x.... 0x....      BL       setChangeRegisterBit
   \      0x97C   0x4680             MOV      R8,R0
    929                            if (result == (uint8_t)SEND_ACK)
   \      0x97E   0x4640             MOV      R0,R8
   \      0x980   0xB2C0             UXTB     R0,R0
   \      0x982   0x2801             CMP      R0,#+1
   \      0x984   0xD124             BNE.N    ??sbcSemMsgProcess_132
    930                            {
    931                              /* a message froma slave on  RS485 has been received: Set the activity bit */
    932                              sbcSemInfoMng.activityStatus |= maskBit;
   \      0x986   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0x98A   0x4330             ORRS     R0,R6,R0
   \      0x98C   0xF8CA 0x0014      STR      R0,[R10, #+20]
    933                              if ((sbcSemInfoMng.scuInDwldIdx == ixScu) && (pMsg->data.rAddr == ADDR_EVSE_ERROR2_RO))
   \      0x990   0xF8BA 0x0012      LDRH     R0,[R10, #+18]
   \      0x994   0xF8BD 0x1008      LDRH     R1,[SP, #+8]
   \      0x998   0x4288             CMP      R0,R1
   \      0x99A   0xF040 0x80A0      BNE.W    ??sbcSemMsgProcess_121
   \      0x99E   0x88A0             LDRH     R0,[R4, #+4]
   \      0x9A0   0xF240 0x4105      MOVW     R1,#+1029
   \      0x9A4   0x4288             CMP      R0,R1
   \      0x9A6   0xF040 0x809A      BNE.W    ??sbcSemMsgProcess_121
    934                              {
    935                                /* the rebooting phase in the slave is terminated: it is necessary to re-scan all info  */
    936                                sbcSemInfoMng.scuInDwldIdx = (uint16_t)0;
   \      0x9AA   0x2000             MOVS     R0,#+0
   \      0x9AC   0xF8AA 0x0012      STRH     R0,[R10, #+18]
    937                                /* set initial socket info */
    938                                sbcSemInfoMng.discoveryMask = (uint32_t)0x2;
   \      0x9B0   0x2002             MOVS     R0,#+2
   \      0x9B2   0xF8CA 0x000A      STR      R0,[R10, #+10]
    939                                sbcSemInfoMng.logicIdSocket = (uint16_t)0x1;
   \      0x9B6   0x2001             MOVS     R0,#+1
   \      0x9B8   0xF8AA 0x0008      STRH     R0,[R10, #+8]
    940                                sbcSemInfoMng.sbcSemStates = SBC_SEM_RECOVERY_INFO;
   \      0x9BC   0x2002             MOVS     R0,#+2
   \      0x9BE   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    941                                sbcSemInfoMng.addrVal = ADDR_START_RDD;
   \      0x9C2   0xF44F 0x7040      MOV      R0,#+768
   \      0x9C6   0xF8AA 0x0006      STRH     R0,[R10, #+6]
    942                                /* timeout 20ms for starting recovery info procedure  */
    943                                timeTickTmp = pdMS_TO_TICKS(TIMEOUT_RD_REQ);  
   \      0x9CA   0x2014             MOVS     R0,#+20
   \      0x9CC   0x0007             MOVS     R7,R0
   \      0x9CE   0xE086             B.N      ??sbcSemMsgProcess_121
    944                              }
    945                            }
    946                            else
    947                            {
    948                              if (result == (uint8_t)SEND_RETRY)
   \                     ??sbcSemMsgProcess_132: (+1)
   \      0x9D0   0x4640             MOV      R0,R8
   \      0x9D2   0xB2C0             UXTB     R0,R0
   \      0x9D4   0x2802             CMP      R0,#+2
   \      0x9D6   0xF040 0x8082      BNE.W    ??sbcSemMsgProcess_121
    949                              {
    950                                /* the current message cannot be managed now, so put in the list */
    951                                headMsg = addNode(headMsg, pMsg);
   \      0x9DA   0xF8DF 0xA0D4      LDR.W    R10,??sbcSemMsgProcess_0+8
   \      0x9DE   0x0021             MOVS     R1,R4
   \      0x9E0   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x9E4   0x.... 0x....      BL       addNode
   \      0x9E8   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \      0x9EC   0xE077             B.N      ??sbcSemMsgProcess_121
    952                              }
    953                            }
    954                          }
    955                        }
    956                      }
    957                    }
    958                    else
    959                    {
    960                      /* a master start the addressing procedure after a its reboot */
    961                      if (ixScu == MODBUS_BROADCAST_ADDR)
   \                     ??sbcSemMsgProcess_119: (+1)
   \      0x9EE   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0x9F2   0x2800             CMP      R0,#+0
   \      0x9F4   0xD16D             BNE.N    ??sbcSemMsgProcess_133
    962                      {
    963                        if (pMsg->data.rAddr == ADDR_EVSE_TM_RW)  // AUTOCONFIG_FUNCTION_RW = ADDR_EVSE_TM_RW = 0x0022 is the register used for polling 
   \      0x9F6   0x88A0             LDRH     R0,[R4, #+4]
   \      0x9F8   0x2822             CMP      R0,#+34
   \      0x9FA   0xD170             BNE.N    ??sbcSemMsgProcess_121
    964                        {
    965                          pWord = (uint16_t *)pMsg->dataToSend.pData;
   \      0x9FC   0x68A0             LDR      R0,[R4, #+8]
   \      0x9FE   0x9003             STR      R0,[SP, #+12]
    966                          if (((uint16_t)SCU_S_PS_STARTUP == *pWord) || ((uint16_t)SCU_S_PS_LIVE == *pWord))  // SCU_S_PS_STARTUP = SCU_S_S = 4 or SCU_S_PS_LIVE in polling phase 
   \      0xA00   0x9803             LDR      R0,[SP, #+12]
   \      0xA02   0x8800             LDRH     R0,[R0, #+0]
   \      0xA04   0x2804             CMP      R0,#+4
   \      0xA06   0xD003             BEQ.N    ??sbcSemMsgProcess_134
   \      0xA08   0x9803             LDR      R0,[SP, #+12]
   \      0xA0A   0x8800             LDRH     R0,[R0, #+0]
   \      0xA0C   0x2805             CMP      R0,#+5
   \      0xA0E   0xD157             BNE.N    ??sbcSemMsgProcess_135
    967                          {
    968                            ixLogic = getLogicalMdbAddrSem();
   \                     ??sbcSemMsgProcess_134: (+1)
   \      0xA10   0x.... 0x....      BL       getLogicalMdbAddrSem
   \      0xA14   0x0005             MOVS     R5,R0
    969                            maskBit = sbcSemMaskBit[ixLogic];
   \      0xA16   0x4827             LDR.N    R0,??sbcSemMsgProcess_0+12
   \      0xA18   0x0029             MOVS     R1,R5
   \      0xA1A   0xB289             UXTH     R1,R1
   \      0xA1C   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \      0xA20   0x0006             MOVS     R6,R0
    970          #ifdef POLLING_ONLY_INACTIVE
    971                            /* the slave responde to polling only if has been inactive during polling period (about 6 sec) */
    972                            if ((socketPresence.keyPresence == KEY_FULL_CONFIG) && 
    973                                ((sbcSemInfoMng.offLine == TRUE) || ((sbcSemInfoMng.activityStatus & maskBit) == 0) || (((uint16_t)SCU_S_S == *pWord))))
    974          #else
    975                            /* the slave responde to polling always (about 6 sec) */
    976                            if (socketPresence.keyPresence == KEY_FULL_CONFIG)
   \      0xA22   0x48D4             LDR.N    R0,??sbcSemMsgProcess_1+8
   \      0xA24   0x6880             LDR      R0,[R0, #+8]
   \      0xA26   0xF64A 0x2155      MOVW     R1,#+43605
   \      0xA2A   0x4288             CMP      R0,R1
   \      0xA2C   0xD144             BNE.N    ??sbcSemMsgProcess_136
    977          #endif
    978                            {
    979                              sbcSemInfoMng.offLine = FALSE;
   \      0xA2E   0x2000             MOVS     R0,#+0
   \      0xA30   0xF88A 0x0027      STRB     R0,[R10, #+39]
    980                              /* the address in ADDR_CONNECTOR_IDS_RW has been already assigned by master */
    981                              currFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \      0xA34   0xF8DF 0xB53C      LDR.W    R11,??sbcSemMsgProcess_3
   \      0xA38   0x2002             MOVS     R0,#+2
   \      0xA3A   0xF8AB 0x0000      STRH     R0,[R11, #+0]
    982                              currFrameSbcSem.data.index = getPhysicalMdbAddr();  /* rs485SemMsgProcess() use phisical address 1...16 */
   \      0xA3E   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0xA42   0xF8AB 0x0002      STRH     R0,[R11, #+2]
    983                              //currFrameSbcSem.data.rAddr = ADDR_CONNECTOR_IDS_RW;
    984                              currFrameSbcSem.data.rAddr = ADDR_EVSE_TM_RW;  // ADDR_EVSE_CHARGE_STATUS_RO or ADDR_EVSE_TM_RW
   \      0xA46   0x2022             MOVS     R0,#+34
   \      0xA48   0xF8AB 0x0004      STRH     R0,[R11, #+4]
    985                              
    986                              currFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \      0xA4C   0xF11A 0x0004      ADDS     R0,R10,#+4
   \      0xA50   0xF8CB 0x0008      STR      R0,[R11, #+8]
    987                              /* to avoid possible conflit on first Tx byte a random delay is used  */
    988                              osDelay((uint32_t)10 * (uint32_t)currFrameSbcSem.data.index);  /* delay in the range 2...50 msec */
   \      0xA54   0xF8BB 0x0002      LDRH     R0,[R11, #+2]
   \      0xA58   0x210A             MOVS     R1,#+10
   \      0xA5A   0x4348             MULS     R0,R1,R0
   \      0xA5C   0x.... 0x....      BL       osDelay
    989                              configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xA60   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xA64   0x2300             MOVS     R3,#+0
   \      0xA66   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xA6A   0x4659             MOV      R1,R11
   \      0xA6C   0x.... 0x....      BL       xQueueGenericSend
   \      0xA70   0x2801             CMP      R0,#+1
   \      0xA72   0xD009             BEQ.N    ??sbcSemMsgProcess_137
   \      0xA74   0xB672             CPSID    I
   \      0xA76   0x2050             MOVS     R0,#+80
   \      0xA78   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xA7C   0xF3BF 0x8F4F      DSB      SY
   \      0xA80   0xF3BF 0x8F6F      ISB      SY
   \      0xA84   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_138: (+1)
   \      0xA86   0xE7FE             B.N      ??sbcSemMsgProcess_138
    990                              sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_WR_MASTER_POLL_ACK;
   \                     ??sbcSemMsgProcess_137: (+1)
   \      0xA88   0x2007             MOVS     R0,#+7
   \      0xA8A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
    991                              // start ACK timer 
    992                              xTimerReset (xSbcSemTimers[TIMER_FOR_ACK], 0);
   \      0xA8E   0x.... 0x....      BL       xTaskGetTickCount
   \      0xA92   0x0002             MOVS     R2,R0
   \      0xA94   0x2000             MOVS     R0,#+0
   \      0xA96   0x9000             STR      R0,[SP, #+0]
   \      0xA98   0x2300             MOVS     R3,#+0
   \      0xA9A   0x2102             MOVS     R1,#+2
   \      0xA9C   0x4802             LDR.N    R0,??sbcSemMsgProcess_0
   \      0xA9E   0x6840             LDR      R0,[R0, #+4]
   \      0xAA0   0x.... 0x....      BL       xTimerGenericCommand
   \      0xAA4   0xE01B             B.N      ??sbcSemMsgProcess_121
   \      0xAA6   0xBF00             Nop
   \                     ??sbcSemMsgProcess_0:
   \      0xAA8   0x....'....        DC32     xSbcSemTimers
   \      0xAAC   0x....'....        DC32     sbcSemInfoMng
   \      0xAB0   0x....'....        DC32     headMsg
   \      0xAB4   0x....'....        DC32     sbcSemMaskBit
    993                            }
    994                            else
    995                            {
    996                              sbcSemInfoMng.activityStatus = 0;
   \                     ??sbcSemMsgProcess_136: (+1)
   \      0xAB8   0x2000             MOVS     R0,#+0
   \      0xABA   0xF8CA 0x0014      STR      R0,[R10, #+20]
   \      0xABE   0xE00E             B.N      ??sbcSemMsgProcess_121
    997                            }
    998                          }
    999                          else
   1000                          {
   1001                            if ((uint16_t)SCU_ALL_FACTORY_PARAM == *pWord) 
   \                     ??sbcSemMsgProcess_135: (+1)
   \      0xAC0   0x9803             LDR      R0,[SP, #+12]
   \      0xAC2   0x8800             LDRH     R0,[R0, #+0]
   \      0xAC4   0xF64F 0x71EC      MOVW     R1,#+65516
   \      0xAC8   0x4288             CMP      R0,R1
   \      0xACA   0xD108             BNE.N    ??sbcSemMsgProcess_121
   1002                            {
   1003                              /* for debug only */
   1004                              restoreFactoryDefault();
   \      0xACC   0x.... 0x....      BL       restoreFactoryDefault
   \      0xAD0   0xE005             B.N      ??sbcSemMsgProcess_121
   1005                            }
   1006                          }
   1007                        }
   1008                      }
   1009                      else
   1010                      {
   1011                        /* SCU slave: a write operation has been done from master over RS485, so an update can be possible  */
   1012                        semUpdateConfig(pMsg);
   \                     ??sbcSemMsgProcess_133: (+1)
   \      0xAD2   0x0020             MOVS     R0,R4
   \      0xAD4   0x.... 0x....      BL       semUpdateConfig
   1013                        osDelay(10);
   \      0xAD8   0x200A             MOVS     R0,#+10
   \      0xADA   0x.... 0x....      BL       osDelay
   1014                      }
   1015                    }
   1016                    break;
   \                     ??sbcSemMsgProcess_121: (+1)
   \      0xADE   0xE1A7             B.N      ??sbcSemMsgProcess_130
   1017          
   1018                  case SBC_SEM_EVENT_UART5_SEND_DWLD_CMD:
   1019                  case SBC_SEM_EVENT_UART5:
   1020                    locScuMode = getScuOpMode();
   \                     ??sbcSemMsgProcess_112: (+1)
   \      0xAE0   0x.... 0x....      BL       getScuOpMode
   \      0xAE4   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1021                    /* message coming from SBC: the writing can be referred to the master or for a slave  */
   1022                    if ((locScuMode == SCU_M_P) && (getPhysicalMdbAddr() == pMsg->data.index))
   \      0xAE8   0xF8BD 0x000A      LDRH     R0,[SP, #+10]
   \      0xAEC   0x2802             CMP      R0,#+2
   \      0xAEE   0xD10A             BNE.N    ??sbcSemMsgProcess_139
   \      0xAF0   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0xAF4   0xB2C0             UXTB     R0,R0
   \      0xAF6   0x8861             LDRH     R1,[R4, #+2]
   \      0xAF8   0xB280             UXTH     R0,R0
   \      0xAFA   0x4288             CMP      R0,R1
   \      0xAFC   0xD103             BNE.N    ??sbcSemMsgProcess_139
   1023                    {
   1024                      /* the write operation refer the SCU MASTER */
   1025                      semUpdateConfig(pMsg);
   \      0xAFE   0x0020             MOVS     R0,R4
   \      0xB00   0x.... 0x....      BL       semUpdateConfig
   \      0xB04   0xE053             B.N      ??sbcSemMsgProcess_140
   1026                    }
   1027                    else
   1028                    {
   1029                      if ((locScuMode == SCU_M_STAND_ALONE) && ((pMsg->data.rAddr == ADDR_FILE_COMMAND_RW) || (pMsg->data.rAddr == ADDR_FILE_SIZE_RW)) &&  
   1030                          (pMsg->sbcSemEvent != SBC_SEM_EVENT_UART5_SEND_DWLD_CMD))
   \                     ??sbcSemMsgProcess_139: (+1)
   \      0xB06   0xF8BD 0x000A      LDRH     R0,[SP, #+10]
   \      0xB0A   0x2805             CMP      R0,#+5
   \      0xB0C   0xD10B             BNE.N    ??sbcSemMsgProcess_141
   \      0xB0E   0x88A0             LDRH     R0,[R4, #+4]
   \      0xB10   0xF5B0 0x7F80      CMP      R0,#+256
   \      0xB14   0xD004             BEQ.N    ??sbcSemMsgProcess_142
   \      0xB16   0x88A0             LDRH     R0,[R4, #+4]
   \      0xB18   0xF240 0x1101      MOVW     R1,#+257
   \      0xB1C   0x4288             CMP      R0,R1
   \      0xB1E   0xD102             BNE.N    ??sbcSemMsgProcess_141
   \                     ??sbcSemMsgProcess_142: (+1)
   \      0xB20   0x8820             LDRH     R0,[R4, #+0]
   \      0xB22   0x280D             CMP      R0,#+13
   \      0xB24   0xD143             BNE.N    ??sbcSemMsgProcess_140
   1031                      {
   1032                        /* the stand alone SCU send the FW upload message on RS485 only at received both info  */
   1033                      }
   1034                      else
   1035                      {
   1036                        pScuRoMapRegSlave = getRoMdbRegs(ixLogic);
   \                     ??sbcSemMsgProcess_141: (+1)
   \      0xB26   0x0028             MOVS     R0,R5
   \      0xB28   0xB2C0             UXTB     R0,R0
   \      0xB2A   0x.... 0x....      BL       getRoMdbRegs
   \      0xB2E   0x9004             STR      R0,[SP, #+16]
   1037                        if (((pScuRoMapRegSlave->scuMapRegNotify.ntfErr2 & ERROR2_OFFL) == 0) && (pollingSlaveMng.offLineCounter[ixLogic] == 0))
   \      0xB30   0x9804             LDR      R0,[SP, #+16]
   \      0xB32   0xF890 0x0100      LDRB     R0,[R0, #+256]
   \      0xB36   0x0700             LSLS     R0,R0,#+28
   \      0xB38   0xD439             BMI.N    ??sbcSemMsgProcess_140
   \      0xB3A   0x.... 0x....      LDR.W    R0,??DataTable6
   \      0xB3E   0x0029             MOVS     R1,R5
   \      0xB40   0xB289             UXTH     R1,R1
   \      0xB42   0x4408             ADD      R0,R0,R1
   \      0xB44   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \      0xB48   0x2800             CMP      R0,#+0
   \      0xB4A   0xD130             BNE.N    ??sbcSemMsgProcess_140
   1038                        {
   1039                           /* we transfer the request on RS485 only if the slave is present on the RS485.  */
   1040                           /* If the master has lost the link sending info to the slave has no sense       */
   1041                          /* the write operation refer the SCU SLAVE so the writing must be sent over RS485  */
   1042                          /* no more master secondary SCU are present in the chain */
   1043                          sbcSemInfoMng.dataVal = (uint16_t)1;  // for discovery primary/secondary slave SCU 
   \      0xB4C   0x2001             MOVS     R0,#+1
   \      0xB4E   0xF8AA 0x0004      STRH     R0,[R10, #+4]
   1044                          currFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \      0xB52   0xF8DF 0xB420      LDR.W    R11,??sbcSemMsgProcess_3
   \      0xB56   0x2003             MOVS     R0,#+3
   \      0xB58   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1045                          currFrameSbcSem.data.index = pMsg->data.index;  // phisical address 1...16 or 0 for broadcast 
   \      0xB5C   0x8860             LDRH     R0,[R4, #+2]
   \      0xB5E   0xF8AB 0x0002      STRH     R0,[R11, #+2]
   1046                          currFrameSbcSem.data.rAddr = pMsg->data.rAddr;
   \      0xB62   0x88A0             LDRH     R0,[R4, #+4]
   \      0xB64   0xF8AB 0x0004      STRH     R0,[R11, #+4]
   1047                          currFrameSbcSem.dataToSend.len = pMsg->dataToSend.len;
   \      0xB68   0x88E0             LDRH     R0,[R4, #+6]
   \      0xB6A   0xF8AB 0x0006      STRH     R0,[R11, #+6]
   1048                          currFrameSbcSem.dataToSend.pData = (uint8_t*)pMsg->dataToSend.pData;
   \      0xB6E   0x68A0             LDR      R0,[R4, #+8]
   \      0xB70   0xF8CB 0x0008      STR      R0,[R11, #+8]
   1049                          configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xB74   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xB78   0x2300             MOVS     R3,#+0
   \      0xB7A   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xB7E   0x4659             MOV      R1,R11
   \      0xB80   0x.... 0x....      BL       xQueueGenericSend
   \      0xB84   0x2801             CMP      R0,#+1
   \      0xB86   0xD009             BEQ.N    ??sbcSemMsgProcess_143
   \      0xB88   0xB672             CPSID    I
   \      0xB8A   0x2050             MOVS     R0,#+80
   \      0xB8C   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xB90   0xF3BF 0x8F4F      DSB      SY
   \      0xB94   0xF3BF 0x8F6F      ISB      SY
   \      0xB98   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_144: (+1)
   \      0xB9A   0xE7FE             B.N      ??sbcSemMsgProcess_144
   1050                          if (pMsg->data.index != MODBUS_BROADCAST_ADDR)
   \                     ??sbcSemMsgProcess_143: (+1)
   \      0xB9C   0x8860             LDRH     R0,[R4, #+2]
   \      0xB9E   0x2800             CMP      R0,#+0
   \      0xBA0   0xD005             BEQ.N    ??sbcSemMsgProcess_140
   1051                          {
   1052                            timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_RESP); 
   \      0xBA2   0xF44F 0x70FA      MOV      R0,#+500
   \      0xBA6   0x0007             MOVS     R7,R0
   1053                            sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_WR_ACK;
   \      0xBA8   0x2005             MOVS     R0,#+5
   \      0xBAA   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1054                          }
   1055                        }
   1056                      }
   1057                    }
   1058                    break;
   \                     ??sbcSemMsgProcess_140: (+1)
   \      0xBAE   0xE13F             B.N      ??sbcSemMsgProcess_130
   1059          
   1060                  case NOTIFY_TO_MASTER_TX:
   1061                    if ((getScuOpMode() == SCU_M_P) && (getPhysicalMdbAddr() == pMsg->data.index))
   \                     ??sbcSemMsgProcess_113: (+1)
   \      0xBB0   0x.... 0x....      BL       getScuOpMode
   \      0xBB4   0x2802             CMP      R0,#+2
   \      0xBB6   0xD120             BNE.N    ??sbcSemMsgProcess_145
   \      0xBB8   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0xBBC   0xB2C0             UXTB     R0,R0
   \      0xBBE   0x8861             LDRH     R1,[R4, #+2]
   \      0xBC0   0xB280             UXTH     R0,R0
   \      0xBC2   0x4288             CMP      R0,R1
   \      0xBC4   0xD119             BNE.N    ??sbcSemMsgProcess_145
   1062                    {
   1063                      result = (uint8_t)setChangeRegisterBit(ixScu, pMsg, (uint32_t)maskBit, ixLogic); 
   \      0xBC6   0x002B             MOVS     R3,R5
   \      0xBC8   0xB29B             UXTH     R3,R3
   \      0xBCA   0x0032             MOVS     R2,R6
   \      0xBCC   0x0021             MOVS     R1,R4
   \      0xBCE   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \      0xBD2   0x.... 0x....      BL       setChangeRegisterBit
   \      0xBD6   0x4680             MOV      R8,R0
   1064                      if (result == (uint8_t)SEND_RETRY)
   \      0xBD8   0x4640             MOV      R0,R8
   \      0xBDA   0xB2C0             UXTB     R0,R0
   \      0xBDC   0x2802             CMP      R0,#+2
   \      0xBDE   0xD108             BNE.N    ??sbcSemMsgProcess_146
   1065                      {
   1066                        /* the current message cannot be managed now, so put in the list */
   1067                        headMsg = addNode(headMsg, pMsg);
   \      0xBE0   0x.... 0x....      LDR.W    R10,??DataTable7
   \      0xBE4   0x0021             MOVS     R1,R4
   \      0xBE6   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xBEA   0x.... 0x....      BL       addNode
   \      0xBEE   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1068                      }
   1069                      osDelay(100);
   \                     ??sbcSemMsgProcess_146: (+1)
   \      0xBF2   0x2064             MOVS     R0,#+100
   \      0xBF4   0x.... 0x....      BL       osDelay
   \      0xBF8   0xE05A             B.N      ??sbcSemMsgProcess_147
   1070                    }
   1071                    else
   1072                    {
   1073                      /* if FW update is ongoing on a slave device, don't notify changes to master */
   1074                      if (getStatusDwnl() == FALSE)
   \                     ??sbcSemMsgProcess_145: (+1)
   \      0xBFA   0x.... 0x....      BL       getStatusDwnl
   \      0xBFE   0x2800             CMP      R0,#+0
   \      0xC00   0xD156             BNE.N    ??sbcSemMsgProcess_147
   1075                      {
   1076                        result = (uint8_t)setChangeRegisterBit(SCU_M_P_ADDR, pMsg, (uint32_t)maskBit, ixLogic);
   \      0xC02   0x002B             MOVS     R3,R5
   \      0xC04   0xB29B             UXTH     R3,R3
   \      0xC06   0x0032             MOVS     R2,R6
   \      0xC08   0x0021             MOVS     R1,R4
   \      0xC0A   0x2001             MOVS     R0,#+1
   \      0xC0C   0x.... 0x....      BL       setChangeRegisterBit
   \      0xC10   0x4680             MOV      R8,R0
   1077                        if (result == (uint8_t)SEND_ACK)
   \      0xC12   0x4640             MOV      R0,R8
   \      0xC14   0xB2C0             UXTB     R0,R0
   \      0xC16   0x2801             CMP      R0,#+1
   \      0xC18   0xD13A             BNE.N    ??sbcSemMsgProcess_148
   1078                        {
   1079                          /* a change inside a slave occured. Data must be sent to master over RS485  */
   1080                          currFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \      0xC1A   0xF8DF 0xB358      LDR.W    R11,??sbcSemMsgProcess_3
   \      0xC1E   0x2002             MOVS     R0,#+2
   \      0xC20   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1081                          currFrameSbcSem.data.index = pMsg->data.index;  //  physical address 1...16 
   \      0xC24   0x8860             LDRH     R0,[R4, #+2]
   \      0xC26   0xF8AB 0x0002      STRH     R0,[R11, #+2]
   1082                          currFrameSbcSem.data.rAddr = pMsg->data.rAddr;
   \      0xC2A   0x88A0             LDRH     R0,[R4, #+4]
   \      0xC2C   0xF8AB 0x0004      STRH     R0,[R11, #+4]
   1083                          currFrameSbcSem.dataToSend.len = pMsg->dataToSend.len;
   \      0xC30   0x88E0             LDRH     R0,[R4, #+6]
   \      0xC32   0xF8AB 0x0006      STRH     R0,[R11, #+6]
   1084                          currFrameSbcSem.dataToSend.pData = (uint8_t*)&pMsg->dataToSend.pData;
   \      0xC36   0xF114 0x0008      ADDS     R0,R4,#+8
   \      0xC3A   0xF8CB 0x0008      STR      R0,[R11, #+8]
   1085                          configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xC3E   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xC42   0x2300             MOVS     R3,#+0
   \      0xC44   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xC48   0x4659             MOV      R1,R11
   \      0xC4A   0x.... 0x....      BL       xQueueGenericSend
   \      0xC4E   0x2801             CMP      R0,#+1
   \      0xC50   0xD009             BEQ.N    ??sbcSemMsgProcess_149
   \      0xC52   0xB672             CPSID    I
   \      0xC54   0x2050             MOVS     R0,#+80
   \      0xC56   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xC5A   0xF3BF 0x8F4F      DSB      SY
   \      0xC5E   0xF3BF 0x8F6F      ISB      SY
   \      0xC62   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_150: (+1)
   \      0xC64   0xE7FE             B.N      ??sbcSemMsgProcess_150
   1086                          /* reset the activity bit: will be set when ACK will be received */
   1087                          sbcSemInfoMng.activityStatus &= (~maskBit);
   \                     ??sbcSemMsgProcess_149: (+1)
   \      0xC66   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0xC6A   0x43B0             BICS     R0,R0,R6
   \      0xC6C   0xF8CA 0x0014      STR      R0,[R10, #+20]
   1088          
   1089                          // start ACK timer 
   1090                          xTimerReset (xSbcSemTimers[TIMER_FOR_ACK], 0);
   \      0xC70   0x.... 0x....      BL       xTaskGetTickCount
   \      0xC74   0x2100             MOVS     R1,#+0
   \      0xC76   0x9100             STR      R1,[SP, #+0]
   \      0xC78   0x2300             MOVS     R3,#+0
   \      0xC7A   0x0002             MOVS     R2,R0
   \      0xC7C   0x2102             MOVS     R1,#+2
   \      0xC7E   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0xC82   0x6840             LDR      R0,[R0, #+4]
   \      0xC84   0x.... 0x....      BL       xTimerGenericCommand
   1091                          sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_WR_MASTER_ACK;
   \      0xC88   0x2006             MOVS     R0,#+6
   \      0xC8A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   \      0xC8E   0xE00F             B.N      ??sbcSemMsgProcess_147
   1092                        }
   1093                        else
   1094                        {
   1095                          if (result == (uint8_t)SEND_RETRY)
   \                     ??sbcSemMsgProcess_148: (+1)
   \      0xC90   0x4640             MOV      R0,R8
   \      0xC92   0xB2C0             UXTB     R0,R0
   \      0xC94   0x2802             CMP      R0,#+2
   \      0xC96   0xD10B             BNE.N    ??sbcSemMsgProcess_147
   1096                          {
   1097                            /* the current message cannot be managed now, so restore it in first position The sequence timing cannot be modified!  */
   1098                            headMsg = addNode(headMsg, pMsg);
   \      0xC98   0x.... 0x....      LDR.W    R10,??DataTable7
   \      0xC9C   0x0021             MOVS     R1,R4
   \      0xC9E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xCA2   0x.... 0x....      BL       addNode
   \      0xCA6   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1099                            osDelay(100);
   \      0xCAA   0x2064             MOVS     R0,#+100
   \      0xCAC   0x.... 0x....      BL       osDelay
   1100                          }
   1101                        }
   1102                      }
   1103                    }
   1104                    break;
   \                     ??sbcSemMsgProcess_147: (+1)
   \      0xCB0   0xE0BE             B.N      ??sbcSemMsgProcess_130
   1105          
   1106                  case SCU_EVENT_MSG_FROM_SBC_RD:
   1107                    if (resetChangeRegisterBit(ixLogic, pMsg->data.rAddr, pMsg->dataToSend.len) == TRUE)
   \                     ??sbcSemMsgProcess_116: (+1)
   \      0xCB2   0x88E2             LDRH     R2,[R4, #+6]
   \      0xCB4   0x88A1             LDRH     R1,[R4, #+4]
   \      0xCB6   0x0028             MOVS     R0,R5
   \      0xCB8   0xB280             UXTH     R0,R0
   \      0xCBA   0x.... 0x....      BL       resetChangeRegisterBit
   \      0xCBE   0x2801             CMP      R0,#+1
   \      0xCC0   0xD111             BNE.N    ??sbcSemMsgProcess_151
   1108                    {
   1109                      sbcSemInfoMng.sbcActive = TRUE;
   \      0xCC2   0x2001             MOVS     R0,#+1
   \      0xCC4   0xF88A 0x0028      STRB     R0,[R10, #+40]
   1110                      //tPrintf("Socket %d Event 0x%X closed!\n\r", ixScu, pMsg->data.rAddr);
   1111                      if (headMsg != NULL)
   \      0xCC8   0x.... 0x....      LDR.W    R10,??DataTable7
   \      0xCCC   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xCD0   0x2800             CMP      R0,#+0
   \      0xCD2   0xD006             BEQ.N    ??sbcSemMsgProcess_152
   1112                      {
   1113                        /* re-send a message in the queue list if present */
   1114                        headMsg = extractSendFirstInList(headMsg);
   \      0xCD4   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xCD8   0x.... 0x....      BL       extractSendFirstInList
   \      0xCDC   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \      0xCE0   0xE001             B.N      ??sbcSemMsgProcess_151
   1115                      }
   1116                      else
   1117                      {
   1118                        resetPacketStatusNum();
   \                     ??sbcSemMsgProcess_152: (+1)
   \      0xCE2   0x.... 0x....      BL       resetPacketStatusNum
   1119                      }
   1120                    }
   1121                    break;
   \                     ??sbcSemMsgProcess_151: (+1)
   \      0xCE6   0xE0A3             B.N      ??sbcSemMsgProcess_130
   1122          
   1123                  case SCU_EVENT_MSG_FROM_MASTER_RD:
   1124                    if (getPhysicalMdbAddr() == pMsg->data.index)  // phisical address 1...16 
   \                     ??sbcSemMsgProcess_117: (+1)
   \      0xCE8   0x.... 0x....      BL       getPhysicalMdbAddr
   1125                    {
   1126                      ;
   1127                    }
   1128                    break;
   \      0xCEC   0xE0A0             B.N      ??sbcSemMsgProcess_130
   1129                    
   1130                  case SBC_SEM_TIMEOUT:
   1131                  case RECOVERY_INFO:
   1132                    while (txRS485Available() == (uint8_t)FALSE) osDelay(100);
   \                     ??sbcSemMsgProcess_114: (+1)
   \      0xCEE   0x.... 0x....      BL       txRS485Available
   \      0xCF2   0x2800             CMP      R0,#+0
   \      0xCF4   0xD103             BNE.N    ??sbcSemMsgProcess_153
   \      0xCF6   0x2064             MOVS     R0,#+100
   \      0xCF8   0x.... 0x....      BL       osDelay
   \      0xCFC   0xE7F7             B.N      ??sbcSemMsgProcess_114
   1133                    if (getInfoSocket((sbcSemInfoMng.activityStatus & (~sbcSemInfoMng.activeLastDiscovery)), &sbcSemInfoMng) == FALSE)
   \                     ??sbcSemMsgProcess_153: (+1)
   \      0xCFE   0x.... 0x....      LDR.W    R10,??DataTable8_1
   \      0xD02   0x4651             MOV      R1,R10
   \      0xD04   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0xD08   0xF8DA 0x2020      LDR      R2,[R10, #+32]
   \      0xD0C   0x4390             BICS     R0,R0,R2
   \      0xD0E   0x.... 0x....      BL       getInfoSocket
   \      0xD12   0x2800             CMP      R0,#+0
   \      0xD14   0xD138             BNE.N    ??sbcSemMsgProcess_154
   1134                    {
   1135          
   1136                      /* force the SBC to read new data from added SCU */
   1137                      forceSBCreadScu(sbcSemInfoMng.activityStatus & (~sbcSemInfoMng.activeLastDiscovery));
   \      0xD16   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \      0xD1A   0xF8DA 0x1020      LDR      R1,[R10, #+32]
   \      0xD1E   0x4388             BICS     R0,R0,R1
   \      0xD20   0x.... 0x....      BL       forceSBCreadScu
   1138          
   1139                      /* all new add socket has been discovered */
   1140                      sbcSemInfoMng.activeLastDiscovery = socketPresence.chainPresence = socketPresence.livePresence;
   \      0xD24   0xF8DF 0xB04C      LDR.W    R11,??sbcSemMsgProcess_1+8
   \      0xD28   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \      0xD2C   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \      0xD30   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0xD34   0xF8CA 0x0020      STR      R0,[R10, #+32]
   1141          
   1142                      /* save in EEPROM also  */
   1143                      if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \      0xD38   0x2254             MOVS     R2,#+84
   \      0xD3A   0x4659             MOV      R1,R11
   \      0xD3C   0xF44F 0x50F4      MOV      R0,#+7808
   \      0xD40   0x.... 0x....      BL       WriteOnEeprom
   \      0xD44   0x2800             CMP      R0,#+0
   \      0xD46   0xD105             BNE.N    ??sbcSemMsgProcess_155
   1144                      {
   1145                        tPrintf("Presences detected --> 0x%x\n\r", socketPresence.chainPresence);
   \      0xD48   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0xD4C   0x.... 0x....      LDR.W    R0,??DataTable9
   \      0xD50   0x.... 0x....      BL       tPrintf
   1146                      }
   1147          
   1148                      /* save all the slave parameters in external flash mememory to restore it in the future */
   1149                      saveAllSlaveParameters();
   \                     ??sbcSemMsgProcess_155: (+1)
   \      0xD54   0x.... 0x....      BL       saveAllSlaveParameters
   1150          
   1151                      sbcSemInfoMng.discoveryMask = 0;
   \      0xD58   0x2000             MOVS     R0,#+0
   \      0xD5A   0xF8CA 0x000A      STR      R0,[R10, #+10]
   1152                      timeTickTmp = portMAX_DELAY;
   \      0xD5E   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0xD62   0x0007             MOVS     R7,R0
   1153                      Print_Slave_FW_Version();
   \      0xD64   0x.... 0x....      BL       Print_Slave_FW_Version
   \      0xD68   0xE011             B.N      ??sbcSemMsgProcess_156
   \      0xD6A   0xBF00             Nop
   \                     ??sbcSemMsgProcess_1:
   \      0xD6C   0x....'....        DC32     pScuRoMapReg
   \      0xD70   0x....'....        DC32     pScuTmMapReg
   \      0xD74   0x....'....        DC32     socketPresence
   \      0xD78   0x....'....        DC32     Default_Socket_Presence+16
   \      0xD7C   0x....'....        DC32     Default_Socket_Presence+48
   \      0xD80   0x....'....        DC32     ?_19
   \      0xD84   0x....'....        DC32     Default_Socket_Presence
   1154                    }
   1155                    else
   1156                    {
   1157                      timeTickTmp = TIMEOUT_ACK_RESP;
   \                     ??sbcSemMsgProcess_154: (+1)
   \      0xD88   0xF44F 0x70FA      MOV      R0,#+500
   \      0xD8C   0x0007             MOVS     R7,R0
   1158                    }
   1159                    break;
   \                     ??sbcSemMsgProcess_156: (+1)
   \      0xD8E   0xE04F             B.N      ??sbcSemMsgProcess_130
   1160          
   1161                  case NOTIFY_MODBUS_RD_ACK:
   1162                    if (((sbcSemInfoMng.logicIdSocket + 1) == pMsg->data.index) && (sbcSemInfoMng.dataVal == pMsg->dataToSend.len))
   \                     ??sbcSemMsgProcess_115: (+1)
   \      0xD90   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0xD94   0x1C40             ADDS     R0,R0,#+1
   \      0xD96   0x8861             LDRH     R1,[R4, #+2]
   \      0xD98   0x4288             CMP      R0,R1
   \      0xD9A   0xD148             BNE.N    ??sbcSemMsgProcess_157
   \      0xD9C   0xF8BA 0x0004      LDRH     R0,[R10, #+4]
   \      0xDA0   0x88E1             LDRH     R1,[R4, #+6]
   \      0xDA2   0x4288             CMP      R0,R1
   \      0xDA4   0xD143             BNE.N    ??sbcSemMsgProcess_157
   1163                    {
   1164                      /* a previous request to read has been accepted and new data are arrived so store it in the map */
   1165                      void* pSrc = (void*)((uint32_t)pMsg->dataToSend.pData + (uint32_t)sizeof(headerAnswRHR_t));
   \      0xDA6   0x68A0             LDR      R0,[R4, #+8]
   \      0xDA8   0x1CC0             ADDS     R0,R0,#+3
   \      0xDAA   0x9006             STR      R0,[SP, #+24]
   1166                      /*      destination                  source                         length */
   1167                      memcpy((void*)sbcSemInfoMng.pDataRd, pSrc, (size_t)(pMsg->dataToSend.len));
   \      0xDAC   0xF8DA 0xB00E      LDR      R11,[R10, #+14]
   \      0xDB0   0x88E0             LDRH     R0,[R4, #+6]
   \      0xDB2   0x9001             STR      R0,[SP, #+4]
   \      0xDB4   0x9806             LDR      R0,[SP, #+24]
   \      0xDB6   0x9000             STR      R0,[SP, #+0]
   \      0xDB8   0x9A01             LDR      R2,[SP, #+4]
   \      0xDBA   0x9900             LDR      R1,[SP, #+0]
   \      0xDBC   0x4658             MOV      R0,R11
   \      0xDBE   0x.... 0x....      BL       __aeabi_memcpy
   1168                      if (sbcSemInfoMng.addrVal == ADDR_START_RDD)
   \      0xDC2   0xF8BA 0x0006      LDRH     R0,[R10, #+6]
   \      0xDC6   0xF5B0 0x7F40      CMP      R0,#+768
   \      0xDCA   0xD10D             BNE.N    ??sbcSemMsgProcess_158
   1169                      {
   1170                        /* point to next possible slave */
   1171                        sbcSemInfoMng.addrVal = ADDR_START_RDD;
   \      0xDCC   0xF44F 0x7040      MOV      R0,#+768
   \      0xDD0   0xF8AA 0x0006      STRH     R0,[R10, #+6]
   1172                        sbcSemInfoMng.discoveryMask = sbcSemInfoMng.discoveryMask << 1;
   \      0xDD4   0xF11A 0x000A      ADDS     R0,R10,#+10
   \      0xDD8   0x6801             LDR      R1,[R0, #+0]
   \      0xDDA   0x0049             LSLS     R1,R1,#+1
   \      0xDDC   0x6001             STR      R1,[R0, #+0]
   1173                        sbcSemInfoMng.logicIdSocket++;
   \      0xDDE   0xF8BA 0x0008      LDRH     R0,[R10, #+8]
   \      0xDE2   0x1C40             ADDS     R0,R0,#+1
   \      0xDE4   0xF8AA 0x0008      STRH     R0,[R10, #+8]
   1174                      }
   1175                      /* timeout 20ms for next reading   */
   1176                      timeTickTmp = pdMS_TO_TICKS(TIMEOUT_RD_REQ);  
   \                     ??sbcSemMsgProcess_158: (+1)
   \      0xDE8   0x2014             MOVS     R0,#+20
   \      0xDEA   0x0007             MOVS     R7,R0
   1177                      /* release the transmitter */
   1178                      currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;             
   \      0xDEC   0xF8DF 0xA184      LDR.W    R10,??sbcSemMsgProcess_3
   \      0xDF0   0x2005             MOVS     R0,#+5
   \      0xDF2   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1179                      configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xDF6   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xDFA   0x2300             MOVS     R3,#+0
   \      0xDFC   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xE00   0x4651             MOV      R1,R10
   \      0xE02   0x.... 0x....      BL       xQueueGenericSend
   \      0xE06   0x2801             CMP      R0,#+1
   \      0xE08   0xD009             BEQ.N    ??sbcSemMsgProcess_159
   \      0xE0A   0xB672             CPSID    I
   \      0xE0C   0x2050             MOVS     R0,#+80
   \      0xE0E   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xE12   0xF3BF 0x8F4F      DSB      SY
   \      0xE16   0xF3BF 0x8F6F      ISB      SY
   \      0xE1A   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_160: (+1)
   \      0xE1C   0xE7FE             B.N      ??sbcSemMsgProcess_160
   1180                      /* release the buffer  */
   1181                      if (pMsg->dataToSend.pData != NULL) 
   \                     ??sbcSemMsgProcess_159: (+1)
   \      0xE1E   0x68A0             LDR      R0,[R4, #+8]
   \      0xE20   0x2800             CMP      R0,#+0
   \      0xE22   0xD004             BEQ.N    ??sbcSemMsgProcess_157
   1182                      {
   1183                        free((void*)pMsg->dataToSend.pData);
   \      0xE24   0x68A0             LDR      R0,[R4, #+8]
   \      0xE26   0x.... 0x....      BL       free
   1184                        pMsg->dataToSend.pData = NULL;
   \      0xE2A   0x2000             MOVS     R0,#+0
   \      0xE2C   0x60A0             STR      R0,[R4, #+8]
   1185                      }
   1186                    }
   1187                    break;
   \                     ??sbcSemMsgProcess_157: (+1)
   \      0xE2E   0xE7FF             B.N      ??sbcSemMsgProcess_130
   1188          
   1189                  default:
   1190                    break;
   1191          
   1192                }
   1193                break;
   \                     ??sbcSemMsgProcess_118: (+1)
   \                     ??sbcSemMsgProcess_130: (+1)
   \      0xE30   0xE14A             B.N      ??sbcSemMsgProcess_37
   1194          
   1195              case SBC_SEM_WAIT_WR_ACK:
   1196                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_12: (+1)
   \      0xE32   0x8820             LDRH     R0,[R4, #+0]
   \      0xE34   0x1E40             SUBS     R0,R0,#+1
   \      0xE36   0x2801             CMP      R0,#+1
   \      0xE38   0xF240 0x809E      BLS.W    ??sbcSemMsgProcess_161
   \      0xE3C   0x1FC0             SUBS     R0,R0,#+7
   \      0xE3E   0xD004             BEQ.N    ??sbcSemMsgProcess_162
   \      0xE40   0xF64F 0x71F6      MOVW     R1,#+65526
   \      0xE44   0x1A40             SUBS     R0,R0,R1
   \      0xE46   0xD042             BEQ.N    ??sbcSemMsgProcess_163
   \      0xE48   0xE0A0             B.N      ??sbcSemMsgProcess_164
   1197                {
   1198                  case NOTIFY_MODBUS_WR_ACK:
   1199                    if (pMsg->data.index == currFrameSbcSem.data.index)  // phisical address 1...16 
   \                     ??sbcSemMsgProcess_162: (+1)
   \      0xE4A   0xF8DF 0xB128      LDR.W    R11,??sbcSemMsgProcess_3
   \      0xE4E   0x8860             LDRH     R0,[R4, #+2]
   \      0xE50   0xF8BB 0x1002      LDRH     R1,[R11, #+2]
   \      0xE54   0x4288             CMP      R0,R1
   \      0xE56   0xD139             BNE.N    ??sbcSemMsgProcess_165
   1200                    {
   1201                      /* the ack coming from expected socket */
   1202                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \      0xE58   0x2004             MOVS     R0,#+4
   \      0xE5A   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1203                      /* release the transmitter */
   1204                      currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0xE5E   0x2005             MOVS     R0,#+5
   \      0xE60   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1205                      configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xE64   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xE68   0x2300             MOVS     R3,#+0
   \      0xE6A   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xE6E   0x4659             MOV      R1,R11
   \      0xE70   0x.... 0x....      BL       xQueueGenericSend
   \      0xE74   0x2801             CMP      R0,#+1
   \      0xE76   0xD009             BEQ.N    ??sbcSemMsgProcess_166
   \      0xE78   0xB672             CPSID    I
   \      0xE7A   0x2050             MOVS     R0,#+80
   \      0xE7C   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xE80   0xF3BF 0x8F4F      DSB      SY
   \      0xE84   0xF3BF 0x8F6F      ISB      SY
   \      0xE88   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_167: (+1)
   \      0xE8A   0xE7FE             B.N      ??sbcSemMsgProcess_167
   1206                      /* the bridge to RS485 successfully: inform the SBC with ACK to WMR message */
   1207                      sendAnswToSem(NO_ERROR, 
   1208                                    (uint8_t)currFrameSbcSem.data.index, 
   1209                                    currFrameSbcSem.data.rAddr, 
   1210                                    currFrameSbcSem.dataToSend.len, 
   1211                                    SCU_EVENT_MSG_FROM_SBC, 
   1212                                    FUNCTION_WRITE_MULTIPLE_REG);
   \                     ??sbcSemMsgProcess_166: (+1)
   \      0xE8C   0x2010             MOVS     R0,#+16
   \      0xE8E   0x9001             STR      R0,[SP, #+4]
   \      0xE90   0x2003             MOVS     R0,#+3
   \      0xE92   0x9000             STR      R0,[SP, #+0]
   \      0xE94   0xF8BB 0x3006      LDRH     R3,[R11, #+6]
   \      0xE98   0xF8BB 0x2004      LDRH     R2,[R11, #+4]
   \      0xE9C   0xF8BB 0x1002      LDRH     R1,[R11, #+2]
   \      0xEA0   0xB2C9             UXTB     R1,R1
   \      0xEA2   0x2000             MOVS     R0,#+0
   \      0xEA4   0x.... 0x....      BL       sendAnswToSem
   1213                      
   1214                      if (headMsg != NULL)
   \      0xEA8   0x.... 0x....      LDR.W    R10,??DataTable7
   \      0xEAC   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xEB0   0x2800             CMP      R0,#+0
   \      0xEB2   0xD006             BEQ.N    ??sbcSemMsgProcess_168
   1215                      {
   1216                        /* re-send the message in the queue list  */
   1217                        headMsg = extractSendFirstInList(headMsg);
   \      0xEB4   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xEB8   0x.... 0x....      BL       extractSendFirstInList
   \      0xEBC   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \      0xEC0   0xE001             B.N      ??sbcSemMsgProcess_169
   1218                      }
   1219                      else
   1220                      {
   1221                        resetPacketStatusNum();
   \                     ??sbcSemMsgProcess_168: (+1)
   \      0xEC2   0x.... 0x....      BL       resetPacketStatusNum
   1222                      }
   1223                      timeTickTmp = portMAX_DELAY;
   \                     ??sbcSemMsgProcess_169: (+1)
   \      0xEC6   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0xECA   0x0007             MOVS     R7,R0
   1224                    }
   1225                    break;
   \                     ??sbcSemMsgProcess_165: (+1)
   \      0xECC   0xE05E             B.N      ??sbcSemMsgProcess_170
   1226          
   1227                  case SBC_SEM_TIMEOUT:
   1228                    sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \                     ??sbcSemMsgProcess_163: (+1)
   \      0xECE   0x2004             MOVS     R0,#+4
   \      0xED0   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1229                    /* release the transmitter */
   1230                    currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0xED4   0xF8DF 0xA09C      LDR.W    R10,??sbcSemMsgProcess_3
   \      0xED8   0x2005             MOVS     R0,#+5
   \      0xEDA   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1231                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xEDE   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xEE2   0x2300             MOVS     R3,#+0
   \      0xEE4   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xEE8   0x4651             MOV      R1,R10
   \      0xEEA   0x.... 0x....      BL       xQueueGenericSend
   \      0xEEE   0x2801             CMP      R0,#+1
   \      0xEF0   0xD012             BEQ.N    ??sbcSemMsgProcess_171
   \      0xEF2   0xB672             CPSID    I
   \      0xEF4   0x2050             MOVS     R0,#+80
   \      0xEF6   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xEFA   0xF3BF 0x8F4F      DSB      SY
   \      0xEFE   0xF3BF 0x8F6F      ISB      SY
   \      0xF02   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_172: (+1)
   \      0xF04   0xE7FE             B.N      ??sbcSemMsgProcess_172
   \      0xF06   0xBF00             Nop
   \                     ??sbcSemMsgProcess_2:
   \      0xF08   0x....'....        DC32     ?_20
   \      0xF0C   0x....'....        DC32     remoteMngTask_attributes
   \      0xF10   0x....'....        DC32     remoteMngTask
   \      0xF14   0x....'....        DC32     remoteMngTaskHandle
   1232                    /* no ack coming from expected socket --> socket unavailable */
   1233                    ixScu = currFrameSbcSem.data.index - 1;
   \                     ??sbcSemMsgProcess_171: (+1)
   \      0xF18   0xF8BA 0x0002      LDRH     R0,[R10, #+2]
   \      0xF1C   0x1E40             SUBS     R0,R0,#+1
   \      0xF1E   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   1234                    /* non info pendig, so upgrade the register */
   1235                    pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] |= (uint32_t)0x04;  // Unavailable status
   \      0xF22   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \      0xF26   0x6801             LDR      R1,[R0, #+0]
   \      0xF28   0xF8BD 0x2008      LDRH     R2,[SP, #+8]
   \      0xF2C   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0xF30   0xF8B1 0x1102      LDRH     R1,[R1, #+258]
   \      0xF34   0xF051 0x0104      ORRS     R1,R1,#0x4
   \      0xF38   0x6802             LDR      R2,[R0, #+0]
   \      0xF3A   0xF8BD 0x3008      LDRH     R3,[SP, #+8]
   \      0xF3E   0xEB02 0x0243      ADD      R2,R2,R3, LSL #+1
   \      0xF42   0xF8A2 0x1102      STRH     R1,[R2, #+258]
   1236                    maskBit = sbcSemMaskBit[ixScu];
   \      0xF46   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \      0xF4A   0xF8BD 0x2008      LDRH     R2,[SP, #+8]
   \      0xF4E   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \      0xF52   0x000E             MOVS     R6,R1
   1237                    pScuRoMapReg->scuMapRegNotify.ntfChangeRo |= (uint32_t)maskBit;
   \      0xF54   0x6802             LDR      R2,[R0, #+0]
   \      0xF56   0xF8D2 0x10FA      LDR      R1,[R2, #+250]
   \      0xF5A   0x6802             LDR      R2,[R0, #+0]
   \      0xF5C   0x4331             ORRS     R1,R6,R1
   \      0xF5E   0xF8C2 0x10FA      STR      R1,[R2, #+250]
   1238                    pScuRoMapReg->scuMapRegStatusMeas.ntfChgStat = (uint16_t)9;
   \      0xF62   0x2109             MOVS     R1,#+9
   \      0xF64   0x6800             LDR      R0,[R0, #+0]
   \      0xF66   0xF8A0 0x1124      STRH     R1,[R0, #+292]
   1239                    timeTickTmp = portMAX_DELAY;
   \      0xF6A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0xF6E   0x0007             MOVS     R7,R0
   1240                    break;
   \      0xF70   0xE00C             B.N      ??sbcSemMsgProcess_170
   \      0xF72   0xBF00             Nop
   \                     ??sbcSemMsgProcess_3:
   \      0xF74   0x....'....        DC32     currFrameSbcSem
   1241          
   1242                  case SBC_SEM_EVENT_UART5:
   1243                  case NOTIFY_TO_MASTER_TX:
   1244                    /* a previous message is sending, so the current is put in the list */
   1245                    headMsg = addNode(headMsg, pMsg);
   \                     ??sbcSemMsgProcess_161: (+1)
   \      0xF78   0x.... 0x....      LDR.W    R10,??DataTable7
   \      0xF7C   0x0021             MOVS     R1,R4
   \      0xF7E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0xF82   0x.... 0x....      BL       addNode
   \      0xF86   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1246                    break;
   \      0xF8A   0xE7FF             B.N      ??sbcSemMsgProcess_170
   1247          
   1248                  default:
   1249                    break;
   1250          
   1251                }
   1252                break;
   \                     ??sbcSemMsgProcess_164: (+1)
   \                     ??sbcSemMsgProcess_170: (+1)
   \      0xF8C   0xE09C             B.N      ??sbcSemMsgProcess_37
   1253                
   1254              case SBC_SEM_WAIT_WR_MASTER_ACK:
   1255              case SBC_SEM_WAIT_WR_MASTER_ACK_STARTUP:
   1256              case SBC_SEM_WAIT_WR_MASTER_POLL_ACK:
   1257                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_13: (+1)
   \      0xF8E   0x8820             LDRH     R0,[R4, #+0]
   \      0xF90   0x2802             CMP      R0,#+2
   \      0xF92   0xD07D             BEQ.N    ??sbcSemMsgProcess_173
   \      0xF94   0x2808             CMP      R0,#+8
   \      0xF96   0xF040 0x8089      BNE.W    ??sbcSemMsgProcess_174
   1258                {
   1259                  case NOTIFY_MODBUS_WR_ACK:
   1260          #ifdef ADDR_NO_TRANSLATION
   1261                    if ((pMsg->data.index == SCU_M_P_ADDR) && (pMsg->data.rAddr == currFrameSbcSem.data.rAddr))
   1262          #else
   1263                    if ((pMsg->data.index == getPhysicalMdbAddr()) && (pMsg->data.rAddr == currFrameSbcSem.data.rAddr))
   \                     ??sbcSemMsgProcess_175: (+1)
   \      0xF9A   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0xF9E   0x8861             LDRH     R1,[R4, #+2]
   \      0xFA0   0xB2C0             UXTB     R0,R0
   \      0xFA2   0xB280             UXTH     R0,R0
   \      0xFA4   0x4281             CMP      R1,R0
   \      0xFA6   0xD172             BNE.N    ??sbcSemMsgProcess_176
   \      0xFA8   0x.... 0x....      LDR.W    R11,??DataTable9_3
   \      0xFAC   0x88A0             LDRH     R0,[R4, #+4]
   \      0xFAE   0xF8BB 0x1004      LDRH     R1,[R11, #+4]
   \      0xFB2   0x4288             CMP      R0,R1
   \      0xFB4   0xD16B             BNE.N    ??sbcSemMsgProcess_176
   1264          #endif
   1265                    {
   1266                      /* stop ACK gard  timer */
   1267                      xTimerStop(xSbcSemTimers[TIMER_FOR_ACK], SBCSEM_TIMER_GARD_TIME);
   \      0xFB6   0xF44F 0x70FA      MOV      R0,#+500
   \      0xFBA   0x9000             STR      R0,[SP, #+0]
   \      0xFBC   0x2300             MOVS     R3,#+0
   \      0xFBE   0x2200             MOVS     R2,#+0
   \      0xFC0   0x2103             MOVS     R1,#+3
   \      0xFC2   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0xFC6   0x6840             LDR      R0,[R0, #+4]
   \      0xFC8   0x.... 0x....      BL       xTimerGenericCommand
   1268                      /* the ack coming from the master i.e physical address SCU_M_P_ADDR = 1 */
   1269                      /* release the transmitter */
   1270                      currFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0xFCC   0x2005             MOVS     R0,#+5
   \      0xFCE   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1271                      configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0xFD2   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0xFD6   0x2300             MOVS     R3,#+0
   \      0xFD8   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0xFDC   0x4659             MOV      R1,R11
   \      0xFDE   0x.... 0x....      BL       xQueueGenericSend
   \      0xFE2   0x2801             CMP      R0,#+1
   \      0xFE4   0xD009             BEQ.N    ??sbcSemMsgProcess_177
   \      0xFE6   0xB672             CPSID    I
   \      0xFE8   0x2050             MOVS     R0,#+80
   \      0xFEA   0xF380 0x8811      MSR      BASEPRI,R0
   \      0xFEE   0xF3BF 0x8F4F      DSB      SY
   \      0xFF2   0xF3BF 0x8F6F      ISB      SY
   \      0xFF6   0xB662             CPSIE    I
   \                     ??sbcSemMsgProcess_178: (+1)
   \      0xFF8   0xE7FE             B.N      ??sbcSemMsgProcess_178
   1272                      if (resetChangeRegisterBit(ixLogic, pMsg->data.rAddr, pMsg->dataToSend.len) == TRUE)
   \                     ??sbcSemMsgProcess_177: (+1)
   \      0xFFA   0x88E2             LDRH     R2,[R4, #+6]
   \      0xFFC   0x88A1             LDRH     R1,[R4, #+4]
   \      0xFFE   0x0028             MOVS     R0,R5
   \     0x1000   0xB280             UXTH     R0,R0
   \     0x1002   0x.... 0x....      BL       resetChangeRegisterBit
   \     0x1006   0x2801             CMP      R0,#+1
   \     0x1008   0xD106             BNE.N    ??sbcSemMsgProcess_179
   1273                      {
   1274                        tPrintf("Socket %d Event 0x%X sent!\n\r", ixScu, pMsg->data.rAddr);
   \     0x100A   0x88A2             LDRH     R2,[R4, #+4]
   \     0x100C   0xF8BD 0x1008      LDRH     R1,[SP, #+8]
   \     0x1010   0x.... 0x....      LDR.W    R0,??DataTable9_4
   \     0x1014   0x.... 0x....      BL       tPrintf
   1275                      }
   1276                      if (SCU_S_REPL_ADDR == getStationId()) /* board with address = 99 is for replacement, so no message storing is need */
   \                     ??sbcSemMsgProcess_179: (+1)
   \     0x1018   0x.... 0x....      BL       getStationId
   \     0x101C   0x2863             CMP      R0,#+99
   \     0x101E   0xD106             BNE.N    ??sbcSemMsgProcess_180
   1277                      {
   1278                        sbcSemInfoMng.sbcSemStates = SBC_SEM_WAIT_TO_BE_OPERATIVE;
   \     0x1020   0x200C             MOVS     R0,#+12
   \     0x1022   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1279                        timeTickTmp = portMAX_DELAY;
   \     0x1026   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \     0x102A   0x0007             MOVS     R7,R0
   1280                        break;
   \     0x102C   0xE03E             B.N      ??sbcSemMsgProcess_181
   1281                      }
   1282          
   1283                      if (headMsg != NULL)
   \                     ??sbcSemMsgProcess_180: (+1)
   \     0x102E   0x.... 0x....      LDR.W    R11,??DataTable7
   \     0x1032   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \     0x1036   0x2800             CMP      R0,#+0
   \     0x1038   0xD006             BEQ.N    ??sbcSemMsgProcess_182
   1284                      {
   1285                        /* re-send a message in the queue list if present */
   1286                        headMsg = extractSendFirstInList(headMsg);
   \     0x103A   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \     0x103E   0x.... 0x....      BL       extractSendFirstInList
   \     0x1042   0xF8CB 0x0000      STR      R0,[R11, #+0]
   \     0x1046   0xE001             B.N      ??sbcSemMsgProcess_183
   1287                      }
   1288                      else
   1289                      {
   1290                        resetPacketStatusNum();
   \                     ??sbcSemMsgProcess_182: (+1)
   \     0x1048   0x.... 0x....      BL       resetPacketStatusNum
   1291                      }
   1292          
   1293                      if (sbcSemInfoMng.sbcSemStates != SBC_SEM_WAIT_WR_MASTER_POLL_ACK)
   \                     ??sbcSemMsgProcess_183: (+1)
   \     0x104C   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \     0x1050   0x2807             CMP      R0,#+7
   \     0x1052   0xD004             BEQ.N    ??sbcSemMsgProcess_184
   1294                      {
   1295                        /* a message froma slave on  RS485 to master has been aknoledged: Set the activity bit */
   1296                        sbcSemInfoMng.activityStatus |= maskBit;
   \     0x1054   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \     0x1058   0x4330             ORRS     R0,R6,R0
   \     0x105A   0xF8CA 0x0014      STR      R0,[R10, #+20]
   1297                      }
   1298          
   1299                      if (sbcSemInfoMng.sbcSemStates == SBC_SEM_WAIT_WR_MASTER_ACK_STARTUP)
   \                     ??sbcSemMsgProcess_184: (+1)
   \     0x105E   0xF8BA 0x0000      LDRH     R0,[R10, #+0]
   \     0x1062   0x280D             CMP      R0,#+13
   \     0x1064   0xD109             BNE.N    ??sbcSemMsgProcess_185
   1300                      {
   1301                        evs_error_get(error_array, 0, 0, 0);
   \     0x1066   0x2300             MOVS     R3,#+0
   \     0x1068   0x2200             MOVS     R2,#+0
   \     0x106A   0x2100             MOVS     R1,#+0
   \     0x106C   0xA805             ADD      R0,SP,#+20
   \     0x106E   0x.... 0x....      BL       evs_error_get
   1302                        updateModbusErrorRegisters(error_array, TRUE);
   \     0x1072   0x2101             MOVS     R1,#+1
   \     0x1074   0xA805             ADD      R0,SP,#+20
   \     0x1076   0x.... 0x....      BL       updateModbusErrorRegisters
   1303                      }
   1304                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \                     ??sbcSemMsgProcess_185: (+1)
   \     0x107A   0x2004             MOVS     R0,#+4
   \     0x107C   0xF8AA 0x0000      STRH     R0,[R10, #+0]
   1305                      sendMonMngMsg(MON_SEM_TASK, MON_START);      // activation task for monitor  
   \     0x1080   0x2100             MOVS     R1,#+0
   \     0x1082   0x2001             MOVS     R0,#+1
   \     0x1084   0x.... 0x....      BL       sendMonMngMsg
   1306                      timeTickTmp = portMAX_DELAY;
   \     0x1088   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \     0x108C   0x0007             MOVS     R7,R0
   1307                    }
   1308                    break;
   \                     ??sbcSemMsgProcess_176: (+1)
   \     0x108E   0xE00D             B.N      ??sbcSemMsgProcess_181
   1309          
   1310                  case NOTIFY_TO_MASTER_TX:
   1311                    if (SCU_S_REPL_ADDR != getStationId()) /* board with address = 99 is for replacement, so no message storing is need */
   \                     ??sbcSemMsgProcess_173: (+1)
   \     0x1090   0x.... 0x....      BL       getStationId
   \     0x1094   0x2863             CMP      R0,#+99
   \     0x1096   0xD008             BEQ.N    ??sbcSemMsgProcess_186
   1312                    {
   1313                      /* a previous message is sending, so the current is put in the list */
   1314                      headMsg = addNode(headMsg, pMsg);
   \     0x1098   0x.... 0x....      LDR.W    R10,??DataTable7
   \     0x109C   0x0021             MOVS     R1,R4
   \     0x109E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \     0x10A2   0x.... 0x....      BL       addNode
   \     0x10A6   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1315                    }
   1316                    break;
   \                     ??sbcSemMsgProcess_186: (+1)
   \     0x10AA   0xE7FF             B.N      ??sbcSemMsgProcess_181
   1317          
   1318                  default:
   1319                    break;
   1320          
   1321                }
   1322                break;
   \                     ??sbcSemMsgProcess_174: (+1)
   \                     ??sbcSemMsgProcess_181: (+1)
   \     0x10AC   0xE00C             B.N      ??sbcSemMsgProcess_37
   1323                
   1324          
   1325              default:
   1326                switch (pMsg->sbcSemEvent)
   \                     ??sbcSemMsgProcess_20: (+1)
   \     0x10AE   0x8820             LDRH     R0,[R4, #+0]
   \     0x10B0   0x2802             CMP      R0,#+2
   \     0x10B2   0xD109             BNE.N    ??sbcSemMsgProcess_187
   1327                {       
   1328                  case NOTIFY_TO_MASTER_TX:
   1329                    /* A notification to master was sent, but automa status is not managed, so put in the queue */
   1330                    headMsg = addNode(headMsg, pMsg);
   \     0x10B4   0x.... 0x....      LDR.W    R10,??DataTable7
   \     0x10B8   0x0021             MOVS     R1,R4
   \     0x10BA   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \     0x10BE   0x.... 0x....      BL       addNode
   \     0x10C2   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1331                    break;
   \     0x10C6   0xE7FF             B.N      ??sbcSemMsgProcess_188
   1332                    
   1333                  default:
   1334                    break;
   1335                }
   1336                break;
   1337            }
   1338          
   1339            if (pMsg->sbcSemEvent == NOTIFY_MODBUS_WR_ACK)
   \                     ??sbcSemMsgProcess_187: (+1)
   \                     ??sbcSemMsgProcess_188: (+1)
   \                     ??sbcSemMsgProcess_37: (+1)
   \     0x10C8   0x8820             LDRH     R0,[R4, #+0]
   \     0x10CA   0x2808             CMP      R0,#+8
   \     0x10CC   0xD105             BNE.N    ??sbcSemMsgProcess_189
   1340            {
   1341              if (pMsg->dataToSend.pData != NULL)
   \     0x10CE   0x68A0             LDR      R0,[R4, #+8]
   \     0x10D0   0x2800             CMP      R0,#+0
   \     0x10D2   0xD002             BEQ.N    ??sbcSemMsgProcess_189
   1342              {
   1343                /* free temporary payload buffer */
   1344                free(pMsg->dataToSend.pData);
   \     0x10D4   0x68A0             LDR      R0,[R4, #+8]
   \     0x10D6   0x.... 0x....      BL       free
   1345              }
   1346            }
   1347          
   1348            return (timeTickTmp);
   \                     ??sbcSemMsgProcess_189: (+1)
   \     0x10DA   0x0038             MOVS     R0,R7
   \     0x10DC   0xB009             ADD      SP,SP,#+36
   \     0x10DE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1349          }
   1350          // --------------------------------------------------------------------------------------------------------------------------- //
   1351          
   1352          /**
   1353          *
   1354          * @brief        Get the pointer to task queue
   1355          *
   1356          * @param [in]   none
   1357          *
   1358          * @retval       xQueueHandle: pointer to defined  queue
   1359          *
   1360          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1361          xQueueHandle getSbcSemQueueHandle(void)
   1362          {
   1363             return(sbcSemQueue);
   \                     getSbcSemQueueHandle: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable10
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR
   1364          }
   1365          
   1366          
   1367          

   \                                 In section .text, align 2, keep-with-next
   1368          void rs485SemGestTask (void * pvParameters)
   1369          {
   \                     rs485SemGestTask: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   1370            uint32_t       timeTick;
   1371            frameSbcSem_st tmpframers485Sem;  
   1372          
   1373            /*-------- Creates an empty mailbox for uart  messages --------------------------*/
   1374            rs485SemQueue = xQueueCreate(NUM_BUFF_RS485_SEM, sizeof(frameSbcSem_st));
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable10_1
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2112             MOVS     R1,#+18
   \        0xE   0x2010             MOVS     R0,#+16
   \       0x10   0x.... 0x....      BL       xQueueGenericCreate
   \       0x14   0x6028             STR      R0,[R5, #+0]
   1375            configASSERT(rs485SemQueue != NULL);
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD109             BNE.N    ??rs485SemGestTask_0
   \       0x1C   0xB672             CPSID    I
   \       0x1E   0x2050             MOVS     R0,#+80
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   \       0x2C   0xB662             CPSIE    I
   \                     ??rs485SemGestTask_1: (+1)
   \       0x2E   0xE7FE             B.N      ??rs485SemGestTask_1
   1376            
   1377            /* init structure for management */
   1378            rs485SemInfoMng.rs485SemStates = RS485_SEM_OPERATIVE;
   \                     ??rs485SemGestTask_0: (+1)
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \       0x36   0x8008             STRH     R0,[R1, #+0]
   1379              
   1380            //timeTick = pdMS_TO_TICKS(TIMEOUT_RESP_500);
   1381            timeTick = portMAX_DELAY;
   \       0x38   0xF05F 0x36FF      MOVS     R6,#+4294967295
   1382          
   1383            for (;;)
   1384            {
   1385              /* Wait for some event from Rx/Tx uart SBC (typically UART5)  */
   1386              if (xQueueReceive(rs485SemQueue, (void *)&framers485Sem, timeTick) == pdPASS)
   \                     ??rs485SemGestTask_2: (+1)
   \       0x3C   0x.... 0x....      LDR.W    R7,??DataTable10_3
   \       0x40   0x0032             MOVS     R2,R6
   \       0x42   0x0039             MOVS     R1,R7
   \       0x44   0x6828             LDR      R0,[R5, #+0]
   \       0x46   0x.... 0x....      BL       xQueueReceive
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xD104             BNE.N    ??rs485SemGestTask_3
   1387              {
   1388                timeTick = rs485SemMsgProcess(&framers485Sem);
   \       0x4E   0x0038             MOVS     R0,R7
   \       0x50   0x.... 0x....      BL       rs485SemMsgProcess
   \       0x54   0x0006             MOVS     R6,R0
   \       0x56   0xE7F1             B.N      ??rs485SemGestTask_2
   1389              }
   1390              else
   1391              {
   1392                tmpframers485Sem.sbcSemEvent = SBC_SEM_TIMEOUT;
   \                     ??rs485SemGestTask_3: (+1)
   \       0x58   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0x5C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1393                timeTick = rs485SemMsgProcess(&tmpframers485Sem);
   \       0x60   0x4668             MOV      R0,SP
   \       0x62   0x.... 0x....      BL       rs485SemMsgProcess
   \       0x66   0x0006             MOVS     R6,R0
   \       0x68   0xE7E8             B.N      ??rs485SemGestTask_2
   1394              }
   1395            }
   1396          }
   1397          
   1398          
   1399          
   1400          /**
   1401          *
   1402          * @brief        Decoder message from / to RS485 (slave <---> master) 
   1403          *
   1404          * @param [in]   none
   1405          *
   1406          * @retval       uint32_t: timeout value 
   1407          *
   1408          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1409          static uint32_t rs485SemMsgProcess(frameSbcSem_st* pMsg)
   1410          {
   \                     rs485SemMsgProcess: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   1411            uint16_t              ixScuPhysical, ixScuLogical;
   1412            uint32_t              timeTickTmp;
   1413            scuRoMapRegister_st*  pRoRegs;
   1414            scuRwMapRegister_st*  pRwRegs;
   1415            tmMapRegister_st*     pTmRegs;
   1416          #ifndef ADDR_NO_TRANSLATION
   1417            uint8_t               addrRs485;   
   1418          #endif
   1419          
   1420            timeTickTmp = portMAX_DELAY;
   \        0x6   0xF05F 0x37FF      MOVS     R7,#+4294967295
   1421          
   1422            if (pMsg->sbcSemEvent != SBC_SEM_TIMEOUT)
   \        0xA   0x8820             LDRH     R0,[R4, #+0]
   \        0xC   0xF64F 0x71FE      MOVW     R1,#+65534
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD027             BEQ.N    ??rs485SemMsgProcess_0
   1423            {
   1424              if (pMsg->data.index == MODBUS_BROADCAST_ADDR)
   \       0x14   0x8860             LDRH     R0,[R4, #+2]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD105             BNE.N    ??rs485SemMsgProcess_1
   1425              {
   1426                ixScuLogical = ixScuPhysical = pMsg->data.index;
   \       0x1A   0x8860             LDRH     R0,[R4, #+2]
   \       0x1C   0x0005             MOVS     R5,R0
   \       0x1E   0x002E             MOVS     R6,R5
   1427                addrRs485 = MODBUS_BROADCAST_ADDR;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x4682             MOV      R10,R0
   \       0x24   0xE00F             B.N      ??rs485SemMsgProcess_2
   1428              }
   1429              else
   1430              {
   1431                ixScuPhysical = pMsg->data.index;                     // physical address 1...16    
   \                     ??rs485SemMsgProcess_1: (+1)
   \       0x26   0x8860             LDRH     R0,[R4, #+2]
   \       0x28   0x0005             MOVS     R5,R0
   1432                ixScuLogical = pMsg->data.index - 1;                  // logical address  0...15
   \       0x2A   0x8860             LDRH     R0,[R4, #+2]
   \       0x2C   0x1E40             SUBS     R0,R0,#+1
   \       0x2E   0x0006             MOVS     R6,R0
   1433          #ifndef ADDR_NO_TRANSLATION
   1434                addrRs485 = socketPresence.matrixConv[ixScuLogical];  // modbus address   1...247
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \       0x34   0x0031             MOVS     R1,R6
   \       0x36   0xB289             UXTH     R1,R1
   \       0x38   0x4408             ADD      R0,R0,R1
   \       0x3A   0x7C00             LDRB     R0,[R0, #+16]
   \       0x3C   0x4682             MOV      R10,R0
   1435                rs485SemInfoMng.rs485RWmR.regAdd = pMsg->data.rAddr;
   \       0x3E   0x88A0             LDRH     R0,[R4, #+4]
   \       0x40   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \       0x44   0x8108             STRH     R0,[R1, #+8]
   1436          #endif
   1437              }
   1438          
   1439              pRoRegs = getRoMdbRegs(ixScuLogical);
   \                     ??rs485SemMsgProcess_2: (+1)
   \       0x46   0x0030             MOVS     R0,R6
   \       0x48   0xB2C0             UXTB     R0,R0
   \       0x4A   0x.... 0x....      BL       getRoMdbRegs
   \       0x4E   0x4680             MOV      R8,R0
   1440              pRwRegs = getRwMdbRegs(ixScuLogical);
   \       0x50   0x0030             MOVS     R0,R6
   \       0x52   0xB2C0             UXTB     R0,R0
   \       0x54   0x.... 0x....      BL       getRwMdbRegs
   \       0x58   0x4681             MOV      R9,R0
   1441              pTmRegs = getTmMdbRegs(ixScuLogical);
   \       0x5A   0x0030             MOVS     R0,R6
   \       0x5C   0xB2C0             UXTB     R0,R0
   \       0x5E   0x.... 0x....      BL       getTmMdbRegs
   \       0x62   0x9000             STR      R0,[SP, #+0]
   1442            }
   1443          
   1444            switch (rs485SemInfoMng.rs485SemStates)
   \                     ??rs485SemMsgProcess_0: (+1)
   \       0x64   0x.... 0x....      LDR.W    R11,??DataTable10_2
   \       0x68   0xF8BB 0x0000      LDRH     R0,[R11, #+0]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD006             BEQ.N    ??rs485SemMsgProcess_3
   \       0x70   0x1E40             SUBS     R0,R0,#+1
   \       0x72   0xD005             BEQ.N    ??rs485SemMsgProcess_4
   \       0x74   0x1EC0             SUBS     R0,R0,#+3
   \       0x76   0x2801             CMP      R0,#+1
   \       0x78   0xF240 0x8126      BLS.W    ??rs485SemMsgProcess_5
   \       0x7C   0xE15C             B.N      ??rs485SemMsgProcess_6
   1445            {
   1446              case RS485_SEM_IDLE:
   1447                break;
   \                     ??rs485SemMsgProcess_3: (+1)
   \       0x7E   0xE15B             B.N      ??rs485SemMsgProcess_7
   1448          
   1449              case RS485_SEM_OPERATIVE:
   1450                switch (pMsg->sbcSemEvent)
   \                     ??rs485SemMsgProcess_4: (+1)
   \       0x80   0x8820             LDRH     R0,[R4, #+0]
   \       0x82   0x2802             CMP      R0,#+2
   \       0x84   0xD006             BEQ.N    ??rs485SemMsgProcess_8
   \       0x86   0x2803             CMP      R0,#+3
   \       0x88   0xF000 0x80C2      BEQ.W    ??rs485SemMsgProcess_9
   \       0x8C   0x2806             CMP      R0,#+6
   \       0x8E   0xF000 0x80FA      BEQ.W    ??rs485SemMsgProcess_10
   \       0x92   0xE118             B.N      ??rs485SemMsgProcess_11
   1451                {
   1452                  case NOTIFY_TO_MASTER_TX:
   1453                    switch (pMsg->data.rAddr)
   \                     ??rs485SemMsgProcess_8: (+1)
   \       0x94   0x88A0             LDRH     R0,[R4, #+4]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD04C             BEQ.N    ??rs485SemMsgProcess_12
   \       0x9A   0x1E80             SUBS     R0,R0,#+2
   \       0x9C   0xD050             BEQ.N    ??rs485SemMsgProcess_13
   \       0x9E   0x1E80             SUBS     R0,R0,#+2
   \       0xA0   0xD040             BEQ.N    ??rs485SemMsgProcess_14
   \       0xA2   0x381E             SUBS     R0,R0,#+30
   \       0xA4   0xF000 0x808A      BEQ.W    ??rs485SemMsgProcess_15
   \       0xA8   0xF240 0x31E2      MOVW     R1,#+994
   \       0xAC   0x1A40             SUBS     R0,R0,R1
   \       0xAE   0xD05F             BEQ.N    ??rs485SemMsgProcess_16
   \       0xB0   0x1E40             SUBS     R0,R0,#+1
   \       0xB2   0xD065             BEQ.N    ??rs485SemMsgProcess_17
   \       0xB4   0xF44F 0x7187      MOV      R1,#+270
   \       0xB8   0x1A40             SUBS     R0,R0,R1
   \       0xBA   0xD069             BEQ.N    ??rs485SemMsgProcess_18
   \       0xBC   0x1E40             SUBS     R0,R0,#+1
   \       0xBE   0xD06E             BEQ.N    ??rs485SemMsgProcess_19
   \       0xC0   0x1E40             SUBS     R0,R0,#+1
   \       0xC2   0xD073             BEQ.N    ??rs485SemMsgProcess_20
   \       0xC4   0x380E             SUBS     R0,R0,#+14
   \       0xC6   0xF000 0x8081      BEQ.W    ??rs485SemMsgProcess_21
   \       0xCA   0x38DD             SUBS     R0,R0,#+221
   \       0xCC   0xD012             BEQ.N    ??rs485SemMsgProcess_22
   \       0xCE   0x1E40             SUBS     R0,R0,#+1
   \       0xD0   0xD008             BEQ.N    ??rs485SemMsgProcess_23
   \       0xD2   0x380D             SUBS     R0,R0,#+13
   \       0xD4   0xD016             BEQ.N    ??rs485SemMsgProcess_24
   \       0xD6   0x3833             SUBS     R0,R0,#+51
   \       0xD8   0xD042             BEQ.N    ??rs485SemMsgProcess_25
   \       0xDA   0x380F             SUBS     R0,R0,#+15
   \       0xDC   0xD038             BEQ.N    ??rs485SemMsgProcess_26
   \       0xDE   0x3818             SUBS     R0,R0,#+24
   \       0xE0   0xD018             BEQ.N    ??rs485SemMsgProcess_27
   \       0xE2   0xE07A             B.N      ??rs485SemMsgProcess_28
   1454                    {
   1455                      case ADDR_EVSE_CHARGE_STATUS_RO:
   1456                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegStatusMeas.ntfChgStat);
   \                     ??rs485SemMsgProcess_23: (+1)
   \       0xE4   0x2002             MOVS     R0,#+2
   \       0xE6   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1457                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.ntfChgStat; 
   \       0xEA   0xF518 0x7092      ADDS     R0,R8,#+292
   \       0xEE   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1458          #ifdef ADDR_NO_TRANSLATION
   1459                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_EVSE_CHARGE_STATUS_RO;
   1460          #endif
   1461                        break;
   \       0xF2   0xE075             B.N      ??rs485SemMsgProcess_29
   1462          
   1463                      case ADDR_EVSE_EVENT_FLAGS_RO:
   1464                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegStatusMeas.ntfSktEvent);
   \                     ??rs485SemMsgProcess_22: (+1)
   \       0xF4   0x2002             MOVS     R0,#+2
   \       0xF6   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1465                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.ntfSktEvent; 
   \       0xFA   0xF518 0x7091      ADDS     R0,R8,#+290
   \       0xFE   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1466          #ifdef ADDR_NO_TRANSLATION
   1467                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_EVSE_EVENT_FLAGS_RO;
   1468          #endif
   1469                        break;
   \      0x102   0xE06D             B.N      ??rs485SemMsgProcess_29
   1470          
   1471                      case ADDR_VOLTAGE_AC_RO:
   1472                        rs485SemInfoMng.rs485RWmR.numBytes = (ADDR_SCU_RESERVED6B - ADDR_VOLTAGE_AC_RO) * 2; // transmit until last info TIME_INCHARGE_RO
   \                     ??rs485SemMsgProcess_24: (+1)
   \      0x104   0x20B8             MOVS     R0,#+184
   \      0x106   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1473                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.mtVsys; 
   \      0x10A   0xF518 0x709F      ADDS     R0,R8,#+318
   \      0x10E   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1474          #ifdef ADDR_NO_TRANSLATION
   1475                        rs485SemInfoMng.rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_VOLTAGE_AC_RO;
   1476          #endif
   1477                        break;
   \      0x112   0xE065             B.N      ??rs485SemMsgProcess_29
   1478          
   1479                      case ADDR_TIME_IN_CHARGE_RO:
   1480                        rs485SemInfoMng.rs485RWmR.numBytes = (LEN_TIME_IN_CHARGE_RO) * 2; // transmit only info TIME_INCHARGE_RO
   \                     ??rs485SemMsgProcess_27: (+1)
   \      0x114   0x2004             MOVS     R0,#+4
   \      0x116   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1481                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.timeInCharge; 
   \      0x11A   0xF518 0x70F9      ADDS     R0,R8,#+498
   \      0x11E   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1482          #ifdef ADDR_NO_TRANSLATION
   1483                        rs485SemInfoMng.rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_TIME_IN_CHARGE_RO;
   1484          #endif
   1485                        break;
   \      0x122   0xE05D             B.N      ??rs485SemMsgProcess_29
   1486          
   1487                      case ADDR_CONNECTOR_IDS_RW:
   1488                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRwRegs->scuSetRegister.devAlias);
   \                     ??rs485SemMsgProcess_14: (+1)
   \      0x124   0x2002             MOVS     R0,#+2
   \      0x126   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1489                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRwRegs->scuSetRegister.devAlias; 
   \      0x12A   0xF119 0x0008      ADDS     R0,R9,#+8
   \      0x12E   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1490          #ifdef ADDR_NO_TRANSLATION
   1491                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_CONNECTOR_IDS_RW;
   1492          #endif
   1493                        break;
   \      0x132   0xE055             B.N      ??rs485SemMsgProcess_29
   1494          
   1495                    case ADDR_CONNECTOR_TYPE_RW:
   1496                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(scuSetRegister_st);
   \                     ??rs485SemMsgProcess_12: (+1)
   \      0x134   0x20D2             MOVS     R0,#+210
   \      0x136   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1497                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRwRegs->scuSetRegister.connType; 
   \      0x13A   0xF8CB 0x9002      STR      R9,[R11, #+2]
   1498          #ifdef ADDR_NO_TRANSLATION
   1499                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_CONNECTOR_TYPE_RW;
   1500          #endif
   1501                        break;
   \      0x13E   0xE04F             B.N      ??rs485SemMsgProcess_29
   1502          
   1503                      case ADDR_ENERGY_METERS_RW:
   1504                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRwRegs->scuSetRegister.mtType);
   \                     ??rs485SemMsgProcess_13: (+1)
   \      0x140   0x2002             MOVS     R0,#+2
   \      0x142   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1505                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRwRegs->scuSetRegister.mtType; 
   \      0x146   0xF119 0x0004      ADDS     R0,R9,#+4
   \      0x14A   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1506          #ifdef ADDR_NO_TRANSLATION
   1507                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_ENERGY_METERS_RW;
   1508          #endif
   1509                        break;
   \      0x14E   0xE047             B.N      ??rs485SemMsgProcess_29
   1510          
   1511                      case ADDR_UID_AUTHORIZATION_RO:
   1512                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegStatusMeas.uidAuth);
   \                     ??rs485SemMsgProcess_26: (+1)
   \      0x150   0x2030             MOVS     R0,#+48
   \      0x152   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1513                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.uidAuth; 
   \      0x156   0xF518 0x70E1      ADDS     R0,R8,#+450
   \      0x15A   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1514          #ifdef ADDR_NO_TRANSLATION
   1515                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_UID_AUTHORIZATION_RO;
   1516          #endif
   1517                        break;
   \      0x15E   0xE03F             B.N      ??rs485SemMsgProcess_29
   1518          
   1519                      case ADDR_SESSION_ID_RO:
   1520                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegStatusMeas.evSessionId);
   \                     ??rs485SemMsgProcess_25: (+1)
   \      0x160   0x2004             MOVS     R0,#+4
   \      0x162   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1521                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.evSessionId; 
   \      0x166   0xF518 0x70D2      ADDS     R0,R8,#+420
   \      0x16A   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1522          #ifdef ADDR_NO_TRANSLATION
   1523                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_SESSION_ID_RO;
   1524          #endif
   1525                        break;
   \      0x16E   0xE037             B.N      ??rs485SemMsgProcess_29
   1526          
   1527                      case ADDR_EVSE_ERROR1_RO:
   1528                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegNotify.ntfErr1);
   \                     ??rs485SemMsgProcess_16: (+1)
   \      0x170   0x2002             MOVS     R0,#+2
   \      0x172   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1529                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegNotify.ntfErr1; 
   \      0x176   0xF118 0x00FE      ADDS     R0,R8,#+254
   \      0x17A   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1530          #ifdef ADDR_NO_TRANSLATION
   1531                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_EVSE_ERROR1_RO;
   1532          #endif
   1533                        break;
   \      0x17E   0xE02F             B.N      ??rs485SemMsgProcess_29
   1534                        
   1535                      case ADDR_EVSE_ERROR2_RO:
   1536                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegNotify.ntfErr2);
   \                     ??rs485SemMsgProcess_17: (+1)
   \      0x180   0x2002             MOVS     R0,#+2
   \      0x182   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1537                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegNotify.ntfErr2; 
   \      0x186   0xF518 0x7080      ADDS     R0,R8,#+256
   \      0x18A   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1538          #ifdef ADDR_NO_TRANSLATION
   1539                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_EVSE_ERROR2_RO;
   1540          #endif
   1541                        break;
   \      0x18E   0xE027             B.N      ??rs485SemMsgProcess_29
   1542          
   1543                      case ADDR_ADDR_S_CONN_RW:
   1544                        rs485SemInfoMng.rs485RWmR.numBytes = pMsg->dataToSend.len;
   \                     ??rs485SemMsgProcess_18: (+1)
   \      0x190   0x88E0             LDRH     R0,[R4, #+6]
   \      0x192   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1545                        rs485SemInfoMng.pOriginData = (uint8_t*)pMsg->dataToSend.pData; 
   \      0x196   0x68A0             LDR      R0,[R4, #+8]
   \      0x198   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1546          #ifdef ADDR_NO_TRANSLATION
   1547                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_ADDR_S_CONN_RW;
   1548          #endif
   1549                        break;
   \      0x19C   0xE020             B.N      ??rs485SemMsgProcess_29
   1550          
   1551                      case ADDR_TM_ADDR_REQ_RW:
   1552                        rs485SemInfoMng.rs485RWmR.numBytes = pMsg->dataToSend.len;
   \                     ??rs485SemMsgProcess_19: (+1)
   \      0x19E   0x88E0             LDRH     R0,[R4, #+6]
   \      0x1A0   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1553                        rs485SemInfoMng.pOriginData = (uint8_t*)pMsg->dataToSend.pData; 
   \      0x1A4   0x68A0             LDR      R0,[R4, #+8]
   \      0x1A6   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1554          #ifdef ADDR_NO_TRANSLATION
   1555                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_TM_ADDR_REQ_RW;
   1556          #endif
   1557                        break;
   \      0x1AA   0xE019             B.N      ??rs485SemMsgProcess_29
   1558          
   1559                      case ADDR_TM_ADDR_ASS_RW:
   1560                        /* in the ADDR_TM_ADDR_REQ_RW there is the randomId received*/
   1561                        /* in the ADDR_TM_ADDR_ASS_RW there is the physical address assigned */
   1562                        rs485SemInfoMng.rs485RWmR.numBytes = pMsg->dataToSend.len;
   \                     ??rs485SemMsgProcess_20: (+1)
   \      0x1AC   0x88E0             LDRH     R0,[R4, #+6]
   \      0x1AE   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1563                        rs485SemInfoMng.pOriginData = (uint8_t*)&pTmRegs->tmAddrReq; 
   \      0x1B2   0x9800             LDR      R0,[SP, #+0]
   \      0x1B4   0x3008             ADDS     R0,R0,#+8
   \      0x1B6   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1564          #ifdef ADDR_NO_TRANSLATION
   1565                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_TM_ADDR_REQ_RW;
   1566          #endif
   1567                        break;
   \      0x1BA   0xE011             B.N      ??rs485SemMsgProcess_29
   1568          
   1569                      case ADDR_EVSE_TM_RW:
   1570                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pRoRegs->scuMapRegStatusMeas.ntfChgStat);
   \                     ??rs485SemMsgProcess_15: (+1)
   \      0x1BC   0x2002             MOVS     R0,#+2
   \      0x1BE   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1571                        rs485SemInfoMng.pOriginData = (uint8_t*)&pRoRegs->scuMapRegStatusMeas.ntfChgStat; 
   \      0x1C2   0xF518 0x7092      ADDS     R0,R8,#+292
   \      0x1C6   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1572          #ifdef ADDR_NO_TRANSLATION
   1573                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_EVSE_CHARGE_STATUS_RO;
   1574          #endif
   1575                        break;
   \      0x1CA   0xE009             B.N      ??rs485SemMsgProcess_29
   1576                        
   1577                      case ADDR_GET_EEPROM_RW:
   1578                        /* this address is used by SCU jolly to request info at the master to clone the previous broken board */
   1579                        rs485SemInfoMng.rs485RWmR.numBytes = sizeof(pTmRegs->tmGetEeprom);
   \                     ??rs485SemMsgProcess_21: (+1)
   \      0x1CC   0x2002             MOVS     R0,#+2
   \      0x1CE   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1580                        rs485SemInfoMng.pOriginData = (uint8_t*)pMsg->dataToSend.pData; 
   \      0x1D2   0x68A0             LDR      R0,[R4, #+8]
   \      0x1D4   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1581          #ifdef ADDR_NO_TRANSLATION
   1582                        rs485SemInfoMng.rs485RWmR.regAdd = SIZE_MODBUS_MAP * ixScuLogical + ADDR_GET_EEPROM_RW;
   1583          #endif
   1584                        break;
   \      0x1D8   0xE002             B.N      ??rs485SemMsgProcess_29
   1585          
   1586                      default:
   1587                        rs485SemInfoMng.pOriginData = NULL; 
   \                     ??rs485SemMsgProcess_28: (+1)
   \      0x1DA   0x2000             MOVS     R0,#+0
   \      0x1DC   0xF8CB 0x0002      STR      R0,[R11, #+2]
   1588                        break;
   1589                    }
   1590                    if (rs485SemInfoMng.pOriginData != NULL)
   \                     ??rs485SemMsgProcess_29: (+1)
   \      0x1E0   0xF11B 0x0102      ADDS     R1,R11,#+2
   \      0x1E4   0x6808             LDR      R0,[R1, #+0]
   \      0x1E6   0x2800             CMP      R0,#+0
   \      0x1E8   0xD011             BEQ.N    ??rs485SemMsgProcess_30
   1591                    {
   1592          #ifdef ADDR_NO_TRANSLATION
   1593                      /* data must be sent to SCU master over RS485 */
   1594                      currFrameSbcSem.data.index = rs485RWmR.unitId = SCU_M_P_ADDR;  /* the message must be sent to SCU master */
   1595          #else
   1596                      currFrameSbcSem.data.index = ixScuPhysical;  /* the message must be sent to SCU master */
   \      0x1EA   0x.... 0x....      LDR.W    R0,??DataTable9_3
   \      0x1EE   0x8045             STRH     R5,[R0, #+2]
   1597                      rs485SemInfoMng.rs485RWmR.unitId = addrRs485;
   \      0x1F0   0xF88B 0xA006      STRB     R10,[R11, #+6]
   1598          #endif
   1599                      writeMasterModbusRegister(rs485SemInfoMng.pOriginData, &rs485SemInfoMng.rs485RWmR);
   \      0x1F4   0x6808             LDR      R0,[R1, #+0]
   \      0x1F6   0xF11B 0x0106      ADDS     R1,R11,#+6
   \      0x1FA   0x.... 0x....      BL       writeMasterModbusRegister
   1600                      rs485SemInfoMng.rs485SemStates = RS485_SEM_ACK_WAITING_WR;
   \      0x1FE   0x2004             MOVS     R0,#+4
   \      0x200   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1601                      /* set parameter for retransmission */
   1602                      rs485SemInfoMng.numRetry = (uint16_t)0;
   \      0x204   0x2000             MOVS     R0,#+0
   \      0x206   0xF8AB 0x0013      STRH     R0,[R11, #+19]
   1603                      timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_TRANSMITTER_RESP); 
   \      0x20A   0x2064             MOVS     R0,#+100
   \      0x20C   0x0007             MOVS     R7,R0
   1604                    }
   1605                    break;
   \                     ??rs485SemMsgProcess_30: (+1)
   \      0x20E   0xE05A             B.N      ??rs485SemMsgProcess_31
   1606          
   1607                  case NOTIFY_TO_SLAVE_TX:
   1608                    if  ((pMsg->data.rAddr < ADDR_RESERVED_A) ||                                                          // area RW configurazioni 
   1609                         ((pMsg->data.rAddr >= ADDR_FILE_COMMAND_RW)  && (pMsg->data.rAddr < ADDR_END_RW_REGS_WO)) ||     // area RW FW upgrade
   1610                         ((pMsg->data.rAddr >= ADDR_TM_MEASURED_CURRENT_RW)  && (pMsg->data.rAddr < ADDR_RESERVED_B)))    // area RW collaudo
   \                     ??rs485SemMsgProcess_9: (+1)
   \      0x210   0x88A0             LDRH     R0,[R4, #+4]
   \      0x212   0x2869             CMP      R0,#+105
   \      0x214   0xDB10             BLT.N    ??rs485SemMsgProcess_32
   \      0x216   0x88A0             LDRH     R0,[R4, #+4]
   \      0x218   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x21C   0xDB03             BLT.N    ??rs485SemMsgProcess_33
   \      0x21E   0x88A0             LDRH     R0,[R4, #+4]
   \      0x220   0xF5B0 0x7F82      CMP      R0,#+260
   \      0x224   0xDB08             BLT.N    ??rs485SemMsgProcess_32
   \                     ??rs485SemMsgProcess_33: (+1)
   \      0x226   0x88A0             LDRH     R0,[R4, #+4]
   \      0x228   0xF5B0 0x6FA2      CMP      R0,#+1296
   \      0x22C   0xDB2A             BLT.N    ??rs485SemMsgProcess_34
   \      0x22E   0x88A0             LDRH     R0,[R4, #+4]
   \      0x230   0xF240 0x5124      MOVW     R1,#+1316
   \      0x234   0x4288             CMP      R0,R1
   \      0x236   0xDA25             BGE.N    ??rs485SemMsgProcess_34
   1611                    {
   1612                      /* filter on register to send to a slave */
   1613          #ifdef ADDR_NO_TRANSLATION
   1614                        rs485SemInfoMng.rs485RWmR.unitId = ixScuPhysical;  /* the message must be sent to SCU slave */
   1615          #else
   1616                      rs485SemInfoMng.rs485RWmR.unitId = addrRs485;     /* the message must be sent to SCU slave */
   \                     ??rs485SemMsgProcess_32: (+1)
   \      0x238   0xF88B 0xA006      STRB     R10,[R11, #+6]
   1617          #endif
   1618                      rs485SemInfoMng.rs485RWmR.numWords = pMsg->dataToSend.len;
   \      0x23C   0x88E0             LDRH     R0,[R4, #+6]
   \      0x23E   0xF8AB 0x000A      STRH     R0,[R11, #+10]
   1619                      rs485SemInfoMng.rs485RWmR.numBytes = 2 * rs485SemInfoMng.rs485RWmR.numWords;
   \      0x242   0xF8BB 0x000A      LDRH     R0,[R11, #+10]
   \      0x246   0xB2C0             UXTB     R0,R0
   \      0x248   0x0040             LSLS     R0,R0,#+1
   \      0x24A   0xF88B 0x000C      STRB     R0,[R11, #+12]
   1620                      rs485SemInfoMng.pOriginData = (uint8_t*)pMsg->dataToSend.pData; 
   \      0x24E   0x68A0             LDR      R0,[R4, #+8]
   \      0x250   0xF11B 0x0102      ADDS     R1,R11,#+2
   \      0x254   0x6008             STR      R0,[R1, #+0]
   1621                      rs485SemInfoMng.rs485RWmR.regAdd = pMsg->data.rAddr;
   \      0x256   0x88A0             LDRH     R0,[R4, #+4]
   \      0x258   0xF8AB 0x0008      STRH     R0,[R11, #+8]
   1622                      writeMasterModbusRegister(rs485SemInfoMng.pOriginData, &rs485SemInfoMng.rs485RWmR);
   \      0x25C   0x6808             LDR      R0,[R1, #+0]
   \      0x25E   0xF11B 0x0106      ADDS     R1,R11,#+6
   \      0x262   0x.... 0x....      BL       writeMasterModbusRegister
   1623                      if (rs485SemInfoMng.rs485RWmR.unitId != MODBUS_BROADCAST_ADDR)
   \      0x266   0xF89B 0x0006      LDRB     R0,[R11, #+6]
   \      0x26A   0x2800             CMP      R0,#+0
   \      0x26C   0xD00A             BEQ.N    ??rs485SemMsgProcess_34
   1624                      {
   1625                        currFrameSbcSem.data.index = rs485SemInfoMng.rs485RWmR.unitId;  // phisical address 1...16
   \      0x26E   0xF89B 0x0006      LDRB     R0,[R11, #+6]
   \      0x272   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \      0x276   0x8048             STRH     R0,[R1, #+2]
   1626                        timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_RESP); 
   \      0x278   0xF44F 0x70FA      MOV      R0,#+500
   \      0x27C   0x0007             MOVS     R7,R0
   1627                        rs485SemInfoMng.rs485SemStates = RS485_SEM_ACK_WAITING_WR;
   \      0x27E   0x2004             MOVS     R0,#+4
   \      0x280   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1628                      }
   1629                    }
   1630                    break;
   \                     ??rs485SemMsgProcess_34: (+1)
   \      0x284   0xE01F             B.N      ??rs485SemMsgProcess_31
   1631          
   1632                  case NOTIFY_TO_SLAVE_RX:
   1633                    rs485SemInfoMng.rs485Rd.numBytes = pMsg->dataToSend.len;
   \                     ??rs485SemMsgProcess_10: (+1)
   \      0x286   0x88E0             LDRH     R0,[R4, #+6]
   \      0x288   0xF8AB 0x0011      STRH     R0,[R11, #+17]
   1634          #ifdef ADDR_NO_TRANSLATION
   1635                    rs485SemInfoMng.rs485Rd.unitId = ixScuPhysical;  /* the message must be sent to SCU slave */
   1636          #else
   1637                    rs485SemInfoMng.rs485Rd.unitId = addrRs485;     /* the message must be sent to SCU slave */
   \      0x28C   0xF88B 0xA00D      STRB     R10,[R11, #+13]
   1638          #endif
   1639                    rs485SemInfoMng.rs485Rd.regAdd = pMsg->data.rAddr;
   \      0x290   0x88A0             LDRH     R0,[R4, #+4]
   \      0x292   0xF8AB 0x000F      STRH     R0,[R11, #+15]
   1640                    readMasterModbusRegister(&rs485SemInfoMng.rs485Rd);
   \      0x296   0xF11B 0x000D      ADDS     R0,R11,#+13
   \      0x29A   0x.... 0x....      BL       readMasterModbusRegister
   1641                    currFrameSbcSem.data.index = rs485SemInfoMng.rs485Rd.unitId;  // phisical address 1...16
   \      0x29E   0xF89B 0x000D      LDRB     R0,[R11, #+13]
   \      0x2A2   0x.... 0x....      LDR.W    R1,??DataTable9_3
   \      0x2A6   0x8048             STRH     R0,[R1, #+2]
   1642                    if (pMsg->data.rAddr == ADDR_GET_EEPROM_RW)
   \      0x2A8   0x88A0             LDRH     R0,[R4, #+4]
   \      0x2AA   0xF240 0x5123      MOVW     R1,#+1315
   \      0x2AE   0x4288             CMP      R0,R1
   \      0x2B0   0xD103             BNE.N    ??rs485SemMsgProcess_35
   1643                    {
   1644                      /* in this case the time out must be longer: the slave will transmit about 1KB and this means about 44ms */
   1645                      timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_RESP); // use 500ms
   \      0x2B2   0xF44F 0x70FA      MOV      R0,#+500
   \      0x2B6   0x0007             MOVS     R7,R0
   \      0x2B8   0xE001             B.N      ??rs485SemMsgProcess_36
   1646                    }
   1647                    else
   1648                    {
   1649                      /* in this case the time out must be longer: the slave will transmit about 1KB and this means about 44ms */
   1650                      timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_TRANSMITTER_RESP); 
   \                     ??rs485SemMsgProcess_35: (+1)
   \      0x2BA   0x2064             MOVS     R0,#+100
   \      0x2BC   0x0007             MOVS     R7,R0
   1651                    }
   1652                    rs485SemInfoMng.rs485SemStates = RS485_SEM_ACK_WAITING_RD;
   \                     ??rs485SemMsgProcess_36: (+1)
   \      0x2BE   0x2005             MOVS     R0,#+5
   \      0x2C0   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1653                    break;
   \      0x2C4   0xE7FF             B.N      ??rs485SemMsgProcess_31
   1654          
   1655                  default:
   1656                    break;
   1657          
   1658                }
   1659                break;
   \                     ??rs485SemMsgProcess_11: (+1)
   \                     ??rs485SemMsgProcess_31: (+1)
   \      0x2C6   0xE037             B.N      ??rs485SemMsgProcess_7
   1660          
   1661              case RS485_SEM_ACK_WAITING_WR:
   1662              case RS485_SEM_ACK_WAITING_RD:
   1663                switch (pMsg->sbcSemEvent)
   \                     ??rs485SemMsgProcess_5: (+1)
   \      0x2C8   0x8820             LDRH     R0,[R4, #+0]
   \      0x2CA   0x2805             CMP      R0,#+5
   \      0x2CC   0xD02F             BEQ.N    ??rs485SemMsgProcess_37
   \      0x2CE   0xF64F 0x71FE      MOVW     R1,#+65534
   \      0x2D2   0x4288             CMP      R0,R1
   \      0x2D4   0xD12F             BNE.N    ??rs485SemMsgProcess_38
   1664                {
   1665                  case SBC_SEM_TIMEOUT:
   1666                    /* no answer. Take here some action to recover the error */
   1667                    if (rs485SemInfoMng.numRetry >= NUM_TRANS_RETRY)
   \                     ??rs485SemMsgProcess_39: (+1)
   \      0x2D6   0xF8BB 0x0013      LDRH     R0,[R11, #+19]
   \      0x2DA   0x2802             CMP      R0,#+2
   \      0x2DC   0xDB06             BLT.N    ??rs485SemMsgProcess_40
   1668                    {
   1669                      rs485SemInfoMng.numRetry = (uint16_t)0;
   \      0x2DE   0x2000             MOVS     R0,#+0
   \      0x2E0   0xF8AB 0x0013      STRH     R0,[R11, #+19]
   1670                      rs485SemInfoMng.rs485SemStates = RS485_SEM_OPERATIVE;
   \      0x2E4   0x2001             MOVS     R0,#+1
   \      0x2E6   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   \      0x2EA   0xE01F             B.N      ??rs485SemMsgProcess_41
   1671                    }
   1672                    else
   1673                    {
   1674                      /* no ACK received, so retry the transmission */
   1675                      rs485SemInfoMng.numRetry++;
   \                     ??rs485SemMsgProcess_40: (+1)
   \      0x2EC   0xF8BB 0x0013      LDRH     R0,[R11, #+19]
   \      0x2F0   0x1C40             ADDS     R0,R0,#+1
   \      0x2F2   0xF8AB 0x0013      STRH     R0,[R11, #+19]
   1676                      if (rs485SemInfoMng.rs485SemStates == RS485_SEM_ACK_WAITING_WR)
   \      0x2F6   0xF8BB 0x0000      LDRH     R0,[R11, #+0]
   \      0x2FA   0x2804             CMP      R0,#+4
   \      0x2FC   0xD106             BNE.N    ??rs485SemMsgProcess_42
   1677                      {
   1678                        writeMasterModbusRegister(rs485SemInfoMng.pOriginData, &rs485SemInfoMng.rs485RWmR);
   \      0x2FE   0xF8DB 0x0002      LDR      R0,[R11, #+2]
   \      0x302   0xF11B 0x0106      ADDS     R1,R11,#+6
   \      0x306   0x.... 0x....      BL       writeMasterModbusRegister
   \      0x30A   0xE003             B.N      ??rs485SemMsgProcess_43
   1679                      }
   1680                      else
   1681                      {
   1682                        readMasterModbusRegister(&rs485SemInfoMng.rs485Rd);
   \                     ??rs485SemMsgProcess_42: (+1)
   \      0x30C   0xF11B 0x000D      ADDS     R0,R11,#+13
   \      0x310   0x.... 0x....      BL       readMasterModbusRegister
   1683                      }
   1684                      tPrintf("Socket %d retrasmission!\n\r", getNumSocketLcd(ixScuLogical));
   \                     ??rs485SemMsgProcess_43: (+1)
   \      0x314   0x0030             MOVS     R0,R6
   \      0x316   0xB2C0             UXTB     R0,R0
   \      0x318   0x.... 0x....      BL       getNumSocketLcd
   \      0x31C   0x0001             MOVS     R1,R0
   \      0x31E   0xB2C9             UXTB     R1,R1
   \      0x320   0x.... 0x....      LDR.W    R0,??DataTable10_5
   \      0x324   0x.... 0x....      BL       tPrintf
   1685                      timeTickTmp = pdMS_TO_TICKS(TIMEOUT_ACK_TRANSMITTER_RESP); 
   \      0x328   0x2064             MOVS     R0,#+100
   \      0x32A   0x0007             MOVS     R7,R0
   1686                    }
   1687                    break;
   \                     ??rs485SemMsgProcess_41: (+1)
   \      0x32C   0xE003             B.N      ??rs485SemMsgProcess_44
   1688          
   1689                  case NOTIFY_MODBUS_ACK:
   1690                    rs485SemInfoMng.rs485SemStates = RS485_SEM_OPERATIVE;
   \                     ??rs485SemMsgProcess_37: (+1)
   \      0x32E   0x2001             MOVS     R0,#+1
   \      0x330   0xF8AB 0x0000      STRH     R0,[R11, #+0]
   1691                    break;
   \      0x334   0xE7FF             B.N      ??rs485SemMsgProcess_44
   1692          
   1693                  default:
   1694                    break;
   1695                }
   1696                break;
   \                     ??rs485SemMsgProcess_38: (+1)
   \                     ??rs485SemMsgProcess_44: (+1)
   \      0x336   0xE7FF             B.N      ??rs485SemMsgProcess_7
   1697          
   1698              default:
   1699                break;
   1700            }
   1701          
   1702            return (timeTickTmp);
   \                     ??rs485SemMsgProcess_6: (+1)
   \                     ??rs485SemMsgProcess_7: (+1)
   \      0x338   0x0038             MOVS     R0,R7
   \      0x33A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1703          }
   1704          // --------------------------------------------------------------------------------------------------------------------------- //
   1705          
   1706          /**
   1707          *
   1708          * @brief        Get the pointer to task queue
   1709          *
   1710          * @param [in]   none
   1711          *
   1712          * @retval       xQueueHandle: pointer to defined  queue
   1713          *
   1714          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1715          xQueueHandle getRs485SemQueueHandle(void)
   1716          {
   1717             return(rs485SemQueue);
   \                     getRs485SemQueueHandle: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR
   1718          }
   1719          
   1720          /**
   1721          *
   1722          * @brief        build an async WRMR message to SCU on RS485  
   1723          *
   1724          * @param [in]   scuRWmultipleReg_st* : pointer to struct where is store the message 
   1725          *
   1726          * @retval       none:  
   1727          *
   1728          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1729          static void  writeMasterModbusRegister (uint8_t* pOriginData, headerReqRWMR_st* pScuRWmR)
   1730          {
   \                     writeMasterModbusRegister: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1731            uint8_t*                pEnd;
   1732            rs485RWmultipleReg_st*  pMsg;
   1733            uint8_t*                pMallocTx;
   1734            uint16_t                length;
   1735            crcMode_u               crc;
   1736          
   1737            pMallocTx = (uint8_t*)malloc(sizeof(headerReqRWMR_st) + pScuRWmR->numBytes + (uint16_t)sizeof(crc)); // remember + 2 for checksum 
   \        0x8   0x79A8             LDRB     R0,[R5, #+6]
   \        0xA   0x3009             ADDS     R0,R0,#+9
   \        0xC   0x.... 0x....      BL       malloc
   \       0x10   0x0007             MOVS     R7,R0
   1738            pMsg = (rs485RWmultipleReg_st*)pMallocTx;
   \       0x12   0x003E             MOVS     R6,R7
   1739            /* the command must be executed    */
   1740            length = (uint16_t)sizeof(headerReqRWMR_st) + pScuRWmR->numBytes;
   \       0x14   0xF895 0x8006      LDRB     R8,[R5, #+6]
   \       0x18   0xF118 0x0807      ADDS     R8,R8,#+7
   1741            pMsg->unitId = pScuRWmR->unitId; 
   \       0x1C   0x7828             LDRB     R0,[R5, #+0]
   \       0x1E   0x7030             STRB     R0,[R6, #+0]
   1742            pMsg->function = FUNCTION_WRITE_MULTIPLE_REG;
   \       0x20   0x2010             MOVS     R0,#+16
   \       0x22   0x7070             STRB     R0,[R6, #+1]
   1743            pMsg->regAdd = swapW(pScuRWmR->regAdd);
   \       0x24   0x8868             LDRH     R0,[R5, #+2]
   \       0x26   0x.... 0x....      BL       swapW
   \       0x2A   0x8070             STRH     R0,[R6, #+2]
   1744            pScuRWmR->numWords = pScuRWmR->numBytes / 2;
   \       0x2C   0x79A8             LDRB     R0,[R5, #+6]
   \       0x2E   0x2102             MOVS     R1,#+2
   \       0x30   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \       0x34   0x80A8             STRH     R0,[R5, #+4]
   1745            pMsg->numWords = swapW(pScuRWmR->numWords);
   \       0x36   0x88A8             LDRH     R0,[R5, #+4]
   \       0x38   0x.... 0x....      BL       swapW
   \       0x3C   0x80B0             STRH     R0,[R6, #+4]
   1746            pMsg->numBytes = pScuRWmR->numBytes;
   \       0x3E   0x79A8             LDRB     R0,[R5, #+6]
   \       0x40   0x71B0             STRB     R0,[R6, #+6]
   1747          
   1748            /*      destination               source          length */
   1749            memcpy((void*)pMsg->data, (void*)pOriginData, (size_t)pScuRWmR->numBytes);
   \       0x42   0xF895 0xA006      LDRB     R10,[R5, #+6]
   \       0x46   0x46A3             MOV      R11,R4
   \       0x48   0xF116 0x0907      ADDS     R9,R6,#+7
   \       0x4C   0x4652             MOV      R2,R10
   \       0x4E   0x4659             MOV      R1,R11
   \       0x50   0x4648             MOV      R0,R9
   \       0x52   0x.... 0x....      BL       __aeabi_memcpy
   1750            
   1751            /* now found the CRC message */
   1752            crc.crcW = crcEvaluation ((uint8_t*)pMsg, length);
   \       0x56   0x4641             MOV      R1,R8
   \       0x58   0xB289             UXTH     R1,R1
   \       0x5A   0x0030             MOVS     R0,R6
   \       0x5C   0x.... 0x....      BL       crcEvaluation
   \       0x60   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1753            /* position pEnd pointer on crc field */
   1754            pEnd =  (uint8_t*)((uint32_t)pMsg + (uint32_t)length);
   \       0x64   0xFA16 0xF088      UXTAH    R0,R6,R8
   1755            *pEnd = crc.crcLH_st.crcL;
   \       0x68   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x6C   0x7001             STRB     R1,[R0, #+0]
   1756            pEnd++;
   \       0x6E   0xF110 0x0901      ADDS     R9,R0,#+1
   1757            *pEnd = crc.crcLH_st.crcH;
   \       0x72   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x76   0xF889 0x0000      STRB     R0,[R9, #+0]
   1758            length += sizeof(crc.crcW);
   \       0x7A   0xF118 0x0802      ADDS     R8,R8,#+2
   1759          
   1760            if (xSemaphoreTake(getScuSinapsiTxUartSemaphoreHandle(), portMAX_DELAY) == pdTRUE)
   \       0x7E   0x.... 0x....      BL       getScuSinapsiTxUartSemaphoreHandle
   \       0x82   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0x86   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x8A   0x2801             CMP      R0,#+1
   \       0x8C   0xD107             BNE.N    ??writeMasterModbusRegister_0
   1761            {
   1762              setMallocTx485(pMallocTx);
   \       0x8E   0x0038             MOVS     R0,R7
   \       0x90   0x.... 0x....      BL       setMallocTx485
   1763              /* start transmission on UART RS485 to SCU RS485 Bus using DMA */
   1764              txOnRs485Bus((uint8_t*)pMsg, (uint16_t)length); 
   \       0x94   0x4641             MOV      R1,R8
   \       0x96   0xB289             UXTH     R1,R1
   \       0x98   0x0030             MOVS     R0,R6
   \       0x9A   0x.... 0x....      BL       txOnRs485Bus
   1765            }
   1766          }
   \                     ??writeMasterModbusRegister_0: (+1)
   \       0x9E   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}
   1767          
   1768          /**
   1769          *
   1770          * @brief        build an async RIR message to slave on RS485  
   1771          *
   1772          * @param [in]   headerRHR_t* : pointer to struct where is stored the read info 
   1773          *
   1774          * @retval       none:  
   1775          *
   1776          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1777          static void  readMasterModbusRegister (headerRHR_t* pScuRIR)
   1778          {
   \                     readMasterModbusRegister: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   1779            uint8_t*                pEnd;
   1780            headerRHR_t*            pMsg;
   1781            uint8_t*                pMallocTx;
   1782            uint16_t                length;
   1783            crcMode_u               crc;
   1784          
   1785            pMallocTx = (uint8_t*)malloc(sizeof(headerRHR_t) + (uint16_t)sizeof(crc)); // remember + 2 for checksum 
   \        0x6   0x2008             MOVS     R0,#+8
   \        0x8   0x.... 0x....      BL       malloc
   \        0xC   0x0006             MOVS     R6,R0
   1786            pMsg = (headerRHR_t*)pMallocTx;
   \        0xE   0x0035             MOVS     R5,R6
   1787            /* the command must be executed    */
   1788            length = (uint16_t)sizeof(headerRHR_t);
   \       0x10   0x2706             MOVS     R7,#+6
   1789            pMsg->unitId = pScuRIR->unitId; 
   \       0x12   0x7820             LDRB     R0,[R4, #+0]
   \       0x14   0x7028             STRB     R0,[R5, #+0]
   1790            pMsg->function = FUNCTION_READ_INPUT_REG;
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0x7068             STRB     R0,[R5, #+1]
   1791            pMsg->regAdd = swapW(pScuRIR->regAdd);
   \       0x1A   0x8860             LDRH     R0,[R4, #+2]
   \       0x1C   0x.... 0x....      BL       swapW
   \       0x20   0x8068             STRH     R0,[R5, #+2]
   1792            pMsg->numBytes = swapW(pScuRIR->numBytes);
   \       0x22   0x88A0             LDRH     R0,[R4, #+4]
   \       0x24   0x.... 0x....      BL       swapW
   \       0x28   0x80A8             STRH     R0,[R5, #+4]
   1793          
   1794            /* now found the CRC message */
   1795            crc.crcW = crcEvaluation ((uint8_t*)pMsg, length);
   \       0x2A   0x0039             MOVS     R1,R7
   \       0x2C   0xB289             UXTH     R1,R1
   \       0x2E   0x0028             MOVS     R0,R5
   \       0x30   0x.... 0x....      BL       crcEvaluation
   \       0x34   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1796            /* position pEnd pointer on crc field */
   1797            pEnd =  (uint8_t*)((uint32_t)pMsg + (uint32_t)length);
   \       0x38   0xFA15 0xF087      UXTAH    R0,R5,R7
   1798            *pEnd = crc.crcLH_st.crcL;
   \       0x3C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x40   0x7001             STRB     R1,[R0, #+0]
   1799            pEnd++;
   \       0x42   0xF110 0x0801      ADDS     R8,R0,#+1
   1800            *pEnd = crc.crcLH_st.crcH;
   \       0x46   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x4A   0xF888 0x0000      STRB     R0,[R8, #+0]
   1801            length += sizeof(crc.crcW);
   \       0x4E   0x1CBF             ADDS     R7,R7,#+2
   1802          
   1803            if (xSemaphoreTake(getScuSinapsiTxUartSemaphoreHandle(), portMAX_DELAY) == pdTRUE)
   \       0x50   0x.... 0x....      BL       getScuSinapsiTxUartSemaphoreHandle
   \       0x54   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0x58   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x5C   0x2801             CMP      R0,#+1
   \       0x5E   0xD107             BNE.N    ??readMasterModbusRegister_0
   1804            {
   1805              setMallocTx485(pMallocTx);
   \       0x60   0x0030             MOVS     R0,R6
   \       0x62   0x.... 0x....      BL       setMallocTx485
   1806              /* start transmission on UART RS485 to SCU RS485 Bus using DMA */
   1807              txOnRs485Bus((uint8_t*)pMsg, (uint16_t)length); 
   \       0x66   0x0039             MOVS     R1,R7
   \       0x68   0xB289             UXTH     R1,R1
   \       0x6A   0x0028             MOVS     R0,R5
   \       0x6C   0x.... 0x....      BL       txOnRs485Bus
   1808            }
   1809          }
   \                     ??readMasterModbusRegister_0: (+1)
   \       0x70   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}
   1810          
   1811          /**
   1812          *
   1813          * @brief       get info from a socket 
   1814          *
   1815          * @param [in]  uint32_t : mask bit for the socket    
   1816          * @param [in]  sbcSemInfoMng_st* : info for discovery    
   1817          *  
   1818          * @retval      uint8_t: TRUE, more slave must be checked; FALSE 
   1819          *              end procedure 
   1820          *  
   1821          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1822          static uint8_t getInfoSocket(uint32_t presenceMask, sbcSemInfoMng_st* pInfo) 
   1823          {
   \                     getInfoSocket: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x000E             MOVS     R6,R1
   1824            uint32_t              result;
   1825            frameSbcSem_st        tmpFrameSbcSem;
   1826            scuRwMapRegister_st*  pRwRegs;
   1827            scuRoMapRegister_st*  pRoRegs; 
   1828            tmMapRegister_st*     pTmRegs;
   1829          
   1830            if (pInfo->logicIdSocket >= SCU_NUM) return(FALSE);
   \        0xA   0x8930             LDRH     R0,[R6, #+8]
   \        0xC   0x2810             CMP      R0,#+16
   \        0xE   0xDB01             BLT.N    ??getInfoSocket_0
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE12C             B.N      ??getInfoSocket_1
   1831          
   1832            pRwRegs = getRwMdbRegs(pInfo->logicIdSocket);
   \                     ??getInfoSocket_0: (+1)
   \       0x14   0x8930             LDRH     R0,[R6, #+8]
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x.... 0x....      BL       getRwMdbRegs
   \       0x1C   0x0007             MOVS     R7,R0
   1833            pRoRegs = getRoMdbRegs(pInfo->logicIdSocket);
   \       0x1E   0x8930             LDRH     R0,[R6, #+8]
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x.... 0x....      BL       getRoMdbRegs
   \       0x26   0x4680             MOV      R8,R0
   1834          
   1835            do
   1836            {
   1837              result = presenceMask & pInfo->discoveryMask;
   \                     ??getInfoSocket_2: (+1)
   \       0x28   0xF8D6 0x000A      LDR      R0,[R6, #+10]
   \       0x2C   0x4028             ANDS     R0,R0,R5
   \       0x2E   0x0004             MOVS     R4,R0
   1838              if ((result) != (uint32_t)0)
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xF000 0x80FE      BEQ.W    ??getInfoSocket_3
   1839              {
   1840                /* the socket with this mask is present */
   1841                switch (pInfo->addrVal)
   \       0x36   0x88F0             LDRH     R0,[R6, #+6]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD06B             BEQ.N    ??getInfoSocket_4
   \       0x3C   0xF5B0 0x7F40      CMP      R0,#+768
   \       0x40   0xD00D             BEQ.N    ??getInfoSocket_5
   \       0x42   0xF240 0x4104      MOVW     R1,#+1028
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xF000 0x8090      BEQ.W    ??getInfoSocket_6
   \       0x4C   0xF240 0x5123      MOVW     R1,#+1315
   \       0x50   0x4288             CMP      R0,R1
   \       0x52   0xF000 0x80BA      BEQ.W    ??getInfoSocket_7
   \       0x56   0xF5B0 0x6FC0      CMP      R0,#+1536
   \       0x5A   0xD02D             BEQ.N    ??getInfoSocket_8
   \       0x5C   0xE0FB             B.N      ??getInfoSocket_9
   1842                {
   1843                  case ADDR_START_RDD:
   1844                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_RX;
   \                     ??getInfoSocket_5: (+1)
   \       0x5E   0x2006             MOVS     R0,#+6
   \       0x60   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1845                    tmpFrameSbcSem.data.index = pInfo->logicIdSocket + 1; // physical address 1...16 
   \       0x64   0x8930             LDRH     R0,[R6, #+8]
   \       0x66   0x1C40             ADDS     R0,R0,#+1
   \       0x68   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1846                    tmpFrameSbcSem.data.rAddr = ADDR_START_RDD;
   \       0x6C   0xF44F 0x7040      MOV      R0,#+768
   \       0x70   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1847                    pInfo->pDataRd = (uint8_t*)&pRoRegs->scuMapRegInfoVer;
   \       0x74   0xF8C6 0x800E      STR      R8,[R6, #+14]
   1848                    tmpFrameSbcSem.dataToSend.len = (uint16_t)(ADDR_SCU_RESERVED1 - ADDR_START_RDD);  /* richiedo la lettura di tutta la remote inventory: versione FW, SN, ... */
   \       0x78   0x207B             MOVS     R0,#+123
   \       0x7A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1849                    pInfo->dataVal = tmpFrameSbcSem.dataToSend.len * 2;  // lenght in bytes 
   \       0x7E   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \       0x82   0xB280             UXTH     R0,R0
   \       0x84   0x0040             LSLS     R0,R0,#+1
   \       0x86   0x80B0             STRH     R0,[R6, #+4]
   1850                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \       0x88   0x.... 0x....      BL       getRs485SemQueueHandle
   \       0x8C   0x2300             MOVS     R3,#+0
   \       0x8E   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x92   0x4669             MOV      R1,SP
   \       0x94   0x.... 0x....      BL       xQueueGenericSend
   \       0x98   0x2801             CMP      R0,#+1
   \       0x9A   0xD009             BEQ.N    ??getInfoSocket_10
   \       0x9C   0xB672             CPSID    I
   \       0x9E   0x2050             MOVS     R0,#+80
   \       0xA0   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xA4   0xF3BF 0x8F4F      DSB      SY
   \       0xA8   0xF3BF 0x8F6F      ISB      SY
   \       0xAC   0xB662             CPSIE    I
   \                     ??getInfoSocket_11: (+1)
   \       0xAE   0xE7FE             B.N      ??getInfoSocket_11
   1851                    /* point to next info to request  */
   1852                    pInfo->addrVal = ADDR_EVSE_EVENT_FLAGS_RO;
   \                     ??getInfoSocket_10: (+1)
   \       0xB0   0xF44F 0x60C0      MOV      R0,#+1536
   \       0xB4   0x80F0             STRH     R0,[R6, #+6]
   1853                    break;
   \       0xB6   0xE0CE             B.N      ??getInfoSocket_9
   1854          
   1855                  case ADDR_EVSE_EVENT_FLAGS_RO:
   1856                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_RX;
   \                     ??getInfoSocket_8: (+1)
   \       0xB8   0x2006             MOVS     R0,#+6
   \       0xBA   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1857                    tmpFrameSbcSem.data.index = pInfo->logicIdSocket + 1;  // physical address 1...16 
   \       0xBE   0x8930             LDRH     R0,[R6, #+8]
   \       0xC0   0x1C40             ADDS     R0,R0,#+1
   \       0xC2   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1858                    tmpFrameSbcSem.data.rAddr = ADDR_EVSE_EVENT_FLAGS_RO;
   \       0xC6   0xF44F 0x60C0      MOV      R0,#+1536
   \       0xCA   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1859                    pInfo->pDataRd = (uint8_t*)&pRoRegs->scuMapRegStatusMeas;
   \       0xCE   0xF518 0x7091      ADDS     R0,R8,#+290
   \       0xD2   0xF8C6 0x000E      STR      R0,[R6, #+14]
   1860                    tmpFrameSbcSem.dataToSend.len = (uint16_t)(ADDR_SCU_RESERVED6B - ADDR_EVSE_EVENT_FLAGS_RO);  /* richiedo la lettura dello stato di tutti gli eventi */
   \       0xD6   0x206A             MOVS     R0,#+106
   \       0xD8   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1861                    pInfo->dataVal = tmpFrameSbcSem.dataToSend.len * 2;  // lenght in bytes  
   \       0xDC   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \       0xE0   0xB280             UXTH     R0,R0
   \       0xE2   0x0040             LSLS     R0,R0,#+1
   \       0xE4   0x80B0             STRH     R0,[R6, #+4]
   1862                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \       0xE6   0x.... 0x....      BL       getRs485SemQueueHandle
   \       0xEA   0x2300             MOVS     R3,#+0
   \       0xEC   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0xF0   0x4669             MOV      R1,SP
   \       0xF2   0x.... 0x....      BL       xQueueGenericSend
   \       0xF6   0x2801             CMP      R0,#+1
   \       0xF8   0xD009             BEQ.N    ??getInfoSocket_12
   \       0xFA   0xB672             CPSID    I
   \       0xFC   0x2050             MOVS     R0,#+80
   \       0xFE   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x102   0xF3BF 0x8F4F      DSB      SY
   \      0x106   0xF3BF 0x8F6F      ISB      SY
   \      0x10A   0xB662             CPSIE    I
   \                     ??getInfoSocket_13: (+1)
   \      0x10C   0xE7FE             B.N      ??getInfoSocket_13
   1863                    /* point to next info to request  */
   1864                    pInfo->addrVal = ADDR_CONNECTOR_TYPE_RW;
   \                     ??getInfoSocket_12: (+1)
   \      0x10E   0x2000             MOVS     R0,#+0
   \      0x110   0x80F0             STRH     R0,[R6, #+6]
   1865                    break;
   \      0x112   0xE0A0             B.N      ??getInfoSocket_9
   1866          
   1867                  case ADDR_CONNECTOR_TYPE_RW:
   1868                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_RX;
   \                     ??getInfoSocket_4: (+1)
   \      0x114   0x2006             MOVS     R0,#+6
   \      0x116   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1869                    tmpFrameSbcSem.data.index = pInfo->logicIdSocket + 1;   // physical address 1...16 
   \      0x11A   0x8930             LDRH     R0,[R6, #+8]
   \      0x11C   0x1C40             ADDS     R0,R0,#+1
   \      0x11E   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1870                    tmpFrameSbcSem.data.rAddr = ADDR_CONNECTOR_TYPE_RW;
   \      0x122   0x2000             MOVS     R0,#+0
   \      0x124   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1871                    pInfo->pDataRd = (uint8_t*)&pRwRegs->scuSetRegister;
   \      0x128   0xF8C6 0x700E      STR      R7,[R6, #+14]
   1872                    tmpFrameSbcSem.dataToSend.len = (uint16_t)(ADDR_RESERVED_A - ADDR_CONNECTOR_TYPE_RW);  /* richiedo la lettura delle configurazioni  */
   \      0x12C   0x2069             MOVS     R0,#+105
   \      0x12E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1873                    pInfo->dataVal = tmpFrameSbcSem.dataToSend.len * 2;  // lenght in bytes 
   \      0x132   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x136   0xB280             UXTH     R0,R0
   \      0x138   0x0040             LSLS     R0,R0,#+1
   \      0x13A   0x80B0             STRH     R0,[R6, #+4]
   1874                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x13C   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x140   0x2300             MOVS     R3,#+0
   \      0x142   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x146   0x4669             MOV      R1,SP
   \      0x148   0x.... 0x....      BL       xQueueGenericSend
   \      0x14C   0x2801             CMP      R0,#+1
   \      0x14E   0xD009             BEQ.N    ??getInfoSocket_14
   \      0x150   0xB672             CPSID    I
   \      0x152   0x2050             MOVS     R0,#+80
   \      0x154   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x158   0xF3BF 0x8F4F      DSB      SY
   \      0x15C   0xF3BF 0x8F6F      ISB      SY
   \      0x160   0xB662             CPSIE    I
   \                     ??getInfoSocket_15: (+1)
   \      0x162   0xE7FE             B.N      ??getInfoSocket_15
   1875                    /* point to next info to request  */
   1876                    pInfo->addrVal = ADDR_EVSE_ERROR1_RO;
   \                     ??getInfoSocket_14: (+1)
   \      0x164   0xF240 0x4004      MOVW     R0,#+1028
   \      0x168   0x80F0             STRH     R0,[R6, #+6]
   1877                    break;
   \      0x16A   0xE074             B.N      ??getInfoSocket_9
   1878          
   1879                  case ADDR_EVSE_ERROR1_RO:
   1880                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_RX;
   \                     ??getInfoSocket_6: (+1)
   \      0x16C   0x2006             MOVS     R0,#+6
   \      0x16E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1881                    tmpFrameSbcSem.data.index = pInfo->logicIdSocket + 1;   // physical address 1...16 
   \      0x172   0x8930             LDRH     R0,[R6, #+8]
   \      0x174   0x1C40             ADDS     R0,R0,#+1
   \      0x176   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1882                    tmpFrameSbcSem.data.rAddr = ADDR_EVSE_ERROR1_RO;
   \      0x17A   0xF240 0x4004      MOVW     R0,#+1028
   \      0x17E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1883                    pInfo->pDataRd = (uint8_t*)&pRoRegs->scuMapRegNotify.ntfErr1;
   \      0x182   0xF118 0x00FE      ADDS     R0,R8,#+254
   \      0x186   0xF8C6 0x000E      STR      R0,[R6, #+14]
   1884                    tmpFrameSbcSem.dataToSend.len = (uint16_t)(ADDR_EVSE_CHANGE_REGISTERS_RO  - ADDR_EVSE_ERROR1_RO);  /* richiedo la lettura degli errori  */
   \      0x18A   0x2002             MOVS     R0,#+2
   \      0x18C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1885                    pInfo->dataVal = tmpFrameSbcSem.dataToSend.len * 2;  // lenght in bytes 
   \      0x190   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x194   0xB280             UXTH     R0,R0
   \      0x196   0x0040             LSLS     R0,R0,#+1
   \      0x198   0x80B0             STRH     R0,[R6, #+4]
   1886                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x19A   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x19E   0x2300             MOVS     R3,#+0
   \      0x1A0   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x1A4   0x4669             MOV      R1,SP
   \      0x1A6   0x.... 0x....      BL       xQueueGenericSend
   \      0x1AA   0x2801             CMP      R0,#+1
   \      0x1AC   0xD009             BEQ.N    ??getInfoSocket_16
   \      0x1AE   0xB672             CPSID    I
   \      0x1B0   0x2050             MOVS     R0,#+80
   \      0x1B2   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x1B6   0xF3BF 0x8F4F      DSB      SY
   \      0x1BA   0xF3BF 0x8F6F      ISB      SY
   \      0x1BE   0xB662             CPSIE    I
   \                     ??getInfoSocket_17: (+1)
   \      0x1C0   0xE7FE             B.N      ??getInfoSocket_17
   1887          #if BOARD_REPAIR
   1888                    if ((pInfo->discoveryMask & pInfo->infoEepromSlaveToDo) == 0)
   1889                    {
   1890                      /* point to next possible slave */
   1891                      pInfo->addrVal = ADDR_START_RDD;
   1892                    }
   1893                    else
   1894                    {
   1895                      /* eeprom info parameter must be reuired to the slave */
   1896                      pInfo->addrVal = ADDR_GET_EEPROM_RW;
   1897                      /* reset the flag: only one time the request must be performed */
   1898                      pInfo->infoEepromSlaveToDo &= (~pInfo->discoveryMask);
   1899                    }
   1900          #else
   1901                    /* point to next possible slave */
   1902                    pInfo->addrVal = ADDR_START_RDD;
   \                     ??getInfoSocket_16: (+1)
   \      0x1C2   0xF44F 0x7040      MOV      R0,#+768
   \      0x1C6   0x80F0             STRH     R0,[R6, #+6]
   1903          #endif
   1904                    break;
   \      0x1C8   0xE045             B.N      ??getInfoSocket_9
   1905          
   1906                  case ADDR_GET_EEPROM_RW:
   1907                    pTmRegs = getTmMdbRegs(pInfo->logicIdSocket);
   \                     ??getInfoSocket_7: (+1)
   \      0x1CA   0x8930             LDRH     R0,[R6, #+8]
   \      0x1CC   0xB2C0             UXTB     R0,R0
   \      0x1CE   0x.... 0x....      BL       getTmMdbRegs
   \      0x1D2   0x4681             MOV      R9,R0
   1908                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_RX;
   \      0x1D4   0x2006             MOVS     R0,#+6
   \      0x1D6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1909                    tmpFrameSbcSem.data.index = pInfo->logicIdSocket + 1;   // physical address 1...16 
   \      0x1DA   0x8930             LDRH     R0,[R6, #+8]
   \      0x1DC   0x1C40             ADDS     R0,R0,#+1
   \      0x1DE   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   1910                    tmpFrameSbcSem.data.rAddr = ADDR_GET_EEPROM_RW;
   \      0x1E2   0xF240 0x5023      MOVW     R0,#+1315
   \      0x1E6   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1911                    pInfo->pDataRd = (uint8_t*)&pTmRegs->tmGetEeprom;  
   \      0x1EA   0xF119 0x0026      ADDS     R0,R9,#+38
   \      0x1EE   0xF8C6 0x000E      STR      R0,[R6, #+14]
   1912                    tmpFrameSbcSem.dataToSend.len = (uint16_t)(LEN_TM_GET_EEPROM_RW);  /* richiedo la lettura della EEPROM  */
   \      0x1F2   0x2001             MOVS     R0,#+1
   \      0x1F4   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1913                    pInfo->dataVal = tmpFrameSbcSem.dataToSend.len * 2;  // lenght in bytes 
   \      0x1F8   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x1FC   0xB280             UXTH     R0,R0
   \      0x1FE   0x0040             LSLS     R0,R0,#+1
   \      0x200   0x80B0             STRH     R0,[R6, #+4]
   1914                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x202   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x206   0x2300             MOVS     R3,#+0
   \      0x208   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x20C   0x4669             MOV      R1,SP
   \      0x20E   0x.... 0x....      BL       xQueueGenericSend
   \      0x212   0x2801             CMP      R0,#+1
   \      0x214   0xD009             BEQ.N    ??getInfoSocket_18
   \      0x216   0xB672             CPSID    I
   \      0x218   0x2050             MOVS     R0,#+80
   \      0x21A   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x21E   0xF3BF 0x8F4F      DSB      SY
   \      0x222   0xF3BF 0x8F6F      ISB      SY
   \      0x226   0xB662             CPSIE    I
   \                     ??getInfoSocket_19: (+1)
   \      0x228   0xE7FE             B.N      ??getInfoSocket_19
   1915                    /* point to next possible slave */
   1916                    pInfo->addrVal = ADDR_START_RDD;
   \                     ??getInfoSocket_18: (+1)
   \      0x22A   0xF44F 0x7040      MOV      R0,#+768
   \      0x22E   0x80F0             STRH     R0,[R6, #+6]
   1917                    break;
   \      0x230   0xE011             B.N      ??getInfoSocket_9
   1918                }
   1919              }
   1920              else
   1921              {
   1922                pInfo->discoveryMask = pInfo->discoveryMask << 1;
   \                     ??getInfoSocket_3: (+1)
   \      0x232   0xF8D6 0x000A      LDR      R0,[R6, #+10]
   \      0x236   0x0040             LSLS     R0,R0,#+1
   \      0x238   0xF8C6 0x000A      STR      R0,[R6, #+10]
   1923                pInfo->logicIdSocket++;
   \      0x23C   0x8930             LDRH     R0,[R6, #+8]
   \      0x23E   0x1C40             ADDS     R0,R0,#+1
   \      0x240   0x8130             STRH     R0,[R6, #+8]
   1924                pRwRegs = getRwMdbRegs(pInfo->logicIdSocket);
   \      0x242   0x8930             LDRH     R0,[R6, #+8]
   \      0x244   0xB2C0             UXTB     R0,R0
   \      0x246   0x.... 0x....      BL       getRwMdbRegs
   \      0x24A   0x0007             MOVS     R7,R0
   1925                pRoRegs = getRoMdbRegs(pInfo->logicIdSocket);
   \      0x24C   0x8930             LDRH     R0,[R6, #+8]
   \      0x24E   0xB2C0             UXTB     R0,R0
   \      0x250   0x.... 0x....      BL       getRoMdbRegs
   \      0x254   0x4680             MOV      R8,R0
   1926              }
   1927            }while ((result == (uint32_t)0) && (pInfo->logicIdSocket < SCU_NUM));
   \                     ??getInfoSocket_9: (+1)
   \      0x256   0x2C00             CMP      R4,#+0
   \      0x258   0xD103             BNE.N    ??getInfoSocket_20
   \      0x25A   0x8930             LDRH     R0,[R6, #+8]
   \      0x25C   0x2810             CMP      R0,#+16
   \      0x25E   0xF6FF 0xAEE3      BLT.W    ??getInfoSocket_2
   1928          
   1929            if (pInfo->logicIdSocket >= SCU_NUM) return(FALSE); else return(TRUE);
   \                     ??getInfoSocket_20: (+1)
   \      0x262   0x8930             LDRH     R0,[R6, #+8]
   \      0x264   0x2810             CMP      R0,#+16
   \      0x266   0xDB01             BLT.N    ??getInfoSocket_21
   \      0x268   0x2000             MOVS     R0,#+0
   \      0x26A   0xE000             B.N      ??getInfoSocket_1
   \                     ??getInfoSocket_21: (+1)
   \      0x26C   0x2001             MOVS     R0,#+1
   \                     ??getInfoSocket_1: (+1)
   \      0x26E   0xB005             ADD      SP,SP,#+20
   \      0x270   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1930          
   1931          }
   1932          
   1933          /**
   1934          *
   1935          * @brief       get info on RS485 transmission status  
   1936          *
   1937          * @param [in]  uint32_t : mask bit for the socket    
   1938          * @param [in]  sbcSemInfoMng_st* : info for discovery    
   1939          *  
   1940          * @retval      uint8_t: TRUE transmission complete (Tx + ACK) 
   1941          *  
   1942          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1943          uint8_t txRS485Available(void) 
   1944          {
   1945            if (rs485SemInfoMng.rs485SemStates == RS485_SEM_OPERATIVE) return(TRUE); else return(FALSE);
   \                     txRS485Available: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \        0x4   0x8800             LDRH     R0,[R0, #+0]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??txRS485Available_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??txRS485Available_1
   \                     ??txRS485Available_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??txRS485Available_1: (+1)
   \       0x10   0x4770             BX       LR
   1946          }
   1947          
   1948          /**
   1949          *
   1950          * @brief       Actuators_Mdb_to_Eeprom_Translate translate modbus to
   1951          *              Eeprom codification
   1952          *           
   1953          * @param [in]  pointer to the variable to change
   1954          *  
   1955          * @retval      None
   1956          *  
   1957          ****************************************************************/
   1958          

   \                                 In section .text, align 2, keep-with-next
   1959          void Actuators_Mdb_to_Eeprom_Translate (uint8_t *ptr)
   1960          {
   \                     Actuators_Mdb_to_Eeprom_Translate: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1961            uint8_t tmp = 0, tmp1 = FALSE;
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1962              
   1963            if((*ptr & ACT_BLCK) == ACT_BLCK)
   \        0xC   0x7820             LDRB     R0,[R4, #+0]
   \        0xE   0x07C0             LSLS     R0,R0,#+31
   \       0x10   0xD501             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_0
   1964            {
   1965              tmp |= BLOCK_ATT0;
   \       0x12   0xF055 0x0508      ORRS     R5,R5,#0x8
   1966            }
   1967            
   1968            if((*ptr & ACT_MIRR) == ACT_MIRR)
   \                     ??Actuators_Mdb_to_Eeprom_Translate_0: (+1)
   \       0x16   0x7820             LDRB     R0,[R4, #+0]
   \       0x18   0x0780             LSLS     R0,R0,#+30
   \       0x1A   0xD501             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_1
   1969            {
   1970              tmp |= CONTACT_ATT0;
   \       0x1C   0xF055 0x0540      ORRS     R5,R5,#0x40
   1971            }
   1972            
   1973            if((*ptr & ACT_RCBO) == ACT_RCBO)
   \                     ??Actuators_Mdb_to_Eeprom_Translate_1: (+1)
   \       0x20   0x7820             LDRB     R0,[R4, #+0]
   \       0x22   0x0740             LSLS     R0,R0,#+29
   \       0x24   0xD501             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_2
   1974            {
   1975              tmp |= RCBO_ATT0;
   \       0x26   0xF055 0x0580      ORRS     R5,R5,#0x80
   1976            }
   1977          
   1978            /* Check if BBCK must be enabled */
   1979            if ((*ptr & ACT_BACK) == ACT_BACK)
   \                     ??Actuators_Mdb_to_Eeprom_Translate_2: (+1)
   \       0x2A   0x7820             LDRB     R0,[R4, #+0]
   \       0x2C   0x06C0             LSLS     R0,R0,#+27
   \       0x2E   0xD504             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_3
   1980            {
   1981              /* Set flag for SEM */
   1982              tmp |= BBCK_ATT0; 
   \       0x30   0xF055 0x0520      ORRS     R5,R5,#0x20
   1983              /* Set backup flag for webUI http */
   1984              tmp1 = TRUE;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1985            }
   1986          
   1987            /* Save Backup flag in eeprom (for webUI http )*/
   1988            eeprom_array_set(BATTERY_CONFIG_EADD, (uint8_t*)&tmp1, 1);    
   \                     ??Actuators_Mdb_to_Eeprom_Translate_3: (+1)
   \       0x3A   0x2201             MOVS     R2,#+1
   \       0x3C   0x4669             MOV      R1,SP
   \       0x3E   0x2007             MOVS     R0,#+7
   \       0x40   0x.... 0x....      BL       eeprom_array_set
   1989            
   1990            /* Get LCD_TYPE address from eeprom, where WIFI_ON is saved */
   1991            eeprom_param_get(LCD_TYPE_EADD, (uint8_t *)&tmp1, 1);
   \       0x44   0x2201             MOVS     R2,#+1
   \       0x46   0x4669             MOV      R1,SP
   \       0x48   0x2034             MOVS     R0,#+52
   \       0x4A   0x.... 0x....      BL       eeprom_param_get
   1992            /* Check if WIFI must be enabled or not */
   1993            if((*ptr & ACT_WIFI) == ACT_WIFI)
   \       0x4E   0x7820             LDRB     R0,[R4, #+0]
   \       0x50   0x0700             LSLS     R0,R0,#+28
   \       0x52   0xD506             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_4
   1994              tmp1 |= WIFI_ON;        /* Enable WIFI */
   \       0x54   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x58   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x5C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x60   0xE005             B.N      ??Actuators_Mdb_to_Eeprom_Translate_5
   1995            else
   1996              tmp1 &= ~WIFI_ON;       /* Disable WIFI */
   \                     ??Actuators_Mdb_to_Eeprom_Translate_4: (+1)
   \       0x62   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x66   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \       0x6A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1997            
   1998            /* Save new configuration */
   1999            
   2000            /*** SAVE ON EEPROM ***/   
   2001            EEPROM_Save_Config (LCD_TYPE_EADD, (uint8_t *)&tmp1, 1);
   \                     ??Actuators_Mdb_to_Eeprom_Translate_5: (+1)
   \       0x6E   0x2201             MOVS     R2,#+1
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0x2034             MOVS     R0,#+52
   \       0x74   0x.... 0x....      BL       EEPROM_Save_Config
   2002            
   2003            /* Get configuration of hw check2 from modbus */ 
   2004            /* P.S --> PAUT in modbus map is inside hw checks settings */
   2005            tmp1 = getHwChecks2();
   \       0x78   0x.... 0x....      BL       getHwChecks2
   \       0x7C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2006          
   2007            /* PAUT enabled? check in modbus map */
   2008            if (tmp1 & PAUT_CRL2)
   \       0x80   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x84   0x0700             LSLS     R0,R0,#+28
   \       0x86   0xD502             BPL.N    ??Actuators_Mdb_to_Eeprom_Translate_6
   2009              tmp |= PAUT_ATT0;   /* Set Post authorization mode */
   \       0x88   0xF055 0x0510      ORRS     R5,R5,#0x10
   \       0x8C   0xE001             B.N      ??Actuators_Mdb_to_Eeprom_Translate_7
   2010            else
   2011              tmp &= ~PAUT_ATT0;  /* Reset Post authorization mode */ 
   \                     ??Actuators_Mdb_to_Eeprom_Translate_6: (+1)
   \       0x8E   0xF015 0x05EF      ANDS     R5,R5,#0xEF
   2012            
   2013            *ptr = tmp;
   \                     ??Actuators_Mdb_to_Eeprom_Translate_7: (+1)
   \       0x92   0x7025             STRB     R5,[R4, #+0]
   2014          }
   \       0x94   0xBD31             POP      {R0,R4,R5,PC}
   2015          
   2016          /**
   2017          *
   2018          * @brief       Save HW Checks and Actuators into Eeeprom 
   2019          *              
   2020          *           
   2021          * @param [in]  Modbus address of the register to save
   2022          *  
   2023          * @retval      None
   2024          *  
   2025          ****************************************************************/
   2026          

   \                                 In section .text, align 2, keep-with-next
   2027          void HW_CHECKS_ACTUATORS_EEprom_Save (uint16_t rAddr)
   2028          {
   \                     HW_CHECKS_ACTUATORS_EEprom_Save: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2029            uint8_t   HwCheckTmp, temp8;
   2030            uint16_t  hwCheck;
   2031            static uint8_t   temp[5];
   2032            uint8_t collaudoFlag;
   2033            
   2034            /* Save in EEPROM check flags and actuator presence */
   2035            switch (rAddr)  
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB280             UXTH     R0,R0
   \        0x8   0x2826             CMP      R0,#+38
   \        0xA   0xD004             BEQ.N    ??HW_CHECKS_ACTUATORS_EEprom_Save_0
   \        0xC   0xD34C             BCC.N    ??HW_CHECKS_ACTUATORS_EEprom_Save_1
   \        0xE   0x2828             CMP      R0,#+40
   \       0x10   0xD033             BEQ.N    ??HW_CHECKS_ACTUATORS_EEprom_Save_2
   \       0x12   0xD31C             BCC.N    ??HW_CHECKS_ACTUATORS_EEprom_Save_3
   \       0x14   0xE048             B.N      ??HW_CHECKS_ACTUATORS_EEprom_Save_1
   2036            {
   2037              case ADDR_HW_CHECKS1_RW:                    /* Prepare HW_CHECK1_RW */
   2038                  /* Get configuration from eeprom */
   2039                  eeprom_param_get(CONTROL_BYTE0_EADD, &HwCheckTmp, 1);
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_0: (+1)
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x2010             MOVS     R0,#+16
   \       0x1C   0x.... 0x....      BL       eeprom_param_get
   2040                  /* bit 4 and 5 have a different codification between Modbus map and Eeprom: BLE and WiFi in modbus, 
   2041                     REMOTE and PULS in GSY and WebUI ???) */
   2042                  /* Configuration from EEprom --> Consider bit 4 and 5, used for REMOTE and PULS */
   2043                  HwCheckTmp &= (uint8_t)(REMOTE_CRL0 | PULS_CRL0);  
   \       0x20   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x24   0xF010 0x0030      ANDS     R0,R0,#0x30
   \       0x28   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2044                  /* Get configuration from modbus */
   2045                  hwCheck = getHwChecks1();
   \       0x2C   0x.... 0x....      BL       getHwChecks1
   2046                  /* Clear bit4 and 5, reserved for REMOTE and PULS */
   2047                  hwCheck &= ~(uint8_t)(REMOTE_CRL0 | PULS_CRL0);
   \       0x30   0xF64F 0x71CF      MOVW     R1,#+65487
   \       0x34   0x4008             ANDS     R0,R1,R0
   \       0x36   0x0005             MOVS     R5,R0
   2048                  temp[0] = (uint8_t)hwCheck | HwCheckTmp;  
   \       0x38   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x3C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x40   0x4329             ORRS     R1,R1,R5
   \       0x42   0x7001             STRB     R1,[R0, #+0]
   2049                  temp[1] = (uint8_t)(hwCheck >> 8);
   \       0x44   0x0029             MOVS     R1,R5
   \       0x46   0xB289             UXTH     R1,R1
   \       0x48   0x0A09             LSRS     R1,R1,#+8
   \       0x4A   0x7041             STRB     R1,[R0, #+1]
   2050                break;
   \       0x4C   0xE02C             B.N      ??HW_CHECKS_ACTUATORS_EEprom_Save_4
   2051                
   2052              case ADDR_HW_CHECKS2_RW:                   /* Prepare HW_CHECK2_RW */
   2053                  /* Get configuration from modbus */      
   2054                  hwCheck = getHwChecks2();
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_3: (+1)
   \       0x4E   0x.... 0x....      BL       getHwChecks2
   \       0x52   0x0005             MOVS     R5,R0
   2055                  temp[2] = (uint8_t)hwCheck;  
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable12
   \       0x58   0x7085             STRB     R5,[R0, #+2]
   2056                  temp[3] = (uint8_t)(hwCheck >> 8);
   \       0x5A   0x0029             MOVS     R1,R5
   \       0x5C   0xB289             UXTH     R1,R1
   \       0x5E   0x0A09             LSRS     R1,R1,#+8
   \       0x60   0x70C1             STRB     R1,[R0, #+3]
   2057                  /* Set HGTP configuration in eeprom for webserver GUI */
   2058                  temp8 = (hwCheck & HGTP_CRL2) >> HGTP_CRL2_bit_pos;        
   \       0x62   0x0028             MOVS     R0,R5
   \       0x64   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \       0x68   0xF88D 0x0001      STRB     R0,[SP, #+1]
   2059                  
   2060                  /*** SAVE ON EEPROM ***/                   
   2061                  EEPROM_Save_Config (TEMP_CTRL_ENB_EADD, &temp8, 1);
   \       0x6C   0x2201             MOVS     R2,#+1
   \       0x6E   0xF10D 0x0101      ADD      R1,SP,#+1
   \       0x72   0x203B             MOVS     R0,#+59
   \       0x74   0x.... 0x....      BL       EEPROM_Save_Config
   2062                break;
   \       0x78   0xE016             B.N      ??HW_CHECKS_ACTUATORS_EEprom_Save_4
   2063                
   2064              case ADDR_HW_ACTUATORS_RW:                /* Prepare HW_ACTUATORS_RW */
   2065                  /* Get actuators from modbus */
   2066                  temp[4] = (uint8_t)getHwActuators();                   
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_2: (+1)
   \       0x7A   0x.... 0x....      LDR.W    R7,??DataTable12
   \       0x7E   0x.... 0x....      BL       getHwActuators
   \       0x82   0x7138             STRB     R0,[R7, #+4]
   2067                  /* Translate actuators informations from modbus format to eeprom format */
   2068                  Actuators_Mdb_to_Eeprom_Translate (&temp[4]);  
   \       0x84   0x1D38             ADDS     R0,R7,#+4
   \       0x86   0x.... 0x....      BL       Actuators_Mdb_to_Eeprom_Translate
   2069                  /* Write settings into eeprom */
   2070                  /*** SAVE ON EEPROM ***/           
   2071                  EEPROM_Save_Config (CONTROL_BYTE0_EADD, (uint8_t *)temp, 5);                                    
   \       0x8A   0x2205             MOVS     R2,#+5
   \       0x8C   0x0039             MOVS     R1,R7
   \       0x8E   0x2010             MOVS     R0,#+16
   \       0x90   0x.... 0x....      BL       EEPROM_Save_Config
   2072          
   2073                  collaudoFlag = getCollaudoRunning();
   \       0x94   0x.... 0x....      BL       getCollaudoRunning
   \       0x98   0x0006             MOVS     R6,R0
   2074                  /* reset immediato  */
   2075                  if(!collaudoFlag)
   \       0x9A   0x0030             MOVS     R0,R6
   \       0x9C   0xB2C0             UXTB     R0,R0
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD101             BNE.N    ??HW_CHECKS_ACTUATORS_EEprom_Save_5
   2076                  {
   2077                    activeImmediateReset(); 
   \       0xA2   0x.... 0x....      BL       activeImmediateReset
   2078                  }
   2079                break;  
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_5: (+1)
   \       0xA6   0xE7FF             B.N      ??HW_CHECKS_ACTUATORS_EEprom_Save_4
   2080                
   2081              default:
   2082                break;
   2083            }
   2084            
   2085          }
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_1: (+1)
   \                     ??HW_CHECKS_ACTUATORS_EEprom_Save_4: (+1)
   \       0xA8   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .bss, align 4
   \                     `HW_CHECKS_ACTUATORS_EEprom_Save::temp`:
   \        0x0                      DS8 8
   2086          
   2087          /**
   2088          *
   2089          * @brief       Save HW Flags into Eeeprom 
   2090          *              
   2091          *           
   2092          * @param [in]  None
   2093          *  
   2094          * @retval      None
   2095          *  
   2096          ****************************************************************/
   2097          

   \                                 In section .text, align 2, keep-with-next
   2098          void HW_PRESENCE_FLAG_EEprom_Save (void)
   2099          {
   \                     HW_PRESENCE_FLAG_EEprom_Save: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   2100             uint8_t   HwFlagsEeprom;
   2101             uint16_t  temp16;
   2102          
   2103             /* Prepare information to save in Eeprom  according to this codification:
   2104             
   2105              LCD_TYPE_EADDR in Eeprom
   2106          
   2107              Bit 0 --> LCD_ON
   2108              Bit 2 --> WIFI_ON 
   2109              Bit 3 --> DIFF_RIARMABILE
   2110          
   2111             */
   2112             
   2113             temp16 = getHwFlags();
   \        0x2   0x.... 0x....      BL       getHwFlags
   \        0x6   0x0004             MOVS     R4,R0
   2114             eeprom_param_get(LCD_TYPE_EADD, (uint8_t *)&HwFlagsEeprom, 1);
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x2034             MOVS     R0,#+52
   \        0xE   0x.... 0x....      BL       eeprom_param_get
   2115             /* Check Display LCD presence */
   2116             if ((temp16 & DISPLAY_LCD_FLAG) == DISPLAY_LCD_FLAG)
   \       0x12   0x07A0             LSLS     R0,R4,#+30
   \       0x14   0xD506             BPL.N    ??HW_PRESENCE_FLAG_EEprom_Save_0
   2117               HwFlagsEeprom |= LCD_2X20;
   \       0x16   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x1A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x1E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x22   0xE005             B.N      ??HW_PRESENCE_FLAG_EEprom_Save_1
   2118             else 
   2119               HwFlagsEeprom &= ~LCD_2X20;     
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_0: (+1)
   \       0x24   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x28   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \       0x2C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2120             /* Check WIFI module presence */
   2121             if ((temp16 & WIFI_CONNECTION_FLAG) == WIFI_CONNECTION_FLAG)
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_1: (+1)
   \       0x30   0x0720             LSLS     R0,R4,#+28
   \       0x32   0xD506             BPL.N    ??HW_PRESENCE_FLAG_EEprom_Save_2
   2122               HwFlagsEeprom |= WIFI_ON;
   \       0x34   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x38   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x3C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x40   0xE005             B.N      ??HW_PRESENCE_FLAG_EEprom_Save_3
   2123             else
   2124               HwFlagsEeprom &= ~WIFI_ON;     
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_2: (+1)
   \       0x42   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x46   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \       0x4A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2125             /* Check DIFF RIARMABILE module presence */
   2126             if ((temp16 & DIFF_RIARM_FLAG) == DIFF_RIARM_FLAG)
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_3: (+1)
   \       0x4E   0x07E0             LSLS     R0,R4,#+31
   \       0x50   0xD506             BPL.N    ??HW_PRESENCE_FLAG_EEprom_Save_4
   2127               HwFlagsEeprom |= DIRI_ON;           
   \       0x52   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x56   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x5A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x5E   0xE005             B.N      ??HW_PRESENCE_FLAG_EEprom_Save_5
   2128             else
   2129               HwFlagsEeprom &= ~DIRI_ON;                
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_4: (+1)
   \       0x60   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x64   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \       0x68   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2130             /* Write settings into eeprom */   
   2131             /*** SAVE ON EEPROM ***/   
   2132             EEPROM_Save_Config (LCD_TYPE_EADD, (uint8_t *)&HwFlagsEeprom, 1);
   \                     ??HW_PRESENCE_FLAG_EEprom_Save_5: (+1)
   \       0x6C   0x2201             MOVS     R2,#+1
   \       0x6E   0x4669             MOV      R1,SP
   \       0x70   0x2034             MOVS     R0,#+52
   \       0x72   0x.... 0x....      BL       EEPROM_Save_Config
   2133          }
   \       0x76   0xBD13             POP      {R0,R1,R4,PC}
   2134          
   2135          /**
   2136          *
   2137          * @brief       Set new connector ID in conversion matrix
   2138          *              
   2139          *           
   2140          * @param [in]  Connector ID
   2141          *  
   2142          * @retval      None
   2143          *  
   2144          ****************************************************************/
   2145          

   \                                 In section .text, align 2, keep-with-next
   2146          void CONN_ID_Set_New (uint16_t New_Connector_ID)
   2147          {
   \                     CONN_ID_Set_New: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2148            uint8_t  mdbAddr;
   2149            
   2150            /* get address on modbus and relative modbus pointer area   */
   2151            mdbAddr = getLogicalMdbAddrSem();  
   \        0x4   0x.... 0x....      BL       getLogicalMdbAddrSem
   \        0x8   0x0005             MOVS     R5,R0
   2152            /* Set New connector ID in matrix */
   2153            socketPresence.matrixIdConn[mdbAddr] = New_Connector_ID;
   \        0xA   0x.... 0x....      LDR.W    R1,??DataTable10_4
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x4408             ADD      R0,R1,R0
   \       0x14   0xF880 0x4030      STRB     R4,[R0, #+48]
   2154            /* Save in eeprom */
   2155            WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t));
   \       0x18   0x2254             MOVS     R2,#+84
   \       0x1A   0xF44F 0x50F4      MOV      R0,#+7808
   \       0x1E   0x.... 0x....      BL       WriteOnEeprom
   2156          }
   \       0x22   0xBD31             POP      {R0,R4,R5,PC}
   2157          
   2158          /**
   2159          *
   2160          * @brief       parser config area to apply the new 
   2161          *              configuration
   2162          *
   2163          * @param [in]  frameSbcSem_st* : pointer to info    
   2164          *  
   2165          * @retval      none 
   2166          *  
   2167          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2168          static void semUpdateConfig(frameSbcSem_st* pMsg) 
   2169          {
   \                     semUpdateConfig: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2170            frameRemote_st  frameRemote;  
   2171            static uint8_t  temp[5];
   2172            uint16_t        temp16;
   2173            uint32_t        temp32;
   2174          
   2175            if (pMsg->data.rAddr <= ADDR_RESERVED_A)
   \        0x4   0x88A0             LDRH     R0,[R4, #+4]
   \        0x6   0x286A             CMP      R0,#+106
   \        0x8   0xF280 0x8199      BGE.W    ??semUpdateConfig_0
   2176            {
   2177                  
   2178              /* we are in configuration parameter area */
   2179              switch (pMsg->data.rAddr)
   \        0xC   0x88A0             LDRH     R0,[R4, #+4]
   \        0xE   0x1E40             SUBS     R0,R0,#+1
   \       0x10   0xF000 0x8129      BEQ.W    ??semUpdateConfig_1
   \       0x14   0x1EC0             SUBS     R0,R0,#+3
   \       0x16   0xF000 0x816F      BEQ.W    ??semUpdateConfig_2
   \       0x1A   0x381F             SUBS     R0,R0,#+31
   \       0x1C   0xF000 0x80DF      BEQ.W    ??semUpdateConfig_3
   \       0x20   0x1E80             SUBS     R0,R0,#+2
   \       0x22   0xF000 0x8123      BEQ.W    ??semUpdateConfig_4
   \       0x26   0x1E40             SUBS     R0,R0,#+1
   \       0x28   0x2802             CMP      R0,#+2
   \       0x2A   0xD923             BLS.N    ??semUpdateConfig_5
   \       0x2C   0x380F             SUBS     R0,R0,#+15
   \       0x2E   0xD05C             BEQ.N    ??semUpdateConfig_6
   \       0x30   0x1F40             SUBS     R0,R0,#+5
   \       0x32   0xF000 0x80FC      BEQ.W    ??semUpdateConfig_7
   \       0x36   0x1E80             SUBS     R0,R0,#+2
   \       0x38   0xF000 0x813C      BEQ.W    ??semUpdateConfig_8
   \       0x3C   0x1E80             SUBS     R0,R0,#+2
   \       0x3E   0xD025             BEQ.N    ??semUpdateConfig_9
   \       0x40   0x1E80             SUBS     R0,R0,#+2
   \       0x42   0xF000 0x813B      BEQ.W    ??semUpdateConfig_10
   \       0x46   0x1E40             SUBS     R0,R0,#+1
   \       0x48   0xF000 0x816C      BEQ.W    ??semUpdateConfig_11
   \       0x4C   0x3819             SUBS     R0,R0,#+25
   \       0x4E   0xF000 0x8116      BEQ.W    ??semUpdateConfig_12
   \       0x52   0x1E80             SUBS     R0,R0,#+2
   \       0x54   0xF000 0x811A      BEQ.W    ??semUpdateConfig_13
   \       0x58   0x1E40             SUBS     R0,R0,#+1
   \       0x5A   0xF000 0x8121      BEQ.W    ??semUpdateConfig_14
   \       0x5E   0x1E40             SUBS     R0,R0,#+1
   \       0x60   0xF000 0x8136      BEQ.W    ??semUpdateConfig_15
   \       0x64   0x1E40             SUBS     R0,R0,#+1
   \       0x66   0xF000 0x813D      BEQ.W    ??semUpdateConfig_16
   \       0x6A   0x1E40             SUBS     R0,R0,#+1
   \       0x6C   0x2805             CMP      R0,#+5
   \       0x6E   0xF240 0x8121      BLS.W    ??semUpdateConfig_8
   \       0x72   0xE164             B.N      ??semUpdateConfig_17
   2180              {
   2181                case ADDR_HW_CHECKS1_RW:
   2182                case ADDR_HW_CHECKS2_RW:
   2183                case ADDR_HW_ACTUATORS_RW:
   2184                  /* Save HW CHECKS and ACTUATORS into EEPROM */
   2185                  HW_CHECKS_ACTUATORS_EEprom_Save(pMsg->data.rAddr);        
   \                     ??semUpdateConfig_5: (+1)
   \       0x74   0x88A0             LDRH     R0,[R4, #+4]
   \       0x76   0x.... 0x....      BL       HW_CHECKS_ACTUATORS_EEprom_Save
   2186                  if (isSemMasterFz() == FALSE) 
   \       0x7A   0x.... 0x....      BL       isSemMasterFz
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD103             BNE.N    ??semUpdateConfig_18
   2187                  {
   2188                    /* the slave must send the change in EEPROM to the master when all 3 regs are written  */
   2189                    restartSbcSemTimer(TIMER_FOR_REQ_ADDR, WAIT_FOR_EEPROM_WRITE);
   \       0x82   0x21C8             MOVS     R1,#+200
   \       0x84   0x2004             MOVS     R0,#+4
   \       0x86   0x.... 0x....      BL       restartSbcSemTimer
   2190                  }
   2191                  break;
   \                     ??semUpdateConfig_18: (+1)
   \       0x8A   0xE158             B.N      ??semUpdateConfig_0
   2192                  
   2193                case ADDR_AUTHORIZATION_FEEDBACK_RW:
   2194                  
   2195                  if (*((uint16_t*)pMsg->dataToSend.pData) == (uint16_t)0x0001)
   \                     ??semUpdateConfig_9: (+1)
   \       0x8C   0x68A0             LDR      R0,[R4, #+8]
   \       0x8E   0x8800             LDRH     R0,[R0, #+0]
   \       0x90   0x2801             CMP      R0,#+1
   \       0x92   0xD11A             BNE.N    ??semUpdateConfig_19
   2196                  {
   2197                    frameRemote.currentEvent = REMOTE_EVS_AUTH_START;
   \       0x94   0x2017             MOVS     R0,#+23
   \       0x96   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2198                    frameRemote.currentData = (uint16_t)0x0001;
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xF8AD 0x0005      STRH     R0,[SP, #+5]
   2199                    configASSERT(xQueueSendToBack(remoteMngQueue, (void *)&frameRemote, portMAX_DELAY) == pdPASS); // remoteSuspRelProcess()
   \       0xA0   0x2300             MOVS     R3,#+0
   \       0xA2   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0xA6   0xA901             ADD      R1,SP,#+4
   \       0xA8   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \       0xAC   0x6800             LDR      R0,[R0, #+0]
   \       0xAE   0x.... 0x....      BL       xQueueGenericSend
   \       0xB2   0x2801             CMP      R0,#+1
   \       0xB4   0xD018             BEQ.N    ??semUpdateConfig_20
   \       0xB6   0xB672             CPSID    I
   \       0xB8   0x2050             MOVS     R0,#+80
   \       0xBA   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xBE   0xF3BF 0x8F4F      DSB      SY
   \       0xC2   0xF3BF 0x8F6F      ISB      SY
   \       0xC6   0xB662             CPSIE    I
   \                     ??semUpdateConfig_21: (+1)
   \       0xC8   0xE7FE             B.N      ??semUpdateConfig_21
   2200                  }
   2201                  else if (*((uint16_t*)pMsg->dataToSend.pData) == (uint16_t)0x0002)
   \                     ??semUpdateConfig_19: (+1)
   \       0xCA   0x68A0             LDR      R0,[R4, #+8]
   \       0xCC   0x8800             LDRH     R0,[R0, #+0]
   \       0xCE   0x2802             CMP      R0,#+2
   \       0xD0   0xD103             BNE.N    ??semUpdateConfig_22
   2202                  {
   2203                    send_to_evs(EVS_AUTH_NEG);
   \       0xD2   0x201A             MOVS     R0,#+26
   \       0xD4   0x.... 0x....      BL       send_to_evs
   \       0xD8   0xE006             B.N      ??semUpdateConfig_20
   2204                  }
   2205                  else if (*((uint16_t*)pMsg->dataToSend.pData) == (uint16_t)0x0003)
   \                     ??semUpdateConfig_22: (+1)
   \       0xDA   0x68A0             LDR      R0,[R4, #+8]
   \       0xDC   0x8800             LDRH     R0,[R0, #+0]
   \       0xDE   0x2803             CMP      R0,#+3
   \       0xE0   0xD102             BNE.N    ??semUpdateConfig_20
   2206                  {
   2207                    send_to_evs(EVS_AUTH_STOP);
   \       0xE2   0x2019             MOVS     R0,#+25
   \       0xE4   0x.... 0x....      BL       send_to_evs
   2208                  }
   2209                  
   2210                  break;
   \                     ??semUpdateConfig_20: (+1)
   \       0xE8   0xE129             B.N      ??semUpdateConfig_0
   2211                  
   2212                case ADDR_REMOTE_COMMANDS_RW:
   2213                  temp16 = *((uint16_t*)pMsg->dataToSend.pData);
   \                     ??semUpdateConfig_6: (+1)
   \       0xEA   0x68A0             LDR      R0,[R4, #+8]
   \       0xEC   0x8800             LDRH     R0,[R0, #+0]
   \       0xEE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2214                  if (temp16 == (uint16_t)0x0001)
   \       0xF2   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0xF6   0x2801             CMP      R0,#+1
   \       0xF8   0xD11A             BNE.N    ??semUpdateConfig_23
   2215                  {
   2216                    frameRemote.currentEvent = REMOTE_EVS_AUTH_STOP;
   \       0xFA   0x2019             MOVS     R0,#+25
   \       0xFC   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2217                    frameRemote.currentData = (uint16_t)0x0001;
   \      0x100   0x2001             MOVS     R0,#+1
   \      0x102   0xF8AD 0x0005      STRH     R0,[SP, #+5]
   2218                    configASSERT(xQueueSendToBack(remoteMngQueue, (void *)&frameRemote, portMAX_DELAY) == pdPASS); // remoteSuspRelProcess()
   \      0x106   0x2300             MOVS     R3,#+0
   \      0x108   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x10C   0xA901             ADD      R1,SP,#+4
   \      0x10E   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \      0x112   0x6800             LDR      R0,[R0, #+0]
   \      0x114   0x.... 0x....      BL       xQueueGenericSend
   \      0x118   0x2801             CMP      R0,#+1
   \      0x11A   0xD05F             BEQ.N    ??semUpdateConfig_24
   \      0x11C   0xB672             CPSID    I
   \      0x11E   0x2050             MOVS     R0,#+80
   \      0x120   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x124   0xF3BF 0x8F4F      DSB      SY
   \      0x128   0xF3BF 0x8F6F      ISB      SY
   \      0x12C   0xB662             CPSIE    I
   \                     ??semUpdateConfig_25: (+1)
   \      0x12E   0xE7FE             B.N      ??semUpdateConfig_25
   2219                  }
   2220                  else if (temp16 == (uint16_t)0x0002)
   \                     ??semUpdateConfig_23: (+1)
   \      0x130   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x134   0x2802             CMP      R0,#+2
   \      0x136   0xD107             BNE.N    ??semUpdateConfig_26
   2221                  {
   2222                    /* inizio carica */
   2223                    lastCommandSent = EVS_AUTH_START;
   \      0x138   0x2017             MOVS     R0,#+23
   \      0x13A   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \      0x13E   0x7008             STRB     R0,[R1, #+0]
   2224                    send_to_evs(EVS_AUTH_START);
   \      0x140   0x2017             MOVS     R0,#+23
   \      0x142   0x.... 0x....      BL       send_to_evs
   \      0x146   0xE049             B.N      ??semUpdateConfig_24
   2225                  }
   2226                  else if (temp16 == (uint16_t)MODE_AVAILABLE)
   \                     ??semUpdateConfig_26: (+1)
   \      0x148   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x14C   0x2805             CMP      R0,#+5
   \      0x14E   0xD10E             BNE.N    ??semUpdateConfig_27
   2227                  {
   2228                    temp[0] = (uint8_t)EVS_MODE_AVAILABLE;
   \      0x150   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \      0x154   0x2001             MOVS     R0,#+1
   \      0x156   0x7008             STRB     R0,[R1, #+0]
   2229                    
   2230                    /*** SAVE ON EEPROM ***/
   2231                    EEPROM_Save_Config (SOCKET_ENABLE_EADD, (uint8_t*)temp, 1);
   \      0x158   0x2201             MOVS     R2,#+1
   \      0x15A   0x2006             MOVS     R0,#+6
   \      0x15C   0x.... 0x....      BL       EEPROM_Save_Config
   2232                    
   2233                    evs_reserved_set(0);
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0x.... 0x....      BL       evs_reserved_set
   2234                    
   2235                    send_to_evs(EVS_AUTORIZATION_MODE);
   \      0x166   0x2003             MOVS     R0,#+3
   \      0x168   0x.... 0x....      BL       send_to_evs
   \      0x16C   0xE036             B.N      ??semUpdateConfig_24
   2236                  }
   2237                  else if (temp16 == (uint16_t)MODE_UNAVAILABLE)
   \                     ??semUpdateConfig_27: (+1)
   \      0x16E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x172   0x2806             CMP      R0,#+6
   \      0x174   0xD10B             BNE.N    ??semUpdateConfig_28
   2238                  {
   2239                    temp[0] = (uint8_t)EVS_MODE_UNAVAILABLE;
   \      0x176   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \      0x17A   0x2000             MOVS     R0,#+0
   \      0x17C   0x7008             STRB     R0,[R1, #+0]
   2240                    
   2241                    /*** SAVE ON EEPROM ***/
   2242                    EEPROM_Save_Config (SOCKET_ENABLE_EADD, (uint8_t*)temp, 1);
   \      0x17E   0x2201             MOVS     R2,#+1
   \      0x180   0x2006             MOVS     R0,#+6
   \      0x182   0x.... 0x....      BL       EEPROM_Save_Config
   2243                                  
   2244                    send_to_evs(EVS_AUTORIZATION_MODE);
   \      0x186   0x2003             MOVS     R0,#+3
   \      0x188   0x.... 0x....      BL       send_to_evs
   \      0x18C   0xE026             B.N      ??semUpdateConfig_24
   2245                  }
   2246                  else if (temp16 == (uint16_t)MODE_RESERVED)
   \                     ??semUpdateConfig_28: (+1)
   \      0x18E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x192   0x2807             CMP      R0,#+7
   \      0x194   0xD106             BNE.N    ??semUpdateConfig_29
   2247                  {
   2248          //          temp[0] = (uint8_t)EVS_MODE_AVAILABLE | (uint8_t)EVS_MODE_RESERVED;
   2249          //          eeprom_param_set(SOCKET_ENABLE_EADD, (uint8_t*)temp, 1);
   2250                    evs_reserved_set(1);
   \      0x196   0x2001             MOVS     R0,#+1
   \      0x198   0x.... 0x....      BL       evs_reserved_set
   2251                    send_to_evs(EVS_AUTORIZATION_MODE);
   \      0x19C   0x2003             MOVS     R0,#+3
   \      0x19E   0x.... 0x....      BL       send_to_evs
   \      0x1A2   0xE01B             B.N      ??semUpdateConfig_24
   2252                  }
   2253                  else if (temp16 == (uint16_t)HARD_REBOOT)
   \                     ??semUpdateConfig_29: (+1)
   \      0x1A4   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1A8   0x28FD             CMP      R0,#+253
   \      0x1AA   0xD102             BNE.N    ??semUpdateConfig_30
   2254                  {
   2255                    /* reset immediato  */
   2256                    activeImmediateReset();
   \      0x1AC   0x.... 0x....      BL       activeImmediateReset
   \      0x1B0   0xE014             B.N      ??semUpdateConfig_24
   2257                  }        
   2258                  else if ((temp16 >= REMOVE_CONNECTOR_ID_START) && (temp16 <= REMOVE_CONNECTOR_ID_END))
   \                     ??semUpdateConfig_30: (+1)
   \      0x1B2   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1B6   0xF64D 0x5102      MOVW     R1,#+56578
   \      0x1BA   0x4288             CMP      R0,R1
   \      0x1BC   0xDB0E             BLT.N    ??semUpdateConfig_24
   \      0x1BE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1C2   0xF64D 0x5111      MOVW     R1,#+56593
   \      0x1C6   0x4288             CMP      R0,R1
   \      0x1C8   0xDA08             BGE.N    ??semUpdateConfig_24
   2259                  {
   2260                    temp[0] = (uint8_t)(temp16 - REMOVE_CONNECTOR_ID_START) + (uint8_t)1; // logic id 1..15 (logic 0 is master and cannot be removed)
   \      0x1CA   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \      0x1CE   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \      0x1D2   0x1E49             SUBS     R1,R1,#+1
   \      0x1D4   0x7001             STRB     R1,[R0, #+0]
   2261                    removeSocketFromList(temp[0]);
   \      0x1D6   0x7800             LDRB     R0,[R0, #+0]
   \      0x1D8   0x.... 0x....      BL       removeSocketFromList
   2262                  }
   2263                  
   2264                  break;
   \                     ??semUpdateConfig_24: (+1)
   \      0x1DC   0xE0AF             B.N      ??semUpdateConfig_0
   2265                  
   2266                case ADDR_EVSE_OPERATION_MODE_RW:
   2267                  
   2268                  temp16 = getOperationMode();
   \                     ??semUpdateConfig_3: (+1)
   \      0x1DE   0x.... 0x....      BL       getOperationMode
   \      0x1E2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2269                  temp[0] = (uint8_t)(temp16);   /* evse_mode in modbus map --> FREE, PERSONAl, NET */
   \      0x1E6   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \      0x1EA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1EE   0x7008             STRB     R0,[R1, #+0]
   2270                  temp[1] = (uint8_t)(temp16 / 0x100) ;  /* master_mode --> LOCAL - OCPP */ 
   \      0x1F0   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x1F4   0xF44F 0x7280      MOV      R2,#+256
   \      0x1F8   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \      0x1FC   0x7048             STRB     R0,[R1, #+1]
   2271                  /* Check if LOCAL mode */
   2272                  if (temp[1] <= (char)0x01)
   \      0x1FE   0x7848             LDRB     R0,[R1, #+1]
   \      0x200   0x2802             CMP      R0,#+2
   \      0x202   0xDA0A             BGE.N    ??semUpdateConfig_31
   2273                  {
   2274                    if (temp[0] <= EVS_NET_MODE)  /* EVS_FREE_MODE = 0, EVS_PERS_MODE = 1, EVS_NET_MODE = 2 NON gestiti: EVS_OCPP_MODE = 3*/
   \      0x204   0x7808             LDRB     R0,[R1, #+0]
   \      0x206   0x2803             CMP      R0,#+3
   \      0x208   0xDA10             BGE.N    ??semUpdateConfig_32
   2275                    {
   2276                      /* set the current operative mode                       */            
   2277                      /*** SAVE ON EEPROM ***/
   2278                      EEPROM_Save_Config (EVS_MODE_EADD, (uint8_t*)&temp[0], 1);
   \      0x20A   0x2201             MOVS     R2,#+1
   \      0x20C   0x200B             MOVS     R0,#+11
   \      0x20E   0x.... 0x....      BL       EEPROM_Save_Config
   2279                                    
   2280                      send_to_evs(EVS_AUTORIZATION_MODE);
   \      0x212   0x2003             MOVS     R0,#+3
   \      0x214   0x.... 0x....      BL       send_to_evs
   \      0x218   0xE008             B.N      ??semUpdateConfig_32
   2281                    }
   2282                  }
   2283                  else
   2284                  {
   2285                    temp[0] = (char)EVS_OCPP_MODE;
   \                     ??semUpdateConfig_31: (+1)
   \      0x21A   0x2003             MOVS     R0,#+3
   \      0x21C   0x7008             STRB     R0,[R1, #+0]
   2286                    /* set OCPP = 3 as current operative mode                       */          
   2287                    /*** SAVE ON EEPROM ***/
   2288                    EEPROM_Save_Config (EVS_MODE_EADD, (uint8_t*)&temp[0], 1);
   \      0x21E   0x2201             MOVS     R2,#+1
   \      0x220   0x200B             MOVS     R0,#+11
   \      0x222   0x.... 0x....      BL       EEPROM_Save_Config
   2289                    send_to_evs(EVS_AUTORIZATION_MODE);
   \      0x226   0x2003             MOVS     R0,#+3
   \      0x228   0x.... 0x....      BL       send_to_evs
   2290                  }        
   2291                  
   2292                  break;
   \                     ??semUpdateConfig_32: (+1)
   \      0x22C   0xE087             B.N      ??semUpdateConfig_0
   2293                  
   2294                case ADDR_MAX_TEMPORARY_POWER_AC:        
   2295                  frameRemote.currentEvent = REMOTE_MAX_POWER_CHANGE;
   \                     ??semUpdateConfig_7: (+1)
   \      0x22E   0x200F             MOVS     R0,#+15
   \      0x230   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2296                  frameRemote.currentData = (uint16_t)0x0002;
   \      0x234   0x2002             MOVS     R0,#+2
   \      0x236   0xF8AD 0x0005      STRH     R0,[SP, #+5]
   2297                  configASSERT(xQueueSendToBack(remoteMngQueue, (void *)&frameRemote, portMAX_DELAY) == pdPASS); // remoteSuspRelProcess()      
   \      0x23A   0x2300             MOVS     R3,#+0
   \      0x23C   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x240   0xA901             ADD      R1,SP,#+4
   \      0x242   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \      0x246   0x6800             LDR      R0,[R0, #+0]
   \      0x248   0x.... 0x....      BL       xQueueGenericSend
   \      0x24C   0x2801             CMP      R0,#+1
   \      0x24E   0xD009             BEQ.N    ??semUpdateConfig_33
   \      0x250   0xB672             CPSID    I
   \      0x252   0x2050             MOVS     R0,#+80
   \      0x254   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x258   0xF3BF 0x8F4F      DSB      SY
   \      0x25C   0xF3BF 0x8F6F      ISB      SY
   \      0x260   0xB662             CPSIE    I
   \                     ??semUpdateConfig_34: (+1)
   \      0x262   0xE7FE             B.N      ??semUpdateConfig_34
   2298                  break;
   \                     ??semUpdateConfig_33: (+1)
   \      0x264   0xE06B             B.N      ??semUpdateConfig_0
   2299                  
   2300                case ADDR_HWC_FLAGS_RW:        
   2301                  /* Save Hw flags into Eeprom */
   2302                  HW_PRESENCE_FLAG_EEprom_Save ();                  
   \                     ??semUpdateConfig_1: (+1)
   \      0x266   0x.... 0x....      BL       HW_PRESENCE_FLAG_EEprom_Save
   2303                  break;
   \      0x26A   0xE068             B.N      ??semUpdateConfig_0
   2304          
   2305                case ADDR_DISPLAY_DEFAULT_LANGUAGE_RW:
   2306                  /* get language received */
   2307                  temp16 = getDefaultLanguage();              
   \                     ??semUpdateConfig_4: (+1)
   \      0x26C   0x.... 0x....      BL       getDefaultLanguage
   \      0x270   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2308                  /* Uniformato a pagina Web Nik e Modbus v21.3. Esempio se bit n.5 settato a 1 --> in eeprom finisce il valore 0x05 - 1 (non bit mask ma enum) */      
   2309                  LANG_Modbus_to_EEprom_Translate ((uint32_t)temp16);
   \      0x274   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x278   0x.... 0x....      BL       LANG_Modbus_to_EEprom_Translate
   2310                  break;
   \      0x27C   0xE05F             B.N      ??semUpdateConfig_0
   2311                  
   2312                case ADDR_DISPLAY_LANGUAGES_RW:
   2313                  /* Get available languages */
   2314                  temp32 = getAvailableLanguages();
   \                     ??semUpdateConfig_12: (+1)
   \      0x27E   0x.... 0x....      BL       getAvailableLanguages
   \      0x282   0x0005             MOVS     R5,R0
   2315                  /* Translate from Modbus to eeprom format */
   2316                  LANG_Available_Mdb_to_EEprom_Translate (temp32);        
   \      0x284   0x0028             MOVS     R0,R5
   \      0x286   0x.... 0x....      BL       LANG_Available_Mdb_to_EEprom_Translate
   2317                  break;
   \      0x28A   0xE058             B.N      ??semUpdateConfig_0
   2318          
   2319                case ADDR_MAX_TYPICAL_CURRENT_RW:
   2320                  /* Get Max typical current */
   2321                  temp16 = getMaxTypicalCurrent();
   \                     ??semUpdateConfig_13: (+1)
   \      0x28C   0x.... 0x....      BL       getMaxTypicalCurrent
   \      0x290   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2322                  /* Store into eeprom location */        
   2323                  /*** SAVE ON EEPROM ***/
   2324                  EEPROM_Save_Config (M3T_CURRENT_EADD, (uint8_t*)&temp16, 1);
   \      0x294   0x2201             MOVS     R2,#+1
   \      0x296   0x4669             MOV      R1,SP
   \      0x298   0x200C             MOVS     R0,#+12
   \      0x29A   0x.... 0x....      BL       EEPROM_Save_Config
   2325                  break;
   \      0x29E   0xE04E             B.N      ??semUpdateConfig_0
   2326                  
   2327                case ADDR_MAX_SIMPLIFIED_CURRENT_RW:
   2328                  /* Get Max typical current */
   2329                  temp16 = getMaxSimplifiedCurrent();
   \                     ??semUpdateConfig_14: (+1)
   \      0x2A0   0x.... 0x....      BL       getMaxSimplifiedCurrent
   \      0x2A4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2330                  /* Store into eeprom location */        
   2331                  /*** SAVE ON EEPROM ***/
   2332                  EEPROM_Save_Config (M3S_CURRENT_EADD, (uint8_t*)&temp16, 1);
   \      0x2A8   0x2201             MOVS     R2,#+1
   \      0x2AA   0x4669             MOV      R1,SP
   \      0x2AC   0x200D             MOVS     R0,#+13
   \      0x2AE   0x.... 0x....      BL       EEPROM_Save_Config
   2333                  break;
   \      0x2B2   0xE044             B.N      ??semUpdateConfig_0
   2334                  
   2335                case ADDR_PM_MODE_RW:
   2336                case ADDR_PM_IMIN_RW:
   2337                case ADDR_PM_PMAX_RW:
   2338                case ADDR_PM_FLAGS_RW:
   2339                case ADDR_PM_HPOWER_RW:
   2340                case ADDR_PM_DSET_RW:
   2341                case ADDR_PM_DMAX_RW:
   2342                  /* Translate from MOdbus to EEprom format */
   2343                  PM_Mdb_to_EEprom_Translate(pMsg->data.rAddr);
   \                     ??semUpdateConfig_8: (+1)
   \      0x2B4   0x88A0             LDRH     R0,[R4, #+4]
   \      0x2B6   0x.... 0x....      BL       PM_Mdb_to_EEprom_Translate
   2344                  break;
   \      0x2BA   0xE040             B.N      ??semUpdateConfig_0
   2345                  
   2346                case ADDR_MENU_VISIBILITY_RW:
   2347                  /* Get PM menu visibility flag */
   2348                  temp16 = getPmMenuVisibility();
   \                     ??semUpdateConfig_10: (+1)
   \      0x2BC   0x.... 0x....      BL       getPmMenuVisibility
   \      0x2C0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2349                  /* Store into eeprom location */        
   2350                  /*** SAVE ON EEPROM ***/
   2351                  EEPROM_Save_Config (HIDDEN_MENU_VIS_EADD, (uint8_t*)&temp16, 1);
   \      0x2C4   0x2201             MOVS     R2,#+1
   \      0x2C6   0x4669             MOV      R1,SP
   \      0x2C8   0x2035             MOVS     R0,#+53
   \      0x2CA   0x.... 0x....      BL       EEPROM_Save_Config
   2352                  break;
   \      0x2CE   0xE036             B.N      ??semUpdateConfig_0
   2353                 
   2354              case ADDR_CHARGE_TIME_RW:
   2355                  /* Get Charge by Time value */      
   2356                  temp16 = getChargeByTime();
   \                     ??semUpdateConfig_15: (+1)
   \      0x2D0   0x.... 0x....      BL       getChargeByTime
   \      0x2D4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2357                  /* Store into eeprom location */        
   2358                  /*** SAVE ON EEPROM ***/
   2359                  EEPROM_Save_Config (TCHARGE_TIME_EADD, (uint8_t*)&temp16, 1);
   \      0x2D8   0x2201             MOVS     R2,#+1
   \      0x2DA   0x4669             MOV      R1,SP
   \      0x2DC   0x2022             MOVS     R0,#+34
   \      0x2DE   0x.... 0x....      BL       EEPROM_Save_Config
   2360                  break;
   \      0x2E2   0xE02C             B.N      ??semUpdateConfig_0
   2361                  
   2362              case ADDR_CHARGE_MAX_ENERGY_RW:
   2363                  /* Get Charge by Energy value */      
   2364                  temp16 = getChargeByEnergy();
   \                     ??semUpdateConfig_16: (+1)
   \      0x2E4   0x.... 0x....      BL       getChargeByEnergy
   \      0x2E8   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2365                  /* Store into eeprom location */        
   2366                  /*** SAVE ON EEPROM ***/
   2367                  EEPROM_Save_Config (ENRG_LIMIT_EADD, (uint8_t*)&temp16, 1);
   \      0x2EC   0x2201             MOVS     R2,#+1
   \      0x2EE   0x4669             MOV      R1,SP
   \      0x2F0   0x2037             MOVS     R0,#+55
   \      0x2F2   0x.... 0x....      BL       EEPROM_Save_Config
   2368                  break;        
   \      0x2F6   0xE022             B.N      ??semUpdateConfig_0
   2369                          
   2370              case ADDR_CONNECTOR_IDS_RW:
   2371                  /* Get Connector ID from modbus map */
   2372                  temp16 = getConnectorId();
   \                     ??semUpdateConfig_2: (+1)
   \      0x2F8   0x.... 0x....      BL       getConnectorId
   \      0x2FC   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2373                  /* Set new connector ID on conversion matrix */
   2374                  CONN_ID_Set_New (temp16);  
   \      0x300   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x304   0x.... 0x....      BL       CONN_ID_Set_New
   2375                  /* Set also the new number to show on LCD with the new value of connector ID*/
   2376                  numberOnLcd = temp16;        
   \      0x308   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x30C   0x.... 0x....      LDR.W    R1,??DataTable13
   \      0x310   0x7008             STRB     R0,[R1, #+0]
   2377                  if (isSemMasterFz() == FALSE) 
   \      0x312   0x.... 0x....      BL       isSemMasterFz
   \      0x316   0x2800             CMP      R0,#+0
   \      0x318   0xD103             BNE.N    ??semUpdateConfig_35
   2378                  {
   2379                    /* the slave must send the change in EEPROM to the master when all 3 regs are written  */
   2380                    restartSbcSemTimer(TIMER_FOR_REQ_ADDR, WAIT_FOR_EEPROM_WRITE);
   \      0x31A   0x21C8             MOVS     R1,#+200
   \      0x31C   0x2004             MOVS     R0,#+4
   \      0x31E   0x.... 0x....      BL       restartSbcSemTimer
   2381                  }
   2382                  break;
   \                     ??semUpdateConfig_35: (+1)
   \      0x322   0xE00C             B.N      ??semUpdateConfig_0
   2383                  
   2384          
   2385                case ADDR_TIMEOUT_RANGE1_RW:
   2386                  /* get the timeout value from SEM message */
   2387                  temp16 = *((uint16_t*)pMsg->dataToSend.pData);
   \                     ??semUpdateConfig_11: (+1)
   \      0x324   0x68A0             LDR      R0,[R4, #+8]
   \      0x326   0x8800             LDRH     R0,[R0, #+0]
   \      0x328   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2388                  /* save this value and set for Evs Manager */
   2389                  saveTimeoutRange1(temp16);
   \      0x32C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x330   0x.... 0x....      BL       saveTimeoutRange1
   2390                  setWaitTimeValue(temp16);
   \      0x334   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \      0x338   0x.... 0x....      BL       setWaitTimeValue
   2391                  break;
   \      0x33C   0xE7FF             B.N      ??semUpdateConfig_0
   2392          
   2393                default:
   2394                  /* not a configuration register */
   2395                  break;
   2396                  
   2397              }
   2398            }
   2399            
   2400          }
   \                     ??semUpdateConfig_17: (+1)
   \                     ??semUpdateConfig_0: (+1)
   \      0x33E   0xBD37             POP      {R0-R2,R4,R5,PC}

   \                                 In section .bss, align 4
   \                     `semUpdateConfig::temp`:
   \        0x0                      DS8 8
   2401          
   2402          /**
   2403          *
   2404          * @brief       start the task management 
   2405          *
   2406          * @param [in]  none    
   2407          *  
   2408          * @retval      none 
   2409          *  
   2410          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2411          void startSbcSemProcess(void) 
   2412          {
   \                     startSbcSemProcess: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   2413            frameSbcSem_st        tmpFrameSbcSem;  
   2414          
   2415            tmpFrameSbcSem.sbcSemEvent = NOTIFY_START_TASK;
   \        0x4   0x2009             MOVS     R0,#+9
   \        0x6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2416            tmpFrameSbcSem.data.index = getPhysicalMdbAddr();
   \        0xA   0x.... 0x....      BL       getPhysicalMdbAddr
   \        0xE   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   2417            tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \       0x12   0x.... 0x....      BL       getPacketStatusNum
   \       0x16   0xF10D 0x010E      ADD      R1,SP,#+14
   \       0x1A   0x6008             STR      R0,[R1, #+0]
   2418            configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \       0x1C   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x20   0x2300             MOVS     R3,#+0
   \       0x22   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x26   0x4669             MOV      R1,SP
   \       0x28   0x.... 0x....      BL       xQueueGenericSend
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD009             BEQ.N    ??startSbcSemProcess_0
   \       0x30   0xB672             CPSID    I
   \       0x32   0x2050             MOVS     R0,#+80
   \       0x34   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x38   0xF3BF 0x8F4F      DSB      SY
   \       0x3C   0xF3BF 0x8F6F      ISB      SY
   \       0x40   0xB662             CPSIE    I
   \                     ??startSbcSemProcess_1: (+1)
   \       0x42   0xE7FE             B.N      ??startSbcSemProcess_1
   2419          }
   \                     ??startSbcSemProcess_0: (+1)
   \       0x44   0xB005             ADD      SP,SP,#+20
   \       0x46   0xBD00             POP      {PC}
   2420          
   2421          /**
   2422          *
   2423          * @brief       set in the modbus map hardware configuration 
   2424          *
   2425          * @param [in]  
   2426          *  
   2427          * @retval      none 
   2428          *  
   2429          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2430          void  upgradeModbusHwConfig(void) 
   2431          {
   \                     upgradeModbusHwConfig: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   2432            uint8_t               mdbAddr;
   2433            frameSbcSem_st        tmpFrameSbcSem;  
   2434            uint16_t              idConn;
   2435          
   2436            idConn = fromRs485ToSem((uint16_t)getPhysicalMdbAddr());
   \        0x4   0x.... 0x....      BL       getPhysicalMdbAddr
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0xB280             UXTH     R0,R0
   \        0xC   0x.... 0x....      BL       fromRs485ToSem
   \       0x10   0x0005             MOVS     R5,R0
   2437            mdbAddr = (uint8_t)idConn;
   \       0x12   0x002C             MOVS     R4,R5
   2438          
   2439            /* Init modbus registers according to the setting in eeprom */
   2440            initModbusRegisters();
   \       0x14   0x.... 0x....      BL       initModbusRegisters
   2441            
   2442            /* If SEM, send this setting to the Master */
   2443            if (isSemMode())
   \       0x18   0x.... 0x....      BL       isSemMode
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD023             BEQ.N    ??upgradeModbusHwConfig_0
   2444            {
   2445              /* send the info to notify manager */
   2446              tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2447              tmpFrameSbcSem.data.index = mdbAddr + 1;  // phisical address 1...16 
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x1C40             ADDS     R0,R0,#+1
   \       0x2C   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   2448              tmpFrameSbcSem.data.rAddr = ADDR_CONNECTOR_TYPE_RW;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   2449              tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \       0x36   0x.... 0x....      BL       getPacketStatusNum
   \       0x3A   0xF10D 0x010E      ADD      R1,SP,#+14
   \       0x3E   0x6008             STR      R0,[R1, #+0]
   2450              configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \       0x40   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x44   0x2300             MOVS     R3,#+0
   \       0x46   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x.... 0x....      BL       xQueueGenericSend
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD009             BEQ.N    ??upgradeModbusHwConfig_0
   \       0x54   0xB672             CPSID    I
   \       0x56   0x2050             MOVS     R0,#+80
   \       0x58   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x5C   0xF3BF 0x8F4F      DSB      SY
   \       0x60   0xF3BF 0x8F6F      ISB      SY
   \       0x64   0xB662             CPSIE    I
   \                     ??upgradeModbusHwConfig_1: (+1)
   \       0x66   0xE7FE             B.N      ??upgradeModbusHwConfig_1
   2451            }
   2452          }
   \                     ??upgradeModbusHwConfig_0: (+1)
   \       0x68   0xB005             ADD      SP,SP,#+20
   \       0x6A   0xBD30             POP      {R4,R5,PC}
   2453          
   2454          /**
   2455          *
   2456          * @brief       upgrade bit for error or status notification  
   2457          *
   2458          * @param [in]  
   2459          *  
   2460          * @retval      none 
   2461          *  
   2462          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2463          void  upgradeModbusReg(uint16_t errAddr) 
   2464          {
   \                     upgradeModbusReg: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   2465            frameSbcSem_st          tmpFrameSbcSem;  
   2466            uint8_t                 mdbAddr;
   2467          
   2468            if (isSemMode() == FALSE)
   \        0x6   0x.... 0x....      BL       isSemMode
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD02C             BEQ.N    ??upgradeModbusReg_0
   2469              return;
   2470            
   2471            if (getSbcSemQueueHandle() == NULL)
   \                     ??upgradeModbusReg_1: (+1)
   \        0xE   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD028             BEQ.N    ??upgradeModbusReg_0
   2472              return;
   2473          
   2474            mdbAddr = getLogicalMdbAddrSem();
   \                     ??upgradeModbusReg_2: (+1)
   \       0x16   0x.... 0x....      BL       getLogicalMdbAddrSem
   \       0x1A   0x0005             MOVS     R5,R0
   2475            /* send the info to notify manager ADDR_EVSE_ERROR1_RO */
   2476            tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   2477            tmpFrameSbcSem.data.index = mdbAddr + 1; // phisical address 1...16
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x1C40             ADDS     R0,R0,#+1
   \       0x28   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   2478            tmpFrameSbcSem.data.rAddr = errAddr;
   \       0x2C   0xF8AD 0x4004      STRH     R4,[SP, #+4]
   2479            tmpFrameSbcSem.dataToSend.len = (uint16_t)1;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   2480            tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \       0x36   0x.... 0x....      BL       getPacketStatusNum
   \       0x3A   0xF10D 0x010E      ADD      R1,SP,#+14
   \       0x3E   0x6008             STR      R0,[R1, #+0]
   2481            configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \       0x40   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x44   0x2300             MOVS     R3,#+0
   \       0x46   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x.... 0x....      BL       xQueueGenericSend
   \       0x50   0x2801             CMP      R0,#+1
   \       0x52   0xD009             BEQ.N    ??upgradeModbusReg_3
   \       0x54   0xB672             CPSID    I
   \       0x56   0x2050             MOVS     R0,#+80
   \       0x58   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x5C   0xF3BF 0x8F4F      DSB      SY
   \       0x60   0xF3BF 0x8F6F      ISB      SY
   \       0x64   0xB662             CPSIE    I
   \                     ??upgradeModbusReg_4: (+1)
   \       0x66   0xE7FE             B.N      ??upgradeModbusReg_4
   2482          }
   \                     ??upgradeModbusReg_3: (+1)
   \                     ??upgradeModbusReg_0: (+1)
   \       0x68   0xB005             ADD      SP,SP,#+20
   \       0x6A   0xBD30             POP      {R4,R5,PC}
   2483          
   2484          /**
   2485          *
   2486          * @brief       set the property bit in the register change 
   2487          *              notification
   2488          *
   2489          * @param [in]  uint16_t: SCU physical index 01...32 
   2490          * @param [in]  uint16_t: base changed register 
   2491          * @param [in]  uint16_t: mask bit 
   2492          * @param [in]  uint16_t: device Id i.e. logical index in array 
   2493          *        structures 
   2494          *  
   2495          * @retval      bitNotifyResult_e: success if TRUE 
   2496          *  
   2497          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2498          static bitNotifyResult_e  setChangeRegisterBit(uint16_t ixScu, frameSbcSem_st* pMsg, uint32_t mskBit, uint16_t deviceId) 
   2499          {
   \                     setChangeRegisterBit: (+1)
   \        0x0   0xE92D 0x4FF5      PUSH     {R0,R2,R4-R11,LR}
   \        0x4   0xB08F             SUB      SP,SP,#+60
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x001D             MOVS     R5,R3
   2500            scuRoMapRegister_st*    pRoRegs;
   2501            scuRwMapRegister_st*    pRwRegs;
   2502            uint16_t                val, regChanged;
   2503            uint8_t                 logicAddr, ix, strReg[36], toPrint, toUpdate;
   2504            bitNotifyResult_e       result; 
   2505          
   2506            result = SEND_ACK;
   \        0xA   0xF05F 0x0A01      MOVS     R10,#+1
   2507            val = 0;
   \        0xE   0x2700             MOVS     R7,#+0
   2508             toPrint = toUpdate = TRUE;
   \       0x10   0xF05F 0x0901      MOVS     R9,#+1
   \       0x14   0xF88D 0x900C      STRB     R9,[SP, #+12]
   2509          
   2510            logicAddr = (uint8_t)deviceId;
   \       0x18   0x46A8             MOV      R8,R5
   2511          
   2512            pRoRegs = getRoMdbRegs(logicAddr);
   \       0x1A   0x4640             MOV      R0,R8
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x.... 0x....      BL       getRoMdbRegs
   \       0x22   0x0006             MOVS     R6,R0
   2513            pRwRegs = getRwMdbRegs(logicAddr);
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0x.... 0x....      BL       getRwMdbRegs
   \       0x2C   0x9004             STR      R0,[SP, #+16]
   2514          
   2515            regChanged = pMsg->data.rAddr;
   \       0x2E   0x88A0             LDRH     R0,[R4, #+4]
   \       0x30   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   2516            switch (regChanged) 
   \       0x34   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xF000 0x80E3      BEQ.W    ??setChangeRegisterBit_0
   \       0x3E   0x1E80             SUBS     R0,R0,#+2
   \       0x40   0xF000 0x8116      BEQ.W    ??setChangeRegisterBit_1
   \       0x44   0xF240 0x4102      MOVW     R1,#+1026
   \       0x48   0x1A40             SUBS     R0,R0,R1
   \       0x4A   0xF000 0x80A5      BEQ.W    ??setChangeRegisterBit_2
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0xF000 0x80BD      BEQ.W    ??setChangeRegisterBit_3
   \       0x54   0xF240 0x11FB      MOVW     R1,#+507
   \       0x58   0x1A40             SUBS     R0,R0,R1
   \       0x5A   0xD028             BEQ.N    ??setChangeRegisterBit_4
   \       0x5C   0x1E40             SUBS     R0,R0,#+1
   \       0x5E   0xD041             BEQ.N    ??setChangeRegisterBit_5
   \       0x60   0x380D             SUBS     R0,R0,#+13
   \       0x62   0xF000 0x8124      BEQ.W    ??setChangeRegisterBit_6
   \       0x66   0x1E80             SUBS     R0,R0,#+2
   \       0x68   0xF000 0x8121      BEQ.W    ??setChangeRegisterBit_6
   \       0x6C   0x3831             SUBS     R0,R0,#+49
   \       0x6E   0xF000 0x80E3      BEQ.W    ??setChangeRegisterBit_7
   \       0x72   0x380F             SUBS     R0,R0,#+15
   \       0x74   0xD003             BEQ.N    ??setChangeRegisterBit_8
   \       0x76   0x3818             SUBS     R0,R0,#+24
   \       0x78   0xF000 0x8125      BEQ.W    ??setChangeRegisterBit_9
   \       0x7C   0xE12A             B.N      ??setChangeRegisterBit_10
   2517            {
   2518              case ADDR_UID_AUTHORIZATION_RO:
   2519                /* set in the map the right value for the origin of the change  */
   2520                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)UID_AUTHORIZATION_BIT;
   \                     ??setChangeRegisterBit_8: (+1)
   \       0x7E   0x.... 0x....      LDR.W    R0,??DataTable15
   \       0x82   0x6801             LDR      R1,[R0, #+0]
   \       0x84   0x4642             MOV      R2,R8
   \       0x86   0xB2D2             UXTB     R2,R2
   \       0x88   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \       0x8C   0x6800             LDR      R0,[R0, #+0]
   \       0x8E   0x4642             MOV      R2,R8
   \       0x90   0xB2D2             UXTB     R2,R2
   \       0x92   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \       0x96   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \       0x9A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x9E   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2521                /*         destination           source */
   2522                strcpy((char *)strReg, AddrUidStr);
   \       0xA2   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \       0xA6   0xA805             ADD      R0,SP,#+20
   \       0xA8   0x.... 0x....      BL       strcpy
   2523                break;
   \       0xAC   0xE114             B.N      ??setChangeRegisterBit_11
   2524          
   2525              case ADDR_EVSE_EVENT_FLAGS_RO:
   2526                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)SOCKET_EVENT_FLAG_BIT;
   \                     ??setChangeRegisterBit_4: (+1)
   \       0xAE   0x.... 0x....      LDR.W    R0,??DataTable15
   \       0xB2   0x6801             LDR      R1,[R0, #+0]
   \       0xB4   0x4642             MOV      R2,R8
   \       0xB6   0xB2D2             UXTB     R2,R2
   \       0xB8   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \       0xBC   0x6800             LDR      R0,[R0, #+0]
   \       0xBE   0x4642             MOV      R2,R8
   \       0xC0   0xB2D2             UXTB     R2,R2
   \       0xC2   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \       0xC6   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \       0xCA   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0xCE   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2527                /*         destination           source */
   2528                strcpy((char *)strReg, AddrEventFlag);
   \       0xD2   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \       0xD6   0xA805             ADD      R0,SP,#+20
   \       0xD8   0x.... 0x....      BL       strcpy
   2529                val = pRoRegs->scuMapRegStatusMeas.ntfSktEvent;
   \       0xDC   0xF8B6 0x0122      LDRH     R0,[R6, #+290]
   \       0xE0   0x0007             MOVS     R7,R0
   2530                break;
   \       0xE2   0xE0F9             B.N      ??setChangeRegisterBit_11
   2531          
   2532              case ADDR_EVSE_CHARGE_STATUS_RO:
   2533          #ifdef COME_ERA
   2534                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)EVSE_CONNECTOR_STATUS_BIT_RO;
   2535                /*         destination           source */
   2536                strcpy((char *)strReg, AddrChargStatus);
   2537                ix = (uint8_t)pRoRegs->scuMapRegStatusMeas.ntfChgStat;
   2538                val = pRoRegs->scuMapRegStatusMeas.ntfChgStat;
   2539                if (ix <= END_CHARGE_STATE)
   2540                {
   2541                  /*         destination       source */
   2542                  strcat((char *)strReg, nameState[ix]);
   2543                }
   2544                if (val == (uint16_t)MDBSTATE_REBOOTING)
   2545                {
   2546                  /* reset max_temporary_power when a reboot on slave occurred */
   2547                  pRwRegs->scuSetRegister.maxTempPowerAc = (uint32_t)0;
   2548                }
   2549                if (val == (uint16_t)MDBSTATE_REBOOTING)
   2550                {
   2551                  /* reset max_temporary_power when a reboot on slave occurred */
   2552                  pRwRegs->scuSetRegister.maxTempPowerAc = (uint32_t)0;
   2553                }
   2554          #else
   2555          
   2556                val = pMsg->status;
   \                     ??setChangeRegisterBit_5: (+1)
   \       0xE4   0x89A0             LDRH     R0,[R4, #+12]
   \       0xE6   0x0007             MOVS     R7,R0
   2557                if (prevState[logicAddr] != val)
   \       0xE8   0x.... 0x....      LDR.W    R11,??DataTable16
   \       0xEC   0x4640             MOV      R0,R8
   \       0xEE   0xB2C0             UXTB     R0,R0
   \       0xF0   0xF83B 0x0010      LDRH     R0,[R11, R0, LSL #+1]
   \       0xF4   0x0039             MOVS     R1,R7
   \       0xF6   0xB289             UXTH     R1,R1
   \       0xF8   0x4288             CMP      R0,R1
   \       0xFA   0xD04A             BEQ.N    ??setChangeRegisterBit_12
   2558                {
   2559                  if ((getScuOpMode() != SCU_M_P) || (pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] & (uint16_t)EVSE_CONNECTOR_STATUS_BIT_RO) == (uint16_t)0)
   \       0xFC   0x.... 0x....      BL       getScuOpMode
   \      0x100   0x2802             CMP      R0,#+2
   \      0x102   0xD10A             BNE.N    ??setChangeRegisterBit_13
   \      0x104   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x108   0x6800             LDR      R0,[R0, #+0]
   \      0x10A   0x4641             MOV      R1,R8
   \      0x10C   0xB2C9             UXTB     R1,R1
   \      0x10E   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x112   0xF890 0x0102      LDRB     R0,[R0, #+258]
   \      0x116   0x0740             LSLS     R0,R0,#+29
   \      0x118   0xD439             BMI.N    ??setChangeRegisterBit_14
   2560                  {
   2561                    pRoRegs->scuMapRegStatusMeas.ntfChgStat = prevState[logicAddr] = val;
   \                     ??setChangeRegisterBit_13: (+1)
   \      0x11A   0x4640             MOV      R0,R8
   \      0x11C   0xB2C0             UXTB     R0,R0
   \      0x11E   0xF82B 0x7010      STRH     R7,[R11, R0, LSL #+1]
   \      0x122   0x4640             MOV      R0,R8
   \      0x124   0xB2C0             UXTB     R0,R0
   \      0x126   0xF83B 0x0010      LDRH     R0,[R11, R0, LSL #+1]
   \      0x12A   0xF8A6 0x0124      STRH     R0,[R6, #+292]
   2562                    pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)EVSE_CONNECTOR_STATUS_BIT_RO;
   \      0x12E   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x132   0x6801             LDR      R1,[R0, #+0]
   \      0x134   0x4642             MOV      R2,R8
   \      0x136   0xB2D2             UXTB     R2,R2
   \      0x138   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x13C   0x6800             LDR      R0,[R0, #+0]
   \      0x13E   0x4642             MOV      R2,R8
   \      0x140   0xB2D2             UXTB     R2,R2
   \      0x142   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x146   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x14A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \      0x14E   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2563                    /*         destination           source */
   2564                    strcpy((char *)strReg, AddrChargStatus);
   \      0x152   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \      0x156   0xA805             ADD      R0,SP,#+20
   \      0x158   0x.... 0x....      BL       strcpy
   2565                    ix = (uint8_t)pRoRegs->scuMapRegStatusMeas.ntfChgStat;
   \      0x15C   0xF8B6 0x0124      LDRH     R0,[R6, #+292]
   \      0x160   0xF88D 0x000D      STRB     R0,[SP, #+13]
   2566                    if (ix <= SUSPENDED_NOPOWER_STATE)
   \      0x164   0xF89D 0x000D      LDRB     R0,[SP, #+13]
   \      0x168   0x280F             CMP      R0,#+15
   \      0x16A   0xDA08             BGE.N    ??setChangeRegisterBit_15
   2567                    {
   2568                      /*         destination       source */
   2569                      strcat((char *)strReg, nameState[ix]);
   \      0x16C   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \      0x170   0xF89D 0x100D      LDRB     R1,[SP, #+13]
   \      0x174   0xF850 0x1021      LDR      R1,[R0, R1, LSL #+2]
   \      0x178   0xA805             ADD      R0,SP,#+20
   \      0x17A   0x.... 0x....      BL       strcat
   2570                    }
   2571                    if (val == (uint16_t)MDBSTATE_REBOOTING)
   \                     ??setChangeRegisterBit_15: (+1)
   \      0x17E   0x0038             MOVS     R0,R7
   \      0x180   0xB280             UXTH     R0,R0
   \      0x182   0x280D             CMP      R0,#+13
   \      0x184   0xD107             BNE.N    ??setChangeRegisterBit_16
   2572                    {
   2573                      /* reset max_temporary_power when a reboot on slave occurred */
   2574                      pRwRegs->scuSetRegister.maxTempPowerAc = (uint32_t)0;
   \      0x186   0x9804             LDR      R0,[SP, #+16]
   \      0x188   0x2100             MOVS     R1,#+0
   \      0x18A   0x6741             STR      R1,[R0, #+116]
   \      0x18C   0xE003             B.N      ??setChangeRegisterBit_16
   2575                    }
   2576                  }
   2577                  else
   2578                  {
   2579                    /* previus info has not been read from SBC */
   2580                    return(SEND_RETRY);
   \                     ??setChangeRegisterBit_14: (+1)
   \      0x18E   0x2002             MOVS     R0,#+2
   \      0x190   0xE0DC             B.N      ??setChangeRegisterBit_17
   2581                  }
   2582                }
   2583                else
   2584                {
   2585                  result = SEND_NULL;
   \                     ??setChangeRegisterBit_12: (+1)
   \      0x192   0x2000             MOVS     R0,#+0
   \      0x194   0x4682             MOV      R10,R0
   2586                }
   2587          #endif
   2588                break;
   \                     ??setChangeRegisterBit_16: (+1)
   \      0x196   0xE09F             B.N      ??setChangeRegisterBit_11
   2589          
   2590              case ADDR_EVSE_ERROR1_RO:
   2591                  pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)EVSE_ERROR1_BIT_RO;
   \                     ??setChangeRegisterBit_2: (+1)
   \      0x198   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x19C   0x6801             LDR      R1,[R0, #+0]
   \      0x19E   0x4642             MOV      R2,R8
   \      0x1A0   0xB2D2             UXTB     R2,R2
   \      0x1A2   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x1A6   0x6800             LDR      R0,[R0, #+0]
   \      0x1A8   0x4642             MOV      R2,R8
   \      0x1AA   0xB2D2             UXTB     R2,R2
   \      0x1AC   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x1B0   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x1B4   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x1B8   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2592                  /*         destination   source */
   2593                  strcpy((char *)strReg, AddrErr1);
   \      0x1BC   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \      0x1C0   0xA805             ADD      R0,SP,#+20
   \      0x1C2   0x.... 0x....      BL       strcpy
   2594                  val = pRoRegs->scuMapRegNotify.ntfErr1;
   \      0x1C6   0xF8B6 0x00FE      LDRH     R0,[R6, #+254]
   \      0x1CA   0x0007             MOVS     R7,R0
   2595                  break;
   \      0x1CC   0xE084             B.N      ??setChangeRegisterBit_11
   2596          
   2597              case ADDR_EVSE_ERROR2_RO:
   2598                  pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)EVSE_ERROR2_BIT_RO;
   \                     ??setChangeRegisterBit_3: (+1)
   \      0x1CE   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x1D2   0x6801             LDR      R1,[R0, #+0]
   \      0x1D4   0x4642             MOV      R2,R8
   \      0x1D6   0xB2D2             UXTB     R2,R2
   \      0x1D8   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x1DC   0x6800             LDR      R0,[R0, #+0]
   \      0x1DE   0x4642             MOV      R2,R8
   \      0x1E0   0xB2D2             UXTB     R2,R2
   \      0x1E2   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x1E6   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x1EA   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x1EE   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2599                  /*         destination   source */
   2600                  strcpy((char *)strReg, AddrErr2);
   \      0x1F2   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \      0x1F6   0xA805             ADD      R0,SP,#+20
   \      0x1F8   0x.... 0x....      BL       strcpy
   2601                  val = pRoRegs->scuMapRegNotify.ntfErr2;
   \      0x1FC   0xF8B6 0x0100      LDRH     R0,[R6, #+256]
   \      0x200   0x0007             MOVS     R7,R0
   2602                  break;
   \      0x202   0xE069             B.N      ??setChangeRegisterBit_11
   2603          
   2604              case ADDR_CONNECTOR_TYPE_RW:
   2605                  pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)CONFIGURATIONS_BIT_RW;
   \                     ??setChangeRegisterBit_0: (+1)
   \      0x204   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x208   0x6801             LDR      R1,[R0, #+0]
   \      0x20A   0x4642             MOV      R2,R8
   \      0x20C   0xB2D2             UXTB     R2,R2
   \      0x20E   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x212   0x6800             LDR      R0,[R0, #+0]
   \      0x214   0x4642             MOV      R2,R8
   \      0x216   0xB2D2             UXTB     R2,R2
   \      0x218   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x21C   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x220   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x224   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2606                  /*         destination     source */
   2607                  strcpy((char *)strReg, AddrConnType);
   \      0x228   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \      0x22C   0xA805             ADD      R0,SP,#+20
   \      0x22E   0x.... 0x....      BL       strcpy
   2608                  val = 0;
   \      0x232   0x2000             MOVS     R0,#+0
   \      0x234   0x0007             MOVS     R7,R0
   2609                  break;
   \      0x236   0xE04F             B.N      ??setChangeRegisterBit_11
   2610          
   2611              case ADDR_SESSION_ID_RO:
   2612                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)SESSION_ID_BIT_RO;
   \                     ??setChangeRegisterBit_7: (+1)
   \      0x238   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x23C   0x6801             LDR      R1,[R0, #+0]
   \      0x23E   0x4642             MOV      R2,R8
   \      0x240   0xB2D2             UXTB     R2,R2
   \      0x242   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x246   0x6800             LDR      R0,[R0, #+0]
   \      0x248   0x4642             MOV      R2,R8
   \      0x24A   0xB2D2             UXTB     R2,R2
   \      0x24C   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x250   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x254   0xF050 0x0020      ORRS     R0,R0,#0x20
   \      0x258   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2613                /*         destination     source */
   2614                strcpy((char *)strReg, AddrSessId);
   \      0x25C   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \      0x260   0xA805             ADD      R0,SP,#+20
   \      0x262   0x.... 0x....      BL       strcpy
   2615                val = pRoRegs->scuMapRegStatusMeas.evSessionId;
   \      0x266   0xF516 0x71D2      ADDS     R1,R6,#+420
   \      0x26A   0x6808             LDR      R0,[R1, #+0]
   \      0x26C   0x0007             MOVS     R7,R0
   2616                break;
   \      0x26E   0xE033             B.N      ??setChangeRegisterBit_11
   2617                
   2618              case ADDR_ENERGY_METERS_RW:
   2619          #ifdef COME_ERA
   2620                /* workaround: on detect EM type set EM error, so the SEM is ready to read it when receive the clearing alarm */
   2621                /* clearing is made by socket at the and of the detected procedure                                            */
   2622                pRoRegs->scuMapRegNotify.ntfErr1 |= ((uint16_t)ERROR1_EMTR);
   2623          #else
   2624                /* an energy meter has been detected, so an EM error must be removed */
   2625                pRoRegs->scuMapRegNotify.ntfErr1 &= (~(uint16_t)ERROR1_EMTR);
   \                     ??setChangeRegisterBit_1: (+1)
   \      0x270   0xF8B6 0x10FE      LDRH     R1,[R6, #+254]
   \      0x274   0xF64B 0x70FF      MOVW     R0,#+49151
   \      0x278   0x4001             ANDS     R1,R0,R1
   \      0x27A   0xF8A6 0x10FE      STRH     R1,[R6, #+254]
   2626          #endif
   2627                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[logicAddr] |= (uint16_t)EVSE_ERROR1_BIT_RO;
   \      0x27E   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x282   0x6801             LDR      R1,[R0, #+0]
   \      0x284   0x4642             MOV      R2,R8
   \      0x286   0xB2D2             UXTB     R2,R2
   \      0x288   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \      0x28C   0x6800             LDR      R0,[R0, #+0]
   \      0x28E   0x4642             MOV      R2,R8
   \      0x290   0xB2D2             UXTB     R2,R2
   \      0x292   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x296   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x29A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x29E   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2628                /*         destination           source */
   2629                strcpy((char *)strReg, AddrEm);
   \      0x2A2   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \      0x2A6   0xA805             ADD      R0,SP,#+20
   \      0x2A8   0x.... 0x....      BL       strcpy
   2630                break;
   \      0x2AC   0xE014             B.N      ??setChangeRegisterBit_11
   2631           
   2632              case ADDR_CURRENT_AC_L1_RO:
   2633              case ADDR_VOLTAGE_AC_RO:
   2634                /*   destination           source */
   2635                strcpy((char *)strReg, AddrMeasure);
   \                     ??setChangeRegisterBit_6: (+1)
   \      0x2AE   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \      0x2B2   0xA805             ADD      R0,SP,#+20
   \      0x2B4   0x.... 0x....      BL       strcpy
   2636                /* for measure upgrade no setting is necessary SEM read it automatically with polling */
   2637                result = SEND_ACK;
   \      0x2B8   0x2001             MOVS     R0,#+1
   \      0x2BA   0x4682             MOV      R10,R0
   2638                toPrint = toUpdate = FALSE;
   \      0x2BC   0x2000             MOVS     R0,#+0
   \      0x2BE   0x4681             MOV      R9,R0
   \      0x2C0   0xF88D 0x900C      STRB     R9,[SP, #+12]
   2639                break;
   \      0x2C4   0xE008             B.N      ??setChangeRegisterBit_11
   2640          
   2641              case ADDR_TIME_IN_CHARGE_RO:
   2642                /* for measure upgrade no setting is necessary SEM read it automatically with polling */
   2643                result = SEND_ACK;
   \                     ??setChangeRegisterBit_9: (+1)
   \      0x2C6   0x2001             MOVS     R0,#+1
   \      0x2C8   0x4682             MOV      R10,R0
   2644                toPrint = toUpdate = FALSE;
   \      0x2CA   0x2000             MOVS     R0,#+0
   \      0x2CC   0x4681             MOV      R9,R0
   \      0x2CE   0xF88D 0x900C      STRB     R9,[SP, #+12]
   2645                break;
   \      0x2D2   0xE001             B.N      ??setChangeRegisterBit_11
   2646                
   2647              default:
   2648                result = SEND_NULL;
   \                     ??setChangeRegisterBit_10: (+1)
   \      0x2D4   0x2000             MOVS     R0,#+0
   \      0x2D6   0x4682             MOV      R10,R0
   2649                break;
   2650            }
   2651            if (result == SEND_ACK)
   \                     ??setChangeRegisterBit_11: (+1)
   \      0x2D8   0x4650             MOV      R0,R10
   \      0x2DA   0xB2C0             UXTB     R0,R0
   \      0x2DC   0x2801             CMP      R0,#+1
   \      0x2DE   0xD133             BNE.N    ??setChangeRegisterBit_18
   2652            {
   2653              // if a slave has been removed from discovered list only at the end of discovery phase must inform SEM 
   2654              if ((isSemMasterFz() == TRUE) && (toUpdate == TRUE) && ((sbcSemInfoMng.activeLastDiscovery & mskBit) != 0))
   \      0x2E0   0x.... 0x....      BL       isSemMasterFz
   \      0x2E4   0x2801             CMP      R0,#+1
   \      0x2E6   0xD113             BNE.N    ??setChangeRegisterBit_19
   \      0x2E8   0x4648             MOV      R0,R9
   \      0x2EA   0xB2C0             UXTB     R0,R0
   \      0x2EC   0x2801             CMP      R0,#+1
   \      0x2EE   0xD10F             BNE.N    ??setChangeRegisterBit_19
   \      0x2F0   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \      0x2F4   0x6A00             LDR      R0,[R0, #+32]
   \      0x2F6   0x9910             LDR      R1,[SP, #+64]
   \      0x2F8   0x4208             TST      R0,R1
   \      0x2FA   0xD009             BEQ.N    ??setChangeRegisterBit_19
   2655              {
   2656                /* set the bit position for this SCU where the change occurred */
   2657                pScuRoMapReg->scuMapRegNotify.ntfChangeRo |= mskBit; 
   \      0x2FC   0x.... 0x....      LDR.W    R0,??DataTable15
   \      0x300   0x6802             LDR      R2,[R0, #+0]
   \      0x302   0xF8D2 0x10FA      LDR      R1,[R2, #+250]
   \      0x306   0x6802             LDR      R2,[R0, #+0]
   \      0x308   0x9810             LDR      R0,[SP, #+64]
   \      0x30A   0x4301             ORRS     R1,R0,R1
   \      0x30C   0xF8C2 0x10FA      STR      R1,[R2, #+250]
   2658              }
   2659              if (toPrint == TRUE)
   \                     ??setChangeRegisterBit_19: (+1)
   \      0x310   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \      0x314   0x2801             CMP      R0,#+1
   \      0x316   0xD117             BNE.N    ??setChangeRegisterBit_18
   2660              {
   2661                tPrintf("Socket %d Reg=0x%X %s Value= 0x%X at %s N=0x%X\n\r", getNumSocketLcd(deviceId), regChanged, strReg, val, getHmsStr(), pMsg->timeEntry);
   \      0x318   0x.... 0x....      BL       getHmsStr
   \      0x31C   0x4683             MOV      R11,R0
   \      0x31E   0x0028             MOVS     R0,R5
   \      0x320   0xB2C0             UXTB     R0,R0
   \      0x322   0x.... 0x....      BL       getNumSocketLcd
   \      0x326   0xF8D4 0x100E      LDR      R1,[R4, #+14]
   \      0x32A   0x9102             STR      R1,[SP, #+8]
   \      0x32C   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \      0x330   0x0039             MOVS     R1,R7
   \      0x332   0xB289             UXTH     R1,R1
   \      0x334   0x9100             STR      R1,[SP, #+0]
   \      0x336   0xAB05             ADD      R3,SP,#+20
   \      0x338   0xF8BD 0x200E      LDRH     R2,[SP, #+14]
   \      0x33C   0xB2C0             UXTB     R0,R0
   \      0x33E   0x0001             MOVS     R1,R0
   \      0x340   0x.... 0x....      LDR.W    R0,??DataTable16_10
   \      0x344   0x.... 0x....      BL       tPrintf
   2662              }
   2663            }
   2664            return(result);
   \                     ??setChangeRegisterBit_18: (+1)
   \      0x348   0x4650             MOV      R0,R10
   \      0x34A   0xB2C0             UXTB     R0,R0
   \                     ??setChangeRegisterBit_17: (+1)
   \      0x34C   0xB011             ADD      SP,SP,#+68
   \      0x34E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   2665          }
   2666          
   2667          /**
   2668          *
   2669          * @brief       reset the property bit in the register change 
   2670          *              notification
   2671          *
   2672          * @param [in]  uint16_t: SCU logical index 00...31 
   2673          * @param [in]  uint16_t: base changed register 
   2674          * @param [in]  uint16_t: num word to be read  
   2675          *  
   2676          * @retval      uint8_t: success if TRUE 
   2677          *  
   2678          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2679          static uint8_t  resetChangeRegisterBit(uint16_t ixScu, uint16_t regChanged, uint16_t lenRd) 
   2680          {
   \                     resetChangeRegisterBit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   2681            scuRoMapRegister_st*  pScuIxRoMapReg;
   2682            uint8_t               result;
   2683          
   2684            result = FALSE;
   \        0xA   0x2700             MOVS     R7,#+0
   2685          
   2686            if ((regChanged == ADDR_EVSE_EVENT_FLAGS_RO) && (lenRd >= (ADDR_SCU_RESERVED6B - ADDR_EVSE_EVENT_FLAGS_RO)))
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0xB280             UXTH     R0,R0
   \       0x10   0xF5B0 0x6FC0      CMP      R0,#+1536
   \       0x14   0xD14C             BNE.N    ??resetChangeRegisterBit_0
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xB280             UXTH     R0,R0
   \       0x1A   0x286A             CMP      R0,#+106
   \       0x1C   0xDB48             BLT.N    ??resetChangeRegisterBit_0
   2687            {
   2688              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] = (uint16_t)0;
   \       0x1E   0x.... 0x....      LDR.W    R8,??DataTable15
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x28   0x0022             MOVS     R2,R4
   \       0x2A   0xB292             UXTH     R2,R2
   \       0x2C   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \       0x30   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   2689              /* no more events to manage for this SCU, so the status bit can be resetted */
   2690              pScuRoMapReg->scuMapRegNotify.ntfChangeRo &= (~(uint32_t)sbcSemMaskBit[ixScu]);
   \       0x34   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x38   0xF8D0 0x10FA      LDR      R1,[R0, #+250]
   \       0x3C   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0x44   0x0023             MOVS     R3,R4
   \       0x46   0xB29B             UXTH     R3,R3
   \       0x48   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \       0x4C   0x4381             BICS     R1,R1,R0
   \       0x4E   0xF8C2 0x10FA      STR      R1,[R2, #+250]
   2691              pScuIxRoMapReg = getRoMdbRegs(ixScu);
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0x.... 0x....      BL       getRoMdbRegs
   \       0x5A   0x4681             MOV      R9,R0
   2692              if (pScuIxRoMapReg->scuMapRegStatusMeas.uidAuth[0] != 0)
   \       0x5C   0xF899 0x01C2      LDRB     R0,[R9, #+450]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD023             BEQ.N    ??resetChangeRegisterBit_1
   2693              {
   2694                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)UID_AUTHORIZATION_BIT); result = TRUE;
   \       0x64   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x68   0x0021             MOVS     R1,R4
   \       0x6A   0xB289             UXTH     R1,R1
   \       0x6C   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \       0x70   0xF8B0 0x1102      LDRH     R1,[R0, #+258]
   \       0x74   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0x78   0x4001             ANDS     R1,R0,R1
   \       0x7A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x7E   0x0022             MOVS     R2,R4
   \       0x80   0xB292             UXTH     R2,R2
   \       0x82   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \       0x86   0xF8A0 0x1102      STRH     R1,[R0, #+258]
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0x0007             MOVS     R7,R0
   2695                pScuIxRoMapReg->scuMapRegStatusMeas.uidAuth[0] = pScuRoMapReg->scuMapRegStatusMeas.uidAuth[1] = (uint8_t)0;
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x94   0xF881 0x01C3      STRB     R0,[R1, #+451]
   \       0x98   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x9C   0xF890 0x01C3      LDRB     R0,[R0, #+451]
   \       0xA0   0xF889 0x01C2      STRB     R0,[R9, #+450]
   2696                gsy_quick_polling_update(RFID_PENDING, 0);
   \       0xA4   0x2100             MOVS     R1,#+0
   \       0xA6   0x2010             MOVS     R0,#+16
   \       0xA8   0x.... 0x....      BL       gsy_quick_polling_update
   2697              }
   2698              return (TRUE);
   \                     ??resetChangeRegisterBit_1: (+1)
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0xE0F0             B.N      ??resetChangeRegisterBit_2
   2699            }
   2700              
   2701            /* reset the bit of the read register by SBC-SEM */
   2702            if (regChanged == ADDR_UID_AUTHORIZATION_RO)
   \                     ??resetChangeRegisterBit_0: (+1)
   \       0xB0   0x0028             MOVS     R0,R5
   \       0xB2   0xB280             UXTH     R0,R0
   \       0xB4   0xF5B0 0x6FCA      CMP      R0,#+1616
   \       0xB8   0xD122             BNE.N    ??resetChangeRegisterBit_3
   2703            {
   2704              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)UID_AUTHORIZATION_BIT); result = TRUE;
   \       0xBA   0x.... 0x....      LDR.W    R1,??DataTable15
   \       0xBE   0x6808             LDR      R0,[R1, #+0]
   \       0xC0   0x0022             MOVS     R2,R4
   \       0xC2   0xB292             UXTH     R2,R2
   \       0xC4   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \       0xC8   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \       0xCC   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0xD0   0x4002             ANDS     R2,R0,R2
   \       0xD2   0x6808             LDR      R0,[R1, #+0]
   \       0xD4   0x0023             MOVS     R3,R4
   \       0xD6   0xB29B             UXTH     R3,R3
   \       0xD8   0xEB00 0x0043      ADD      R0,R0,R3, LSL #+1
   \       0xDC   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0x0007             MOVS     R7,R0
   2705              pScuRoMapReg->scuMapRegStatusMeas.uidAuth[0] = pScuRoMapReg->scuMapRegStatusMeas.uidAuth[1] = (uint8_t)0;
   \       0xE4   0x2000             MOVS     R0,#+0
   \       0xE6   0x680A             LDR      R2,[R1, #+0]
   \       0xE8   0xF882 0x01C3      STRB     R0,[R2, #+451]
   \       0xEC   0x6808             LDR      R0,[R1, #+0]
   \       0xEE   0xF890 0x01C3      LDRB     R0,[R0, #+451]
   \       0xF2   0x6809             LDR      R1,[R1, #+0]
   \       0xF4   0xF881 0x01C2      STRB     R0,[R1, #+450]
   2706              gsy_quick_polling_update(RFID_PENDING, 0);
   \       0xF8   0x2100             MOVS     R1,#+0
   \       0xFA   0x2010             MOVS     R0,#+16
   \       0xFC   0x.... 0x....      BL       gsy_quick_polling_update
   2707            }
   2708            if (regChanged == ADDR_EVSE_EVENT_FLAGS_RO)
   \                     ??resetChangeRegisterBit_3: (+1)
   \      0x100   0x0028             MOVS     R0,R5
   \      0x102   0xB280             UXTH     R0,R0
   \      0x104   0xF5B0 0x6FC0      CMP      R0,#+1536
   \      0x108   0xD114             BNE.N    ??resetChangeRegisterBit_4
   2709            {
   2710              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)SOCKET_EVENT_FLAG_BIT); result = TRUE;
   \      0x10A   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x10E   0x6808             LDR      R0,[R1, #+0]
   \      0x110   0x0022             MOVS     R2,R4
   \      0x112   0xB292             UXTH     R2,R2
   \      0x114   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x118   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x11C   0xF64F 0x70FD      MOVW     R0,#+65533
   \      0x120   0x4002             ANDS     R2,R0,R2
   \      0x122   0x6808             LDR      R0,[R1, #+0]
   \      0x124   0x0021             MOVS     R1,R4
   \      0x126   0xB289             UXTH     R1,R1
   \      0x128   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x12C   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x130   0x2001             MOVS     R0,#+1
   \      0x132   0x0007             MOVS     R7,R0
   2711            }
   2712            if (regChanged == ADDR_EVSE_CHARGE_STATUS_RO)
   \                     ??resetChangeRegisterBit_4: (+1)
   \      0x134   0x0028             MOVS     R0,R5
   \      0x136   0xF240 0x6101      MOVW     R1,#+1537
   \      0x13A   0xB280             UXTH     R0,R0
   \      0x13C   0x4288             CMP      R0,R1
   \      0x13E   0xD114             BNE.N    ??resetChangeRegisterBit_5
   2713            {
   2714              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)EVSE_CONNECTOR_STATUS_BIT_RO); result = TRUE;
   \      0x140   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x144   0x6808             LDR      R0,[R1, #+0]
   \      0x146   0x0022             MOVS     R2,R4
   \      0x148   0xB292             UXTH     R2,R2
   \      0x14A   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x14E   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x152   0xF64F 0x70FB      MOVW     R0,#+65531
   \      0x156   0x4002             ANDS     R2,R0,R2
   \      0x158   0x6808             LDR      R0,[R1, #+0]
   \      0x15A   0x0021             MOVS     R1,R4
   \      0x15C   0xB289             UXTH     R1,R1
   \      0x15E   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x162   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x166   0x2001             MOVS     R0,#+1
   \      0x168   0x0007             MOVS     R7,R0
   2715            }
   2716            if ((regChanged <= ADDR_EVSE_ERROR1_RO) && (regChanged + lenRd > ADDR_EVSE_ERROR1_RO))
   \                     ??resetChangeRegisterBit_5: (+1)
   \      0x16A   0xF240 0x4005      MOVW     R0,#+1029
   \      0x16E   0x0029             MOVS     R1,R5
   \      0x170   0xB289             UXTH     R1,R1
   \      0x172   0x4281             CMP      R1,R0
   \      0x174   0xDA1A             BGE.N    ??resetChangeRegisterBit_6
   \      0x176   0x0031             MOVS     R1,R6
   \      0x178   0xB289             UXTH     R1,R1
   \      0x17A   0xFA11 0xF185      UXTAH    R1,R1,R5
   \      0x17E   0x4281             CMP      R1,R0
   \      0x180   0xDB14             BLT.N    ??resetChangeRegisterBit_6
   2717            {
   2718              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)EVSE_ERROR1_BIT_RO); result = TRUE;
   \      0x182   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x186   0x6808             LDR      R0,[R1, #+0]
   \      0x188   0x0022             MOVS     R2,R4
   \      0x18A   0xB292             UXTH     R2,R2
   \      0x18C   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x190   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x194   0xF64F 0x70F7      MOVW     R0,#+65527
   \      0x198   0x4002             ANDS     R2,R0,R2
   \      0x19A   0x6808             LDR      R0,[R1, #+0]
   \      0x19C   0x0021             MOVS     R1,R4
   \      0x19E   0xB289             UXTH     R1,R1
   \      0x1A0   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x1A4   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x1A8   0x2001             MOVS     R0,#+1
   \      0x1AA   0x0007             MOVS     R7,R0
   2719            }
   2720            if ((regChanged <= ADDR_EVSE_ERROR2_RO) && (regChanged + lenRd > ADDR_EVSE_ERROR2_RO))
   \                     ??resetChangeRegisterBit_6: (+1)
   \      0x1AC   0xF240 0x4006      MOVW     R0,#+1030
   \      0x1B0   0x0029             MOVS     R1,R5
   \      0x1B2   0xB289             UXTH     R1,R1
   \      0x1B4   0x4281             CMP      R1,R0
   \      0x1B6   0xDA1A             BGE.N    ??resetChangeRegisterBit_7
   \      0x1B8   0x0031             MOVS     R1,R6
   \      0x1BA   0xB289             UXTH     R1,R1
   \      0x1BC   0xFA11 0xF185      UXTAH    R1,R1,R5
   \      0x1C0   0x4281             CMP      R1,R0
   \      0x1C2   0xDB14             BLT.N    ??resetChangeRegisterBit_7
   2721            {
   2722              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)EVSE_ERROR2_BIT_RO); result = TRUE;
   \      0x1C4   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x1C8   0x6808             LDR      R0,[R1, #+0]
   \      0x1CA   0x0022             MOVS     R2,R4
   \      0x1CC   0xB292             UXTH     R2,R2
   \      0x1CE   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x1D2   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x1D6   0xF64F 0x70EF      MOVW     R0,#+65519
   \      0x1DA   0x4002             ANDS     R2,R0,R2
   \      0x1DC   0x6808             LDR      R0,[R1, #+0]
   \      0x1DE   0x0021             MOVS     R1,R4
   \      0x1E0   0xB289             UXTH     R1,R1
   \      0x1E2   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x1E6   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x1EA   0x2001             MOVS     R0,#+1
   \      0x1EC   0x0007             MOVS     R7,R0
   2723            }
   2724            if (regChanged == ADDR_CONNECTOR_TYPE_RW)
   \                     ??resetChangeRegisterBit_7: (+1)
   \      0x1EE   0x0028             MOVS     R0,R5
   \      0x1F0   0xB280             UXTH     R0,R0
   \      0x1F2   0x2800             CMP      R0,#+0
   \      0x1F4   0xD114             BNE.N    ??resetChangeRegisterBit_8
   2725            {
   2726              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)CONFIGURATIONS_BIT_RW); result = TRUE;
   \      0x1F6   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x1FA   0x6808             LDR      R0,[R1, #+0]
   \      0x1FC   0x0022             MOVS     R2,R4
   \      0x1FE   0xB292             UXTH     R2,R2
   \      0x200   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x204   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x208   0xF64F 0x50FF      MOVW     R0,#+65023
   \      0x20C   0x4002             ANDS     R2,R0,R2
   \      0x20E   0x6808             LDR      R0,[R1, #+0]
   \      0x210   0x0021             MOVS     R1,R4
   \      0x212   0xB289             UXTH     R1,R1
   \      0x214   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x218   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x21C   0x2001             MOVS     R0,#+1
   \      0x21E   0x0007             MOVS     R7,R0
   2727            }
   2728            if (regChanged == ADDR_SESSION_ID_RO)
   \                     ??resetChangeRegisterBit_8: (+1)
   \      0x220   0x0028             MOVS     R0,R5
   \      0x222   0xF240 0x6141      MOVW     R1,#+1601
   \      0x226   0xB280             UXTH     R0,R0
   \      0x228   0x4288             CMP      R0,R1
   \      0x22A   0xD114             BNE.N    ??resetChangeRegisterBit_9
   2729            {
   2730              pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] &= (~(uint16_t)SESSION_ID_BIT_RO); result = TRUE;
   \      0x22C   0x.... 0x....      LDR.W    R1,??DataTable15
   \      0x230   0x6808             LDR      R0,[R1, #+0]
   \      0x232   0x0022             MOVS     R2,R4
   \      0x234   0xB292             UXTH     R2,R2
   \      0x236   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \      0x23A   0xF8B0 0x2102      LDRH     R2,[R0, #+258]
   \      0x23E   0xF64F 0x70DF      MOVW     R0,#+65503
   \      0x242   0x4002             ANDS     R2,R0,R2
   \      0x244   0x6808             LDR      R0,[R1, #+0]
   \      0x246   0x0021             MOVS     R1,R4
   \      0x248   0xB289             UXTH     R1,R1
   \      0x24A   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x24E   0xF8A0 0x2102      STRH     R2,[R0, #+258]
   \      0x252   0x2001             MOVS     R0,#+1
   \      0x254   0x0007             MOVS     R7,R0
   2731            }
   2732          
   2733            if (result == TRUE)
   \                     ??resetChangeRegisterBit_9: (+1)
   \      0x256   0x0038             MOVS     R0,R7
   \      0x258   0xB2C0             UXTB     R0,R0
   \      0x25A   0x2801             CMP      R0,#+1
   \      0x25C   0xD117             BNE.N    ??resetChangeRegisterBit_10
   2734            {
   2735              if (pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[ixScu] == (uint16_t)0)
   \      0x25E   0x.... 0x....      LDR.W    R2,??DataTable15
   \      0x262   0x6810             LDR      R0,[R2, #+0]
   \      0x264   0x0021             MOVS     R1,R4
   \      0x266   0xB289             UXTH     R1,R1
   \      0x268   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \      0x26C   0xF8B0 0x0102      LDRH     R0,[R0, #+258]
   \      0x270   0x2800             CMP      R0,#+0
   \      0x272   0xD10C             BNE.N    ??resetChangeRegisterBit_10
   2736              {
   2737                /* no more events to manage for this SCU, so the status bit can be resetted */
   2738                pScuRoMapReg->scuMapRegNotify.ntfChangeRo &= (~(uint32_t)sbcSemMaskBit[ixScu]);
   \      0x274   0x6810             LDR      R0,[R2, #+0]
   \      0x276   0xF8D0 0x10FA      LDR      R1,[R0, #+250]
   \      0x27A   0x6812             LDR      R2,[R2, #+0]
   \      0x27C   0x.... 0x....      LDR.W    R0,??DataTable17
   \      0x280   0x0023             MOVS     R3,R4
   \      0x282   0xB29B             UXTH     R3,R3
   \      0x284   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \      0x288   0x4381             BICS     R1,R1,R0
   \      0x28A   0xF8C2 0x10FA      STR      R1,[R2, #+250]
   2739              }
   2740            }
   2741            return(result);
   \                     ??resetChangeRegisterBit_10: (+1)
   \      0x28E   0x0038             MOVS     R0,R7
   \      0x290   0xB2C0             UXTB     R0,R0
   \                     ??resetChangeRegisterBit_2: (+1)
   \      0x292   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2742          }
   2743          
   2744          /**
   2745          *
   2746          * @brief       set the property UID bytes in the registers 
   2747          *
   2748          * @param [in]  none 
   2749          *  
   2750          * @retval      none 
   2751          *  
   2752          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2753          void setUIDinfoROmap (void) 
   2754          {
   \                     setUIDinfoROmap: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   2755            scuRoMapRegister_st*    pRoRegs;
   2756            uint8_t                 mdbAddr;
   2757          
   2758            mdbAddr = getLogicalMdbAddrSem();
   \        0x2   0x.... 0x....      BL       getLogicalMdbAddrSem
   \        0x6   0x0005             MOVS     R5,R0
   2759            pRoRegs = getRoMdbRegs(mdbAddr);
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x.... 0x....      BL       getRoMdbRegs
   \       0x10   0x0004             MOVS     R4,R0
   2760          
   2761            /* set in the map the right value for len, card type and UID */
   2762            rfid_uid_get((uint8_t *)&pRoRegs->scuMapRegStatusMeas.uidAuth[2], (sl030_type_en*)(&pRoRegs->scuMapRegStatusMeas.uidAuth[1]));
   \       0x12   0xF204 0x11C3      ADDW     R1,R4,#+451
   \       0x16   0xF514 0x70E2      ADDS     R0,R4,#+452
   \       0x1A   0x.... 0x....      BL       rfid_uid_get
   2763            if ((pRoRegs->scuMapRegStatusMeas.uidAuth[6] == 0) && (pRoRegs->scuMapRegStatusMeas.uidAuth[7] == 0) &&
   2764                (pRoRegs->scuMapRegStatusMeas.uidAuth[8] == 0) && (pRoRegs->scuMapRegStatusMeas.uidAuth[9] == 0))
   \       0x1E   0xF894 0x01C8      LDRB     R0,[R4, #+456]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10F             BNE.N    ??setUIDinfoROmap_0
   \       0x26   0xF894 0x01C9      LDRB     R0,[R4, #+457]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD10B             BNE.N    ??setUIDinfoROmap_0
   \       0x2E   0xF894 0x01CA      LDRB     R0,[R4, #+458]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD107             BNE.N    ??setUIDinfoROmap_0
   \       0x36   0xF894 0x01CB      LDRB     R0,[R4, #+459]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD103             BNE.N    ??setUIDinfoROmap_0
   2765            {
   2766              pRoRegs->scuMapRegStatusMeas.uidAuth[0] = (uint8_t)4;
   \       0x3E   0x2004             MOVS     R0,#+4
   \       0x40   0xF884 0x01C2      STRB     R0,[R4, #+450]
   \       0x44   0xE002             B.N      ??setUIDinfoROmap_1
   2767            }
   2768            else
   2769            {
   2770              pRoRegs->scuMapRegStatusMeas.uidAuth[0] = (uint8_t)7;
   \                     ??setUIDinfoROmap_0: (+1)
   \       0x46   0x2007             MOVS     R0,#+7
   \       0x48   0xF884 0x01C2      STRB     R0,[R4, #+450]
   2771            }
   2772          }
   \                     ??setUIDinfoROmap_1: (+1)
   \       0x4C   0xBD31             POP      {R0,R4,R5,PC}
   2773          
   2774          /**
   2775          *
   2776          * @brief        callback to manager timers   
   2777          *
   2778          * @param [in]   TimerHandle_t: the elapsed timer 
   2779          *
   2780          * @retval       none
   2781          *
   2782          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2783          static void sbcSemTimCallBack (TimerHandle_t pxTimer)
   2784          {
   \                     sbcSemTimCallBack: (+1)
   \        0x0   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x0004             MOVS     R4,R0
   2785            frameSbcSem_st        tmpFrameSbcSem;  
   2786            uint32_t              timer_id, val;
   2787            scuOpModes_e          locScuMode;
   2788            uint8_t               result;
   2789          
   2790            /* find the led  which the timer is referred */
   2791            timer_id = (uint32_t)pvTimerGetTimerID(pxTimer);
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       pvTimerGetTimerID
   \        0xE   0x0006             MOVS     R6,R0
   2792          
   2793            switch (timer_id)
   \       0x10   0x2E00             CMP      R6,#+0
   \       0x12   0xD00A             BEQ.N    ??sbcSemTimCallBack_0
   \       0x14   0x2E02             CMP      R6,#+2
   \       0x16   0xF000 0x81DE      BEQ.W    ??sbcSemTimCallBack_1
   \       0x1A   0xF0C0 0x813D      BCC.W    ??sbcSemTimCallBack_2
   \       0x1E   0x2E04             CMP      R6,#+4
   \       0x20   0xF000 0x81FA      BEQ.W    ??sbcSemTimCallBack_3
   \       0x24   0xF0C0 0x81DA      BCC.W    ??sbcSemTimCallBack_4
   \       0x28   0xE24B             B.N      ??sbcSemTimCallBack_5
   2794            {
   2795              case (uint32_t)TIMER_FIND_CONFIG:
   2796                switch (sbcSemInfoMng.sbcSemStates)
   \                     ??sbcSemTimCallBack_0: (+1)
   \       0x2A   0x.... 0x....      LDR.W    R7,??DataTable16_9
   \       0x2E   0x8838             LDRH     R0,[R7, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD008             BEQ.N    ??sbcSemTimCallBack_6
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD05F             BEQ.N    ??sbcSemTimCallBack_7
   \       0x38   0x2804             CMP      R0,#+4
   \       0x3A   0xF000 0x80F3      BEQ.W    ??sbcSemTimCallBack_8
   \       0x3E   0x280C             CMP      R0,#+12
   \       0x40   0xF000 0x80CB      BEQ.W    ??sbcSemTimCallBack_9
   \       0x44   0xE127             B.N      ??sbcSemTimCallBack_10
   2797                {
   2798                  case SBC_SEM_INIT_DISCOVERY:
   2799                    if (isSemMasterFz() == TRUE)
   \                     ??sbcSemTimCallBack_6: (+1)
   \       0x46   0x.... 0x....      BL       isSemMasterFz
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xD12D             BNE.N    ??sbcSemTimCallBack_11
   2800                    {
   2801                      sbcSemInfoMng.dataVal = (uint16_t)SCU_S_PS_STARTUP;  // for discovery slave SCU (slave primary, i.e with TFT or slave secondary) 
   \       0x4E   0x2004             MOVS     R0,#+4
   \       0x50   0x80B8             STRH     R0,[R7, #+4]
   2802                      tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \       0x52   0x2003             MOVS     R0,#+3
   \       0x54   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   2803                      tmpFrameSbcSem.data.index = MODBUS_BROADCAST_ADDR;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   2804                      tmpFrameSbcSem.data.rAddr = ADDR_EVSE_TM_RW;
   \       0x5E   0x2022             MOVS     R0,#+34
   \       0x60   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   2805                      tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \       0x64   0x1D38             ADDS     R0,R7,#+4
   \       0x66   0x9004             STR      R0,[SP, #+16]
   2806                      tmpFrameSbcSem.dataToSend.len = LEN_EVSE_TM_MODE_RW;
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   2807                      configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \       0x6E   0x.... 0x....      BL       getRs485SemQueueHandle
   \       0x72   0x2300             MOVS     R3,#+0
   \       0x74   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x78   0xA902             ADD      R1,SP,#+8
   \       0x7A   0x.... 0x....      BL       xQueueGenericSend
   \       0x7E   0x2801             CMP      R0,#+1
   \       0x80   0xD009             BEQ.N    ??sbcSemTimCallBack_12
   \       0x82   0xB672             CPSID    I
   \       0x84   0x2050             MOVS     R0,#+80
   \       0x86   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x8A   0xF3BF 0x8F4F      DSB      SY
   \       0x8E   0xF3BF 0x8F6F      ISB      SY
   \       0x92   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_13: (+1)
   \       0x94   0xE7FE             B.N      ??sbcSemTimCallBack_13
   2808                      restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_DISCOVERY_SLAVE); // the master restart the timeout 1000msec
   \                     ??sbcSemTimCallBack_12: (+1)
   \       0x96   0xF44F 0x717A      MOV      R1,#+1000
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x.... 0x....      BL       restartSbcSemTimer
   2809                      sbcSemInfoMng.activityStatus = 0; 
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0x6178             STR      R0,[R7, #+20]
   2810                      sbcSemInfoMng.sbcSemStates = SBC_SEM_DISCOVERY_S;
   \       0xA4   0x2001             MOVS     R0,#+1
   \       0xA6   0x8038             STRH     R0,[R7, #+0]
   \       0xA8   0xE025             B.N      ??sbcSemTimCallBack_14
   2811                    }
   2812                    else
   2813                    {
   2814                      /* the ack coming from expected socket */
   2815                      sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \                     ??sbcSemTimCallBack_11: (+1)
   \       0xAA   0x2004             MOVS     R0,#+4
   \       0xAC   0x8038             STRH     R0,[R7, #+0]
   2816                      locScuMode = getScuOpMode();
   \       0xAE   0x.... 0x....      BL       getScuOpMode
   \       0xB2   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   2817                      if ((locScuMode == SCU_S_P) || (locScuMode == SCU_S_S))
   \       0xB6   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \       0xBA   0x2803             CMP      R0,#+3
   \       0xBC   0xD003             BEQ.N    ??sbcSemTimCallBack_15
   \       0xBE   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \       0xC2   0x2804             CMP      R0,#+4
   \       0xC4   0xD117             BNE.N    ??sbcSemTimCallBack_14
   2818                      {
   2819                        /* after update it is necessary a slave must inform the master about new FW   */
   2820                        val = HAL_RTCEx_BKUPRead((RTC_HandleTypeDef*) getHandleRtc(), BACKUP_HW_INFO);
   \                     ??sbcSemTimCallBack_15: (+1)
   \       0xC6   0x.... 0x....      BL       getHandleRtc
   \       0xCA   0x2109             MOVS     R1,#+9
   \       0xCC   0x.... 0x....      BL       HAL_RTCEx_BKUPRead
   \       0xD0   0x0005             MOVS     R5,R0
   2821                        if ((val & NOTIFY_FW_UPD_MASK) == NOTIFY_FW_UPD_FLAG)
   \       0xD2   0xF415 0x1040      ANDS     R0,R5,#0x300000
   \       0xD6   0xF5B0 0x1F80      CMP      R0,#+1048576
   \       0xDA   0xD10C             BNE.N    ??sbcSemTimCallBack_14
   2822                        {
   2823                          /* reset the flag */
   2824                          val &= (~NOTIFY_FW_UPD_MASK);
   \       0xDC   0xF435 0x1540      BICS     R5,R5,#0x300000
   2825                          HAL_RTCEx_BKUPWrite((RTC_HandleTypeDef*)getHandleRtc(), (uint32_t)BACKUP_HW_INFO, val);       
   \       0xE0   0x.... 0x....      BL       getHandleRtc
   \       0xE4   0x002A             MOVS     R2,R5
   \       0xE6   0x2109             MOVS     R1,#+9
   \       0xE8   0x.... 0x....      BL       HAL_RTCEx_BKUPWrite
   2826                          /* send the info on communication error   */
   2827                          sendEventToSemMng(NOTIFY_TO_MASTER_TX, ADDR_EVSE_ERROR2_RO);
   \       0xEC   0xF240 0x4105      MOVW     R1,#+1029
   \       0xF0   0x2002             MOVS     R0,#+2
   \       0xF2   0x.... 0x....      BL       sendEventToSemMng
   2828                        }
   2829                      }
   2830                    }
   2831                    break;
   \                     ??sbcSemTimCallBack_14: (+1)
   \       0xF6   0xE0CE             B.N      ??sbcSemTimCallBack_16
   2832          
   2833                  case SBC_SEM_DISCOVERY_S:
   2834                    /* no more master secondary SCU are present in the chain */
   2835                    if ((socketPresence.livePresence & (~SCU_MASTER_MASK_BIT)) == 0)
   \                     ??sbcSemTimCallBack_7: (+1)
   \       0xF8   0x.... 0x....      LDR.W    R8,??DataTable22
   \       0xFC   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \      0x100   0x0840             LSRS     R0,R0,#+1
   \      0x102   0x0040             LSLS     R0,R0,#+1
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD11E             BNE.N    ??sbcSemTimCallBack_17
   2836                    {
   2837                      pScuRoMapReg->scuMapRegNotify.ntfPresences = (uint32_t)0x01; // only SCU master is present --> stand alone socket
   \      0x108   0x.... 0x....      LDR.W    R9,??DataTable15
   \      0x10C   0xF05F 0x0A01      MOVS     R10,#+1
   \      0x110   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x114   0xF8C0 0xA0F6      STR      R10,[R0, #+246]
   2838                      socketPresence.chainPresence |= (uint32_t)0x01;
   \      0x118   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x11C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x120   0xF8C8 0x0000      STR      R0,[R8, #+0]
   2839                      /* the alive task must be started to check if a slave will be connected   */
   2840                      sbcSemInfoMng.discoveryMask = 0;
   \      0x124   0xF117 0x0B0A      ADDS     R11,R7,#+10
   \      0x128   0x2000             MOVS     R0,#+0
   \      0x12A   0xF8CB 0x0000      STR      R0,[R11, #+0]
   2841                      if (getScuOpMode() == SCU_M_STAND_ALONE)
   \      0x12E   0x.... 0x....      BL       getScuOpMode
   \      0x132   0x2805             CMP      R0,#+5
   \      0x134   0xD119             BNE.N    ??sbcSemTimCallBack_18
   2842                      {
   2843                        /* set initial socket info */
   2844                        sbcSemInfoMng.discoveryMask = (uint32_t)0x1;
   \      0x136   0xF8CB 0xA000      STR      R10,[R11, #+0]
   2845                        /* only the SCU Isolated is present For SEM this SCU must be put in OFF-LINE */
   2846                        pScuRoMapReg->scuMapRegStatusMeas.ntfChgStat = (uint16_t)MDBSTATE_UNAVAILABLE;
   \      0x13A   0x2009             MOVS     R0,#+9
   \      0x13C   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x140   0xF8A1 0x0124      STRH     R0,[R1, #+292]
   \      0x144   0xE011             B.N      ??sbcSemTimCallBack_18
   2847                      }
   2848                    }
   2849                    else
   2850                    {
   2851                      if (getRemotePmFlag() == FALSE) setPmRemoteSemFlag(TRUE); // we are working in SEM with one slave present atleast 
   \                     ??sbcSemTimCallBack_17: (+1)
   \      0x146   0x.... 0x....      BL       getRemotePmFlag
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD102             BNE.N    ??sbcSemTimCallBack_19
   \      0x14E   0x2001             MOVS     R0,#+1
   \      0x150   0x.... 0x....      BL       setPmRemoteSemFlag
   2852                      if (getScuOpMode() == SCU_M_STAND_ALONE)
   \                     ??sbcSemTimCallBack_19: (+1)
   \      0x154   0x.... 0x....      BL       getScuOpMode
   \      0x158   0x2805             CMP      R0,#+5
   \      0x15A   0xD103             BNE.N    ??sbcSemTimCallBack_20
   2853                      {
   2854                        /* set initial socket info */
   2855                        sbcSemInfoMng.discoveryMask = (uint32_t)0x1;
   \      0x15C   0x2001             MOVS     R0,#+1
   \      0x15E   0xF8C7 0x000A      STR      R0,[R7, #+10]
   \      0x162   0xE002             B.N      ??sbcSemTimCallBack_18
   2856                      }
   2857                      else
   2858                      {
   2859                        /* set initial socket info */
   2860                        sbcSemInfoMng.discoveryMask = (uint32_t)0x2;
   \                     ??sbcSemTimCallBack_20: (+1)
   \      0x164   0x2002             MOVS     R0,#+2
   \      0x166   0xF8C7 0x000A      STR      R0,[R7, #+10]
   2861                      }
   2862                    }
   2863                    sbcSemInfoMng.activityStatus = socketPresence.livePresence; // set mask for discovery procedure
   \                     ??sbcSemTimCallBack_18: (+1)
   \      0x16A   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \      0x16E   0x6178             STR      R0,[R7, #+20]
   2864          
   2865                    sbcSemInfoMng.addrVal = ADDR_START_RDD;  // to get info on  discovered primary/secondary slave an master SCU 
   \      0x170   0xF44F 0x7040      MOV      R0,#+768
   \      0x174   0x80F8             STRH     R0,[R7, #+6]
   2866                    tmpFrameSbcSem.sbcSemEvent = RECOVERY_INFO;
   \      0x176   0x2104             MOVS     R1,#+4
   \      0x178   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   2867                    tmpFrameSbcSem.data.rAddr = sbcSemInfoMng.addrVal = ADDR_START_RDD;
   \      0x17C   0x80F8             STRH     R0,[R7, #+6]
   \      0x17E   0x88F8             LDRH     R0,[R7, #+6]
   \      0x180   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   2868                    sbcSemInfoMng.sbcSemStates = SBC_SEM_RECOVERY_INFO;
   \      0x184   0x2002             MOVS     R0,#+2
   \      0x186   0x8038             STRH     R0,[R7, #+0]
   2869                    if (getScuOpMode() == SCU_M_P)
   \      0x188   0x.... 0x....      BL       getScuOpMode
   \      0x18C   0x2802             CMP      R0,#+2
   \      0x18E   0xD105             BNE.N    ??sbcSemTimCallBack_21
   2870                    {
   2871                      /* set initial socket info */
   2872                      sbcSemInfoMng.logicIdSocket = (uint16_t)0x1;
   \      0x190   0x2001             MOVS     R0,#+1
   \      0x192   0x8138             STRH     R0,[R7, #+8]
   2873                      tmpFrameSbcSem.data.index = (uint16_t)0x1;
   \      0x194   0x2001             MOVS     R0,#+1
   \      0x196   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   \      0x19A   0xE004             B.N      ??sbcSemTimCallBack_22
   2874                    }
   2875                    else
   2876                    {
   2877                      /* SCU_M_STAND_ALONE case */
   2878                      sbcSemInfoMng.logicIdSocket = (uint16_t)0x0;
   \                     ??sbcSemTimCallBack_21: (+1)
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0x8138             STRH     R0,[R7, #+8]
   2879                      tmpFrameSbcSem.data.index = (uint16_t)0x0;
   \      0x1A0   0x2000             MOVS     R0,#+0
   \      0x1A2   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   2880                    }
   2881                    tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \                     ??sbcSemTimCallBack_22: (+1)
   \      0x1A6   0x.... 0x....      BL       getPacketStatusNum
   \      0x1AA   0xF10D 0x0116      ADD      R1,SP,#+22
   \      0x1AE   0x6008             STR      R0,[R1, #+0]
   2882                    configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \      0x1B0   0x.... 0x....      BL       getSbcSemQueueHandle
   \      0x1B4   0x2300             MOVS     R3,#+0
   \      0x1B6   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x1BA   0xA902             ADD      R1,SP,#+8
   \      0x1BC   0x.... 0x....      BL       xQueueGenericSend
   \      0x1C0   0x2801             CMP      R0,#+1
   \      0x1C2   0xD009             BEQ.N    ??sbcSemTimCallBack_23
   \      0x1C4   0xB672             CPSID    I
   \      0x1C6   0x2050             MOVS     R0,#+80
   \      0x1C8   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x1CC   0xF3BF 0x8F4F      DSB      SY
   \      0x1D0   0xF3BF 0x8F6F      ISB      SY
   \      0x1D4   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_24: (+1)
   \      0x1D6   0xE7FE             B.N      ??sbcSemTimCallBack_24
   2883                    break;
   \                     ??sbcSemTimCallBack_23: (+1)
   \      0x1D8   0xE05D             B.N      ??sbcSemTimCallBack_16
   2884          
   2885                  case SBC_SEM_WAIT_TO_BE_OPERATIVE:
   2886                    /* the ack coming from expected socket */
   2887                    locScuMode = getScuOpMode();
   \                     ??sbcSemTimCallBack_9: (+1)
   \      0x1DA   0x.... 0x....      BL       getScuOpMode
   \      0x1DE   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   2888                    if ((locScuMode == SCU_S_P) || (locScuMode == SCU_S_S))
   \      0x1E2   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x1E6   0x2803             CMP      R0,#+3
   \      0x1E8   0xD003             BEQ.N    ??sbcSemTimCallBack_25
   \      0x1EA   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x1EE   0x2804             CMP      R0,#+4
   \      0x1F0   0xD117             BNE.N    ??sbcSemTimCallBack_26
   2889                    {
   2890                      /* after update it is necessary a slave must inform the master about new FW   */
   2891                      val = HAL_RTCEx_BKUPRead((RTC_HandleTypeDef*) getHandleRtc(), BACKUP_HW_INFO);
   \                     ??sbcSemTimCallBack_25: (+1)
   \      0x1F2   0x.... 0x....      BL       getHandleRtc
   \      0x1F6   0x2109             MOVS     R1,#+9
   \      0x1F8   0x.... 0x....      BL       HAL_RTCEx_BKUPRead
   \      0x1FC   0x0005             MOVS     R5,R0
   2892                      if ((val & NOTIFY_FW_UPD_MASK) == NOTIFY_FW_UPD_FLAG)
   \      0x1FE   0xF415 0x1040      ANDS     R0,R5,#0x300000
   \      0x202   0xF5B0 0x1F80      CMP      R0,#+1048576
   \      0x206   0xD10C             BNE.N    ??sbcSemTimCallBack_26
   2893                      {
   2894                        /* reset the flag */
   2895                        val &= (~NOTIFY_FW_UPD_MASK);
   \      0x208   0xF435 0x1540      BICS     R5,R5,#0x300000
   2896                        HAL_RTCEx_BKUPWrite((RTC_HandleTypeDef*)getHandleRtc(), (uint32_t)BACKUP_HW_INFO, val);       
   \      0x20C   0x.... 0x....      BL       getHandleRtc
   \      0x210   0x002A             MOVS     R2,R5
   \      0x212   0x2109             MOVS     R1,#+9
   \      0x214   0x.... 0x....      BL       HAL_RTCEx_BKUPWrite
   2897                        /* send the info on communication error   */
   2898                        sendEventToSemMng(NOTIFY_TO_MASTER_TX, ADDR_EVSE_ERROR2_RO);
   \      0x218   0xF240 0x4105      MOVW     R1,#+1029
   \      0x21C   0x2002             MOVS     R0,#+2
   \      0x21E   0x.... 0x....      BL       sendEventToSemMng
   2899                      }
   2900                    }
   2901                    break;
   \                     ??sbcSemTimCallBack_26: (+1)
   \      0x222   0xE038             B.N      ??sbcSemTimCallBack_16
   2902          
   2903                  case SBC_SEM_OPERATIVE:
   2904                    sbcSemInfoMng.addrVal = ADDR_START_RDD;  // to get info on  discovered primary/secondary slave an master SCU 
   \                     ??sbcSemTimCallBack_8: (+1)
   \      0x224   0xF44F 0x7040      MOV      R0,#+768
   \      0x228   0x80F8             STRH     R0,[R7, #+6]
   2905                    tmpFrameSbcSem.sbcSemEvent = RECOVERY_INFO;
   \      0x22A   0x2104             MOVS     R1,#+4
   \      0x22C   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   2906                    tmpFrameSbcSem.data.rAddr = sbcSemInfoMng.addrVal = ADDR_START_RDD;
   \      0x230   0x80F8             STRH     R0,[R7, #+6]
   \      0x232   0x88F8             LDRH     R0,[R7, #+6]
   \      0x234   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   2907                    /* set initial socket info */
   2908                    if (getScuOpMode() == SCU_M_P)
   \      0x238   0x.... 0x....      BL       getScuOpMode
   \      0x23C   0x2802             CMP      R0,#+2
   \      0x23E   0xD108             BNE.N    ??sbcSemTimCallBack_27
   2909                    {
   2910                      /* set initial socket info */
   2911                      sbcSemInfoMng.discoveryMask = (uint32_t)0x2;
   \      0x240   0x2002             MOVS     R0,#+2
   \      0x242   0xF8C7 0x000A      STR      R0,[R7, #+10]
   2912                      sbcSemInfoMng.logicIdSocket = (uint16_t)0x1;
   \      0x246   0x2001             MOVS     R0,#+1
   \      0x248   0x8138             STRH     R0,[R7, #+8]
   2913                      tmpFrameSbcSem.data.index = (uint16_t)0x1;
   \      0x24A   0x2001             MOVS     R0,#+1
   \      0x24C   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   \      0x250   0xE007             B.N      ??sbcSemTimCallBack_28
   2914                    }
   2915                    else
   2916                    {
   2917                      /* SCU_M_STAND_ALONE case */
   2918                      sbcSemInfoMng.discoveryMask = (uint32_t)0x1;
   \                     ??sbcSemTimCallBack_27: (+1)
   \      0x252   0x2001             MOVS     R0,#+1
   \      0x254   0xF8C7 0x000A      STR      R0,[R7, #+10]
   2919                      sbcSemInfoMng.logicIdSocket = (uint16_t)0x0;
   \      0x258   0x2000             MOVS     R0,#+0
   \      0x25A   0x8138             STRH     R0,[R7, #+8]
   2920                      tmpFrameSbcSem.data.index = (uint16_t)0x0;
   \      0x25C   0x2000             MOVS     R0,#+0
   \      0x25E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   2921                    }
   2922                    tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \                     ??sbcSemTimCallBack_28: (+1)
   \      0x262   0x.... 0x....      BL       getPacketStatusNum
   \      0x266   0xF10D 0x0116      ADD      R1,SP,#+22
   \      0x26A   0x6008             STR      R0,[R1, #+0]
   2923                    configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \      0x26C   0x.... 0x....      BL       getSbcSemQueueHandle
   \      0x270   0x2300             MOVS     R3,#+0
   \      0x272   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x276   0xA902             ADD      R1,SP,#+8
   \      0x278   0x.... 0x....      BL       xQueueGenericSend
   \      0x27C   0x2801             CMP      R0,#+1
   \      0x27E   0xD009             BEQ.N    ??sbcSemTimCallBack_29
   \      0x280   0xB672             CPSID    I
   \      0x282   0x2050             MOVS     R0,#+80
   \      0x284   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x288   0xF3BF 0x8F4F      DSB      SY
   \      0x28C   0xF3BF 0x8F6F      ISB      SY
   \      0x290   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_30: (+1)
   \      0x292   0xE7FE             B.N      ??sbcSemTimCallBack_30
   2924                    break;
   \                     ??sbcSemTimCallBack_29: (+1)
   \      0x294   0xE7FF             B.N      ??sbcSemTimCallBack_16
   2925          
   2926                  default:
   2927                    break;
   2928                }
   2929                break;
   \                     ??sbcSemTimCallBack_10: (+1)
   \                     ??sbcSemTimCallBack_16: (+1)
   \      0x296   0xE114             B.N      ??sbcSemTimCallBack_31
   2930          
   2931              case TIMER_FOR_ACK:
   2932                switch (sbcSemInfoMng.sbcSemStates)  
   \                     ??sbcSemTimCallBack_2: (+1)
   \      0x298   0x.... 0x....      LDR.W    R7,??DataTable16_9
   \      0x29C   0x8838             LDRH     R0,[R7, #+0]
   \      0x29E   0x2800             CMP      R0,#+0
   \      0x2A0   0xD008             BEQ.N    ??sbcSemTimCallBack_32
   \      0x2A2   0x2804             CMP      R0,#+4
   \      0x2A4   0xD074             BEQ.N    ??sbcSemTimCallBack_33
   \      0x2A6   0x2806             CMP      R0,#+6
   \      0x2A8   0xD073             BEQ.N    ??sbcSemTimCallBack_34
   \      0x2AA   0x2807             CMP      R0,#+7
   \      0x2AC   0xD071             BEQ.N    ??sbcSemTimCallBack_34
   \      0x2AE   0x2809             CMP      R0,#+9
   \      0x2B0   0xD032             BEQ.N    ??sbcSemTimCallBack_35
   \      0x2B2   0xE08F             B.N      ??sbcSemTimCallBack_36
   2933                {
   2934                  case SBC_SEM_INIT_DISCOVERY:
   2935                    /* release the transmitter */
   2936                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \                     ??sbcSemTimCallBack_32: (+1)
   \      0x2B4   0x2005             MOVS     R0,#+5
   \      0x2B6   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   2937                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x2BA   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x2BE   0x2300             MOVS     R3,#+0
   \      0x2C0   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x2C4   0xA902             ADD      R1,SP,#+8
   \      0x2C6   0x.... 0x....      BL       xQueueGenericSend
   \      0x2CA   0x2801             CMP      R0,#+1
   \      0x2CC   0xD009             BEQ.N    ??sbcSemTimCallBack_37
   \      0x2CE   0xB672             CPSID    I
   \      0x2D0   0x2050             MOVS     R0,#+80
   \      0x2D2   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x2D6   0xF3BF 0x8F4F      DSB      SY
   \      0x2DA   0xF3BF 0x8F6F      ISB      SY
   \      0x2DE   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_38: (+1)
   \      0x2E0   0xE7FE             B.N      ??sbcSemTimCallBack_38
   2938                    /* the previous message hasn't received ACK: possible conflit on firstr Tx byte? Retry */
   2939                    osDelay(getRandomDelay());  /* delay in the range 2...50 msec */
   \                     ??sbcSemTimCallBack_37: (+1)
   \      0x2E2   0x.... 0x....      BL       getRandomDelay
   \      0x2E6   0xB2C0             UXTB     R0,R0
   \      0x2E8   0x.... 0x....      BL       osDelay
   2940                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&currFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x2EC   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x2F0   0x2300             MOVS     R3,#+0
   \      0x2F2   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x2F6   0x.... 0x....      LDR.W    R1,??DataTable24
   \      0x2FA   0x.... 0x....      BL       xQueueGenericSend
   \      0x2FE   0x2801             CMP      R0,#+1
   \      0x300   0xD009             BEQ.N    ??sbcSemTimCallBack_39
   \      0x302   0xB672             CPSID    I
   \      0x304   0x2050             MOVS     R0,#+80
   \      0x306   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x30A   0xF3BF 0x8F4F      DSB      SY
   \      0x30E   0xF3BF 0x8F6F      ISB      SY
   \      0x312   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_40: (+1)
   \      0x314   0xE7FE             B.N      ??sbcSemTimCallBack_40
   2941                    break;
   \                     ??sbcSemTimCallBack_39: (+1)
   \      0x316   0xE05D             B.N      ??sbcSemTimCallBack_41
   2942          
   2943                  case SBC_SEM_WAIT_TO_REGISTER:
   2944                    if (sbcSemInfoMng.firstIdFree > (uint16_t)SCU_M_P_ADDR)
   \                     ??sbcSemTimCallBack_35: (+1)
   \      0x318   0x8878             LDRH     R0,[R7, #+2]
   \      0x31A   0x2802             CMP      R0,#+2
   \      0x31C   0xDB37             BLT.N    ??sbcSemTimCallBack_42
   2945                    {
   2946                      locScuMode = getScuOpMode();
   \      0x31E   0x.... 0x....      BL       getScuOpMode
   \      0x322   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   2947                      if (getScuOpMode() == SCU_S_S)
   \      0x326   0x.... 0x....      BL       getScuOpMode
   \      0x32A   0x2804             CMP      R0,#+4
   \      0x32C   0xD10C             BNE.N    ??sbcSemTimCallBack_43
   2948                      {
   2949                        if (socketPresence.keyPresence == KEY_FULL_MASTER_P)
   \      0x32E   0x.... 0x....      LDR.W    R0,??DataTable22
   \      0x332   0x6881             LDR      R1,[R0, #+8]
   \      0x334   0x2988             CMP      R1,#+136
   \      0x336   0xD103             BNE.N    ??sbcSemTimCallBack_44
   2950                        {
   2951                          /* the edge address coming from Broadcast procedure SCU MASTER */
   2952                          socketPresence.keyPresence = KEY_FULL_MASTER_P_S;
   \      0x338   0xF64D 0x5188      MOVW     R1,#+56712
   \      0x33C   0x6081             STR      R1,[R0, #+8]
   \      0x33E   0xE008             B.N      ??sbcSemTimCallBack_45
   2953                        }
   2954                        else
   2955                        {
   2956                          /* the edge address coming from linked secondary master  */
   2957                          socketPresence.keyPresence = KEY_FULL_MASTER_S;
   \                     ??sbcSemTimCallBack_44: (+1)
   \      0x340   0xF44F 0x415D      MOV      R1,#+56576
   \      0x344   0x6081             STR      R1,[R0, #+8]
   \      0x346   0xE004             B.N      ??sbcSemTimCallBack_45
   2958                        }
   2959                      }
   2960                      else
   2961                      {
   2962                        socketPresence.keyPresence = KEY_FULL_CONFIG;
   \                     ??sbcSemTimCallBack_43: (+1)
   \      0x348   0xF64A 0x2055      MOVW     R0,#+43605
   \      0x34C   0x.... 0x....      LDR.W    R1,??DataTable22
   \      0x350   0x6088             STR      R0,[R1, #+8]
   2963                      }
   2964                      result = (uint8_t)sbcSemInfoMng.firstIdFree; sbcSemInfoMng.firstIdFree = 0; 
   \                     ??sbcSemTimCallBack_45: (+1)
   \      0x352   0x8878             LDRH     R0,[R7, #+2]
   \      0x354   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \      0x358   0x2000             MOVS     R0,#+0
   \      0x35A   0x8078             STRH     R0,[R7, #+2]
   2965                      if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \      0x35C   0x2254             MOVS     R2,#+84
   \      0x35E   0x.... 0x....      LDR.W    R1,??DataTable22
   \      0x362   0xF44F 0x50F4      MOV      R0,#+7808
   \      0x366   0x.... 0x....      BL       WriteOnEeprom
   \      0x36A   0x2800             CMP      R0,#+0
   \      0x36C   0xD10F             BNE.N    ??sbcSemTimCallBack_42
   2966                      {
   2967                        tPrintf("Assigned address %d\n\r", result);
   \      0x36E   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \      0x372   0x.... 0x....      LDR.W    R0,??DataTable27
   \      0x376   0x.... 0x....      BL       tPrintf
   2968                        /* a new address must be set */
   2969                        eeprom_array_set(RS485_ADD_EADD, (uint8_t*)&result, 1);
   \      0x37A   0x2201             MOVS     R2,#+1
   \      0x37C   0xA901             ADD      R1,SP,#+4
   \      0x37E   0x2009             MOVS     R0,#+9
   \      0x380   0x.... 0x....      BL       eeprom_array_set
   2970                        /* Send event to update eeprom */
   2971                        send_to_eeprom(EEPROM_UPDATE); 
   \      0x384   0x2002             MOVS     R0,#+2
   \      0x386   0x.... 0x....      BL       send_to_eeprom
   2972          
   2973                        /* restart with new RS485 address */
   2974                        activeImmediateReset();
   \      0x38A   0x.... 0x....      BL       activeImmediateReset
   2975                      }
   2976                    }
   2977                    break;
   \                     ??sbcSemTimCallBack_42: (+1)
   \      0x38E   0xE021             B.N      ??sbcSemTimCallBack_41
   2978          
   2979                  case SBC_SEM_OPERATIVE:
   2980                    break;
   \                     ??sbcSemTimCallBack_33: (+1)
   \      0x390   0xE020             B.N      ??sbcSemTimCallBack_41
   2981          
   2982                  case SBC_SEM_WAIT_WR_MASTER_ACK:
   2983                  case SBC_SEM_WAIT_WR_MASTER_POLL_ACK: 
   2984                    sbcSemInfoMng.offLine = TRUE;
   \                     ??sbcSemTimCallBack_34: (+1)
   \      0x392   0x2001             MOVS     R0,#+1
   \      0x394   0xF887 0x0027      STRB     R0,[R7, #+39]
   2985                    tPrintf("Master unavailable!\n\r");
   \      0x398   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \      0x39C   0x.... 0x....      BL       tPrintf
   2986                    /* communication problem with master */
   2987                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0x3A0   0x2005             MOVS     R0,#+5
   \      0x3A2   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   2988                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x3A6   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x3AA   0x2300             MOVS     R3,#+0
   \      0x3AC   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x3B0   0xA902             ADD      R1,SP,#+8
   \      0x3B2   0x.... 0x....      BL       xQueueGenericSend
   \      0x3B6   0x2801             CMP      R0,#+1
   \      0x3B8   0xD009             BEQ.N    ??sbcSemTimCallBack_46
   \      0x3BA   0xB672             CPSID    I
   \      0x3BC   0x2050             MOVS     R0,#+80
   \      0x3BE   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x3C2   0xF3BF 0x8F4F      DSB      SY
   \      0x3C6   0xF3BF 0x8F6F      ISB      SY
   \      0x3CA   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_47: (+1)
   \      0x3CC   0xE7FE             B.N      ??sbcSemTimCallBack_47
   2989                    sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \                     ??sbcSemTimCallBack_46: (+1)
   \      0x3CE   0x2004             MOVS     R0,#+4
   \      0x3D0   0x8038             STRH     R0,[R7, #+0]
   2990                    break;
   \      0x3D2   0xE7FF             B.N      ??sbcSemTimCallBack_41
   2991          
   2992                  default:
   2993                    break;
   2994                }
   2995                break;
   \                     ??sbcSemTimCallBack_36: (+1)
   \                     ??sbcSemTimCallBack_41: (+1)
   \      0x3D4   0xE075             B.N      ??sbcSemTimCallBack_31
   2996          
   2997              case TIMER_FOR_TICK_RTC:
   2998                setCurrentDateTimeInSem();
   \                     ??sbcSemTimCallBack_1: (+1)
   \      0x3D6   0x.... 0x....      BL       setCurrentDateTimeInSem
   2999                break;
   \      0x3DA   0xE072             B.N      ??sbcSemTimCallBack_31
   3000          
   3001              case TIMER_FOR_ACK_POLLING:
   3002                switch (sbcSemInfoMng.sbcSemStates)
   \                     ??sbcSemTimCallBack_4: (+1)
   \      0x3DC   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \      0x3E0   0x8800             LDRH     R0,[R0, #+0]
   \      0x3E2   0x2804             CMP      R0,#+4
   \      0x3E4   0xD117             BNE.N    ??sbcSemTimCallBack_48
   3003                {
   3004                  case SBC_SEM_OPERATIVE:
   3005                    /* release the transmitter */
   3006                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_MODBUS_ACK;
   \      0x3E6   0x2005             MOVS     R0,#+5
   \      0x3E8   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   3007                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x3EC   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x3F0   0x2300             MOVS     R3,#+0
   \      0x3F2   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x3F6   0xA902             ADD      R1,SP,#+8
   \      0x3F8   0x.... 0x....      BL       xQueueGenericSend
   \      0x3FC   0x2801             CMP      R0,#+1
   \      0x3FE   0xD009             BEQ.N    ??sbcSemTimCallBack_49
   \      0x400   0xB672             CPSID    I
   \      0x402   0x2050             MOVS     R0,#+80
   \      0x404   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x408   0xF3BF 0x8F4F      DSB      SY
   \      0x40C   0xF3BF 0x8F6F      ISB      SY
   \      0x410   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_50: (+1)
   \      0x412   0xE7FE             B.N      ??sbcSemTimCallBack_50
   3008                    break;
   \                     ??sbcSemTimCallBack_49: (+1)
   \      0x414   0xE7FF             B.N      ??sbcSemTimCallBack_51
   3009          
   3010                  default:
   3011                    break;
   3012                }
   3013                break;
   \                     ??sbcSemTimCallBack_48: (+1)
   \                     ??sbcSemTimCallBack_51: (+1)
   \      0x416   0xE054             B.N      ??sbcSemTimCallBack_31
   3014          
   3015              case TIMER_FOR_REQ_ADDR:
   3016                switch (sbcSemInfoMng.sbcSemStates)
   \                     ??sbcSemTimCallBack_3: (+1)
   \      0x418   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \      0x41C   0x8801             LDRH     R1,[R0, #+0]
   \      0x41E   0x2904             CMP      R1,#+4
   \      0x420   0xD03F             BEQ.N    ??sbcSemTimCallBack_52
   \      0x422   0x2909             CMP      R1,#+9
   \      0x424   0xD14C             BNE.N    ??sbcSemTimCallBack_53
   3017                {
   3018                  case SBC_SEM_WAIT_TO_REGISTER:
   3019                    /* a  slve SCU is present in the chain and requires an address */
   3020                    sbcSemInfoMng.dataVal = (uint16_t)sbcSemInfoMng.random;                 // copy in the tag Id the product SN crc 100....
   \                     ??sbcSemTimCallBack_54: (+1)
   \      0x426   0x69C1             LDR      R1,[R0, #+28]
   \      0x428   0x8081             STRH     R1,[R0, #+4]
   3021                    pScuTmMapReg->tmAddrReq = sbcSemInfoMng.dataVal;                         
   \      0x42A   0x.... 0x....      LDR.W    R7,??DataTable31
   \      0x42E   0x8880             LDRH     R0,[R0, #+4]
   \      0x430   0x6839             LDR      R1,[R7, #+0]
   \      0x432   0x8108             STRH     R0,[R1, #+8]
   3022                    pScuTmMapReg->tmAddrAss = (uint16_t)getPhysicalMdbAddr();               // just for debug put the current address
   \      0x434   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0x438   0xB2C0             UXTB     R0,R0
   \      0x43A   0x6839             LDR      R1,[R7, #+0]
   \      0x43C   0x8148             STRH     R0,[R1, #+10]
   3023                    tmpFrameSbcSem.dataToSend.len = (uint16_t)6;                            /* we send 3 word = 6 bytes starting from ADDR_ADDR_S_CONN_RW */
   \      0x43E   0x2006             MOVS     R0,#+6
   \      0x440   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   3024                    tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_MASTER_TX;
   \      0x444   0x2002             MOVS     R0,#+2
   \      0x446   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   3025                    tmpFrameSbcSem.data.index = getPhysicalMdbAddr();                         /* just for debug  rs485SemMsgProcess() */
   \      0x44A   0x.... 0x....      BL       getPhysicalMdbAddr
   \      0x44E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   3026                    tmpFrameSbcSem.data.rAddr = ADDR_ADDR_S_CONN_RW;
   \      0x452   0xF240 0x5013      MOVW     R0,#+1299
   \      0x456   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   3027                    tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&pScuTmMapReg->tmAddrSconnM;
   \      0x45A   0x6838             LDR      R0,[R7, #+0]
   \      0x45C   0x1D80             ADDS     R0,R0,#+6
   \      0x45E   0x9004             STR      R0,[SP, #+16]
   3028                    configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x460   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x464   0x2300             MOVS     R3,#+0
   \      0x466   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x46A   0xA902             ADD      R1,SP,#+8
   \      0x46C   0x.... 0x....      BL       xQueueGenericSend
   \      0x470   0x2801             CMP      R0,#+1
   \      0x472   0xD009             BEQ.N    ??sbcSemTimCallBack_55
   \      0x474   0xB672             CPSID    I
   \      0x476   0x2050             MOVS     R0,#+80
   \      0x478   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x47C   0xF3BF 0x8F4F      DSB      SY
   \      0x480   0xF3BF 0x8F6F      ISB      SY
   \      0x484   0xB662             CPSIE    I
   \                     ??sbcSemTimCallBack_56: (+1)
   \      0x486   0xE7FE             B.N      ??sbcSemTimCallBack_56
   3029                    // start ACK timer 
   3030                    xTimerReset (xSbcSemTimers[TIMER_FOR_ACK], 0);
   \                     ??sbcSemTimCallBack_55: (+1)
   \      0x488   0x.... 0x....      BL       xTaskGetTickCount
   \      0x48C   0x0002             MOVS     R2,R0
   \      0x48E   0x2000             MOVS     R0,#+0
   \      0x490   0x9000             STR      R0,[SP, #+0]
   \      0x492   0x2300             MOVS     R3,#+0
   \      0x494   0x2102             MOVS     R1,#+2
   \      0x496   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \      0x49A   0x6840             LDR      R0,[R0, #+4]
   \      0x49C   0x.... 0x....      BL       xTimerGenericCommand
   3031                    break;
   \      0x4A0   0xE00E             B.N      ??sbcSemTimCallBack_57
   3032          
   3033                  case SBC_SEM_OPERATIVE:
   3034                    /* the slave must send eeprom_array info to the master for updating configuration */
   3035                    val = (uint32_t)getLogicalMdbAddrSem();
   \                     ??sbcSemTimCallBack_52: (+1)
   \      0x4A2   0x.... 0x....      BL       getLogicalMdbAddrSem
   \      0x4A6   0x0005             MOVS     R5,R0
   3036                    if (getAndsendAllSlaveParameters((uint8_t)val) == 0)  // 0 means NO_ERROR
   \      0x4A8   0x0028             MOVS     R0,R5
   \      0x4AA   0xB2C0             UXTB     R0,R0
   \      0x4AC   0x.... 0x....      BL       getAndsendAllSlaveParameters
   \      0x4B0   0x2800             CMP      R0,#+0
   \      0x4B2   0xD104             BNE.N    ??sbcSemTimCallBack_58
   3037                    {
   3038                      tPrintf("Sent upgrade eeprom info slave %02d!!\n\r", val + 1);
   \      0x4B4   0x1C69             ADDS     R1,R5,#+1
   \      0x4B6   0x.... 0x....      LDR.W    R0,??DataTable31_2
   \      0x4BA   0x.... 0x....      BL       tPrintf
   3039                    }
   3040                    break;
   \                     ??sbcSemTimCallBack_58: (+1)
   \      0x4BE   0xE7FF             B.N      ??sbcSemTimCallBack_57
   3041          
   3042                  default:
   3043                    break;
   3044                }
   3045                break;
   \                     ??sbcSemTimCallBack_53: (+1)
   \                     ??sbcSemTimCallBack_57: (+1)
   \      0x4C0   0xE7FF             B.N      ??sbcSemTimCallBack_31
   3046          
   3047              default:
   3048                break;
   3049            }
   3050          }
   \                     ??sbcSemTimCallBack_5: (+1)
   \                     ??sbcSemTimCallBack_31: (+1)
   \      0x4C2   0xB007             ADD      SP,SP,#+28
   \      0x4C4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3051          
   3052          /**
   3053          *
   3054          * @brief        send a message in broadcast mode for firmware update   
   3055          *
   3056          * @param [in]   none
   3057          *
   3058          * @retval       none
   3059          *
   3060          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3061          void upgradeFwSlaveBroadcast(uint8_t ixScu)
   3062          {
   \                     upgradeFwSlaveBroadcast: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   3063            scuRwMapRegister_st*    pRwRegs;
   3064            frameSbcSem_st          tmpFrameSbcSem;  
   3065          
   3066            pRwRegs = getRwMdbRegs(SCU_M_P_ADDR_LOG);
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x.... 0x....      BL       getRwMdbRegs
   \        0xC   0x0005             MOVS     R5,R0
   3067            tmpFrameSbcSem.sbcSemEvent = SBC_SEM_EVENT_UART5_SEND_DWLD_CMD;
   \        0xE   0x200D             MOVS     R0,#+13
   \       0x10   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   3068            tmpFrameSbcSem.data.index = (uint16_t)ixScu;                                // physical address 1...31 or broadcast 0
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   3069            tmpFrameSbcSem.data.rAddr = ADDR_FILE_COMMAND_RW; // 
   \       0x1C   0xF44F 0x7080      MOV      R0,#+256
   \       0x20   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   3070            tmpFrameSbcSem.dataToSend.len = LEN_FILE_COMMAND_RW + LEN_FILE_SIZE_RW;           // lenght in word of data to be transmitted over RS485
   \       0x24   0x2003             MOVS     R0,#+3
   \       0x26   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   3071            tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&pRwRegs->scuSetRegFwUpd.fileCommand; // data origin
   \       0x2A   0xF515 0x7080      ADDS     R0,R5,#+256
   \       0x2E   0x9002             STR      R0,[SP, #+8]
   3072            tmpFrameSbcSem.timeEntry = getPacketStatusNum();
   \       0x30   0x.... 0x....      BL       getPacketStatusNum
   \       0x34   0xF10D 0x010E      ADD      R1,SP,#+14
   \       0x38   0x6008             STR      R0,[R1, #+0]
   3073             
   3074            configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \       0x3A   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x3E   0x2300             MOVS     R3,#+0
   \       0x40   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0x.... 0x....      BL       xQueueGenericSend
   \       0x4A   0x2801             CMP      R0,#+1
   \       0x4C   0xD009             BEQ.N    ??upgradeFwSlaveBroadcast_0
   \       0x4E   0xB672             CPSID    I
   \       0x50   0x2050             MOVS     R0,#+80
   \       0x52   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x56   0xF3BF 0x8F4F      DSB      SY
   \       0x5A   0xF3BF 0x8F6F      ISB      SY
   \       0x5E   0xB662             CPSIE    I
   \                     ??upgradeFwSlaveBroadcast_1: (+1)
   \       0x60   0xE7FE             B.N      ??upgradeFwSlaveBroadcast_1
   3075          }
   \                     ??upgradeFwSlaveBroadcast_0: (+1)
   \       0x62   0xB005             ADD      SP,SP,#+20
   \       0x64   0xBD30             POP      {R4,R5,PC}
   3076          
   3077          /**
   3078          *
   3079          * @brief        Creating a node for sem message     
   3080          *
   3081          * @param [in]   node
   3082          *
   3083          * @retval       none
   3084          *
   3085          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3086          nodeMsg createNode()
   3087          {
   \                     createNode: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3088              nodeMsg temp; // declare a node
   3089          
   3090              temp = (nodeMsg)malloc(sizeof(struct semMsgList));  // allocate memory using malloc()
   \        0x2   0x2018             MOVS     R0,#+24
   \        0x4   0x.... 0x....      BL       malloc
   3091              temp->next = NULL;                                  // make next point to NULL
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6141             STR      R1,[R0, #+20]
   3092              return temp;                                        //return the new node
   \        0xC   0xBD02             POP      {R1,PC}
   3093          }
   3094          
   3095          /**
   3096          *
   3097          * @brief        Adding a message on node 
   3098          *
   3099          * @param [in]   node
   3100          *
   3101          * @retval       none
   3102          *
   3103          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3104          static nodeMsg addNode(nodeMsg head, frameSbcSem_st *pMessage)
   3105          {
   \                     addNode: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   3106              nodeMsg temp,p;           // declare three nodes temp, p
   3107          
   3108              temp = createNode();      //createNode will return a new node with data = value and next pointing to NULL.
   \        0x8   0x.... 0x....      BL       createNode
   \        0xC   0x0006             MOVS     R6,R0
   3109              /* add element's value to data part of node */
   3110              /*      destination               source           length */
   3111              memcpy((void*)&temp->inMsg, (void*)pMessage, (size_t)sizeof(frameSbcSem_st));
   \        0xE   0xF05F 0x0812      MOVS     R8,#+18
   \       0x12   0x46A9             MOV      R9,R5
   \       0x14   0x46B2             MOV      R10,R6
   \       0x16   0x4642             MOV      R2,R8
   \       0x18   0x4649             MOV      R1,R9
   \       0x1A   0x4650             MOV      R0,R10
   \       0x1C   0x.... 0x....      BL       __aeabi_memcpy
   3112          
   3113              if(head == NULL)
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD101             BNE.N    ??addNode_0
   3114              {
   3115                head = temp;            //when linked list is empty
   \       0x24   0x0034             MOVS     R4,R6
   \       0x26   0xE006             B.N      ??addNode_1
   3116              }
   3117              else
   3118              {
   3119                p = head;              //assign head to p and pFirst 
   \                     ??addNode_0: (+1)
   \       0x28   0x0027             MOVS     R7,R4
   3120                while(p->next != NULL)
   \                     ??addNode_2: (+1)
   \       0x2A   0x6978             LDR      R0,[R7, #+20]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD001             BEQ.N    ??addNode_3
   3121                {
   3122                  p = p->next;          //traverse the list until p is the last node.The last node always points to NULL.
   \       0x30   0x697F             LDR      R7,[R7, #+20]
   \       0x32   0xE7FA             B.N      ??addNode_2
   3123                }
   3124                p->next = temp;
   \                     ??addNode_3: (+1)
   \       0x34   0x617E             STR      R6,[R7, #+20]
   3125              }
   3126              return head;
   \                     ??addNode_1: (+1)
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0xE8BD 0x87F0      POP      {R4-R10,PC}
   3127          }
   3128          
   3129          /**
   3130          *
   3131          * @brief        Sent the first message waiting in the list 
   3132          *
   3133          * @param [in]   nodeMsg: head of the list 
   3134          *
   3135          * @retval       none
   3136          *
   3137          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3138          static nodeMsg extractSendFirstInList(nodeMsg head)
   3139          {
   \                     extractSendFirstInList: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x0006             MOVS     R6,R0
   3140              frameSbcSem_st        locFrameSbcSem;
   3141              nodeMsg               p, pPrev, pMin, pMinPrev;
   3142              uint32_t              minId;
   3143          
   3144              p = pMinPrev = pMin = head;              //assign head to p and pFirst 
   \        0x8   0x0034             MOVS     R4,R6
   \        0xA   0x46A0             MOV      R8,R4
   \        0xC   0x46A1             MOV      R9,R4
   3145              minId = p->inMsg.timeEntry;
   \        0xE   0xF8D4 0x500E      LDR      R5,[R4, #+14]
   3146              while(p != NULL)
   \                     ??extractSendFirstInList_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD00B             BEQ.N    ??extractSendFirstInList_1
   3147              {
   3148                if (p->inMsg.timeEntry < minId)
   \       0x16   0xF8D4 0x000E      LDR      R0,[R4, #+14]
   \       0x1A   0x42A8             CMP      R0,R5
   \       0x1C   0xD204             BCS.N    ??extractSendFirstInList_2
   3149                {
   3150                  minId = p->inMsg.timeEntry;
   \       0x1E   0xF8D4 0x000E      LDR      R0,[R4, #+14]
   \       0x22   0x0005             MOVS     R5,R0
   3151                  pMin = p;
   \       0x24   0x46A0             MOV      R8,R4
   3152                  pMinPrev = pPrev;
   \       0x26   0x46B9             MOV      R9,R7
   3153                }                     // find the oldest packet --> first to be processed 
   3154                pPrev = p;
   \                     ??extractSendFirstInList_2: (+1)
   \       0x28   0x0027             MOVS     R7,R4
   3155                p = p->next;          //traverse the list until p is the last node.The last node always points to NULL.
   \       0x2A   0x6964             LDR      R4,[R4, #+20]
   \       0x2C   0xE7F1             B.N      ??extractSendFirstInList_0
   3156              }
   3157              pMinPrev->next = pMin->next;  // extract the item and link the previous to the next 
   \                     ??extractSendFirstInList_1: (+1)
   \       0x2E   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x32   0xF8C9 0x0014      STR      R0,[R9, #+20]
   3158          
   3159              /*      destination               source           length */
   3160              memcpy((void*)&locFrameSbcSem, (void*)pMin, (size_t)sizeof(frameSbcSem_st));
   \       0x36   0xF05F 0x0A12      MOVS     R10,#+18
   \       0x3A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x3E   0xF10D 0x0B04      ADD      R11,SP,#+4
   \       0x42   0x4652             MOV      R2,R10
   \       0x44   0x9900             LDR      R1,[SP, #+0]
   \       0x46   0x4658             MOV      R0,R11
   \       0x48   0x.... 0x....      BL       __aeabi_memcpy
   3161              free(pMin);               // free previous allocated area 
   \       0x4C   0x4640             MOV      R0,R8
   \       0x4E   0x.... 0x....      BL       free
   3162              configASSERT(xQueueSendToBack(getSbcSemQueueHandle(), (void *)&locFrameSbcSem, portMAX_DELAY) == pdPASS);  // sbcSemMsgProcess()
   \       0x52   0x.... 0x....      BL       getSbcSemQueueHandle
   \       0x56   0x2300             MOVS     R3,#+0
   \       0x58   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x5C   0xA901             ADD      R1,SP,#+4
   \       0x5E   0x.... 0x....      BL       xQueueGenericSend
   \       0x62   0x2801             CMP      R0,#+1
   \       0x64   0xD009             BEQ.N    ??extractSendFirstInList_3
   \       0x66   0xB672             CPSID    I
   \       0x68   0x2050             MOVS     R0,#+80
   \       0x6A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x6E   0xF3BF 0x8F4F      DSB      SY
   \       0x72   0xF3BF 0x8F6F      ISB      SY
   \       0x76   0xB662             CPSIE    I
   \                     ??extractSendFirstInList_4: (+1)
   \       0x78   0xE7FE             B.N      ??extractSendFirstInList_4
   3163              if (pMin != head)
   \                     ??extractSendFirstInList_3: (+1)
   \       0x7A   0x45B0             CMP      R8,R6
   \       0x7C   0xD001             BEQ.N    ??extractSendFirstInList_5
   3164              {
   3165                return(head);
   \       0x7E   0x0030             MOVS     R0,R6
   \       0x80   0xE001             B.N      ??extractSendFirstInList_6
   3166              }
   3167              else
   3168              {
   3169                return(pMin->next);
   \                     ??extractSendFirstInList_5: (+1)
   \       0x82   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \                     ??extractSendFirstInList_6: (+1)
   \       0x86   0xB007             ADD      SP,SP,#+28
   \       0x88   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3170              }
   3171          }
   3172          
   3173          
   3174          /**
   3175          *
   3176          * @brief        Set the load balancing by SEM  
   3177          *
   3178          * @param [in]   none 
   3179          *
   3180          * @retval       none
   3181          *
   3182          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3183          void setNewMaxTempPowerSem(void)
   3184          {
   \                     setNewMaxTempPowerSem: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   3185            uint32_t temp32;
   3186          
   3187            temp32 = getMaxTempPowerAc();
   \        0x2   0x.... 0x....      BL       getMaxTempPowerAc
   \        0x6   0x0004             MOVS     R4,R0
   3188            pmng_sem_power_set((uint16_t)temp32, 1);
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x.... 0x....      BL       pmng_sem_power_set
   3189          }
   \       0x12   0xBD10             POP      {R4,PC}
   3190          
   3191          /**
   3192          *
   3193          * @brief        Set the current date and time in  SEM  
   3194          *
   3195          * @param [in]   none 
   3196          *
   3197          * @retval       none
   3198          *
   3199          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3200          void setCurrentDateTimeInSem(void)
   3201          {
   \                     setCurrentDateTimeInSem: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   3202            time_t                currUT;
   3203            scuRwMapRegister_st*  pRwRegs;
   3204            uint8_t               mdbAddr;
   3205            uint8_t               timezone;
   3206            uint8_t               dst;
   3207            struct tm             *pTimeinfo;
   3208          
   3209            //setUtcDateTimeRegister();
   3210          
   3211            currUT = getCurrentUnixTime();
   \        0x2   0x.... 0x....      BL       getCurrentUnixTime
   \        0x6   0xE9CD 0x0102      STRD     R0,R1,[SP, #+8]
   3212          
   3213            /* update globat date and time structure  **/
   3214            pTimeinfo = localtime (&currUT);
   \        0xA   0xA802             ADD      R0,SP,#+8
   \        0xC   0x.... 0x....      BL       localtime
   \       0x10   0x0006             MOVS     R6,R0
   3215          
   3216          
   3217          
   3218            mdbAddr = getLogicalMdbAddrSem();
   \       0x12   0x.... 0x....      BL       getLogicalMdbAddrSem
   \       0x16   0x0005             MOVS     R5,R0
   3219            pRwRegs = getRwMdbRegs(mdbAddr);
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x.... 0x....      BL       getRwMdbRegs
   \       0x20   0x0004             MOVS     R4,R0
   3220            
   3221            /* Get timezone saved in eeprom */
   3222            eeprom_param_get(TIME_ZONE_EADD, (uint8_t*)&timezone, 1);
   \       0x22   0x2201             MOVS     R2,#+1
   \       0x24   0xF10D 0x0105      ADD      R1,SP,#+5
   \       0x28   0x2030             MOVS     R0,#+48
   \       0x2A   0x.... 0x....      BL       eeprom_param_get
   3223              
   3224            /* Get dst flag saved in eeprom */
   3225            eeprom_param_get(DST_EADD, (uint8_t*)&dst, 1);
   \       0x2E   0x2201             MOVS     R2,#+1
   \       0x30   0xA901             ADD      R1,SP,#+4
   \       0x32   0x2031             MOVS     R0,#+49
   \       0x34   0x.... 0x....      BL       eeprom_param_get
   3226            
   3227            pRwRegs->scuSetRegister.rtcInf[0] = pTimeinfo->tm_sec;
   \       0x38   0x6830             LDR      R0,[R6, #+0]
   \       0x3A   0xF884 0x002C      STRB     R0,[R4, #+44]
   3228            pRwRegs->scuSetRegister.rtcInf[2] = pTimeinfo->tm_min;
   \       0x3E   0x6870             LDR      R0,[R6, #+4]
   \       0x40   0xF884 0x002E      STRB     R0,[R4, #+46]
   3229            pRwRegs->scuSetRegister.rtcInf[4] = pTimeinfo->tm_hour;
   \       0x44   0x68B0             LDR      R0,[R6, #+8]
   \       0x46   0xF884 0x0030      STRB     R0,[R4, #+48]
   3230            pRwRegs->scuSetRegister.rtcInf[6] = pTimeinfo->tm_mday;
   \       0x4A   0x68F0             LDR      R0,[R6, #+12]
   \       0x4C   0xF884 0x0032      STRB     R0,[R4, #+50]
   3231            pRwRegs->scuSetRegister.rtcInf[8] = pTimeinfo->tm_mon;
   \       0x50   0x6930             LDR      R0,[R6, #+16]
   \       0x52   0xF884 0x0034      STRB     R0,[R4, #+52]
   3232            pRwRegs->scuSetRegister.rtcInf[10] = ((pTimeinfo->tm_year) & 0xFF);        /* Fixed ticket SCU-113 */ 
   \       0x56   0x6970             LDR      R0,[R6, #+20]
   \       0x58   0xF884 0x0036      STRB     R0,[R4, #+54]
   3233            pRwRegs->scuSetRegister.rtcInf[11] = ((pTimeinfo->tm_year) & 0xFF00) >> 8; /* Fixed ticket SCU-113 */
   \       0x5C   0x6970             LDR      R0,[R6, #+20]
   \       0x5E   0x1200             ASRS     R0,R0,#+8
   \       0x60   0xF884 0x0037      STRB     R0,[R4, #+55]
   3234            pRwRegs->scuSetRegister.rtcInf[12] = pTimeinfo->tm_wday;
   \       0x64   0x69B0             LDR      R0,[R6, #+24]
   \       0x66   0xF884 0x0038      STRB     R0,[R4, #+56]
   3235            pRwRegs->scuSetRegister.rtcInf[13] = (pTimeinfo->tm_yday & 0xFF);          /* Fixed ticket SCU-113 */
   \       0x6A   0x69F0             LDR      R0,[R6, #+28]
   \       0x6C   0xF884 0x0039      STRB     R0,[R4, #+57]
   3236            pRwRegs->scuSetRegister.rtcInf[14] = (pTimeinfo->tm_yday & 0xFF00) >> 8;   /* Fixed ticket SCU-113 */
   \       0x70   0x69F0             LDR      R0,[R6, #+28]
   \       0x72   0x1200             ASRS     R0,R0,#+8
   \       0x74   0xF884 0x003A      STRB     R0,[R4, #+58]
   3237            pRwRegs->scuSetRegister.rtcInf[16] = dst;
   \       0x78   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x7C   0xF884 0x003C      STRB     R0,[R4, #+60]
   3238            
   3239            pRwRegs->scuSetRegister.rtcTimeZone = timezone * 60;
   \       0x80   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \       0x84   0x213C             MOVS     R1,#+60
   \       0x86   0xFB10 0xF001      SMULBB   R0,R0,R1
   \       0x8A   0xF8A4 0x007E      STRH     R0,[R4, #+126]
   3240          
   3241            // every 10 sec recall RTC for syncronization 
   3242            while ((xTimerChangePeriod (xSbcSemTimers[TIMER_FOR_TICK_RTC], TICK_FOR_RTC_SYNCRO, SBCSEM_TIMER_GARD_TIME) != pdPASS)); 
   \                     ??setCurrentDateTimeInSem_0: (+1)
   \       0x8E   0xF44F 0x70FA      MOV      R0,#+500
   \       0x92   0x9000             STR      R0,[SP, #+0]
   \       0x94   0x2300             MOVS     R3,#+0
   \       0x96   0xF242 0x7210      MOVW     R2,#+10000
   \       0x9A   0x2104             MOVS     R1,#+4
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \       0xA0   0x6880             LDR      R0,[R0, #+8]
   \       0xA2   0x.... 0x....      BL       xTimerGenericCommand
   \       0xA6   0x2801             CMP      R0,#+1
   \       0xA8   0xD1F1             BNE.N    ??setCurrentDateTimeInSem_0
   3243          
   3244          }
   \       0xAA   0xBD7F             POP      {R0-R6,PC}
   3245          
   3246          /**
   3247          *
   3248          * @brief        Save the right key in the structure    
   3249          *
   3250          * @param [in]   uint8: fixed / adjustable address type  
   3251          *
   3252          * @retval       none 
   3253          *
   3254          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3255          void setAddressType(uint8_t type, uint8_t clearPresence)
   3256          {
   \                     setAddressType: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   3257            uint8_t result; 
   3258          
   3259            result = ReadFromEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t));
   \        0x6   0x.... 0x....      LDR.W    R7,??DataTable22
   \        0xA   0x2254             MOVS     R2,#+84
   \        0xC   0x0039             MOVS     R1,R7
   \        0xE   0xF44F 0x50F4      MOV      R0,#+7808
   \       0x12   0x.... 0x....      BL       ReadFromEeprom
   \       0x16   0x0006             MOVS     R6,R0
   3260            if (clearPresence == TRUE)
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD103             BNE.N    ??setAddressType_0
   3261            {
   3262              socketPresence.chainPresence = socketPresence.livePresence = socketPresence.assignedDeviceId = 0;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x6538             STR      R0,[R7, #+80]
   \       0x24   0x6078             STR      R0,[R7, #+4]
   \       0x26   0x6038             STR      R0,[R7, #+0]
   3263            }
   3264          
   3265            if (result == osOK)
   \                     ??setAddressType_0: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD11B             BNE.N    ??setAddressType_1
   3266            {
   3267              if (type == (uint8_t)SCU_FIXED_ADDR)
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD106             BNE.N    ??setAddressType_2
   3268              {
   3269                socketPresence.keyPresence = KEY_FULL_CONFIG;
   \       0x38   0xF64A 0x2055      MOVW     R0,#+43605
   \       0x3C   0x60B8             STR      R0,[R7, #+8]
   3270                setScuAddressTypeMode(SCU_FIXED_ADDR);
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x.... 0x....      BL       setScuAddressTypeMode
   \       0x44   0xE004             B.N      ??setAddressType_3
   3271              }
   3272              else
   3273              {
   3274                socketPresence.keyPresence = (uint16_t)0;
   \                     ??setAddressType_2: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x60B8             STR      R0,[R7, #+8]
   3275                setScuAddressTypeMode(SCU_TEMPORARY_ADDR);
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x.... 0x....      BL       setScuAddressTypeMode
   3276              }
   3277              if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \                     ??setAddressType_3: (+1)
   \       0x50   0x2254             MOVS     R2,#+84
   \       0x52   0x0039             MOVS     R1,R7
   \       0x54   0xF44F 0x50F4      MOV      R0,#+7808
   \       0x58   0x.... 0x....      BL       WriteOnEeprom
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD103             BNE.N    ??setAddressType_1
   3278              {
   3279                tPrintf("Presences Defined\n\r");
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable35
   \       0x64   0x.... 0x....      BL       tPrintf
   3280              }
   3281            }
   3282          }
   \                     ??setAddressType_1: (+1)
   \       0x68   0xBDF1             POP      {R0,R4-R7,PC}
   3283          
   3284          /**
   3285          *
   3286          * @brief        Task to manage the alive polling on present slave     
   3287          *
   3288          * @param [in]   void*: parameters task  
   3289          *
   3290          * @retval       none 
   3291          *
   3292          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3293          static void pollingSlaveTask (void * pvParameters)
   3294          {
   \                     pollingSlaveTask: (+1)
   \        0x0   0xB578             PUSH     {R3-R6,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
   3295            frameSbcSem_st tmpFrameSbcSem;  
   3296            uint32_t       timeTickPoll;
   3297          
   3298            /*-------- Creates an empty mailbox for uart  messages --------------------------*/
   3299            pollingSlaveQueue = xQueueCreate(NUM_BUFF_POLLING, sizeof(frameSbcSem_st));
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable34
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2112             MOVS     R1,#+18
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0x.... 0x....      BL       xQueueGenericCreate
   \       0x14   0x6028             STR      R0,[R5, #+0]
   3300            configASSERT(pollingSlaveQueue != NULL);
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD109             BNE.N    ??pollingSlaveTask_0
   \       0x1C   0xB672             CPSID    I
   \       0x1E   0x2050             MOVS     R0,#+80
   \       0x20   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x24   0xF3BF 0x8F4F      DSB      SY
   \       0x28   0xF3BF 0x8F6F      ISB      SY
   \       0x2C   0xB662             CPSIE    I
   \                     ??pollingSlaveTask_1: (+1)
   \       0x2E   0xE7FE             B.N      ??pollingSlaveTask_1
   3301            
   3302            /* init structure for management */
   3303            pollingSlaveMng.pollStates = SLAVE_INIT;
   \                     ??pollingSlaveTask_0: (+1)
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable35_1
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x7001             STRB     R1,[R0, #+0]
   3304            pollingSlaveMng.unreachableSlave = (uint16_t)0;
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0xF8A0 0x1011      STRH     R1,[R0, #+17]
   3305          
   3306              
   3307            timeTickPoll = ACTIVITY_PERIOD_CHECK_TIME;
   \       0x3E   0xF44F 0x56FA      MOV      R6,#+8000
   3308          
   3309            for (;;)
   3310            {
   3311              /* Wait for some event from timer or message   */
   3312              if (xQueueReceive(pollingSlaveQueue, (void *)&tmpFrameSbcSem, timeTickPoll) == pdPASS)
   \                     ??pollingSlaveTask_2: (+1)
   \       0x42   0x0032             MOVS     R2,R6
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x.... 0x....      BL       xQueueReceive
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD105             BNE.N    ??pollingSlaveTask_3
   3313              {
   3314                timeTickPoll = pollingSlaveProcess(&frameSbcSem);
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable36
   \       0x54   0x.... 0x....      BL       pollingSlaveProcess
   \       0x58   0x0006             MOVS     R6,R0
   \       0x5A   0xE7F2             B.N      ??pollingSlaveTask_2
   3315              }
   3316              else
   3317              {
   3318                tmpFrameSbcSem.sbcSemEvent = SBC_SEM_TIMEOUT;
   \                     ??pollingSlaveTask_3: (+1)
   \       0x5C   0xF64F 0x70FE      MOVW     R0,#+65534
   \       0x60   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   3319                timeTickPoll = pollingSlaveProcess(&tmpFrameSbcSem);
   \       0x64   0x4668             MOV      R0,SP
   \       0x66   0x.... 0x....      BL       pollingSlaveProcess
   \       0x6A   0x0006             MOVS     R6,R0
   \       0x6C   0xE7E9             B.N      ??pollingSlaveTask_2
   3320              }
   3321            }
   3322          }
   3323          
   3324          /**
   3325          *
   3326          * @brief        Manage the polling on present slave  
   3327          *
   3328          * @param [in]   frameSbcSem_st*: pointer to incoming message 
   3329          *
   3330          * @retval       uint32_t: new timeout 
   3331          *
   3332          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3333          static uint32_t pollingSlaveProcess(frameSbcSem_st* pMsg)
   3334          {
   \                     pollingSlaveProcess: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   3335            uint32_t              timeTickTmp;
   3336            frameSbcSem_st        tmpFrameSbcSem;  
   3337            scuRoMapRegister_st*  pRoRegs; 
   3338            uint16_t              scuId, maskId, logicId;
   3339          
   3340          
   3341            timeTickTmp = ACTIVITY_PERIOD_CHECK_TIME;
   \        0x6   0xF44F 0x59FA      MOV      R9,#+8000
   \        0xA   0xF8CD 0x9000      STR      R9,[SP, #+0]
   3342          
   3343            if ((getStatusDwnl() == TRUE)  || (getBroadcastDownload() == TRUE))  
   \        0xE   0x.... 0x....      BL       getStatusDwnl
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD003             BEQ.N    ??pollingSlaveProcess_0
   \       0x16   0x.... 0x....      BL       getBroadcastDownload
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD103             BNE.N    ??pollingSlaveProcess_1
   3344              pollingSlaveMng.pollStates = FW_DOWNLOAD;
   \                     ??pollingSlaveProcess_0: (+1)
   \       0x1E   0x2005             MOVS     R0,#+5
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable35_1
   \       0x24   0x7008             STRB     R0,[R1, #+0]
   3345          
   3346            switch (pollingSlaveMng.pollStates)
   \                     ??pollingSlaveProcess_1: (+1)
   \       0x26   0x.... 0x....      LDR.W    R8,??DataTable35_1
   \       0x2A   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD00A             BEQ.N    ??pollingSlaveProcess_2
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD025             BEQ.N    ??pollingSlaveProcess_3
   \       0x36   0x2804             CMP      R0,#+4
   \       0x38   0xD050             BEQ.N    ??pollingSlaveProcess_4
   \       0x3A   0x2805             CMP      R0,#+5
   \       0x3C   0xF000 0x813B      BEQ.W    ??pollingSlaveProcess_5
   \       0x40   0x2807             CMP      R0,#+7
   \       0x42   0xF000 0x810C      BEQ.W    ??pollingSlaveProcess_6
   \       0x46   0xE145             B.N      ??pollingSlaveProcess_7
   3347            {
   3348              case SLAVE_INIT:
   3349                switch (pMsg->sbcSemEvent)
   \                     ??pollingSlaveProcess_2: (+1)
   \       0x48   0x9806             LDR      R0,[SP, #+24]
   \       0x4A   0x8800             LDRH     R0,[R0, #+0]
   \       0x4C   0xF64F 0x71FE      MOVW     R1,#+65534
   \       0x50   0x4288             CMP      R0,R1
   \       0x52   0xD115             BNE.N    ??pollingSlaveProcess_8
   3350                {
   3351                  case SBC_SEM_TIMEOUT:
   3352                    if (sbcSemInfoMng.pollingFlag ==(uint16_t)ENABLED)
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable37
   \       0x58   0x8B41             LDRH     R1,[R0, #+26]
   \       0x5A   0x2901             CMP      R1,#+1
   \       0x5C   0xD10D             BNE.N    ??pollingSlaveProcess_9
   3353                    {
   3354                      pollingSlaveMng.pollStates = SLAVE_IDLE;
   \       0x5E   0x2101             MOVS     R1,#+1
   \       0x60   0xF888 0x1000      STRB     R1,[R8, #+0]
   3355                      pollingSlaveMng.checkMask = (uint16_t)SCU_MASTER_MASK_BIT;     // init with master data 
   \       0x64   0x2101             MOVS     R1,#+1
   \       0x66   0xF8C8 0x1007      STR      R1,[R8, #+7]
   3356                      pollingSlaveMng.phyId = (uint16_t)SCU_M_P_ADDR;                // the master is out of polling periodic check 
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0xF8A8 0x1005      STRH     R1,[R8, #+5]
   3357                      /* starts to check slaves  */
   3358                      pollingSlaveMng.pollStates = SLAVE_IDLE;
   \       0x70   0x2101             MOVS     R1,#+1
   \       0x72   0xF888 0x1000      STRB     R1,[R8, #+0]
   3359                      timeTickTmp = ACTIVITY_PERIOD_CHECK_TIME;
   \       0x76   0xF8CD 0x9000      STR      R9,[SP, #+0]
   3360                    }
   3361                    sbcSemInfoMng.activityStatus = 0;                             // reset all activity bit        
   \                     ??pollingSlaveProcess_9: (+1)
   \       0x7A   0x2100             MOVS     R1,#+0
   \       0x7C   0x6141             STR      R1,[R0, #+20]
   3362                    break;
   \       0x7E   0xE7FF             B.N      ??pollingSlaveProcess_10
   3363          
   3364                  default:
   3365                    break;
   3366                }
   3367                break;
   \                     ??pollingSlaveProcess_8: (+1)
   \                     ??pollingSlaveProcess_10: (+1)
   \       0x80   0xE128             B.N      ??pollingSlaveProcess_11
   3368          
   3369              case SLAVE_IDLE:
   3370                sbcSemInfoMng.dataVal = (uint16_t)SCU_S_PS_LIVE;    // for discovery slave SCU (slave primary, i.e with TFT or slave secondary) 
   \                     ??pollingSlaveProcess_3: (+1)
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable37
   \       0x86   0x2105             MOVS     R1,#+5
   \       0x88   0x8081             STRH     R1,[R0, #+4]
   3371                tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \       0x8A   0x2103             MOVS     R1,#+3
   \       0x8C   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   3372                tmpFrameSbcSem.data.index = MODBUS_BROADCAST_ADDR;
   \       0x90   0x2100             MOVS     R1,#+0
   \       0x92   0xF8AD 0x1006      STRH     R1,[SP, #+6]
   3373                tmpFrameSbcSem.data.rAddr = ADDR_EVSE_TM_RW;        // AUTOCONFIG_FUNCTION_RW = ADDR_EVSE_TM_RW = 0x0022 is the register used for polling 
   \       0x96   0x2122             MOVS     R1,#+34
   \       0x98   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   3374                tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \       0x9C   0x1D00             ADDS     R0,R0,#+4
   \       0x9E   0x9003             STR      R0,[SP, #+12]
   3375                tmpFrameSbcSem.dataToSend.len = LEN_EVSE_TM_MODE_RW;
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   3376                configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \       0xA6   0x.... 0x....      BL       getRs485SemQueueHandle
   \       0xAA   0x2300             MOVS     R3,#+0
   \       0xAC   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0xB0   0xA901             ADD      R1,SP,#+4
   \       0xB2   0x.... 0x....      BL       xQueueGenericSend
   \       0xB6   0x2801             CMP      R0,#+1
   \       0xB8   0xD009             BEQ.N    ??pollingSlaveProcess_12
   \       0xBA   0xB672             CPSID    I
   \       0xBC   0x2050             MOVS     R0,#+80
   \       0xBE   0xF380 0x8811      MSR      BASEPRI,R0
   \       0xC2   0xF3BF 0x8F4F      DSB      SY
   \       0xC6   0xF3BF 0x8F6F      ISB      SY
   \       0xCA   0xB662             CPSIE    I
   \                     ??pollingSlaveProcess_13: (+1)
   \       0xCC   0xE7FE             B.N      ??pollingSlaveProcess_13
   3377                /* command is sent: wait next slot */
   3378                pollingSlaveMng.pollStates = CTRL_SLAVE;
   \                     ??pollingSlaveProcess_12: (+1)
   \       0xCE   0x2004             MOVS     R0,#+4
   \       0xD0   0xF888 0x0000      STRB     R0,[R8, #+0]
   3379                timeTickTmp = START_PERIOD_CHECK_LIVE; // timeout for receive responce from all active slaves 1000ms 
   \       0xD4   0xF44F 0x60FA      MOV      R0,#+2000
   \       0xD8   0x9000             STR      R0,[SP, #+0]
   3380                break;
   \       0xDA   0xE0FB             B.N      ??pollingSlaveProcess_11
   3381          
   3382              case CTRL_SLAVE:
   3383                switch (pMsg->sbcSemEvent)
   \                     ??pollingSlaveProcess_4: (+1)
   \       0xDC   0x9806             LDR      R0,[SP, #+24]
   \       0xDE   0x8800             LDRH     R0,[R0, #+0]
   \       0xE0   0xF64F 0x71FE      MOVW     R1,#+65534
   \       0xE4   0x4288             CMP      R0,R1
   \       0xE6   0xF040 0x80B9      BNE.W    ??pollingSlaveProcess_14
   3384                {
   3385                  case SBC_SEM_TIMEOUT:
   3386                    pollingSlaveMng.unactiveSlave = (socketPresence.chainPresence & pScuRoMapReg->scuMapRegNotify.ntfPresences) ^ sbcSemInfoMng.activityStatus;
   \       0xEA   0x.... 0x....      LDR.W    R0,??DataTable42
   \       0xEE   0x6800             LDR      R0,[R0, #+0]
   \       0xF0   0xF8D0 0x10F6      LDR      R1,[R0, #+246]
   \       0xF4   0x.... 0x....      LDR.W    R10,??DataTable22
   \       0xF8   0x.... 0x....      LDR.W    R9,??DataTable37
   \       0xFC   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x100   0x4001             ANDS     R1,R1,R0
   \      0x102   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \      0x106   0x4041             EORS     R1,R0,R1
   \      0x108   0xF8A8 0x100F      STRH     R1,[R8, #+15]
   3387                    if (pollingSlaveMng.unactiveSlave != 0)
   \      0x10C   0xF8B8 0x000F      LDRH     R0,[R8, #+15]
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xF000 0x809C      BEQ.W    ??pollingSlaveProcess_15
   3388                    {
   3389                      if (getScuOpMode() == SCU_M_STAND_ALONE)
   \      0x116   0x.... 0x....      BL       getScuOpMode
   \      0x11A   0x2805             CMP      R0,#+5
   \      0x11C   0xD106             BNE.N    ??pollingSlaveProcess_16
   3390                      {
   3391                        scuId = 1; maskId = 1; logicId = 0;            
   \      0x11E   0x2001             MOVS     R0,#+1
   \      0x120   0x0005             MOVS     R5,R0
   \      0x122   0x2001             MOVS     R0,#+1
   \      0x124   0x0006             MOVS     R6,R0
   \      0x126   0x2000             MOVS     R0,#+0
   \      0x128   0x0007             MOVS     R7,R0
   \      0x12A   0xE005             B.N      ??pollingSlaveProcess_17
   3392                      }
   3393                      else
   3394                      {
   3395                        scuId = 2; maskId = 2; logicId = 1;
   \                     ??pollingSlaveProcess_16: (+1)
   \      0x12C   0x2002             MOVS     R0,#+2
   \      0x12E   0x0005             MOVS     R5,R0
   \      0x130   0x2002             MOVS     R0,#+2
   \      0x132   0x0006             MOVS     R6,R0
   \      0x134   0x2001             MOVS     R0,#+1
   \      0x136   0x0007             MOVS     R7,R0
   3396                      }
   3397          
   3398                      for ( ; scuId < SCU_NUM; scuId++, maskId = maskId << 1, logicId++)
   \                     ??pollingSlaveProcess_17: (+1)
   \      0x138   0x0028             MOVS     R0,R5
   \      0x13A   0xB280             UXTH     R0,R0
   \      0x13C   0x2810             CMP      R0,#+16
   \      0x13E   0xF280 0x8086      BGE.W    ??pollingSlaveProcess_15
   3399                      {
   3400                        /* the check doen't involved the master */
   3401                        pRoRegs = getRoMdbRegs(logicId);
   \      0x142   0x0038             MOVS     R0,R7
   \      0x144   0xB2C0             UXTB     R0,R0
   \      0x146   0x.... 0x....      BL       getRoMdbRegs
   \      0x14A   0x0004             MOVS     R4,R0
   3402                        if ((pollingSlaveMng.unactiveSlave & maskId) != 0)
   \      0x14C   0xF8B8 0x000F      LDRH     R0,[R8, #+15]
   \      0x150   0x4230             TST      R0,R6
   \      0x152   0xD056             BEQ.N    ??pollingSlaveProcess_18
   3403                        {
   3404                          if ((pRoRegs->scuMapRegNotify.ntfErr2 & ERROR2_OFFL) == 0)
   \      0x154   0xF894 0x0100      LDRB     R0,[R4, #+256]
   \      0x158   0x0700             LSLS     R0,R0,#+28
   \      0x15A   0xD474             BMI.N    ??pollingSlaveProcess_19
   3405                          {
   3406                            if (pollingSlaveMng.offLineCounter[logicId] >= NUM_OFF_LINE_RETRY)
   \      0x15C   0x0038             MOVS     R0,R7
   \      0x15E   0xB280             UXTH     R0,R0
   \      0x160   0x4440             ADD      R0,R8,R0
   \      0x162   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \      0x166   0x2800             CMP      R0,#+0
   \      0x168   0xD02A             BEQ.N    ??pollingSlaveProcess_20
   3407                            {
   3408                              /* the current scuId doesn't respond: put it in OFF_L error status Only one time !!! */
   3409                              pRoRegs->scuMapRegNotify.ntfErr2 |= ERROR2_OFFL;
   \      0x16A   0xF8B4 0x0100      LDRH     R0,[R4, #+256]
   \      0x16E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x172   0xF8A4 0x0100      STRH     R0,[R4, #+256]
   3410                              /* set error for SEM communication */
   3411                              tmpFrameSbcSem.data.rAddr = ADDR_EVSE_ERROR2_RO;
   \      0x176   0xF240 0x4005      MOVW     R0,#+1029
   \      0x17A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   3412                              (void)setChangeRegisterBit(scuId, (frameSbcSem_st*)&tmpFrameSbcSem, (uint32_t)maskId, logicId); 
   \      0x17E   0x003B             MOVS     R3,R7
   \      0x180   0xB29B             UXTH     R3,R3
   \      0x182   0x0032             MOVS     R2,R6
   \      0x184   0xB292             UXTH     R2,R2
   \      0x186   0xA901             ADD      R1,SP,#+4
   \      0x188   0x0028             MOVS     R0,R5
   \      0x18A   0xB280             UXTH     R0,R0
   \      0x18C   0x.... 0x....      BL       setChangeRegisterBit
   3413                              tPrintf ("SCU %02d off-line! %s\n\r" , scuId, getHmsStr());
   \      0x190   0x.... 0x....      BL       getHmsStr
   \      0x194   0x0002             MOVS     R2,R0
   \      0x196   0x0029             MOVS     R1,R5
   \      0x198   0xB289             UXTH     R1,R1
   \      0x19A   0x.... 0x....      LDR.W    R0,??DataTable45
   \      0x19E   0x.... 0x....      BL       tPrintf
   3414                              /* remove from discovered list so, when RS485 will be reconnected, a new discovery starts */
   3415                              socketPresence.livePresence &= ~(maskId);
   \      0x1A2   0xF8DA 0x1004      LDR      R1,[R10, #+4]
   \      0x1A6   0x0030             MOVS     R0,R6
   \      0x1A8   0xB280             UXTH     R0,R0
   \      0x1AA   0x4381             BICS     R1,R1,R0
   \      0x1AC   0xF8CA 0x1004      STR      R1,[R10, #+4]
   3416                              sbcSemInfoMng.activeLastDiscovery &= ~(maskId);  
   \      0x1B0   0xF8D9 0x1020      LDR      R1,[R9, #+32]
   \      0x1B4   0x0030             MOVS     R0,R6
   \      0x1B6   0xB280             UXTH     R0,R0
   \      0x1B8   0x4381             BICS     R1,R1,R0
   \      0x1BA   0xF8C9 0x1020      STR      R1,[R9, #+32]
   \      0x1BE   0xE042             B.N      ??pollingSlaveProcess_19
   3417                            }
   3418                            else
   3419                            {
   3420                              pollingSlaveMng.offLineCounter[logicId]++;
   \                     ??pollingSlaveProcess_20: (+1)
   \      0x1C0   0x0038             MOVS     R0,R7
   \      0x1C2   0xB280             UXTH     R0,R0
   \      0x1C4   0x4440             ADD      R0,R8,R0
   \      0x1C6   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \      0x1CA   0x1C40             ADDS     R0,R0,#+1
   \      0x1CC   0x0039             MOVS     R1,R7
   \      0x1CE   0xB289             UXTH     R1,R1
   \      0x1D0   0x4441             ADD      R1,R8,R1
   \      0x1D2   0xF881 0x0023      STRB     R0,[R1, #+35]
   3421                              tPrintf ("SCU %02d off-line! Retry=%d %s\n\r" , getNumSocketLcd(logicId), pollingSlaveMng.offLineCounter[logicId], getHmsStr());
   \      0x1D6   0x.... 0x....      BL       getHmsStr
   \      0x1DA   0x4683             MOV      R11,R0
   \      0x1DC   0x0038             MOVS     R0,R7
   \      0x1DE   0xB2C0             UXTB     R0,R0
   \      0x1E0   0x.... 0x....      BL       getNumSocketLcd
   \      0x1E4   0x0001             MOVS     R1,R0
   \      0x1E6   0x465B             MOV      R3,R11
   \      0x1E8   0x0038             MOVS     R0,R7
   \      0x1EA   0xB280             UXTH     R0,R0
   \      0x1EC   0x4440             ADD      R0,R8,R0
   \      0x1EE   0xF890 0x2023      LDRB     R2,[R0, #+35]
   \      0x1F2   0xB2C9             UXTB     R1,R1
   \      0x1F4   0x.... 0x....      LDR.W    R0,??DataTable45_1
   \      0x1F8   0x.... 0x....      BL       tPrintf
   3422                              /* restore RS485   */
   3423                              uartReintialization(); 
   \      0x1FC   0x.... 0x....      BL       uartReintialization
   \      0x200   0xE021             B.N      ??pollingSlaveProcess_19
   3424                            }
   3425                          }
   3426                          else
   3427                          {
   3428                            ;
   3429                          }
   3430                        }
   3431                        else
   3432                        {
   3433                          if (pollingSlaveMng.offLineCounter[logicId] >= NUM_OFF_LINE_RETRY)
   \                     ??pollingSlaveProcess_18: (+1)
   \      0x202   0x0038             MOVS     R0,R7
   \      0x204   0xB280             UXTH     R0,R0
   \      0x206   0x4440             ADD      R0,R8,R0
   \      0x208   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \      0x20C   0x2800             CMP      R0,#+0
   \      0x20E   0xD014             BEQ.N    ??pollingSlaveProcess_21
   3434                          {
   3435                            /* the current scuId  respond now: put it in ON_LINE  Only one time !!! */
   3436                            pRoRegs->scuMapRegNotify.ntfErr2 &= (~ERROR2_OFFL);
   \      0x210   0xF8B4 0x1100      LDRH     R1,[R4, #+256]
   \      0x214   0xF64F 0x70F7      MOVW     R0,#+65527
   \      0x218   0x4001             ANDS     R1,R0,R1
   \      0x21A   0xF8A4 0x1100      STRH     R1,[R4, #+256]
   3437                            tPrintf ("SCU %02d on-line!! %s\n\r" , getNumSocketLcd(logicId), getHmsStr()); //  HAL_GetTick()
   \      0x21E   0x.... 0x....      BL       getHmsStr
   \      0x222   0x4683             MOV      R11,R0
   \      0x224   0x0038             MOVS     R0,R7
   \      0x226   0xB2C0             UXTB     R0,R0
   \      0x228   0x.... 0x....      BL       getNumSocketLcd
   \      0x22C   0x465A             MOV      R2,R11
   \      0x22E   0xB2C0             UXTB     R0,R0
   \      0x230   0x0001             MOVS     R1,R0
   \      0x232   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \      0x236   0x.... 0x....      BL       tPrintf
   3438                          }
   3439                          pollingSlaveMng.offLineCounter[logicId] = 0;
   \                     ??pollingSlaveProcess_21: (+1)
   \      0x23A   0x2000             MOVS     R0,#+0
   \      0x23C   0x0039             MOVS     R1,R7
   \      0x23E   0xB289             UXTH     R1,R1
   \      0x240   0x4441             ADD      R1,R8,R1
   \      0x242   0xF881 0x0023      STRB     R0,[R1, #+35]
   3440                        }
   3441                      }
   \                     ??pollingSlaveProcess_19: (+1)
   \      0x246   0x1C6D             ADDS     R5,R5,#+1
   \      0x248   0x0076             LSLS     R6,R6,#+1
   \      0x24A   0x1C7F             ADDS     R7,R7,#+1
   \      0x24C   0xE774             B.N      ??pollingSlaveProcess_17
   3442                    }
   3443                    timeTickTmp = START_PERIOD_CHECK_LIVE;  // timeout for receive responce from all active slave 1000ms 
   \                     ??pollingSlaveProcess_15: (+1)
   \      0x24E   0xF44F 0x60FA      MOV      R0,#+2000
   \      0x252   0x9000             STR      R0,[SP, #+0]
   3444                    pollingSlaveMng.pollStates = FIND_NEW_SLAVE;  // 2000ms 
   \      0x254   0x2007             MOVS     R0,#+7
   \      0x256   0xF888 0x0000      STRB     R0,[R8, #+0]
   3445                    break;
   \      0x25A   0xE7FF             B.N      ??pollingSlaveProcess_22
   3446          
   3447                  default:
   3448                    break;
   3449                }
   3450                break;
   \                     ??pollingSlaveProcess_14: (+1)
   \                     ??pollingSlaveProcess_22: (+1)
   \      0x25C   0xE03A             B.N      ??pollingSlaveProcess_11
   3451          
   3452              case FIND_NEW_SLAVE:
   3453                sbcSemInfoMng.dataVal = (uint16_t)SCU_S_PS_NEW;  // for discovery new slave SCU (slave primary, i.e with TFT or slave secondary) 
   \                     ??pollingSlaveProcess_6: (+1)
   \      0x25E   0x.... 0x....      LDR.W    R0,??DataTable37
   \      0x262   0x2106             MOVS     R1,#+6
   \      0x264   0x8081             STRH     R1,[R0, #+4]
   3454                tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \      0x266   0x2103             MOVS     R1,#+3
   \      0x268   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   3455                tmpFrameSbcSem.data.index = MODBUS_BROADCAST_ADDR;
   \      0x26C   0x2100             MOVS     R1,#+0
   \      0x26E   0xF8AD 0x1006      STRH     R1,[SP, #+6]
   3456                tmpFrameSbcSem.data.rAddr = ADDR_EVSE_TM_RW;
   \      0x272   0x2122             MOVS     R1,#+34
   \      0x274   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   3457                tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \      0x278   0x1D00             ADDS     R0,R0,#+4
   \      0x27A   0x9003             STR      R0,[SP, #+12]
   3458                tmpFrameSbcSem.dataToSend.len = LEN_EVSE_TM_MODE_RW;
   \      0x27C   0x2001             MOVS     R0,#+1
   \      0x27E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   3459                configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \      0x282   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x286   0x2300             MOVS     R3,#+0
   \      0x288   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x28C   0xA901             ADD      R1,SP,#+4
   \      0x28E   0x.... 0x....      BL       xQueueGenericSend
   \      0x292   0x2801             CMP      R0,#+1
   \      0x294   0xD009             BEQ.N    ??pollingSlaveProcess_23
   \      0x296   0xB672             CPSID    I
   \      0x298   0x2050             MOVS     R0,#+80
   \      0x29A   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x29E   0xF3BF 0x8F4F      DSB      SY
   \      0x2A2   0xF3BF 0x8F6F      ISB      SY
   \      0x2A6   0xB662             CPSIE    I
   \                     ??pollingSlaveProcess_24: (+1)
   \      0x2A8   0xE7FE             B.N      ??pollingSlaveProcess_24
   3460                /* command is sent: wait next slot */
   3461                pollingSlaveMng.pollStates = SLAVE_INIT;
   \                     ??pollingSlaveProcess_23: (+1)
   \      0x2AA   0x2000             MOVS     R0,#+0
   \      0x2AC   0xF888 0x0000      STRB     R0,[R8, #+0]
   3462                timeTickTmp = ACTIVITY_PERIOD_CHECK_TIME; // next time is 8sec
   \      0x2B0   0xF8CD 0x9000      STR      R9,[SP, #+0]
   3463                break;
   \      0x2B4   0xE00E             B.N      ??pollingSlaveProcess_11
   3464          
   3465              case FW_DOWNLOAD:           /* FW download ongoing */
   3466                 if ((getBroadcastDownload() == TRUE))
   \                     ??pollingSlaveProcess_5: (+1)
   \      0x2B6   0x.... 0x....      BL       getBroadcastDownload
   \      0x2BA   0x2801             CMP      R0,#+1
   \      0x2BC   0xD103             BNE.N    ??pollingSlaveProcess_25
   3467                 {
   3468                   /* the task will be stopped with portMAX_DELAY value. Wait for reset at the end download  */
   3469                   timeTickTmp = portMAX_DELAY;
   \      0x2BE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \      0x2C2   0x9000             STR      R0,[SP, #+0]
   \      0x2C4   0xE005             B.N      ??pollingSlaveProcess_26
   3470                 }
   3471                 else
   3472                 {
   3473                   /* the polling will restart at the end of slave upload */
   3474                   timeTickTmp = SUSPEND_FOR_UPLOAD_TIME;
   \                     ??pollingSlaveProcess_25: (+1)
   \      0x2C6   0x.... 0x....      LDR.W    R0,??DataTable46
   \      0x2CA   0x9000             STR      R0,[SP, #+0]
   3475                   pollingSlaveMng.pollStates = SLAVE_INIT;
   \      0x2CC   0x2000             MOVS     R0,#+0
   \      0x2CE   0xF888 0x0000      STRB     R0,[R8, #+0]
   3476                 }
   3477                break;
   \                     ??pollingSlaveProcess_26: (+1)
   \      0x2D2   0xE7FF             B.N      ??pollingSlaveProcess_11
   3478          
   3479                default:
   3480                  break;
   3481          
   3482            }
   3483            return(timeTickTmp);
   \                     ??pollingSlaveProcess_7: (+1)
   \                     ??pollingSlaveProcess_11: (+1)
   \      0x2D4   0x9800             LDR      R0,[SP, #+0]
   \      0x2D6   0xB007             ADD      SP,SP,#+28
   \      0x2D8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   3484          }
   3485          
   3486          /**
   3487          *
   3488          * @brief       get FW version from the slaves
   3489          *
   3490          * @param [in]  None
   3491          *  
   3492          * @retval      none  
   3493          *  
   3494          ****************************************************************/
   3495          

   \                                 In section .text, align 2, keep-with-next
   3496          void Print_Slave_FW_Version (void)
   3497          {
   \                     Print_Slave_FW_Version: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   3498            uint8_t cnt;
   3499            uint32_t mask;
   3500            scuRoMapRegister_st*  pRoRegs;
   3501            
   3502            for (cnt = 0, mask = 1; cnt < SCU_NUM; cnt++, mask <<= 1)
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2501             MOVS     R5,#+1
   \                     ??Print_Slave_FW_Version_0: (+1)
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x2810             CMP      R0,#+16
   \        0xC   0xDA16             BGE.N    ??Print_Slave_FW_Version_1
   3503            {
   3504               pRoRegs = getRoMdbRegs(cnt);
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x.... 0x....      BL       getRoMdbRegs
   \       0x16   0x0006             MOVS     R6,R0
   3505              
   3506               if (socketPresence.livePresence & mask)     
   \       0x18   0x....             LDR.N    R0,??DataTable22
   \       0x1A   0x6840             LDR      R0,[R0, #+4]
   \       0x1C   0x4228             TST      R0,R5
   \       0x1E   0xD007             BEQ.N    ??Print_Slave_FW_Version_2
   3507                 tPrintf ("SCU id%02d --> FW version %s\n\r" , cnt +1, pRoRegs->scuMapRegInfoVer.mfwVer);
   \       0x20   0x0032             MOVS     R2,R6
   \       0x22   0x0021             MOVS     R1,R4
   \       0x24   0xB2C9             UXTB     R1,R1
   \       0x26   0x1C49             ADDS     R1,R1,#+1
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable46_1
   \       0x2C   0x.... 0x....      BL       tPrintf
   3508               osDelay(10);
   \                     ??Print_Slave_FW_Version_2: (+1)
   \       0x30   0x200A             MOVS     R0,#+10
   \       0x32   0x.... 0x....      BL       osDelay
   3509            }
   \       0x36   0x1C64             ADDS     R4,R4,#+1
   \       0x38   0x006D             LSLS     R5,R5,#+1
   \       0x3A   0xE7E4             B.N      ??Print_Slave_FW_Version_0
   3510            
   3511          }
   \                     ??Print_Slave_FW_Version_1: (+1)
   \       0x3C   0xBD70             POP      {R4-R6,PC}
   3512          
   3513          /**
   3514          *
   3515          * @brief       get  slaves with assogned address
   3516          *
   3517          * @param [in]  None
   3518          *  
   3519          * @retval      none  
   3520          *  
   3521          ****************************************************************/
   3522          

   \                                 In section .text, align 2, keep-with-next
   3523          void Print_Slave_Assigned (void)
   3524          {
   \                     Print_Slave_Assigned: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   3525            uint8_t cnt;
   3526            uint32_t mask;
   3527            
   3528            for (cnt = 0, mask = 1; cnt < SCU_NUM; cnt++, mask <<= 1)
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x2501             MOVS     R5,#+1
   \                     ??Print_Slave_Assigned_0: (+1)
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x2810             CMP      R0,#+16
   \        0xC   0xDA10             BGE.N    ??Print_Slave_Assigned_1
   3529            {
   3530               if (socketPresence.chainPresence & mask) 
   \        0xE   0x....             LDR.N    R0,??DataTable22
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x4228             TST      R0,R5
   \       0x14   0xD006             BEQ.N    ??Print_Slave_Assigned_2
   3531               {
   3532                 tPrintf ("Address %02d Assigned\n\r" , cnt +1);
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0xB2C9             UXTB     R1,R1
   \       0x1A   0x1C49             ADDS     R1,R1,#+1
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable46_2
   \       0x20   0x.... 0x....      BL       tPrintf
   3533               }
   3534               osDelay(10);
   \                     ??Print_Slave_Assigned_2: (+1)
   \       0x24   0x200A             MOVS     R0,#+10
   \       0x26   0x.... 0x....      BL       osDelay
   3535            }
   \       0x2A   0x1C64             ADDS     R4,R4,#+1
   \       0x2C   0x006D             LSLS     R5,R5,#+1
   \       0x2E   0xE7EA             B.N      ??Print_Slave_Assigned_0
   3536            
   3537          }
   \                     ??Print_Slave_Assigned_1: (+1)
   \       0x30   0xBD31             POP      {R0,R4,R5,PC}
   3538          
   3539          
   3540          
   3541          /**
   3542          *
   3543          * @brief       reset current command sent to EVS for suspend / 
   3544          *              resume function 
   3545          *
   3546          * @param [in]  None
   3547          *  
   3548          * @retval      none  
   3549          *  
   3550          ****************************************************************/
   3551          

   \                                 In section .text, align 2, keep-with-next
   3552          void resetCommandRemote (void)
   3553          {
   3554            //lastCommandSent = EVS_EVENT_NULL;
   3555          }
   \                     resetCommandRemote: (+1)
   \        0x0   0x4770             BX       LR
   3556          
   3557          /**
   3558          *
   3559          * @brief       get socket index inside fake code  
   3560          *
   3561          * @param [in]  uint32_t : mask bit for the socket    
   3562          * @param [in]  sbcSemInfoMng_st* : info for discovery    
   3563          *  
   3564          * @retval      none  
   3565          *  
   3566          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3567          static uint8_t  getSktNumInFakeCode(void) 
   3568          {
   \                     getSktNumInFakeCode: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3569            uint8_t connNum;
   3570          
   3571          	eeprom_param_get(CONNECTOR_NUMBER_EADD, (uint8_t *)&connNum, 1);
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x2042             MOVS     R0,#+66
   \        0x8   0x.... 0x....      BL       eeprom_param_get
   3572            return (connNum);
   \        0xC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x10   0xBD02             POP      {R1,PC}
   3573          }
   3574          
   3575          /**
   3576          *
   3577          * @brief       get tag id from product serial number   
   3578          *
   3579          * @param [in]  none    
   3580          *  
   3581          * @retval      uint16_t: crc on product SN  
   3582          *  
   3583          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3584          static uint16_t  getTagIdFromPrdSn(void) 
   3585          {
   \                     getTagIdFromPrdSn: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   3586            scuRoMapRegister_st*  pRoRegs;
   3587            crcMode_u             crc;
   3588            uint16_t              length;
   3589            uint8_t               mdbAddr;
   3590          
   3591            mdbAddr = getLogicalMdbAddrSem();
   \        0x2   0x.... 0x....      BL       getLogicalMdbAddrSem
   \        0x6   0x0006             MOVS     R6,R0
   3592            pRoRegs = getRoMdbRegs(mdbAddr);
   \        0x8   0x0030             MOVS     R0,R6
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x.... 0x....      BL       getRoMdbRegs
   \       0x10   0x0004             MOVS     R4,R0
   3593          
   3594            length = (uint16_t)strlen((char*)pRoRegs->scuMapRegInfoVer.prodSn);
   \       0x12   0xF114 0x00B4      ADDS     R0,R4,#+180
   \       0x16   0x.... 0x....      BL       strlen
   \       0x1A   0x0005             MOVS     R5,R0
   3595            /* now found the CRC message */
   3596            crc.crcW = crcEvaluation ((uint8_t*)pRoRegs->scuMapRegInfoVer.prodSn, length);
   \       0x1C   0x0029             MOVS     R1,R5
   \       0x1E   0xB289             UXTH     R1,R1
   \       0x20   0xF114 0x00B4      ADDS     R0,R4,#+180
   \       0x24   0x.... 0x....      BL       crcEvaluation
   3597            return(crc.crcW);
   \       0x28   0xB280             UXTH     R0,R0
   \       0x2A   0xBD70             POP      {R4-R6,PC}
   3598          }
   3599          
   3600          /**
   3601          *
   3602          * @brief       get the id for LCD    
   3603          *
   3604          * @param [in]  none    
   3605          *  
   3606          * @retval      uint8_t: id to put on LCD   
   3607          *  
   3608          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3609          uint8_t  getIdNumberForLcd(void) 
   3610          {
   \                     getIdNumberForLcd: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   3611            uint8_t                 idLcd;
   3612          
   3613            if (isSemMode() == TRUE)
   \        0x2   0x.... 0x....      BL       isSemMode
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD105             BNE.N    ??getIdNumberForLcd_0
   3614            {
   3615              idLcd = numberOnLcd;
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable47
   \        0xE   0x7800             LDRB     R0,[R0, #+0]
   \       0x10   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x14   0xE009             B.N      ??getIdNumberForLcd_1
   3616            }
   3617            else
   3618            {
   3619              /* get SCU address        */
   3620              eeprom_param_get(RS485_ADD_EADD, (uint8_t *)&idLcd, 1);
   \                     ??getIdNumberForLcd_0: (+1)
   \       0x16   0x2201             MOVS     R2,#+1
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x2009             MOVS     R0,#+9
   \       0x1C   0x.... 0x....      BL       eeprom_param_get
   3621              idLcd++;
   \       0x20   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x24   0x1C40             ADDS     R0,R0,#+1
   \       0x26   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3622            }
   3623            return(idLcd);
   \                     ??getIdNumberForLcd_1: (+1)
   \       0x2A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2E   0xBD02             POP      {R1,PC}
   3624          }
   3625          
   3626          /**
   3627          *
   3628          * @brief       get the id LCD from device Id    
   3629          *
   3630          * @param [in]  uint8_t: device Id (0...15)    
   3631          *  
   3632          * @retval      uint8_t: id on LCD  
   3633          *  
   3634          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3635          uint8_t  getNumSocketLcd(uint8_t deviceId) 
   3636          {
   \                     getNumSocketLcd: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3637            scuRwMapRegister_st*  pRwRegs;
   3638            uint8_t               lcdNum;
   3639          
   3640            pRwRegs = getRwMdbRegs(deviceId);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x.... 0x....      BL       getRwMdbRegs
   \        0xC   0x0001             MOVS     R1,R0
   3641            lcdNum = (uint8_t)pRwRegs->scuSetRegister.devAlias;
   \        0xE   0x8908             LDRH     R0,[R1, #+8]
   3642            return(lcdNum);
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0xBD10             POP      {R4,PC}
   3643          }
   3644            
   3645          
   3646          
   3647          /**
   3648          *
   3649          * @brief       set in the modbus map the alias id number
   3650          *
   3651          * @param [in]  uint16_t: station status  
   3652          *  
   3653          * @retval      none 
   3654          *  
   3655          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3656          void  setDevAlias (void) 
   3657          {
   \                     setDevAlias: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   3658            scuRwMapRegister_st*  pRwRegs;
   3659            uint8_t               mdbAddr;
   3660            uint16_t              idDev;
   3661          
   3662            /* get address on modbus and relative modbus pointer area   */
   3663            if (isSemMode() == TRUE)
   \        0x2   0x.... 0x....      BL       isSemMode
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD12B             BNE.N    ??setDevAlias_0
   3664            {
   3665              mdbAddr = getPhysicalMdbAddr();
   \        0xA   0x.... 0x....      BL       getPhysicalMdbAddr
   \        0xE   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3666              idDev = fromRs485ToSem(mdbAddr);
   \       0x12   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x.... 0x....      BL       fromRs485ToSem
   \       0x1C   0x0004             MOVS     R4,R0
   3667              
   3668              // NULL id ? exit
   3669              if (idDev == NULL_ID)
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD028             BEQ.N    ??setDevAlias_1
   3670                return;
   3671              
   3672              pRwRegs = getRwMdbRegs(idDev);
   \                     ??setDevAlias_2: (+1)
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x.... 0x....      BL       getRwMdbRegs
   \       0x32   0x0005             MOVS     R5,R0
   3673              pRwRegs->scuSetRegister.devAlias = socketPresence.matrixIdConn[idDev]; 
   \       0x34   0x....             LDR.N    R0,??DataTable22
   \       0x36   0x0021             MOVS     R1,R4
   \       0x38   0xB289             UXTH     R1,R1
   \       0x3A   0x4408             ADD      R0,R0,R1
   \       0x3C   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \       0x40   0x8128             STRH     R0,[R5, #+8]
   3674              numberOnLcd = (uint8_t)pRwRegs->scuSetRegister.devAlias;
   \       0x42   0x.... 0x....      LDR.W    R6,??DataTable47
   \       0x46   0x8928             LDRH     R0,[R5, #+8]
   \       0x48   0x7030             STRB     R0,[R6, #+0]
   3675          
   3676              eeprom_param_get(RS485_ADD_EADD, &mdbAddr, 1);
   \       0x4A   0x2201             MOVS     R2,#+1
   \       0x4C   0x4669             MOV      R1,SP
   \       0x4E   0x2009             MOVS     R0,#+9
   \       0x50   0x.... 0x....      BL       eeprom_param_get
   3677              if (mdbAddr == (SCU_S_REPL_ADDR - 1))
   \       0x54   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x58   0x2862             CMP      R0,#+98
   \       0x5A   0xD10F             BNE.N    ??setDevAlias_3
   3678              {
   3679                /* this is a board for replacement: its address is 99 but 16 for Firmware  */
   3680                numberOnLcd = SCU_S_REPL_ADDR;
   \       0x5C   0x2063             MOVS     R0,#+99
   \       0x5E   0x7030             STRB     R0,[R6, #+0]
   \       0x60   0xE00C             B.N      ??setDevAlias_3
   3681              }
   3682            }
   3683            else
   3684            {
   3685              mdbAddr = getLogicalMdbAddr();
   \                     ??setDevAlias_0: (+1)
   \       0x62   0x.... 0x....      BL       getLogicalMdbAddr
   \       0x66   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3686              pRwRegs = getRwMdbRegs(mdbAddr);
   \       0x6A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x6E   0x.... 0x....      BL       getRwMdbRegs
   \       0x72   0x0005             MOVS     R5,R0
   3687              pRwRegs->scuSetRegister.devAlias = mdbAddr + 1; 
   \       0x74   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x78   0x1C40             ADDS     R0,R0,#+1
   \       0x7A   0x8128             STRH     R0,[R5, #+8]
   3688            }
   3689          }
   \                     ??setDevAlias_3: (+1)
   \                     ??setDevAlias_1: (+1)
   \       0x7C   0xBD73             POP      {R0,R1,R4-R6,PC}
   3690          
   3691          
   3692          /**
   3693          *
   3694          * @brief       Check if to send to  master a request to receive 
   3695          *              a new modbus address
   3696          *
   3697          * @param [in]  frameSbcSem_st*: pointer to received message    
   3698          *  
   3699          * @retval      sbcSemStates_e: the new state for the process  
   3700          *  
   3701          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3702          static sbcSemStates_e  checkToSendReqAddress(frameSbcSem_st* pMsg) 
   3703          {
   \                     checkToSendReqAddress: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   3704            uint16_t*             pWord;
   3705            sbcSemStates_e        retState;
   3706            uint32_t              reqDelay;
   3707          
   3708            pWord = (uint16_t *)pMsg->dataToSend.pData;
   \        0x6   0x68A5             LDR      R5,[R4, #+8]
   3709            retState = SBC_SEM_WAIT_TO_REGISTER;
   \        0x8   0x2609             MOVS     R6,#+9
   3710            gsy_connected_set((uint8_t)1); // the slave suppose that SEM is present 
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x.... 0x....      BL       gsy_connected_set
   3711          
   3712            if (((uint16_t)SCU_S_PS_STARTUP == *pWord)  || ((uint16_t)SCU_S_PS_NEW == *pWord))  // SCU_S_PS_STARTUP == 4 all slave SCU, secondary or primary 
   \       0x10   0x8828             LDRH     R0,[R5, #+0]
   \       0x12   0x2804             CMP      R0,#+4
   \       0x14   0xD002             BEQ.N    ??checkToSendReqAddress_0
   \       0x16   0x8828             LDRH     R0,[R5, #+0]
   \       0x18   0x2806             CMP      R0,#+6
   \       0x1A   0xD158             BNE.N    ??checkToSendReqAddress_1
   3713            {                                                                                   // SCU_S_PS_NEW == 6 all slave SCU, secondary or primary
   3714              /* the current slave is the same type required from master */
   3715              if (pMsg->data.rAddr == ADDR_EVSE_TM_RW)
   \                     ??checkToSendReqAddress_0: (+1)
   \       0x1C   0x88A0             LDRH     R0,[R4, #+4]
   \       0x1E   0x2822             CMP      R0,#+34
   \       0x20   0xD155             BNE.N    ??checkToSendReqAddress_1
   3716              {
   3717                if ((socketPresence.keyPresence != KEY_FULL_CONFIG)  || 
   3718                    ((socketPresence.keyPresence == KEY_FULL_CONFIG) && socketPresence.chainPresence ==0)) // coming from a factory reset 
   \       0x22   0xF64A 0x2055      MOVW     R0,#+43605
   \       0x26   0x....             LDR.N    R1,??DataTable22
   \       0x28   0x688A             LDR      R2,[R1, #+8]
   \       0x2A   0x4282             CMP      R2,R0
   \       0x2C   0xD105             BNE.N    ??checkToSendReqAddress_2
   \       0x2E   0x688A             LDR      R2,[R1, #+8]
   \       0x30   0x4282             CMP      R2,R0
   \       0x32   0xD14C             BNE.N    ??checkToSendReqAddress_1
   \       0x34   0x6808             LDR      R0,[R1, #+0]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD149             BNE.N    ??checkToSendReqAddress_1
   3719                {
   3720                  if (getSktNumInFakeCode() == 1)
   \                     ??checkToSendReqAddress_2: (+1)
   \       0x3A   0x.... 0x....      BL       getSktNumInFakeCode
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD13E             BNE.N    ??checkToSendReqAddress_3
   3721                  {
   3722                    /* only the first socket slave answer to require the address: the other wait for the assigning  message  */
   3723                    switch (getNumSktInProduct())
   \       0x42   0x.... 0x....      BL       getNumSktInProduct
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD004             BEQ.N    ??checkToSendReqAddress_4
   \       0x4A   0x2802             CMP      R0,#+2
   \       0x4C   0xD008             BEQ.N    ??checkToSendReqAddress_5
   \       0x4E   0x2804             CMP      R0,#+4
   \       0x50   0xD00D             BEQ.N    ??checkToSendReqAddress_6
   \       0x52   0xE013             B.N      ??checkToSendReqAddress_7
   3724                    {
   3725                      case 1:
   3726                        pScuTmMapReg->tmAddrSconnM = (uint16_t)0;
   \                     ??checkToSendReqAddress_4: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x.... 0x....      LDR.W    R1,??DataTable31
   \       0x5A   0x6809             LDR      R1,[R1, #+0]
   \       0x5C   0x80C8             STRH     R0,[R1, #+6]
   3727                        break;
   \       0x5E   0xE013             B.N      ??checkToSendReqAddress_8
   3728                      case 2:
   3729                        pScuTmMapReg->tmAddrSconnM = KEY_SCU_SLAVE_LINKED_2;
   \                     ??checkToSendReqAddress_5: (+1)
   \       0x60   0xF64C 0x4072      MOVW     R0,#+52338
   \       0x64   0x.... 0x....      LDR.W    R1,??DataTable31
   \       0x68   0x6809             LDR      R1,[R1, #+0]
   \       0x6A   0x80C8             STRH     R0,[R1, #+6]
   3730                        break;
   \       0x6C   0xE00C             B.N      ??checkToSendReqAddress_8
   3731                      case 4:
   3732                        pScuTmMapReg->tmAddrSconnM = KEY_SCU_SLAVE_LINKED_4;
   \                     ??checkToSendReqAddress_6: (+1)
   \       0x6E   0xF64C 0x4074      MOVW     R0,#+52340
   \       0x72   0x.... 0x....      LDR.W    R1,??DataTable31
   \       0x76   0x6809             LDR      R1,[R1, #+0]
   \       0x78   0x80C8             STRH     R0,[R1, #+6]
   3733                        break;
   \       0x7A   0xE005             B.N      ??checkToSendReqAddress_8
   3734                      default:
   3735                        pScuTmMapReg->tmAddrSconnM = KEY_SCU_SLAVE_LINKED_2;
   \                     ??checkToSendReqAddress_7: (+1)
   \       0x7C   0xF64C 0x4072      MOVW     R0,#+52338
   \       0x80   0x.... 0x....      LDR.W    R1,??DataTable31
   \       0x84   0x6809             LDR      R1,[R1, #+0]
   \       0x86   0x80C8             STRH     R0,[R1, #+6]
   3736                        break;
   3737                    }
   3738                    sbcSemInfoMng.dataVal = (uint16_t)0xFFFF;  /* set the flag for transmission executed to dummy state */
   \                     ??checkToSendReqAddress_8: (+1)
   \       0x88   0x.... 0x....      LDR.W    R8,??DataTable37
   \       0x8C   0xF64F 0x70FF      MOVW     R0,#+65535
   \       0x90   0xF8A8 0x0004      STRH     R0,[R8, #+4]
   3739                    sbcSemInfoMng.random = (uint32_t)getTagIdFromPrdSn();
   \       0x94   0x.... 0x....      BL       getTagIdFromPrdSn
   \       0x98   0xF8C8 0x001C      STR      R0,[R8, #+28]
   3740                    reqDelay =  (uint32_t)(sbcSemInfoMng.random / FACTOR_FOR_RANDOM_DELAY);  //  --> random delay from 0...2048 msec
   \       0x9C   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \       0xA0   0x0980             LSRS     R0,R0,#+6
   \       0xA2   0x0007             MOVS     R7,R0
   3741          
   3742                    /* to avoid possible conflit on first Tx byte a random delay is used  */
   3743                    //osDelay((uint32_t)(random / 100));  /* random delay in the range 0...655 msec depending on LSB CRC Product SN */
   3744                    
   3745                    while ((xTimerChangePeriod (xSbcSemTimers[TIMER_FOR_REQ_ADDR], reqDelay, SBCSEM_TIMER_GARD_TIME) != pdPASS)); 
   \                     ??checkToSendReqAddress_9: (+1)
   \       0xA4   0xF44F 0x70FA      MOV      R0,#+500
   \       0xA8   0x9000             STR      R0,[SP, #+0]
   \       0xAA   0x2300             MOVS     R3,#+0
   \       0xAC   0x003A             MOVS     R2,R7
   \       0xAE   0x2104             MOVS     R1,#+4
   \       0xB0   0x.... 0x....      LDR.W    R0,??DataTable31_1
   \       0xB4   0x6900             LDR      R0,[R0, #+16]
   \       0xB6   0x.... 0x....      BL       xTimerGenericCommand
   \       0xBA   0x2801             CMP      R0,#+1
   \       0xBC   0xD1F2             BNE.N    ??checkToSendReqAddress_9
   \       0xBE   0xE006             B.N      ??checkToSendReqAddress_1
   3746                  }
   3747                  else
   3748                  {
   3749                    sbcSemInfoMng.dataVal = getTagIdFromPrdSn();  // copy in the tag Id the product SN crc  
   \                     ??checkToSendReqAddress_3: (+1)
   \       0xC0   0x.... 0x....      BL       getTagIdFromPrdSn
   \       0xC4   0x.... 0x....      LDR.W    R1,??DataTable37
   \       0xC8   0x8088             STRH     R0,[R1, #+4]
   3750                    /* the slave SCU wait for address */
   3751                    retState = SBC_SEM_WAIT_RS485_ADDR;
   \       0xCA   0x200A             MOVS     R0,#+10
   \       0xCC   0x0006             MOVS     R6,R0
   3752                  }
   3753                }
   3754              }
   3755            }
   3756            return(retState);
   \                     ??checkToSendReqAddress_1: (+1)
   \       0xCE   0x0030             MOVS     R0,R6
   \       0xD0   0xB280             UXTH     R0,R0
   \       0xD2   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   3757          }
   3758          
   3759          /**
   3760          *
   3761          * @brief       Check the assigned address received from master 
   3762          *
   3763          * @param [in]  frameSbcSem_st*: pointer to received message    
   3764          *  
   3765          * @retval      uint8_t: error code (0 = no error)  
   3766          *  
   3767          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3768          static uint8_t  checkAssignNewAddress(frameSbcSem_st* pMsg) 
   3769          {
   \                     checkAssignNewAddress: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   3770            uint16_t*             pWord;
   3771            uint16_t              ixScu, maskBit, idLogic;
   3772            uint8_t               modbusAddr, error, deviceId1, deviceId2;
   3773          
   3774            pWord = (uint16_t *)pMsg->dataToSend.pData;
   \        0x6   0x68A5             LDR      R5,[R4, #+8]
   3775            error = osOK;
   \        0x8   0xF05F 0x0800      MOVS     R8,#+0
   3776          
   3777            /* the received message from master (word sequence): tag id - modbusAddress - device Id 1 - device Id 2 */
   3778            if (sbcSemInfoMng.dataVal == *pWord) // check if it is my tag id (crc SN)
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable37
   \       0x10   0x8880             LDRH     R0,[R0, #+4]
   \       0x12   0x8829             LDRH     R1,[R5, #+0]
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD166             BNE.N    ??checkAssignNewAddress_0
   3779            {
   3780              /* recovery the modbusAddress  */
   3781              pWord++;
   \       0x18   0x1CAD             ADDS     R5,R5,#+2
   3782              ixScu = modbusAddr = (uint8_t)(*pWord);
   \       0x1A   0x8828             LDRH     R0,[R5, #+0]
   \       0x1C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x20   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x24   0x0006             MOVS     R6,R0
   3783              modbusAddr--;                                    // for hystoryc reason we stored modbusAddr - 1
   \       0x26   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x2A   0x1E40             SUBS     R0,R0,#+1
   \       0x2C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3784              if (pMsg->data.rAddr == ADDR_TM_ADDR_REQ_RW)
   \       0x30   0x88A0             LDRH     R0,[R4, #+4]
   \       0x32   0xF240 0x5114      MOVW     R1,#+1300
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD157             BNE.N    ??checkAssignNewAddress_1
   3785              {
   3786                socketPresence.keyPresence = KEY_FULL_CONFIG;
   \       0x3A   0x.... 0x....      LDR.W    R11,??DataTable53
   \       0x3E   0xF64A 0x2055      MOVW     R0,#+43605
   \       0x42   0xF8CB 0x0008      STR      R0,[R11, #+8]
   3787                pWord++;
   \       0x46   0x1CA8             ADDS     R0,R5,#+2
   3788                deviceId1 = (uint8_t)(*pWord);                 // the master assign the address at the first socket i.e. the socket with SocketNumber = 1
   \       0x48   0x8801             LDRH     R1,[R0, #+0]
   \       0x4A   0x4689             MOV      R9,R1
   3789                pWord++;
   \       0x4C   0x1C85             ADDS     R5,R0,#+2
   3790                deviceId2 = (uint8_t)(*pWord);                 // the second device Id assigned from master  
   \       0x4E   0x8828             LDRH     R0,[R5, #+0]
   \       0x50   0x4682             MOV      R10,R0
   3791                if (getSktNumInFakeCode() == 1)
   \       0x52   0x.... 0x....      BL       getSktNumInFakeCode
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD103             BNE.N    ??checkAssignNewAddress_2
   3792                {
   3793                  idLogic = deviceId1;
   \       0x5A   0x4648             MOV      R0,R9
   \       0x5C   0xB2C0             UXTB     R0,R0
   \       0x5E   0x0007             MOVS     R7,R0
   \       0x60   0xE008             B.N      ??checkAssignNewAddress_3
   3794                }
   3795                else
   3796                {
   3797                  idLogic = deviceId2;
   \                     ??checkAssignNewAddress_2: (+1)
   \       0x62   0x4650             MOV      R0,R10
   \       0x64   0xB2C0             UXTB     R0,R0
   \       0x66   0x0007             MOVS     R7,R0
   3798                  modbusAddr++;                               // the linked SCU has address + 1 from the original SCU
   \       0x68   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x6C   0x1C40             ADDS     R0,R0,#+1
   \       0x6E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   3799                  ixScu++;
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   3800                }
   3801                maskBit = sbcSemMaskBit[idLogic];
   \                     ??checkAssignNewAddress_3: (+1)
   \       0x74   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \       0x78   0x0039             MOVS     R1,R7
   \       0x7A   0xB289             UXTH     R1,R1
   \       0x7C   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \       0x80   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   3802                socketPresence.livePresence |= maskBit;
   \       0x84   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \       0x88   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \       0x8C   0x4301             ORRS     R1,R0,R1
   \       0x8E   0xF8CB 0x1004      STR      R1,[R11, #+4]
   3803                socketPresence.matrixConv[idLogic] = ixScu;           // update matrix deviceId with physical Modbus Address
   \       0x92   0x0038             MOVS     R0,R7
   \       0x94   0xB280             UXTH     R0,R0
   \       0x96   0x4458             ADD      R0,R11,R0
   \       0x98   0x7406             STRB     R6,[R0, #+16]
   3804                socketPresence.matrixIdConn[idLogic] = idLogic + 1;   // update matrix idConn: default is device id + 1 (number on LCD)
   \       0x9A   0x1C78             ADDS     R0,R7,#+1
   \       0x9C   0x0039             MOVS     R1,R7
   \       0x9E   0xB289             UXTH     R1,R1
   \       0xA0   0x4459             ADD      R1,R11,R1
   \       0xA2   0xF881 0x0030      STRB     R0,[R1, #+48]
   3805          
   3806                /* a new address must be set */
   3807                eeprom_array_set(RS485_ADD_EADD, (uint8_t*)&modbusAddr, 1);
   \       0xA6   0x2201             MOVS     R2,#+1
   \       0xA8   0x4669             MOV      R1,SP
   \       0xAA   0x2009             MOVS     R0,#+9
   \       0xAC   0x.... 0x....      BL       eeprom_array_set
   3808                if (WriteOnEeprom(RS485_ADD_EADD, (uint8_t*)&modbusAddr, 1) == osOK)
   \       0xB0   0x2201             MOVS     R2,#+1
   \       0xB2   0x4669             MOV      R1,SP
   \       0xB4   0x2009             MOVS     R0,#+9
   \       0xB6   0x.... 0x....      BL       WriteOnEeprom
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD101             BNE.N    ??checkAssignNewAddress_4
   3809                {
   3810                  /* it necessary to change current SCU modbus address */
   3811                  updateScuModbusAddrr();
   \       0xBE   0x.... 0x....      BL       updateScuModbusAddrr
   3812                }
   3813                if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \                     ??checkAssignNewAddress_4: (+1)
   \       0xC2   0x2254             MOVS     R2,#+84
   \       0xC4   0x4659             MOV      R1,R11
   \       0xC6   0xF44F 0x50F4      MOV      R0,#+7808
   \       0xCA   0x.... 0x....      BL       WriteOnEeprom
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD106             BNE.N    ??checkAssignNewAddress_5
   3814                {
   3815                  tPrintf("Assigned Physical address %d\n\r", ixScu);
   \       0xD2   0x0031             MOVS     R1,R6
   \       0xD4   0xB289             UXTH     R1,R1
   \       0xD6   0x.... 0x....      LDR.W    R0,??DataTable53_2
   \       0xDA   0x.... 0x....      BL       tPrintf
   \       0xDE   0xE004             B.N      ??checkAssignNewAddress_1
   3816                }
   3817                else
   3818                {
   3819                  error = (uint8_t)1;
   \                     ??checkAssignNewAddress_5: (+1)
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0x4680             MOV      R8,R0
   \       0xE4   0xE001             B.N      ??checkAssignNewAddress_1
   3820                }
   3821              }
   3822            }
   3823            else
   3824            {
   3825              error = (uint8_t)2;
   \                     ??checkAssignNewAddress_0: (+1)
   \       0xE6   0x2002             MOVS     R0,#+2
   \       0xE8   0x4680             MOV      R8,R0
   3826            }
   3827            return(error);
   \                     ??checkAssignNewAddress_1: (+1)
   \       0xEA   0x4640             MOV      R0,R8
   \       0xEC   0xB2C0             UXTB     R0,R0
   \       0xEE   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   3828          }
   3829          
   3830          /**
   3831          *
   3832          * @brief       Manager the new modbus address request from a 
   3833          *              slave
   3834          *
   3835          * @param [in]  frameSbcSem_st*: pointer to received message    
   3836          *  
   3837          * @retval      none  
   3838          *  
   3839          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3840          static void  mngReqAddress(frameSbcSem_st* pMsg) 
   3841          {
   \                     mngReqAddress: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0xB085             SUB      SP,SP,#+20
   \        0x6   0x0004             MOVS     R4,R0
   3842            uint16_t*             pWord;
   3843            frameSbcSem_st        tmpFrameSbcSem;  
   3844            uint32_t              maskBit;
   3845          
   3846            sbcSemInfoMng.firstIdFree = getFirstFreeLogicId();
   \        0x8   0x.... 0x....      LDR.W    R7,??DataTable37
   \        0xC   0x.... 0x....      BL       getFirstFreeLogicId
   \       0x10   0x8078             STRH     R0,[R7, #+2]
   3847          #ifdef TRANSLATE_ID_LOGIC
   3848            sbcSemInfoMng.addrModFree = setModbusAddress();
   3849          #else
   3850            /* default relation is: address on modbus is logic Id (sbcSemInfoMng.firstIdFree) + 1 */
   3851            sbcSemInfoMng.addrModFree = sbcSemInfoMng.firstIdFree + 1;
   \       0x12   0x8878             LDRH     R0,[R7, #+2]
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \       0x16   0xF887 0x0026      STRB     R0,[R7, #+38]
   3852          #endif
   3853          
   3854            /* a  secondary slave SCU is present in the chain and requires an address */
   3855            pWord = (uint16_t *)pMsg->dataToSend.pData;
   \       0x1A   0x68A0             LDR      R0,[R4, #+8]
   3856            /* a  secondary master SCU is present in the chain and requires an address */
   3857            pScuTmMapReg->tmAddrSconnM = *pWord;                      // copy the flag for slave linked
   \       0x1C   0x.... 0x....      LDR.W    R8,??DataTable31
   \       0x20   0x8801             LDRH     R1,[R0, #+0]
   \       0x22   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x26   0x80D1             STRH     R1,[R2, #+6]
   3858            pWord++;
   \       0x28   0x1C81             ADDS     R1,R0,#+2
   3859            pScuTmMapReg->tmAddrReq = *pWord;                         // copy the tag Id 
   \       0x2A   0x8808             LDRH     R0,[R1, #+0]
   \       0x2C   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x30   0x8110             STRH     R0,[R2, #+8]
   3860             
   3861            pScuTmMapReg->tmAddrAss = (uint16_t)sbcSemInfoMng.addrModFree;          // assign the first free modbus address (LSB) 
   \       0x32   0xF897 0x0026      LDRB     R0,[R7, #+38]
   \       0x36   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x3A   0x8150             STRH     R0,[R2, #+10]
   3862            pScuTmMapReg->tmError1InTest = (uint16_t)sbcSemInfoMng.firstIdFree;     // assign the logic Id to be used for the slave in MSB
   \       0x3C   0x8878             LDRH     R0,[R7, #+2]
   \       0x3E   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x42   0x8190             STRH     R0,[R2, #+12]
   3863            pWord = (uint16_t*)&pScuTmMapReg->tmError1InTest;
   \       0x44   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x48   0xF110 0x050C      ADDS     R5,R0,#+12
   3864            tmpFrameSbcSem.dataToSend.len = (uint16_t)3;                            /* we send 3 word starting from ADDR_TM_ADDR_REQ_RW */
   \       0x4C   0x2003             MOVS     R0,#+3
   \       0x4E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   3865            tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \       0x52   0x2003             MOVS     R0,#+3
   \       0x54   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   3866            tmpFrameSbcSem.data.index = MODBUS_BROADCAST_ADDR;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
   3867            tmpFrameSbcSem.data.rAddr = ADDR_TM_ADDR_REQ_RW;
   \       0x5E   0xF240 0x5014      MOVW     R0,#+1300
   \       0x62   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   3868            tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&pScuTmMapReg->tmAddrReq;
   \       0x66   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x6A   0x3008             ADDS     R0,R0,#+8
   \       0x6C   0x9002             STR      R0,[SP, #+8]
   3869          
   3870            maskBit = sbcSemMaskBit[sbcSemInfoMng.firstIdFree];
   \       0x6E   0x.... 0x....      LDR.W    R9,??DataTable53_1
   \       0x72   0x8878             LDRH     R0,[R7, #+2]
   \       0x74   0xF859 0x6020      LDR      R6,[R9, R0, LSL #+2]
   3871            socketPresence.livePresence |= maskBit;
   \       0x78   0x.... 0x....      LDR.W    R10,??DataTable53
   \       0x7C   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0x80   0x4330             ORRS     R0,R6,R0
   \       0x82   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3872            socketPresence.chainPresence |= maskBit;
   \       0x86   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x8A   0x4330             ORRS     R0,R6,R0
   \       0x8C   0xF8CA 0x0000      STR      R0,[R10, #+0]
   3873            sbcSemInfoMng.activityStatus |= maskBit;
   \       0x90   0x6978             LDR      R0,[R7, #+20]
   \       0x92   0x4330             ORRS     R0,R6,R0
   \       0x94   0x6178             STR      R0,[R7, #+20]
   3874            socketPresence.matrixConv[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.addrModFree;
   \       0x96   0xF897 0x0026      LDRB     R0,[R7, #+38]
   \       0x9A   0x887A             LDRH     R2,[R7, #+2]
   \       0x9C   0x4452             ADD      R2,R10,R2
   \       0x9E   0x7410             STRB     R0,[R2, #+16]
   3875            socketPresence.matrixIdConn[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.firstIdFree + 1;
   \       0xA0   0x8878             LDRH     R0,[R7, #+2]
   \       0xA2   0x1C40             ADDS     R0,R0,#+1
   \       0xA4   0x887A             LDRH     R2,[R7, #+2]
   \       0xA6   0x4452             ADD      R2,R10,R2
   \       0xA8   0xF882 0x0030      STRB     R0,[R2, #+48]
   3876            if (sbcSemInfoMng.discoveryMask == 0)
   \       0xAC   0xF117 0x020A      ADDS     R2,R7,#+10
   \       0xB0   0x6810             LDR      R0,[R2, #+0]
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD102             BNE.N    ??mngReqAddress_0
   3877            {
   3878              sbcSemInfoMng.discoveryMask = maskBit;                        // set the mask to start the next info request phase 
   \       0xB6   0x6016             STR      R6,[R2, #+0]
   3879              sbcSemInfoMng.logicIdSocket = sbcSemInfoMng.firstIdFree;      // set the logic address for the first new assigned socket 
   \       0xB8   0x8878             LDRH     R0,[R7, #+2]
   \       0xBA   0x8138             STRH     R0,[R7, #+8]
   3880            }
   3881            if ((pScuTmMapReg->tmAddrSconnM == KEY_SCU_SLAVE_LINKED_2) || (pScuTmMapReg->tmAddrSconnM == KEY_SCU_SLAVE_LINKED_4))
   \                     ??mngReqAddress_0: (+1)
   \       0xBC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xC0   0x88C0             LDRH     R0,[R0, #+6]
   \       0xC2   0xF64C 0x4172      MOVW     R1,#+52338
   \       0xC6   0x4288             CMP      R0,R1
   \       0xC8   0xD007             BEQ.N    ??mngReqAddress_1
   \       0xCA   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xCE   0x88C0             LDRH     R0,[R0, #+6]
   \       0xD0   0xF64C 0x4174      MOVW     R1,#+52340
   \       0xD4   0x4288             CMP      R0,R1
   \       0xD6   0xF040 0x808A      BNE.W    ??mngReqAddress_2
   3882            {
   3883              sbcSemInfoMng.firstIdFree = getFirstFreeLogicId();
   \                     ??mngReqAddress_1: (+1)
   \       0xDA   0x.... 0x....      BL       getFirstFreeLogicId
   \       0xDE   0x8078             STRH     R0,[R7, #+2]
   3884          #ifdef TRANSLATE_ID_LOGIC
   3885              sbcSemInfoMng.addrModFree = setModbusAddress();
   3886          #else
   3887              /* default relation is: address on modbus is logic Id (sbcSemInfoMng.firstIdFree) + 1 */
   3888              sbcSemInfoMng.addrModFree = sbcSemInfoMng.firstIdFree + 1;
   \       0xE0   0x8878             LDRH     R0,[R7, #+2]
   \       0xE2   0x1C40             ADDS     R0,R0,#+1
   \       0xE4   0xF887 0x0026      STRB     R0,[R7, #+38]
   3889          #endif
   3890              /* this secondary slave  has a SCU slave linked the next id is assigned using same tagId*/
   3891              maskBit = sbcSemMaskBit[sbcSemInfoMng.firstIdFree];
   \       0xE8   0x8878             LDRH     R0,[R7, #+2]
   \       0xEA   0xF859 0x0020      LDR      R0,[R9, R0, LSL #+2]
   \       0xEE   0x0006             MOVS     R6,R0
   3892              socketPresence.livePresence |= maskBit;
   \       0xF0   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0xF4   0x4330             ORRS     R0,R6,R0
   \       0xF6   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3893              socketPresence.chainPresence |= maskBit;
   \       0xFA   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0xFE   0x4330             ORRS     R0,R6,R0
   \      0x100   0xF8CA 0x0000      STR      R0,[R10, #+0]
   3894              sbcSemInfoMng.activityStatus |= maskBit;
   \      0x104   0x6978             LDR      R0,[R7, #+20]
   \      0x106   0x4330             ORRS     R0,R6,R0
   \      0x108   0x6178             STR      R0,[R7, #+20]
   3895              socketPresence.matrixConv[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.addrModFree;
   \      0x10A   0xF897 0x0026      LDRB     R0,[R7, #+38]
   \      0x10E   0x8879             LDRH     R1,[R7, #+2]
   \      0x110   0x4451             ADD      R1,R10,R1
   \      0x112   0x7408             STRB     R0,[R1, #+16]
   3896              socketPresence.matrixIdConn[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.firstIdFree + 1;
   \      0x114   0x8878             LDRH     R0,[R7, #+2]
   \      0x116   0x1C40             ADDS     R0,R0,#+1
   \      0x118   0x8879             LDRH     R1,[R7, #+2]
   \      0x11A   0x4451             ADD      R1,R10,R1
   \      0x11C   0xF881 0x0030      STRB     R0,[R1, #+48]
   3897              /* update info for the slave */
   3898              tmpFrameSbcSem.dataToSend.len++;                                        /* we send 4 word starting from ADDR_TM_ADDR_REQ_RW */
   \      0x120   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x124   0x1C40             ADDS     R0,R0,#+1
   \      0x126   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   3899              pWord++;
   \      0x12A   0x1CAD             ADDS     R5,R5,#+2
   3900              *pWord = (uint16_t)sbcSemInfoMng.firstIdFree;
   \      0x12C   0x8878             LDRH     R0,[R7, #+2]
   \      0x12E   0x8028             STRH     R0,[R5, #+0]
   3901          
   3902              if (pScuTmMapReg->tmAddrSconnM == KEY_SCU_SLAVE_LINKED_4)
   \      0x130   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x134   0x88C0             LDRH     R0,[R0, #+6]
   \      0x136   0xF64C 0x4174      MOVW     R1,#+52340
   \      0x13A   0x4288             CMP      R0,R1
   \      0x13C   0xD157             BNE.N    ??mngReqAddress_2
   3903              {
   3904                sbcSemInfoMng.firstIdFree = getFirstFreeLogicId();
   \      0x13E   0x.... 0x....      BL       getFirstFreeLogicId
   \      0x142   0x8078             STRH     R0,[R7, #+2]
   3905          #ifdef TRANSLATE_ID_LOGIC
   3906                sbcSemInfoMng.addrModFree = setModbusAddress();
   3907          #else
   3908                /* default relation is: address on modbus is logic Id (sbcSemInfoMng.firstIdFree) + 1 */
   3909                sbcSemInfoMng.addrModFree = sbcSemInfoMng.firstIdFree + 1;
   \      0x144   0x8878             LDRH     R0,[R7, #+2]
   \      0x146   0x1C40             ADDS     R0,R0,#+1
   \      0x148   0xF887 0x0026      STRB     R0,[R7, #+38]
   3910          #endif
   3911                /* this secondary master has a 3 SCU slave linked the next id is assigned using same tagId*/
   3912                maskBit = sbcSemMaskBit[sbcSemInfoMng.firstIdFree];
   \      0x14C   0x8878             LDRH     R0,[R7, #+2]
   \      0x14E   0xF859 0x8020      LDR      R8,[R9, R0, LSL #+2]
   3913                socketPresence.livePresence |= maskBit;
   \      0x152   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x156   0xEA58 0x0000      ORRS     R0,R8,R0
   \      0x15A   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3914                socketPresence.chainPresence |= maskBit;
   \      0x15E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x162   0xEA58 0x0000      ORRS     R0,R8,R0
   \      0x166   0xF8CA 0x0000      STR      R0,[R10, #+0]
   3915                sbcSemInfoMng.activityStatus |= maskBit;
   \      0x16A   0x6978             LDR      R0,[R7, #+20]
   \      0x16C   0xEA58 0x0000      ORRS     R0,R8,R0
   \      0x170   0x6178             STR      R0,[R7, #+20]
   3916                socketPresence.matrixConv[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.addrModFree;
   \      0x172   0xF897 0x0026      LDRB     R0,[R7, #+38]
   \      0x176   0x8879             LDRH     R1,[R7, #+2]
   \      0x178   0x4451             ADD      R1,R10,R1
   \      0x17A   0x7408             STRB     R0,[R1, #+16]
   3917                socketPresence.matrixIdConn[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.firstIdFree + 1;
   \      0x17C   0x8878             LDRH     R0,[R7, #+2]
   \      0x17E   0x1C40             ADDS     R0,R0,#+1
   \      0x180   0x8879             LDRH     R1,[R7, #+2]
   \      0x182   0x4451             ADD      R1,R10,R1
   \      0x184   0xF881 0x0030      STRB     R0,[R1, #+48]
   3918                /* update info for the slave */
   3919                tmpFrameSbcSem.dataToSend.len++;                                        /* we send 5 word starting from ADDR_TM_ADDR_REQ_RW */
   \      0x188   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x18C   0x1C40             ADDS     R0,R0,#+1
   \      0x18E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   3920                pWord++;
   \      0x192   0x1CAD             ADDS     R5,R5,#+2
   3921                *pWord = (uint16_t)sbcSemInfoMng.firstIdFree;
   \      0x194   0x8878             LDRH     R0,[R7, #+2]
   \      0x196   0x8028             STRH     R0,[R5, #+0]
   3922          
   3923                /* set the 4th socket */
   3924                sbcSemInfoMng.firstIdFree = getFirstFreeLogicId();
   \      0x198   0x.... 0x....      BL       getFirstFreeLogicId
   \      0x19C   0x8078             STRH     R0,[R7, #+2]
   3925          #ifdef TRANSLATE_ID_LOGIC
   3926                sbcSemInfoMng.addrModFree = setModbusAddress();
   3927          #else
   3928                /* default relation is: address on modbus is logic Id (sbcSemInfoMng.firstIdFree) + 1 */
   3929                sbcSemInfoMng.addrModFree = sbcSemInfoMng.firstIdFree + 1;
   \      0x19E   0x8878             LDRH     R0,[R7, #+2]
   \      0x1A0   0x1C40             ADDS     R0,R0,#+1
   \      0x1A2   0xF887 0x0026      STRB     R0,[R7, #+38]
   3930          #endif
   3931                maskBit = sbcSemMaskBit[sbcSemInfoMng.firstIdFree];
   \      0x1A6   0x8878             LDRH     R0,[R7, #+2]
   \      0x1A8   0xF859 0x0020      LDR      R0,[R9, R0, LSL #+2]
   \      0x1AC   0x0006             MOVS     R6,R0
   3932                socketPresence.livePresence |= maskBit;
   \      0x1AE   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x1B2   0x4330             ORRS     R0,R6,R0
   \      0x1B4   0xF8CA 0x0004      STR      R0,[R10, #+4]
   3933                socketPresence.chainPresence |= maskBit;
   \      0x1B8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1BC   0x4330             ORRS     R0,R6,R0
   \      0x1BE   0xF8CA 0x0000      STR      R0,[R10, #+0]
   3934                sbcSemInfoMng.activityStatus |= maskBit;
   \      0x1C2   0x6978             LDR      R0,[R7, #+20]
   \      0x1C4   0x4330             ORRS     R0,R6,R0
   \      0x1C6   0x6178             STR      R0,[R7, #+20]
   3935                socketPresence.matrixConv[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.addrModFree;
   \      0x1C8   0xF897 0x0026      LDRB     R0,[R7, #+38]
   \      0x1CC   0x8879             LDRH     R1,[R7, #+2]
   \      0x1CE   0x4451             ADD      R1,R10,R1
   \      0x1D0   0x7408             STRB     R0,[R1, #+16]
   3936                socketPresence.matrixIdConn[sbcSemInfoMng.firstIdFree] = (uint8_t)sbcSemInfoMng.firstIdFree + 1;
   \      0x1D2   0x8878             LDRH     R0,[R7, #+2]
   \      0x1D4   0x1C40             ADDS     R0,R0,#+1
   \      0x1D6   0x8879             LDRH     R1,[R7, #+2]
   \      0x1D8   0x4451             ADD      R1,R10,R1
   \      0x1DA   0xF881 0x0030      STRB     R0,[R1, #+48]
   3937                /* update info for the slave */
   3938                tmpFrameSbcSem.dataToSend.len++;                                        /* we send 6 word starting from ADDR_TM_ADDR_REQ_RW */
   \      0x1DE   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \      0x1E2   0x1C40             ADDS     R0,R0,#+1
   \      0x1E4   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   3939                pWord++;
   \      0x1E8   0x1CAD             ADDS     R5,R5,#+2
   3940                *pWord = (uint16_t)sbcSemInfoMng.firstIdFree;
   \      0x1EA   0x8878             LDRH     R0,[R7, #+2]
   \      0x1EC   0x8028             STRH     R0,[R5, #+0]
   3941              }
   3942            }
   3943            configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \                     ??mngReqAddress_2: (+1)
   \      0x1EE   0x.... 0x....      BL       getRs485SemQueueHandle
   \      0x1F2   0x2300             MOVS     R3,#+0
   \      0x1F4   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \      0x1F8   0x4669             MOV      R1,SP
   \      0x1FA   0x.... 0x....      BL       xQueueGenericSend
   \      0x1FE   0x2801             CMP      R0,#+1
   \      0x200   0xD009             BEQ.N    ??mngReqAddress_3
   \      0x202   0xB672             CPSID    I
   \      0x204   0x2050             MOVS     R0,#+80
   \      0x206   0xF380 0x8811      MSR      BASEPRI,R0
   \      0x20A   0xF3BF 0x8F4F      DSB      SY
   \      0x20E   0xF3BF 0x8F6F      ISB      SY
   \      0x212   0xB662             CPSIE    I
   \                     ??mngReqAddress_4: (+1)
   \      0x214   0xE7FE             B.N      ??mngReqAddress_4
   3944            restartSbcSemTimer(TIMER_FIND_CONFIG, WAIT_FOR_NEXT_DISCOVERY); // the master restart the timeout 2500msec
   \                     ??mngReqAddress_3: (+1)
   \      0x216   0xF640 0x11C4      MOVW     R1,#+2500
   \      0x21A   0x2000             MOVS     R0,#+0
   \      0x21C   0x.... 0x....      BL       restartSbcSemTimer
   3945          }
   \      0x220   0xB006             ADD      SP,SP,#+24
   \      0x222   0xE8BD 0x87F0      POP      {R4-R10,PC}
   3946          
   3947          /**
   3948          *
   3949          * @brief       get pointer to socket info  
   3950          *
   3951          * @param [in]  none    
   3952          *  
   3953          * @retval      none  
   3954          *  
   3955          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3956          socketPresence_t* getDefSocketInfoPtr(void) 
   3957          {
   3958          
   3959            return((socketPresence_t*)&Default_Socket_Presence);
   \                     getDefSocketInfoPtr: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53_3
   \        0x4   0x4770             BX       LR
   3960          }
   3961          
   3962          /**
   3963          *
   3964          * @brief       get the number of discovered socket (could be > 
   3965          *              then socketPresence.livePresence
   3966          *
   3967          * @param [in]  none    
   3968          *  
   3969          * @retval      uint16_t: bit position discovered sockets  
   3970          *  
   3971          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3972          uint32_t getSocketDiscovered(void) 
   3973          {
   3974          
   3975            return(socketPresence.chainPresence);
   \                     getSocketDiscovered: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x4770             BX       LR
   3976          }
   3977          
   3978          /**
   3979          *
   3980          * @brief       save the number of effective socket 
   3981          *
   3982          * @param [in]  uint16_t: bit mask for present sockets    
   3983          *  
   3984          * @retval      none  
   3985          *  
   3986          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3987          void setSocketDiscovered(uint16_t maskPresence) 
   3988          {
   \                     setSocketDiscovered: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3989          
   3990            socketPresence.chainPresence = maskPresence;
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable53
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0xB280             UXTH     R0,R0
   \        0xC   0x6028             STR      R0,[R5, #+0]
   3991            /* save in EEPROM also  */
   3992            if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \        0xE   0x2254             MOVS     R2,#+84
   \       0x10   0x0029             MOVS     R1,R5
   \       0x12   0xF44F 0x50F4      MOV      R0,#+7808
   \       0x16   0x.... 0x....      BL       WriteOnEeprom
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD104             BNE.N    ??setSocketDiscovered_0
   3993            {
   3994              tPrintf("Presences confirmed --> 0x%x\n\r", socketPresence.chainPresence);
   \       0x1E   0x6829             LDR      R1,[R5, #+0]
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable53_4
   \       0x24   0x.... 0x....      BL       tPrintf
   3995            }
   3996          }
   \                     ??setSocketDiscovered_0: (+1)
   \       0x28   0xBD31             POP      {R0,R4,R5,PC}
   3997          
   3998          /**
   3999          *
   4000          * @brief       Restore all SCU to factory parameters  
   4001          *
   4002          * @param [in]  none    
   4003          *  
   4004          * @retval      none  
   4005          *  
   4006          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4007          void restoreFactoryDefaultForAll(void) 
   4008          {
   \                     restoreFactoryDefaultForAll: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   4009            frameSbcSem_st        tmpFrameSbcSem;  
   4010          
   4011            if (isSemMasterFz() == TRUE)
   \        0x4   0x.... 0x....      BL       isSemMasterFz
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD12E             BNE.N    ??restoreFactoryDefaultForAll_0
   4012            {
   4013              sbcSemInfoMng.dataVal = (uint16_t)SCU_ALL_FACTORY_PARAM;   
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable53_5
   \       0x10   0xF64F 0x71EC      MOVW     R1,#+65516
   \       0x14   0x8081             STRH     R1,[R0, #+4]
   4014              tmpFrameSbcSem.sbcSemEvent = NOTIFY_TO_SLAVE_TX;
   \       0x16   0x2103             MOVS     R1,#+3
   \       0x18   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   4015              tmpFrameSbcSem.data.index = MODBUS_BROADCAST_ADDR;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0xF8AD 0x1002      STRH     R1,[SP, #+2]
   4016              tmpFrameSbcSem.data.rAddr = ADDR_EVSE_TM_RW;
   \       0x22   0x2122             MOVS     R1,#+34
   \       0x24   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   4017              tmpFrameSbcSem.dataToSend.pData = (uint8_t*)&sbcSemInfoMng.dataVal;
   \       0x28   0x1D00             ADDS     R0,R0,#+4
   \       0x2A   0x9002             STR      R0,[SP, #+8]
   4018              tmpFrameSbcSem.dataToSend.len = LEN_EVSE_TM_MODE_RW;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   4019              configASSERT(xQueueSendToBack(getRs485SemQueueHandle(), (void *)&tmpFrameSbcSem, portMAX_DELAY) == pdPASS);  // rs485SemMsgProcess()
   \       0x32   0x.... 0x....      BL       getRs485SemQueueHandle
   \       0x36   0x2300             MOVS     R3,#+0
   \       0x38   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x3C   0x4669             MOV      R1,SP
   \       0x3E   0x.... 0x....      BL       xQueueGenericSend
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD009             BEQ.N    ??restoreFactoryDefaultForAll_1
   \       0x46   0xB672             CPSID    I
   \       0x48   0x2050             MOVS     R0,#+80
   \       0x4A   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x4E   0xF3BF 0x8F4F      DSB      SY
   \       0x52   0xF3BF 0x8F6F      ISB      SY
   \       0x56   0xB662             CPSIE    I
   \                     ??restoreFactoryDefaultForAll_2: (+1)
   \       0x58   0xE7FE             B.N      ??restoreFactoryDefaultForAll_2
   4020              osDelay(500);
   \                     ??restoreFactoryDefaultForAll_1: (+1)
   \       0x5A   0xF44F 0x70FA      MOV      R0,#+500
   \       0x5E   0x.... 0x....      BL       osDelay
   4021              eraseAllBoardInfoEeprom();
   \       0x62   0x.... 0x....      BL       eraseAllBoardInfoEeprom
   4022              restoreFactoryDefault();
   \       0x66   0x.... 0x....      BL       restoreFactoryDefault
   4023            }
   4024          }
   \                     ??restoreFactoryDefaultForAll_0: (+1)
   \       0x6A   0xB005             ADD      SP,SP,#+20
   \       0x6C   0xBD00             POP      {PC}
   4025          
   4026          /**
   4027          *
   4028          * @brief       Get the modbus control manager status   
   4029          *
   4030          * @param [in]  none    
   4031          *  
   4032          * @retval      uint8_t: TRUE if operative   
   4033          *  
   4034          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4035          uint8_t isModbusManagerActive (void) 
   4036          {
   4037            if (sbcSemInfoMng.sbcSemStates == SBC_SEM_OPERATIVE) return(TRUE); else return(FALSE);
   \                     isModbusManagerActive: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53_5
   \        0x4   0x8800             LDRH     R0,[R0, #+0]
   \        0x6   0x2804             CMP      R0,#+4
   \        0x8   0xD101             BNE.N    ??isModbusManagerActive_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??isModbusManagerActive_1
   \                     ??isModbusManagerActive_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??isModbusManagerActive_1: (+1)
   \       0x10   0x4770             BX       LR
   4038          }
   4039          
   4040          /**
   4041          *
   4042          * @brief       Get the slave status operative   
   4043          *
   4044          * @param [in]  none    
   4045          *  
   4046          * @retval      uint8_t: TRUE if the slave in a no transmission 
   4047          *              window (wait to be operative, typically a little
   4048          *              time after the address has been assigned)
   4049          *  
   4050          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4051          uint8_t isSlaveWaitToBeOperative (void) 
   4052          {
   4053            if (sbcSemInfoMng.sbcSemStates == SBC_SEM_BLANK_AFTER_ASS_ADDR) return(TRUE); else return(FALSE);
   \                     isSlaveWaitToBeOperative: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53_5
   \        0x4   0x8800             LDRH     R0,[R0, #+0]
   \        0x6   0x280F             CMP      R0,#+15
   \        0x8   0xD101             BNE.N    ??isSlaveWaitToBeOperative_0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE000             B.N      ??isSlaveWaitToBeOperative_1
   \                     ??isSlaveWaitToBeOperative_0: (+1)
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??isSlaveWaitToBeOperative_1: (+1)
   \       0x10   0x4770             BX       LR
   4054          }
   4055          
   4056          
   4057          /**
   4058          *
   4059          * @brief        Task to manage the the remote suspend / release  command    
   4060          *
   4061          * @param [in]   void*: parameters task  
   4062          *
   4063          * @retval       none 
   4064          *
   4065          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4066          static void remoteMngTask (void * pvParameters)
   4067          {
   \                     remoteMngTask: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4068            frameRemote_st frameRemote;  
   4069            uint32_t       timeTickRemote;
   4070          
   4071            /*-------- Creates an empty mailbox for uart  messages --------------------------*/
   4072            remoteMngQueue = xQueueCreate(NUM_BUFF_REMOTE, sizeof(frameRemote_st));
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable53_6
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x2103             MOVS     R1,#+3
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0x.... 0x....      BL       xQueueGenericCreate
   \       0x12   0x6028             STR      R0,[R5, #+0]
   4073            configASSERT(remoteMngQueue != NULL);
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD109             BNE.N    ??remoteMngTask_0
   \       0x1A   0xB672             CPSID    I
   \       0x1C   0x2050             MOVS     R0,#+80
   \       0x1E   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x22   0xF3BF 0x8F4F      DSB      SY
   \       0x26   0xF3BF 0x8F6F      ISB      SY
   \       0x2A   0xB662             CPSIE    I
   \                     ??remoteMngTask_1: (+1)
   \       0x2C   0xE7FE             B.N      ??remoteMngTask_1
   4074            
   4075            /* init structure for management */
   4076            remoteMng.remoteStates = REMOTE_INIT;
   \                     ??remoteMngTask_0: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x.... 0x....      LDR.W    R1,??DataTable53_7
   \       0x34   0x7008             STRB     R0,[R1, #+0]
   4077          
   4078            timeTickRemote = TIMER_ACTION_AT_START;
   \       0x36   0x26C8             MOVS     R6,#+200
   4079          
   4080            for (;;)
   4081            {
   4082              /* Wait for some event from timer or message   */
   4083              if (xQueueReceive(remoteMngQueue, (void *)&frameRemote, timeTickRemote) == pdPASS)
   \                     ??remoteMngTask_2: (+1)
   \       0x38   0x0032             MOVS     R2,R6
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x.... 0x....      BL       xQueueReceive
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD104             BNE.N    ??remoteMngTask_3
   4084              {
   4085                timeTickRemote = remoteSuspRelProcess(&frameRemote);
   \       0x46   0x4668             MOV      R0,SP
   \       0x48   0x.... 0x....      BL       remoteSuspRelProcess
   \       0x4C   0x0006             MOVS     R6,R0
   \       0x4E   0xE7F3             B.N      ??remoteMngTask_2
   4086              }
   4087              else
   4088              {
   4089                frameRemote.currentEvent = REMOTE_TIMEOUT;
   \                     ??remoteMngTask_3: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xF88D 0x0000      STRB     R0,[SP, #+0]
   4090                timeTickRemote = remoteSuspRelProcess(&frameRemote);
   \       0x56   0x4668             MOV      R0,SP
   \       0x58   0x.... 0x....      BL       remoteSuspRelProcess
   \       0x5C   0x0006             MOVS     R6,R0
   \       0x5E   0xE7EB             B.N      ??remoteMngTask_2
   4091              }
   4092            }
   4093          }
   4094          
   4095          /**
   4096          *
   4097          * @brief        Manage the polling on present slave  
   4098          *
   4099          * @param [in]   frameSbcSem_st*: pointer to incoming message 
   4100          *
   4101          * @retval       uint32_t: new timeout 
   4102          *
   4103          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4104          static uint32_t remoteSuspRelProcess(frameRemote_st* pMsg)
   4105          {
   \                     remoteSuspRelProcess: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   4106            uint32_t              timeTickTmp, temp32;
   4107          
   4108          
   4109            timeTickTmp = portMAX_DELAY;
   \        0x4   0xF05F 0x36FF      MOVS     R6,#+4294967295
   4110          
   4111            if (pMsg->currentEvent == RETURN_TO_OPERATIVE) 
   \        0x8   0x7828             LDRB     R0,[R5, #+0]
   \        0xA   0x2810             CMP      R0,#+16
   \        0xC   0xD105             BNE.N    ??remoteSuspRelProcess_0
   4112            {
   4113              remoteMng.remoteStates = REMOTE_OPERATIVE;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable53_7
   \       0x14   0x7008             STRB     R0,[R1, #+0]
   4114              return(timeTickTmp);
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xE097             B.N      ??remoteSuspRelProcess_1
   4115           }
   4116          
   4117            switch (remoteMng.remoteStates)
   \                     ??remoteSuspRelProcess_0: (+1)
   \       0x1A   0x.... 0x....      LDR.W    R7,??DataTable53_7
   \       0x1E   0x7838             LDRB     R0,[R7, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD009             BEQ.N    ??remoteSuspRelProcess_2
   \       0x24   0x2802             CMP      R0,#+2
   \       0x26   0xD045             BEQ.N    ??remoteSuspRelProcess_3
   \       0x28   0xD319             BCC.N    ??remoteSuspRelProcess_4
   \       0x2A   0x2804             CMP      R0,#+4
   \       0x2C   0xD068             BEQ.N    ??remoteSuspRelProcess_5
   \       0x2E   0xD341             BCC.N    ??remoteSuspRelProcess_3
   \       0x30   0x2805             CMP      R0,#+5
   \       0x32   0xF000 0x807F      BEQ.W    ??remoteSuspRelProcess_6
   \       0x36   0xE087             B.N      ??remoteSuspRelProcess_7
   4118            {
   4119              case REMOTE_INIT:
   4120                switch (pMsg->currentEvent)
   \                     ??remoteSuspRelProcess_2: (+1)
   \       0x38   0x7828             LDRB     R0,[R5, #+0]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD10E             BNE.N    ??remoteSuspRelProcess_8
   4121                {
   4122                  case REMOTE_TIMEOUT:
   4123                    if (getRemotePmFlag() == TRUE)
   \       0x3E   0x.... 0x....      BL       getRemotePmFlag
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD107             BNE.N    ??remoteSuspRelProcess_9
   4124                    {
   4125                      /* to inform Vania's world to use current max power defined by SEM or default */
   4126                      temp32 = getMaxTempPowerAc();
   \       0x46   0x.... 0x....      BL       getMaxTempPowerAc
   \       0x4A   0x0004             MOVS     R4,R0
   4127                      pmng_sem_power_set((uint16_t)temp32, 0xFF);
   \       0x4C   0x21FF             MOVS     R1,#+255
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0xB280             UXTH     R0,R0
   \       0x52   0x.... 0x....      BL       pmng_sem_power_set
   4128                    }
   4129                    /* no action on timeout after task is started */
   4130                    remoteMng.remoteStates = REMOTE_OPERATIVE;
   \                     ??remoteSuspRelProcess_9: (+1)
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0x7038             STRB     R0,[R7, #+0]
   4131                    break;
   \       0x5A   0xE7FF             B.N      ??remoteSuspRelProcess_10
   4132          
   4133                  default:
   4134                    break;
   4135                }
   4136                break;
   \                     ??remoteSuspRelProcess_8: (+1)
   \                     ??remoteSuspRelProcess_10: (+1)
   \       0x5C   0xE074             B.N      ??remoteSuspRelProcess_11
   4137          
   4138              case REMOTE_OPERATIVE:
   4139                switch (pMsg->currentEvent)
   \                     ??remoteSuspRelProcess_4: (+1)
   \       0x5E   0x7828             LDRB     R0,[R5, #+0]
   \       0x60   0x280F             CMP      R0,#+15
   \       0x62   0xD012             BEQ.N    ??remoteSuspRelProcess_12
   \       0x64   0x2817             CMP      R0,#+23
   \       0x66   0xD124             BNE.N    ??remoteSuspRelProcess_13
   4140                {
   4141                  case REMOTE_EVS_AUTH_START:
   4142                    temp32 = getMaxTempPowerAc();
   \                     ??remoteSuspRelProcess_14: (+1)
   \       0x68   0x.... 0x....      BL       getMaxTempPowerAc
   \       0x6C   0x0004             MOVS     R4,R0
   4143                    if (temp32 != 0)
   \       0x6E   0x2C00             CMP      R4,#+0
   \       0x70   0xD005             BEQ.N    ??remoteSuspRelProcess_15
   4144                    {
   4145                      /* SBC has written a non null power --> remove remote suspend if present  */
   4146                      send_to_evs(EVS_REMOTE_RELEASE);
   \       0x72   0x200E             MOVS     R0,#+14
   \       0x74   0x.... 0x....      BL       send_to_evs
   4147                      osDelay(100);
   \       0x78   0x2064             MOVS     R0,#+100
   \       0x7A   0x.... 0x....      BL       osDelay
   4148                    }
   4149                    send_to_evs(EVS_AUTH_START);
   \                     ??remoteSuspRelProcess_15: (+1)
   \       0x7E   0x2017             MOVS     R0,#+23
   \       0x80   0x.... 0x....      BL       send_to_evs
   4150                    remoteMng.remoteStates = REMOTE_EVS_AUTH;
   \       0x84   0x2002             MOVS     R0,#+2
   \       0x86   0x7038             STRB     R0,[R7, #+0]
   4151                    break;
   \       0x88   0xE013             B.N      ??remoteSuspRelProcess_16
   4152          
   4153                  case REMOTE_MAX_POWER_CHANGE:
   4154                    temp32 = getMaxTempPowerAc();
   \                     ??remoteSuspRelProcess_12: (+1)
   \       0x8A   0x.... 0x....      BL       getMaxTempPowerAc
   \       0x8E   0x0004             MOVS     R4,R0
   4155                    pmng_sem_power_set((uint16_t)temp32, 1);
   \       0x90   0x2101             MOVS     R1,#+1
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0xB280             UXTH     R0,R0
   \       0x96   0x.... 0x....      BL       pmng_sem_power_set
   4156          /*          if (evs_mode_get() == EVS_FREE_MODE)
   4157                    {
   4158                      if ((evs_state_get() == EVSTATE_CHARGING) && (temp32 == (uint32_t)0))
   4159                      {
   4160                        remoteMng.remoteStates = REMOTE_EVS_SUSPENDING;
   4161                        send_to_evs(EVS_REMOTE_SUSPENDING);
   4162                      }
   4163                      else
   4164                      {
   4165                        if ((evs_state_get() == EVSTATE_SUSPENDING) && (temp32 != (uint32_t)0))
   4166                        {
   4167                          remoteMng.remoteStates = REMOTE_EVS_RELEASE;
   4168                          send_to_evs(EVS_REMOTE_RELEASE);
   4169                        }
   4170                      }
   4171                    }
   4172                    else*/
   4173                    {
   4174                      if (temp32 == 0)
   \       0x9A   0x2C00             CMP      R4,#+0
   \       0x9C   0xD105             BNE.N    ??remoteSuspRelProcess_17
   4175                      {
   4176                        remoteMng.remoteStates = REMOTE_EVS_SUSPENDING;
   \       0x9E   0x2004             MOVS     R0,#+4
   \       0xA0   0x7038             STRB     R0,[R7, #+0]
   4177                        send_to_evs(EVS_REMOTE_SUSPENDING);
   \       0xA2   0x200D             MOVS     R0,#+13
   \       0xA4   0x.... 0x....      BL       send_to_evs
   \       0xA8   0xE002             B.N      ??remoteSuspRelProcess_18
   4178                      }
   4179                      else
   4180                      {
   4181                        /* SBC has written a non null power --> remove remote suspend if present  */
   4182                        send_to_evs(EVS_REMOTE_RELEASE);
   \                     ??remoteSuspRelProcess_17: (+1)
   \       0xAA   0x200E             MOVS     R0,#+14
   \       0xAC   0x.... 0x....      BL       send_to_evs
   4183                      }
   4184                    }
   4185                    break;
   \                     ??remoteSuspRelProcess_18: (+1)
   \       0xB0   0xE7FF             B.N      ??remoteSuspRelProcess_16
   4186          
   4187                  default:
   4188                    break;
   4189                }
   4190                break;
   \                     ??remoteSuspRelProcess_13: (+1)
   \                     ??remoteSuspRelProcess_16: (+1)
   \       0xB2   0xE049             B.N      ??remoteSuspRelProcess_11
   4191          
   4192              case REMOTE_EVS_AUTH:
   4193              case REMOTE_EVS_RELEASE:
   4194                switch (pMsg->currentEvent)
   \                     ??remoteSuspRelProcess_3: (+1)
   \       0xB4   0x7828             LDRB     R0,[R5, #+0]
   \       0xB6   0x280F             CMP      R0,#+15
   \       0xB8   0xD004             BEQ.N    ??remoteSuspRelProcess_19
   \       0xBA   0x2817             CMP      R0,#+23
   \       0xBC   0xD016             BEQ.N    ??remoteSuspRelProcess_20
   \       0xBE   0x2819             CMP      R0,#+25
   \       0xC0   0xD017             BEQ.N    ??remoteSuspRelProcess_21
   \       0xC2   0xE01C             B.N      ??remoteSuspRelProcess_22
   4195                {
   4196                  case REMOTE_MAX_POWER_CHANGE:
   4197                    temp32 = getMaxTempPowerAc();
   \                     ??remoteSuspRelProcess_19: (+1)
   \       0xC4   0x.... 0x....      BL       getMaxTempPowerAc
   \       0xC8   0x0004             MOVS     R4,R0
   4198                    pmng_sem_power_set((uint16_t)temp32, 1);
   \       0xCA   0x2101             MOVS     R1,#+1
   \       0xCC   0x0020             MOVS     R0,R4
   \       0xCE   0xB280             UXTH     R0,R0
   \       0xD0   0x.... 0x....      BL       pmng_sem_power_set
   4199                    /* SEM sent a new value for MAX_TEMPORARY_POWER_AC_RW */
   4200                    if (temp32 == (uint32_t)0)
   \       0xD4   0x2C00             CMP      R4,#+0
   \       0xD6   0xD105             BNE.N    ??remoteSuspRelProcess_23
   4201                    {
   4202                      remoteMng.remoteStates = REMOTE_EVS_SUSPENDING;
   \       0xD8   0x2004             MOVS     R0,#+4
   \       0xDA   0x7038             STRB     R0,[R7, #+0]
   4203                      send_to_evs(EVS_REMOTE_SUSPENDING);
   \       0xDC   0x200D             MOVS     R0,#+13
   \       0xDE   0x.... 0x....      BL       send_to_evs
   \       0xE2   0xE002             B.N      ??remoteSuspRelProcess_24
   4204                    }
   4205                    else // if (temp32 != (uint32_t)0)
   4206                    {
   4207                      send_to_evs(EVS_REMOTE_RELEASE);
   \                     ??remoteSuspRelProcess_23: (+1)
   \       0xE4   0x200E             MOVS     R0,#+14
   \       0xE6   0x.... 0x....      BL       send_to_evs
   4208                    }
   4209                    break;
   \                     ??remoteSuspRelProcess_24: (+1)
   \       0xEA   0xE008             B.N      ??remoteSuspRelProcess_25
   4210          
   4211                  case REMOTE_EVS_AUTH_START:
   4212                    /* da remoto su chiusura carica (inizia con questo messaggio  */
   4213                    remoteMng.remoteStates = REMOTE_EVS_WAIT_TO_STOP;
   \                     ??remoteSuspRelProcess_20: (+1)
   \       0xEC   0x2005             MOVS     R0,#+5
   \       0xEE   0x7038             STRB     R0,[R7, #+0]
   4214                    break;
   \       0xF0   0xE005             B.N      ??remoteSuspRelProcess_25
   4215          
   4216                  case REMOTE_EVS_AUTH_STOP:
   4217                    send_to_evs(EVS_AUTH_STOP);
   \                     ??remoteSuspRelProcess_21: (+1)
   \       0xF2   0x2019             MOVS     R0,#+25
   \       0xF4   0x.... 0x....      BL       send_to_evs
   4218                    remoteMng.remoteStates = REMOTE_OPERATIVE;
   \       0xF8   0x2001             MOVS     R0,#+1
   \       0xFA   0x7038             STRB     R0,[R7, #+0]
   4219                    break;
   \       0xFC   0xE7FF             B.N      ??remoteSuspRelProcess_25
   4220          
   4221                  default:
   4222                    break;
   4223                }
   4224                break;
   \                     ??remoteSuspRelProcess_22: (+1)
   \                     ??remoteSuspRelProcess_25: (+1)
   \       0xFE   0xE023             B.N      ??remoteSuspRelProcess_11
   4225          
   4226              case REMOTE_EVS_SUSPENDING:
   4227                switch (pMsg->currentEvent)
   \                     ??remoteSuspRelProcess_5: (+1)
   \      0x100   0x7828             LDRB     R0,[R5, #+0]
   \      0x102   0x280F             CMP      R0,#+15
   \      0x104   0xD002             BEQ.N    ??remoteSuspRelProcess_26
   \      0x106   0x2817             CMP      R0,#+23
   \      0x108   0xD010             BEQ.N    ??remoteSuspRelProcess_27
   \      0x10A   0xE012             B.N      ??remoteSuspRelProcess_28
   4228                {
   4229                  case REMOTE_MAX_POWER_CHANGE:
   4230                    temp32 = getMaxTempPowerAc();
   \                     ??remoteSuspRelProcess_26: (+1)
   \      0x10C   0x.... 0x....      BL       getMaxTempPowerAc
   \      0x110   0x0004             MOVS     R4,R0
   4231                    pmng_sem_power_set((uint16_t)temp32, 1);
   \      0x112   0x2101             MOVS     R1,#+1
   \      0x114   0x0020             MOVS     R0,R4
   \      0x116   0xB280             UXTH     R0,R0
   \      0x118   0x.... 0x....      BL       pmng_sem_power_set
   4232                    /* SEM sent a new value for MAX_TEMPORARY_POWER_AC_RW */
   4233                    if (temp32 != (uint32_t)0)
   \      0x11C   0x2C00             CMP      R4,#+0
   \      0x11E   0xD004             BEQ.N    ??remoteSuspRelProcess_29
   4234                    {
   4235                      send_to_evs(EVS_REMOTE_RELEASE);
   \      0x120   0x200E             MOVS     R0,#+14
   \      0x122   0x.... 0x....      BL       send_to_evs
   4236                      remoteMng.remoteStates = REMOTE_EVS_AUTH;
   \      0x126   0x2002             MOVS     R0,#+2
   \      0x128   0x7038             STRB     R0,[R7, #+0]
   4237                    }
   4238                    break;
   \                     ??remoteSuspRelProcess_29: (+1)
   \      0x12A   0xE002             B.N      ??remoteSuspRelProcess_30
   4239          
   4240                  case REMOTE_EVS_AUTH_START:
   4241                    /* da remoto su chiusura carica (inizia con questo messaggio  */
   4242                    remoteMng.remoteStates = REMOTE_EVS_WAIT_TO_STOP;
   \                     ??remoteSuspRelProcess_27: (+1)
   \      0x12C   0x2005             MOVS     R0,#+5
   \      0x12E   0x7038             STRB     R0,[R7, #+0]
   4243                    break;
   \      0x130   0xE7FF             B.N      ??remoteSuspRelProcess_30
   4244          
   4245                  default:
   4246                    break;
   4247                }
   4248                break;
   \                     ??remoteSuspRelProcess_28: (+1)
   \                     ??remoteSuspRelProcess_30: (+1)
   \      0x132   0xE009             B.N      ??remoteSuspRelProcess_11
   4249          
   4250              case REMOTE_EVS_WAIT_TO_STOP:
   4251                switch (pMsg->currentEvent)
   \                     ??remoteSuspRelProcess_6: (+1)
   \      0x134   0x7828             LDRB     R0,[R5, #+0]
   \      0x136   0x2819             CMP      R0,#+25
   \      0x138   0xD105             BNE.N    ??remoteSuspRelProcess_31
   4252                {
   4253                  case REMOTE_EVS_AUTH_STOP:
   4254                    send_to_evs(EVS_AUTH_STOP);
   \      0x13A   0x2019             MOVS     R0,#+25
   \      0x13C   0x.... 0x....      BL       send_to_evs
   4255                    remoteMng.remoteStates = REMOTE_OPERATIVE;
   \      0x140   0x2001             MOVS     R0,#+1
   \      0x142   0x7038             STRB     R0,[R7, #+0]
   4256                    break;
   \      0x144   0xE7FF             B.N      ??remoteSuspRelProcess_32
   4257          
   4258                  default:
   4259                    break;
   4260                }
   4261                break;
   \                     ??remoteSuspRelProcess_31: (+1)
   \                     ??remoteSuspRelProcess_32: (+1)
   \      0x146   0xE7FF             B.N      ??remoteSuspRelProcess_11
   4262          
   4263              default:
   4264                break;
   4265          
   4266            }
   4267            return(timeTickTmp);
   \                     ??remoteSuspRelProcess_7: (+1)
   \                     ??remoteSuspRelProcess_11: (+1)
   \      0x148   0x0030             MOVS     R0,R6
   \                     ??remoteSuspRelProcess_1: (+1)
   \      0x14A   0xBDF2             POP      {R1,R4-R7,PC}
   4268          }
   4269          
   4270          /**
   4271          *
   4272          * @brief       Get the remote PM flag status   
   4273          *
   4274          * @param [in]  none    
   4275          *  
   4276          * @retval      uint8_t: TRUE / FALSE   
   4277          *  
   4278          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4279          uint8_t getRemotePmFlag (void) 
   4280          {
   \                     getRemotePmFlag: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4281            uint8_t               pmng_enable;
   4282          
   4283            eeprom_param_get(HIDDEN_MENU_ENB_EADD, &pmng_enable, 1);     // legge power management enable
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x2036             MOVS     R0,#+54
   \        0x8   0x.... 0x....      BL       eeprom_param_get
   4284            if ((pmng_enable & HIDDEN_MENU_SEM_ENB) == 0) return(FALSE); else return(TRUE);
   \        0xC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x10   0x0700             LSLS     R0,R0,#+28
   \       0x12   0xD401             BMI.N    ??getRemotePmFlag_0
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE000             B.N      ??getRemotePmFlag_1
   \                     ??getRemotePmFlag_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \                     ??getRemotePmFlag_1: (+1)
   \       0x1A   0xBD02             POP      {R1,PC}
   4285          }
   4286          
   4287          /**
   4288          *
   4289          * @brief       Send a restore mesage    
   4290          *
   4291          * @param [in]  none    
   4292          *  
   4293          * @retval      none   
   4294          *  
   4295          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4296          void restoreOperativeState (void) 
   4297          {
   \                     restoreOperativeState: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   4298            frameRemote_st  frameRemote;
   4299            
   4300            if (remoteMngQueue != NULL)
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable53_6
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD015             BEQ.N    ??restoreOperativeState_0
   4301            {
   4302              frameRemote.currentEvent = RETURN_TO_OPERATIVE;
   \        0xC   0x2010             MOVS     R0,#+16
   \        0xE   0xF88D 0x0000      STRB     R0,[SP, #+0]
   4303              configASSERT(xQueueSendToBack(remoteMngQueue, (void *)&frameRemote, portMAX_DELAY) == pdPASS); // remoteSuspRelProcess()
   \       0x12   0x2300             MOVS     R3,#+0
   \       0x14   0xF05F 0x32FF      MOVS     R2,#+4294967295
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      BL       xQueueGenericSend
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD009             BEQ.N    ??restoreOperativeState_0
   \       0x24   0xB672             CPSID    I
   \       0x26   0x2050             MOVS     R0,#+80
   \       0x28   0xF380 0x8811      MSR      BASEPRI,R0
   \       0x2C   0xF3BF 0x8F4F      DSB      SY
   \       0x30   0xF3BF 0x8F6F      ISB      SY
   \       0x34   0xB662             CPSIE    I
   \                     ??restoreOperativeState_1: (+1)
   \       0x36   0xE7FE             B.N      ??restoreOperativeState_1
   4304            }
   4305            /* end of charge: reset all current and power value */
   4306            resetPowerCurrentValues();
   \                     ??restoreOperativeState_0: (+1)
   \       0x38   0x.... 0x....      BL       resetPowerCurrentValues
   4307          }
   \       0x3C   0xBD13             POP      {R0,R1,R4,PC}
   4308          
   4309          /**
   4310          *
   4311          * @brief       restart a timer with new period     
   4312          *
   4313          * @param [in]  uint16_t: timerid    
   4314          * @param [in]  uint32_t: new period    
   4315          *  
   4316          * @retval      none   
   4317          *  
   4318          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4319          static void restartSbcSemTimer (uint16_t timerId, uint32_t period) 
   4320          {
   \                     restartSbcSemTimer: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   4321          
   4322            while ((xTimerChangePeriod (xSbcSemTimers[timerId], period, SBCSEM_TIMER_GARD_TIME) != pdPASS)); 
   \                     ??restartSbcSemTimer_0: (+1)
   \        0x6   0x.... 0x....      LDR.W    R6,??DataTable53_8
   \        0xA   0xF44F 0x70FA      MOV      R0,#+500
   \        0xE   0x9000             STR      R0,[SP, #+0]
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x002A             MOVS     R2,R5
   \       0x14   0x2104             MOVS     R1,#+4
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0xB280             UXTH     R0,R0
   \       0x1A   0xF856 0x0020      LDR      R0,[R6, R0, LSL #+2]
   \       0x1E   0x.... 0x....      BL       xTimerGenericCommand
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD1EF             BNE.N    ??restartSbcSemTimer_0
   4323            xTimerReset (xSbcSemTimers[timerId], 0);     // the master restart the timeout  
   \       0x26   0x.... 0x....      BL       xTaskGetTickCount
   \       0x2A   0x0002             MOVS     R2,R0
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   \       0x30   0x2300             MOVS     R3,#+0
   \       0x32   0x2102             MOVS     R1,#+2
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0xB280             UXTH     R0,R0
   \       0x38   0xF856 0x0020      LDR      R0,[R6, R0, LSL #+2]
   \       0x3C   0x.... 0x....      BL       xTimerGenericCommand
   4324          }
   \       0x40   0xBD73             POP      {R0,R1,R4-R6,PC}
   4325          
   4326          /**
   4327          *
   4328          * @brief       set all bit in Scu map for active SCU to force a 
   4329          *              read from SBC
   4330          *
   4331          * @param [in]  uint32_t: bit position active SCU     
   4332          *  
   4333          * @retval      none   
   4334          *  
   4335          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4336          static void forceSBCreadScu (uint32_t activityMask) 
   4337          {
   \                     forceSBCreadScu: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   4338            uint16_t              idScu;
   4339            uint32_t              maskId, changeRo;
   4340            scuRoMapRegister_st*  pRoRegs; 
   4341          
   4342            /* first of all update the live presence register */
   4343            socketPresence.livePresence |= activityMask;
   \        0x6   0x.... 0x....      LDR.W    R9,??DataTable53
   \        0xA   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \        0xE   0x4320             ORRS     R0,R4,R0
   \       0x10   0xF8C9 0x0004      STR      R0,[R9, #+4]
   4344          
   4345            for (idScu = 0, maskId = (uint32_t)0x1, changeRo = 0; idScu <= SCU_NUM; idScu++, maskId = maskId << 1) // SCU_M_P_ADDR -> logic address = 0
   \       0x14   0x2500             MOVS     R5,#+0
   \       0x16   0x2601             MOVS     R6,#+1
   \       0x18   0x2700             MOVS     R7,#+0
   \                     ??forceSBCreadScu_0: (+1)
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0xB280             UXTH     R0,R0
   \       0x1E   0x2811             CMP      R0,#+17
   \       0x20   0xDA43             BGE.N    ??forceSBCreadScu_1
   4346            {
   4347              if ((activityMask & maskId) != 0)
   \       0x22   0x4234             TST      R4,R6
   \       0x24   0xD009             BEQ.N    ??forceSBCreadScu_2
   4348              {
   4349                /* this SCU is present: set the flags change for this SCU */
   4350                changeRo |= maskId;   
   \       0x26   0x4337             ORRS     R7,R6,R7
   4351                /* force update to SBC for connector status and errors  */       
   4352                pScuRoMapReg->scuMapRegNotify.ntfChangeRegRo[idScu] = ((uint16_t)EVSE_CONNECTOR_STATUS_BIT_RO | (uint16_t)EVSE_ERROR2_BIT_RO) | (uint16_t)EVSE_ERROR1_BIT_RO;
   \       0x28   0x201C             MOVS     R0,#+28
   \       0x2A   0x....             LDR.N    R1,??DataTable42
   \       0x2C   0x6809             LDR      R1,[R1, #+0]
   \       0x2E   0x002A             MOVS     R2,R5
   \       0x30   0xB292             UXTH     R2,R2
   \       0x32   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \       0x36   0xF8A1 0x0102      STRH     R0,[R1, #+258]
   4353              }
   4354              /* remove current OFF_L alarm  */
   4355              pRoRegs = getRoMdbRegs(idScu);
   \                     ??forceSBCreadScu_2: (+1)
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x.... 0x....      BL       getRoMdbRegs
   \       0x42   0x4680             MOV      R8,R0
   4356              if (((pRoRegs->scuMapRegNotify.ntfErr2 & ERROR2_OFFL) != 0) || (pollingSlaveMng.offLineCounter[idScu] != 0) ||
   4357                  ((getScuOpMode() == SCU_M_STAND_ALONE) && (pollingSlaveMng.offLineCounter[idScu] >= NUM_OFF_LINE_RETRY)))
   \       0x44   0xF898 0x0100      LDRB     R0,[R8, #+256]
   \       0x48   0x0700             LSLS     R0,R0,#+28
   \       0x4A   0xD413             BMI.N    ??forceSBCreadScu_3
   \       0x4C   0x.... 0x....      LDR.W    R10,??DataTable35_1
   \       0x50   0x0028             MOVS     R0,R5
   \       0x52   0xB280             UXTH     R0,R0
   \       0x54   0x4450             ADD      R0,R10,R0
   \       0x56   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD10A             BNE.N    ??forceSBCreadScu_3
   \       0x5E   0x.... 0x....      BL       getScuOpMode
   \       0x62   0x2805             CMP      R0,#+5
   \       0x64   0xD11E             BNE.N    ??forceSBCreadScu_4
   \       0x66   0x0028             MOVS     R0,R5
   \       0x68   0xB280             UXTH     R0,R0
   \       0x6A   0x4450             ADD      R0,R10,R0
   \       0x6C   0xF890 0x0023      LDRB     R0,[R0, #+35]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD017             BEQ.N    ??forceSBCreadScu_4
   4358          
   4359              {
   4360                pollingSlaveMng.offLineCounter[idScu] = 0;
   \                     ??forceSBCreadScu_3: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x....             LDR.N    R1,??DataTable35_1
   \       0x78   0x002A             MOVS     R2,R5
   \       0x7A   0xB292             UXTH     R2,R2
   \       0x7C   0x4411             ADD      R1,R1,R2
   \       0x7E   0xF881 0x0023      STRB     R0,[R1, #+35]
   4361                /* the current scuId  respond now: put it in ON_LINE  Only one time !!! */
   4362                pRoRegs->scuMapRegNotify.ntfErr2 &= (~ERROR2_OFFL);
   \       0x82   0xF8B8 0x1100      LDRH     R1,[R8, #+256]
   \       0x86   0xF64F 0x70F7      MOVW     R0,#+65527
   \       0x8A   0x4001             ANDS     R1,R0,R1
   \       0x8C   0xF8A8 0x1100      STRH     R1,[R8, #+256]
   4363                tPrintf ("SCU %02d on-line! %s\n\r" , idScu + 1, getHmsStr()); //  HAL_GetTick()
   \       0x90   0x.... 0x....      BL       getHmsStr
   \       0x94   0x0002             MOVS     R2,R0
   \       0x96   0x0029             MOVS     R1,R5
   \       0x98   0xB289             UXTH     R1,R1
   \       0x9A   0x1C49             ADDS     R1,R1,#+1
   \       0x9C   0x.... 0x....      LDR.W    R0,??DataTable53_9
   \       0xA0   0x.... 0x....      BL       tPrintf
   4364              }
   4365            }
   \                     ??forceSBCreadScu_4: (+1)
   \       0xA4   0x1C6D             ADDS     R5,R5,#+1
   \       0xA6   0x0076             LSLS     R6,R6,#+1
   \       0xA8   0xE7B7             B.N      ??forceSBCreadScu_0
   4366            /* flags to invite a reading by SBC */
   4367            pScuRoMapReg->scuMapRegNotify.ntfPresences = (uint32_t)socketPresence.livePresence; // now the map of the precence on RS485 bus is complete
   \                     ??forceSBCreadScu_1: (+1)
   \       0xAA   0x....             LDR.N    R0,??DataTable42
   \       0xAC   0x6801             LDR      R1,[R0, #+0]
   \       0xAE   0xF8D9 0x2004      LDR      R2,[R9, #+4]
   \       0xB2   0xF8C1 0x20F6      STR      R2,[R1, #+246]
   4368            pScuRoMapReg->scuMapRegNotify.ntfChangeRo |= changeRo;
   \       0xB6   0x6802             LDR      R2,[R0, #+0]
   \       0xB8   0xF8D2 0x10FA      LDR      R1,[R2, #+250]
   \       0xBC   0x6800             LDR      R0,[R0, #+0]
   \       0xBE   0x4339             ORRS     R1,R7,R1
   \       0xC0   0xF8C0 0x10FA      STR      R1,[R0, #+250]
   4369            sbcSemInfoMng.discoveryMask = 0;
   \       0xC4   0x....             LDR.N    R0,??DataTable37
   \       0xC6   0x2100             MOVS     R1,#+0
   \       0xC8   0xF8C0 0x100A      STR      R1,[R0, #+10]
   4370          }
   \       0xCC   0xE8BD 0x87F0      POP      {R4-R10,PC}
   4371          
   4372          /**
   4373          *
   4374          * @brief       set all bit in Scu map for active SCU to force a 
   4375          *              read from SBC
   4376          *
   4377          * @param [in]  uint16_t: address on RS485    
   4378          * @param [in]  uint16_t: pointer where store the device Id
   4379          *        linked to incoming address on RS485
   4380          *  
   4381          * @retval      none   
   4382          *  
   4383          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4384           uint16_t fromRs485ToSem (uint16_t addrRS485) 
   4385          {
   \                     fromRs485ToSem: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   4386            uint16_t    idx;
   4387          
   4388            if (addrRS485 == 0)   /* in case of broadcast */
   \        0x2   0x0008             MOVS     R0,R1
   \        0x4   0xB280             UXTH     R0,R0
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD102             BNE.N    ??fromRs485ToSem_0
   4389              return addrRS485;
   \        0xA   0x0008             MOVS     R0,R1
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0xE015             B.N      ??fromRs485ToSem_1
   4390              
   4391            for (idx = 0; idx < SCU_NUM; idx++)
   \                     ??fromRs485ToSem_0: (+1)
   \       0x10   0x2200             MOVS     R2,#+0
   \                     ??fromRs485ToSem_2: (+1)
   \       0x12   0x0010             MOVS     R0,R2
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x2810             CMP      R0,#+16
   \       0x18   0xDA0E             BGE.N    ??fromRs485ToSem_3
   4392            {
   4393              if (socketPresence.matrixConv[idx] == (uint8_t)addrRS485)
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable53
   \       0x1E   0x0013             MOVS     R3,R2
   \       0x20   0xB29B             UXTH     R3,R3
   \       0x22   0x4418             ADD      R0,R0,R3
   \       0x24   0x7C00             LDRB     R0,[R0, #+16]
   \       0x26   0x000B             MOVS     R3,R1
   \       0x28   0xB2DB             UXTB     R3,R3
   \       0x2A   0x4298             CMP      R0,R3
   \       0x2C   0xD102             BNE.N    ??fromRs485ToSem_4
   4394              {
   4395                return idx;
   \       0x2E   0x0010             MOVS     R0,R2
   \       0x30   0xB280             UXTH     R0,R0
   \       0x32   0xE003             B.N      ??fromRs485ToSem_1
   4396              }
   4397            }
   \                     ??fromRs485ToSem_4: (+1)
   \       0x34   0x1C52             ADDS     R2,R2,#+1
   \       0x36   0xE7EC             B.N      ??fromRs485ToSem_2
   4398            
   4399            return NULL_ID;
   \                     ??fromRs485ToSem_3: (+1)
   \       0x38   0xF64F 0x70FF      MOVW     R0,#+65535
   \                     ??fromRs485ToSem_1: (+1)
   \       0x3C   0x4770             BX       LR
   4400            
   4401          }
   4402          
   4403          /**
   4404          *
   4405          * @brief       set all bit in Scu map for active SCU to force a 
   4406          *              read from SBC
   4407          *
   4408          * @param [in]  uint8_t: logic socket id 0...15    
   4409          *  
   4410          * @retval      none   
   4411          *  
   4412          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4413          static void removeSocketFromList (uint8_t skId) 
   4414          {
   \                     removeSocketFromList: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   4415            uint32_t              maskBit;
   4416             
   4417            maskBit = (uint32_t)sbcSemMaskBit[skId];
   \        0x4   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \        0x8   0x0021             MOVS     R1,R4
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0xF850 0x5021      LDR      R5,[R0, R1, LSL #+2]
   4418          
   4419            pScuRoMapReg->scuMapRegNotify.ntfPresences &= (uint32_t)(~maskBit);
   \       0x10   0x....             LDR.N    R0,??DataTable42
   \       0x12   0x6802             LDR      R2,[R0, #+0]
   \       0x14   0xF8D2 0x10F6      LDR      R1,[R2, #+246]
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x43A9             BICS     R1,R1,R5
   \       0x1C   0xF8C0 0x10F6      STR      R1,[R0, #+246]
   4420            socketPresence.livePresence &= (uint16_t)(~maskBit);
   \       0x20   0x.... 0x....      LDR.W    R1,??DataTable53
   \       0x24   0x684A             LDR      R2,[R1, #+4]
   \       0x26   0x43E8             MVNS     R0,R5
   \       0x28   0xB280             UXTH     R0,R0
   \       0x2A   0x4002             ANDS     R2,R0,R2
   \       0x2C   0x604A             STR      R2,[R1, #+4]
   4421            socketPresence.chainPresence &= (uint16_t)(~maskBit);
   \       0x2E   0x680A             LDR      R2,[R1, #+0]
   \       0x30   0x43E8             MVNS     R0,R5
   \       0x32   0xB280             UXTH     R0,R0
   \       0x34   0x4002             ANDS     R2,R0,R2
   \       0x36   0x600A             STR      R2,[R1, #+0]
   4422            sbcSemInfoMng.activeLastDiscovery &= (uint16_t)(~maskBit);
   \       0x38   0x....             LDR.N    R2,??DataTable37
   \       0x3A   0x6A13             LDR      R3,[R2, #+32]
   \       0x3C   0x43E8             MVNS     R0,R5
   \       0x3E   0xB280             UXTH     R0,R0
   \       0x40   0x4003             ANDS     R3,R0,R3
   \       0x42   0x6213             STR      R3,[R2, #+32]
   4423            /* la matrice di conversione per il momento non la tocchiamo. Resta fissa la corrispondenza uno a uno: [0]->1, [1]->2, [2]-> 3, .... [31] -*/
   4424            //socketPresence.matrixConv[skId] = (uint8_t)0; 
   4425            if (WriteOnEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t)) == osOK)    // save socket Presence 
   \       0x44   0x2254             MOVS     R2,#+84
   \       0x46   0xF44F 0x50F4      MOV      R0,#+7808
   \       0x4A   0x.... 0x....      BL       WriteOnEeprom
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD108             BNE.N    ??removeSocketFromList_0
   4426            {
   4427              tPrintf("Socket Id %2d removed!\n\r", (skId + 1));
   \       0x52   0x0021             MOVS     R1,R4
   \       0x54   0xB2C9             UXTB     R1,R1
   \       0x56   0x1C49             ADDS     R1,R1,#+1
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable53_10
   \       0x5C   0x.... 0x....      BL       tPrintf
   4428              /* a change on configuration has been made */
   4429              activeImmediateResetFromRemove();
   \       0x60   0x.... 0x....      BL       activeImmediateResetFromRemove
   4430            }
   4431          }
   \                     ??removeSocketFromList_0: (+1)
   \       0x64   0xBD31             POP      {R0,R4,R5,PC}
   4432          
   4433          #ifdef TRANSLATE_ID_LOGIC
   4434          /**
   4435          *
   4436          * @brief       set the first addres modbus free
   4437          *
   4438          * @param [in]  none    
   4439          *  
   4440          * @retval      none   
   4441          *  
   4442          ****************************************************************/
   4443          static uint8_t setModbusAddress (void) 
   4444          {
   4445            uint32_t    maskId;
   4446            uint8_t     maxAddrVal, ix;
   4447          
   4448            maxAddrVal = 0; maskId = 1;
   4449            if (!((getScuOpMode() == SCU_M_STAND_ALONE) && ((socketPresence.assignedDeviceId & SCU_MASTER_MASK_BIT) == 0)))  // in stand alone mode address 1 not assigned 
   4450            {
   4451              for (ix = 0; ix < SCU_NUM; ix++, maskId = maskId << 1)
   4452              {
   4453                if ((socketPresence.chainPresence & maskId) == maskId)
   4454                {
   4455                  if (socketPresence.matrixConv[ix] > maxAddrVal)
   4456                  {
   4457                    maxAddrVal = socketPresence.matrixConv[ix];
   4458                  }
   4459                }
   4460              }
   4461            }
   4462            socketPresence.assignedDeviceId |= maskId;
   4463            return(maxAddrVal + (uint8_t)1);
   4464          }
   4465          #endif
   4466          /**
   4467          *
   4468          * @brief       get the first id connector free 1..15 
   4469          *
   4470          * @param [in]  none    
   4471          *  
   4472          * @retval      uint8_t: the first free position in the presence word 1..15 (position 0 is reserved for master)  
   4473          *  
   4474          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4475          static uint8_t getFirstFreeLogicId (void) 
   4476          {
   \                     getFirstFreeLogicId: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   4477            uint32_t    maskId;
   4478            uint8_t     ix;
   4479          
   4480            ix = 0; maskId = 1;
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x2401             MOVS     R4,#+1
   4481            if (!((getScuOpMode() == SCU_M_STAND_ALONE) && ((socketPresence.assignedDeviceId & SCU_MASTER_MASK_BIT) == 0)))
   \        0x6   0x.... 0x....      BL       getScuOpMode
   \        0xA   0x2805             CMP      R0,#+5
   \        0xC   0xD105             BNE.N    ??getFirstFreeLogicId_0
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable53
   \       0x12   0xF890 0x0050      LDRB     R0,[R0, #+80]
   \       0x16   0x07C0             LSLS     R0,R0,#+31
   \       0x18   0xD50E             BPL.N    ??getFirstFreeLogicId_1
   4482            {
   4483              for (; ix < SCU_NUM; ix++, maskId = maskId << 1)
   \                     ??getFirstFreeLogicId_0: (+1)
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x2810             CMP      R0,#+16
   \       0x20   0xDA0A             BGE.N    ??getFirstFreeLogicId_1
   4484              {
   4485                if (((socketPresence.chainPresence & maskId) == (uint16_t)0) && ((socketPresence.livePresence & maskId) == (uint16_t)0))
   \       0x22   0x.... 0x....      LDR.W    R0,??DataTable53
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x4221             TST      R1,R4
   \       0x2A   0xD102             BNE.N    ??getFirstFreeLogicId_2
   \       0x2C   0x6840             LDR      R0,[R0, #+4]
   \       0x2E   0x4220             TST      R0,R4
   \       0x30   0xD002             BEQ.N    ??getFirstFreeLogicId_1
   4486                {
   4487                  break;
   4488                }
   4489              }
   \                     ??getFirstFreeLogicId_2: (+1)
   \       0x32   0x1C6D             ADDS     R5,R5,#+1
   \       0x34   0x0064             LSLS     R4,R4,#+1
   \       0x36   0xE7F0             B.N      ??getFirstFreeLogicId_0
   4490            }
   4491            return(ix);
   \                     ??getFirstFreeLogicId_1: (+1)
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0xB2C0             UXTB     R0,R0
   \       0x3C   0xBD32             POP      {R1,R4,R5,PC}
   4492          }
   4493          /**
   4494          *
   4495          * @brief       set  status polling flag  
   4496          *
   4497          * @param [in]  uint8_t: status flag     
   4498          *  
   4499          * @retval      none   
   4500          *  
   4501          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4502          void setPollingFlag (uint8_t flagStatus) 
   4503          {
   4504            sbcSemInfoMng.pollingFlag = (uint16_t)flagStatus;
   \                     setPollingFlag: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x.... 0x....      LDR.W    R2,??DataTable53_5
   \        0x8   0x8351             STRH     R1,[R2, #+26]
   4505          }
   \        0xA   0x4770             BX       LR
   4506          
   4507          /**
   4508          *
   4509          * @brief       read socket presence information from eeprom   
   4510          *
   4511          * @param [in]  none     
   4512          *  
   4513          * @retval      uint8_t:  osOK if successfull  
   4514          *  
   4515          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4516          uint8_t readSocketPresence (void) 
   4517          {
   \                     readSocketPresence: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   4518            uint8_t   result;
   4519          
   4520            result = ReadFromEeprom(SOCKETS_PRESENCE_EE_ADDRES, (uint8_t*)&socketPresence, sizeof(socketPresence_t));
   \        0x2   0x2254             MOVS     R2,#+84
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable53
   \        0x8   0xF44F 0x50F4      MOV      R0,#+7808
   \        0xC   0x.... 0x....      BL       ReadFromEeprom
   4521            return (result);
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0xBD02             POP      {R1,PC}
   4522          }
   4523          
   4524          /**
   4525          *
   4526          * @brief       get new packet status identifier    
   4527          *
   4528          * @param [in]  none     
   4529          *  
   4530          * @retval      uint32_t:  the packet status identifier   
   4531          *  
   4532          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4533          uint32_t getPacketStatusNum (void) 
   4534          {
   4535            uint32_t   packNum;
   4536          
   4537            packNum = packetStatsCounter;
   \                     getPacketStatusNum: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable53_11
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   4538            packetStatsCounter++;
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x1C52             ADDS     R2,R2,#+1
   \        0xA   0x600A             STR      R2,[R1, #+0]
   4539          
   4540            return (packNum);
   \        0xC   0x4770             BX       LR
   4541          }
   4542          
   4543          /**
   4544          *
   4545          * @brief       reset packet counter    
   4546          *
   4547          * @param [in]  none     
   4548          *  
   4549          * @retval      uint32_t:  the packet status identifier   
   4550          *  
   4551          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4552          static void resetPacketStatusNum (void) 
   4553          {
   4554            packetStatsCounter = (uint32_t)0;
   \                     resetPacketStatusNum: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x.... 0x....      LDR.W    R1,??DataTable53_11
   \        0x6   0x6008             STR      R0,[R1, #+0]
   4555          }
   \        0x8   0x4770             BX       LR
   4556          
   4557          /**
   4558          *
   4559          * @brief        check if all task involved in SBC SEM communication are in the operative state  
   4560          *
   4561          * @param [in]   none
   4562          *
   4563          * @retval       uint8_t: TRUE if all OK, i.e. operative 
   4564          *
   4565          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4566          uint8_t allTaskAreOperative (void)
   4567          {
   4568            if ((sbcSemInfoMng.sbcSemStates == SBC_SEM_OPERATIVE) && (rs485SemInfoMng.rs485SemStates == RS485_SEM_OPERATIVE))
   \                     allTaskAreOperative: (+1)
   \        0x0   0x.... 0x....      LDR.W    R0,??DataTable53_5
   \        0x4   0x8800             LDRH     R0,[R0, #+0]
   \        0x6   0x2804             CMP      R0,#+4
   \        0x8   0xD106             BNE.N    ??allTaskAreOperative_0
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable53_12
   \        0xE   0x8800             LDRH     R0,[R0, #+0]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD101             BNE.N    ??allTaskAreOperative_0
   4569            {
   4570              return(TRUE);
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xE000             B.N      ??allTaskAreOperative_1
   4571            }
   4572            else
   4573            {
   4574              return(FALSE);
   \                     ??allTaskAreOperative_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \                     ??allTaskAreOperative_1: (+1)
   \       0x1A   0x4770             BX       LR
   4575            }
   4576          }
   4577          
   4578          /**
   4579          *
   4580          * @brief        reset the SEM task  in the operative state  
   4581          *
   4582          * @param [in]   none
   4583          *
   4584          * @retval       none 
   4585          *
   4586          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4587          void resetInOperative (void)
   4588          {
   \                     resetInOperative: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   4589            tPrintf( "Error on Sbc Task! St = %d St = %d\r\n", sbcSemInfoMng.sbcSemStates, rs485SemInfoMng.rs485SemStates);
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable53_5
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable53_12
   \        0xA   0x882A             LDRH     R2,[R5, #+0]
   \        0xC   0x8821             LDRH     R1,[R4, #+0]
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable53_13
   \       0x12   0x.... 0x....      BL       tPrintf
   4590            sbcSemInfoMng.sbcSemStates = SBC_SEM_OPERATIVE;
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0x8020             STRH     R0,[R4, #+0]
   4591            rs485SemInfoMng.rs485SemStates = RS485_SEM_OPERATIVE;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x8028             STRH     R0,[R5, #+0]
   4592            /* restore RS485   */
   4593            uartReintialization(); 
   \       0x1E   0x.... 0x....      BL       uartReintialization
   4594          }
   \       0x22   0xBD31             POP      {R0,R4,R5,PC}
   4595          
   4596          /**
   4597          *
   4598          * @brief       get modbus address from device id 
   4599          *
   4600          * @param [in]  uint8_t: device id 0..31    
   4601          *  
   4602          * @retval      uint8_t: modbus Address on RS485 for this device 
   4603          *              ID
   4604          *  
   4605          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4606          uint8_t getModbusAddrFromDevId (uint8_t devId) 
   4607          {
   4608            return((uint8_t)socketPresence.matrixConv[devId]);
   \                     getModbusAddrFromDevId: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable53
   \        0x4   0xB2C0             UXTB     R0,R0
   \        0x6   0x4408             ADD      R0,R1,R0
   \        0x8   0x7C00             LDRB     R0,[R0, #+16]
   \        0xA   0x4770             BX       LR
   4609          }
   4610          
   4611          
   4612          /**
   4613          *
   4614          * @brief       save all slave parameter in the external flah 
   4615          *              area 
   4616          *
   4617          * @param [in]  none:     
   4618          *  
   4619          * @retval      uint8_t: number of saved slave  
   4620          *              
   4621          *  
   4622          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4623          static void saveAllSlaveParameters(void)
   4624          {
   4625          #ifdef BOARD_REPAIR
   4626            uint8_t*          pData;
   4627            uint16_t          cnt;
   4628            uint32_t          cks;
   4629            FRESULT           ferr;
   4630            areaConfPar_st*   pConfPar; 
   4631            uint8_t           newEntryFound;    
   4632          
   4633          
   4634            if (ptrAreaConfPar == NULL)
   4635            {
   4636              return;
   4637            }
   4638            pConfPar = (areaConfPar_st*)malloc(sizeof(areaConfPar_st));
   4639            if (pConfPar != NULL)
   4640            {
   4641              ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)pConfPar, sizeof(areaConfPar_st));
   4642              /* in the heap there is the area with all slave EEPROM info: save it in the external SPI flash */
   4643              for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   4644              {
   4645                cks += pData[cnt];
   4646              }
   4647              if ((ferr == FR_OK) && ((cks == pConfPar->globalCkecksumControl) || (pConfPar->globalCkecksumControl == 0xFFFFFFFF)))
   4648              {
   4649                if (pConfPar->globalCkecksumControl == 0xFFFFFFFF)
   4650                {
   4651                  /*             destination                                  source                                   len         */
   4652                  memcpy((uint8_t *)&pConfPar->blockConfPar[0], (uint8_t *)&ptrAreaConfPar->blockConfPar[0], sizeof(areaConfPar_st));    
   4653                  newEntryFound = TRUE;    
   4654                }
   4655                else
   4656                {
   4657                  for (cnt = 0, newEntryFound = FALSE; cnt < SCU_NUM; cnt++)
   4658                  {
   4659                    if ((cnt == 0) || (ptrAreaConfPar->blockConfPar[cnt].idLogicScu > (uint16_t)SCU_NUM))continue;
   4660                    /* save only the new entry */
   4661                    /*             destination                                  source                                   len         */
   4662                    memcpy((uint8_t *)&pConfPar->blockConfPar[cnt], (uint8_t *)&ptrAreaConfPar->blockConfPar[cnt], sizeof(blockConfPar_st));
   4663                    newEntryFound = TRUE;    
   4664                  }
   4665                }
   4666                if (newEntryFound == TRUE)
   4667                {
   4668                  /* now in the heap, pointer pConfPar, we have the info eeprom updated */
   4669                  /* in the heap there is the area with all slave EEPROM info: save it in the external SPI flash */
   4670                  for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   4671                  {
   4672                    cks += pData[cnt];
   4673                  }
   4674                  pConfPar->globalCkecksumControl = cks;
   4675                  /* write all eeprom data received from all slave in the SPI flash whit checksum at the end */
   4676                  ferr = (FRESULT)FlashWrite(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)pConfPar, sizeof(areaConfPar_st), sizeof(areaConfPar_st));
   4677                  /* readback the data and check if the alla data is OK */
   4678                  if (ferr == FR_OK)
   4679                  {
   4680                    ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)ptrAreaConfPar, sizeof(areaConfPar_st));
   4681                    for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   4682                    {
   4683                      cks += pData[cnt];
   4684                    }
   4685                    if (ptrAreaConfPar->globalCkecksumControl != cks)
   4686                    {
   4687                      ferr = FR_DISK_ERR;
   4688                    }
   4689                    if (ferr == FR_OK)
   4690                    {
   4691                      tPrintf("All eeprom slave info saved in SPI flash!!\n\r");
   4692                    }
   4693                    else
   4694                    {
   4695                      tPrintf("Error on write eeprom slave info in SPI flash!!\n\r");
   4696                    }
   4697                  }
   4698                }
   4699              }
   4700            }
   4701            if (pConfPar != NULL)
   4702            {
   4703              free((void*)pConfPar);
   4704            }
   4705            if (ptrAreaConfPar != NULL)
   4706            {
   4707              free((void*)ptrAreaConfPar);
   4708              ptrAreaConfPar = NULL;
   4709            }
   4710          #endif
   4711          }
   \                     saveAllSlaveParameters: (+1)
   \        0x0   0x4770             BX       LR
   4712          
   4713          /**
   4714          *
   4715          * @brief       save  slave parameter in the external flah 
   4716          *              area 
   4717          *
   4718          * @param [in]  uint8_t: slave logic id     
   4719          *  
   4720          * @retval      uint8_t: 0 if no errors occured  
   4721          *              
   4722          *  
   4723          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4724          uint8_t saveSlaveParameters(void)
   4725          {
   \                     saveSlaveParameters: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   4726            uint8_t*          pData;
   4727            uint16_t          cnt;
   4728            uint32_t          cks;
   4729            FRESULT           ferr;
   4730            areaConfPar_st*   pConfPar; 
   4731            uint8_t           newEntryFound, idLogic;    
   4732          
   4733          
   4734            ferr = FR_NOT_READY;
   \        0x4   0xF05F 0x0803      MOVS     R8,#+3
   4735          
   4736            if (ptrAreaConfPar == NULL)
   \        0x8   0x.... 0x....      LDR.W    R9,??DataTable53_14
   \        0xC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD102             BNE.N    ??saveSlaveParameters_0
   4737            {
   4738              return(ferr);
   \       0x14   0x4640             MOV      R0,R8
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0xE0CA             B.N      ??saveSlaveParameters_1
   4739            }
   4740            pConfPar = (areaConfPar_st*)malloc(sizeof(areaConfPar_st));
   \                     ??saveSlaveParameters_0: (+1)
   \       0x1A   0xF643 0x6AC4      MOVW     R10,#+16068
   \       0x1E   0x4650             MOV      R0,R10
   \       0x20   0x.... 0x....      BL       malloc
   \       0x24   0x0004             MOVS     R4,R0
   4741            if (pConfPar != NULL)
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xF000 0x80B0      BEQ.W    ??saveSlaveParameters_2
   4742            {
   4743              ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)pConfPar, sizeof(areaConfPar_st));
   \       0x2C   0x4652             MOV      R2,R10
   \       0x2E   0x0021             MOVS     R1,R4
   \       0x30   0xF45F 0x10A0      MOVS     R0,#+1310720
   \       0x34   0x.... 0x....      BL       FlashRead
   \       0x38   0x4680             MOV      R8,R0
   4744              /* in the heap there is the area with all slave EEPROM info: save it in the external SPI flash */
   4745              for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x0006             MOVS     R6,R0
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x0007             MOVS     R7,R0
   \       0x42   0x0025             MOVS     R5,R4
   \                     ??saveSlaveParameters_3: (+1)
   \       0x44   0x0030             MOVS     R0,R6
   \       0x46   0xB280             UXTH     R0,R0
   \       0x48   0xF5B0 0x5F7B      CMP      R0,#+16064
   \       0x4C   0xD205             BCS.N    ??saveSlaveParameters_4
   4746              {
   4747                cks += pData[cnt];
   \       0x4E   0x0030             MOVS     R0,R6
   \       0x50   0xB280             UXTH     R0,R0
   \       0x52   0x5C28             LDRB     R0,[R5, R0]
   \       0x54   0x183F             ADDS     R7,R7,R0
   4748              }
   \       0x56   0x1C76             ADDS     R6,R6,#+1
   \       0x58   0xE7F4             B.N      ??saveSlaveParameters_3
   4749              if ((ferr == FR_OK) && (cks == pConfPar->globalCkecksumControl))
   \                     ??saveSlaveParameters_4: (+1)
   \       0x5A   0x4640             MOV      R0,R8
   \       0x5C   0xB2C0             UXTB     R0,R0
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xF040 0x8094      BNE.W    ??saveSlaveParameters_2
   \       0x64   0xF514 0x507B      ADDS     R0,R4,#+16064
   \       0x68   0x6800             LDR      R0,[R0, #+0]
   \       0x6A   0x4287             CMP      R7,R0
   \       0x6C   0xF040 0x808E      BNE.W    ??saveSlaveParameters_2
   4750              {
   4751                for (cnt = 0, newEntryFound = FALSE; cnt < SCU_NUM; cnt++)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x0006             MOVS     R6,R0
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??saveSlaveParameters_5: (+1)
   \       0x7A   0x0030             MOVS     R0,R6
   \       0x7C   0xB280             UXTH     R0,R0
   \       0x7E   0x2810             CMP      R0,#+16
   \       0x80   0xDA2D             BGE.N    ??saveSlaveParameters_6
   4752                {
   4753                  if (cnt == 0) continue;
   \       0x82   0x0030             MOVS     R0,R6
   \       0x84   0xB280             UXTH     R0,R0
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD027             BEQ.N    ??saveSlaveParameters_7
   4754                  /* save only the new entry */
   4755                  if (pConfPar->blockConfPar[cnt].idLogicScu == ptrAreaConfPar->blockConfPar[cnt].idLogicScu)
   \                     ??saveSlaveParameters_8: (+1)
   \       0x8A   0xF44F 0x707B      MOV      R0,#+1004
   \       0x8E   0x0031             MOVS     R1,R6
   \       0x90   0xB289             UXTH     R1,R1
   \       0x92   0x4341             MULS     R1,R0,R1
   \       0x94   0x5A61             LDRH     R1,[R4, R1]
   \       0x96   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \       0x9A   0x0033             MOVS     R3,R6
   \       0x9C   0xB29B             UXTH     R3,R3
   \       0x9E   0x4343             MULS     R3,R0,R3
   \       0xA0   0x5AD2             LDRH     R2,[R2, R3]
   \       0xA2   0x4291             CMP      R1,R2
   \       0xA4   0xD119             BNE.N    ??saveSlaveParameters_7
   4756                  {
   4757                    /*             destination                                  source                                   len         */
   4758                    memcpy((uint8_t *)&pConfPar->blockConfPar[cnt], (uint8_t *)&ptrAreaConfPar->blockConfPar[cnt], sizeof(blockConfPar_st));
   \       0xA6   0x9001             STR      R0,[SP, #+4]
   \       0xA8   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0xAC   0x0032             MOVS     R2,R6
   \       0xAE   0xB292             UXTH     R2,R2
   \       0xB0   0x4342             MULS     R2,R0,R2
   \       0xB2   0xEB01 0x0A02      ADD      R10,R1,R2
   \       0xB6   0x0031             MOVS     R1,R6
   \       0xB8   0xB289             UXTH     R1,R1
   \       0xBA   0xFB00 0xF001      MUL      R0,R0,R1
   \       0xBE   0xEB04 0x0B00      ADD      R11,R4,R0
   \       0xC2   0x9A01             LDR      R2,[SP, #+4]
   \       0xC4   0x4651             MOV      R1,R10
   \       0xC6   0x4658             MOV      R0,R11
   \       0xC8   0x.... 0x....      BL       __aeabi_memcpy
   4759                    idLogic = (uint8_t)cnt;
   \       0xCC   0x0030             MOVS     R0,R6
   \       0xCE   0xF88D 0x0001      STRB     R0,[SP, #+1]
   4760                    newEntryFound = TRUE;    
   \       0xD2   0x2001             MOVS     R0,#+1
   \       0xD4   0xF88D 0x0000      STRB     R0,[SP, #+0]
   4761                    break;
   \       0xD8   0xE001             B.N      ??saveSlaveParameters_6
   4762                  }
   4763                }
   \                     ??saveSlaveParameters_7: (+1)
   \       0xDA   0x1C76             ADDS     R6,R6,#+1
   \       0xDC   0xE7CD             B.N      ??saveSlaveParameters_5
   4764                if (newEntryFound == TRUE)
   \                     ??saveSlaveParameters_6: (+1)
   \       0xDE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xE2   0x2801             CMP      R0,#+1
   \       0xE4   0xD150             BNE.N    ??saveSlaveParameters_9
   4765                {
   4766                  /* now in the heap, pointer pConfPar, we have the info eeprom updated */
   4767                  /* in the heap there is the area with all slave EEPROM info: save it in the external SPI flash */
   4768                  for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0x0006             MOVS     R6,R0
   \       0xEA   0x2000             MOVS     R0,#+0
   \       0xEC   0x0007             MOVS     R7,R0
   \       0xEE   0x0025             MOVS     R5,R4
   \                     ??saveSlaveParameters_10: (+1)
   \       0xF0   0x0030             MOVS     R0,R6
   \       0xF2   0xB280             UXTH     R0,R0
   \       0xF4   0xF5B0 0x5F7B      CMP      R0,#+16064
   \       0xF8   0xD205             BCS.N    ??saveSlaveParameters_11
   4769                  {
   4770                    cks += pData[cnt];
   \       0xFA   0x0030             MOVS     R0,R6
   \       0xFC   0xB280             UXTH     R0,R0
   \       0xFE   0x5C28             LDRB     R0,[R5, R0]
   \      0x100   0x183F             ADDS     R7,R7,R0
   4771                  }
   \      0x102   0x1C76             ADDS     R6,R6,#+1
   \      0x104   0xE7F4             B.N      ??saveSlaveParameters_10
   4772                  pConfPar->globalCkecksumControl = cks;
   \                     ??saveSlaveParameters_11: (+1)
   \      0x106   0xF44F 0x5B7B      MOV      R11,#+16064
   \      0x10A   0xF844 0x700B      STR      R7,[R4, R11]
   4773                  /* write all eeprom data received from all slave in the SPI flash whit checksum at the end */
   4774                  ferr = (FRESULT)FlashWrite(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)pConfPar, sizeof(areaConfPar_st), sizeof(areaConfPar_st));
   \      0x10E   0xF643 0x6AC4      MOVW     R10,#+16068
   \      0x112   0x4653             MOV      R3,R10
   \      0x114   0x4652             MOV      R2,R10
   \      0x116   0x0021             MOVS     R1,R4
   \      0x118   0xF45F 0x10A0      MOVS     R0,#+1310720
   \      0x11C   0x.... 0x....      BL       FlashWrite
   \      0x120   0x4680             MOV      R8,R0
   4775                  /* readback the data and check if the alla data is OK */
   4776                  if (ferr == FR_OK)
   \      0x122   0x4640             MOV      R0,R8
   \      0x124   0xB2C0             UXTB     R0,R0
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD130             BNE.N    ??saveSlaveParameters_2
   4777                  {
   4778                    ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)ptrAreaConfPar, sizeof(areaConfPar_st));
   \      0x12A   0x4652             MOV      R2,R10
   \      0x12C   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x130   0xF45F 0x10A0      MOVS     R0,#+1310720
   \      0x134   0x.... 0x....      BL       FlashRead
   \      0x138   0x4680             MOV      R8,R0
   4779                    for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   \      0x13A   0x2000             MOVS     R0,#+0
   \      0x13C   0x0006             MOVS     R6,R0
   \      0x13E   0x2000             MOVS     R0,#+0
   \      0x140   0x0007             MOVS     R7,R0
   \      0x142   0x0025             MOVS     R5,R4
   \                     ??saveSlaveParameters_12: (+1)
   \      0x144   0x0030             MOVS     R0,R6
   \      0x146   0xB280             UXTH     R0,R0
   \      0x148   0xF5B0 0x5F7B      CMP      R0,#+16064
   \      0x14C   0xD205             BCS.N    ??saveSlaveParameters_13
   4780                    {
   4781                      cks += pData[cnt];
   \      0x14E   0x0030             MOVS     R0,R6
   \      0x150   0xB280             UXTH     R0,R0
   \      0x152   0x5C28             LDRB     R0,[R5, R0]
   \      0x154   0x183F             ADDS     R7,R7,R0
   4782                    }
   \      0x156   0x1C76             ADDS     R6,R6,#+1
   \      0x158   0xE7F4             B.N      ??saveSlaveParameters_12
   4783                    if (ptrAreaConfPar->globalCkecksumControl != cks)
   \                     ??saveSlaveParameters_13: (+1)
   \      0x15A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x15E   0xF850 0x000B      LDR      R0,[R0, R11]
   \      0x162   0x42B8             CMP      R0,R7
   \      0x164   0xD001             BEQ.N    ??saveSlaveParameters_14
   4784                    {
   4785                      ferr = FR_DISK_ERR;
   \      0x166   0x2001             MOVS     R0,#+1
   \      0x168   0x4680             MOV      R8,R0
   4786                    }
   4787                    if (ferr == FR_OK)
   \                     ??saveSlaveParameters_14: (+1)
   \      0x16A   0x4640             MOV      R0,R8
   \      0x16C   0xB2C0             UXTB     R0,R0
   \      0x16E   0x2800             CMP      R0,#+0
   \      0x170   0xD106             BNE.N    ??saveSlaveParameters_15
   4788                    {
   4789                      tPrintf("eeprom slave info %2d saved in SPI flash!!\n\r", idLogic + 1);
   \      0x172   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \      0x176   0x1C49             ADDS     R1,R1,#+1
   \      0x178   0x....             LDR.N    R0,??DataTable53_15
   \      0x17A   0x.... 0x....      BL       tPrintf
   \      0x17E   0xE005             B.N      ??saveSlaveParameters_2
   4790                    }
   4791                    else
   4792                    {
   4793                      tPrintf("Error on write eeprom slave info in SPI flash!!\n\r");
   \                     ??saveSlaveParameters_15: (+1)
   \      0x180   0x....             LDR.N    R0,??DataTable53_16
   \      0x182   0x.... 0x....      BL       tPrintf
   \      0x186   0xE001             B.N      ??saveSlaveParameters_2
   4794                    }
   4795                  }
   4796                }
   4797                else
   4798                {
   4799                  ferr = FR_NOT_READY;
   \                     ??saveSlaveParameters_9: (+1)
   \      0x188   0x2003             MOVS     R0,#+3
   \      0x18A   0x4680             MOV      R8,R0
   4800                }
   4801              }
   4802            }
   4803            if (pConfPar != NULL)
   \                     ??saveSlaveParameters_2: (+1)
   \      0x18C   0x2C00             CMP      R4,#+0
   \      0x18E   0xD002             BEQ.N    ??saveSlaveParameters_16
   4804            {
   4805              free((void*)pConfPar);
   \      0x190   0x0020             MOVS     R0,R4
   \      0x192   0x.... 0x....      BL       free
   4806            }
   4807            if (ptrAreaConfPar != NULL)
   \                     ??saveSlaveParameters_16: (+1)
   \      0x196   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x19A   0x2800             CMP      R0,#+0
   \      0x19C   0xD006             BEQ.N    ??saveSlaveParameters_17
   4808            {
   4809              free((void*)ptrAreaConfPar);
   \      0x19E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x1A2   0x.... 0x....      BL       free
   4810              ptrAreaConfPar = NULL;
   \      0x1A6   0x2000             MOVS     R0,#+0
   \      0x1A8   0xF8C9 0x0000      STR      R0,[R9, #+0]
   4811            }
   4812            return ((uint8_t)ferr);
   \                     ??saveSlaveParameters_17: (+1)
   \      0x1AC   0x4640             MOV      R0,R8
   \      0x1AE   0xB2C0             UXTB     R0,R0
   \                     ??saveSlaveParameters_1: (+1)
   \      0x1B0   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   4813          }
   4814          
   4815          
   4816          /**
   4817          *
   4818          * @brief       get and send to master all slave parameters in 
   4819          *              stored in EEPROM area 
   4820          *
   4821          * @param [in]  uint8_t: slave logic address     
   4822          *  
   4823          * @retval      uint8_t: number of saved slave  
   4824          *              
   4825          *  
   4826          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4827          uint8_t getAndsendAllSlaveParameters(uint8_t idLogic)
   4828          {
   \                     getAndsendAllSlaveParameters: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   4829            uint16_t          cnt;
   4830            blockConfPar_st*  pConfPar;
   4831            uint8_t*          pData;
   4832            uint8_t           result;
   4833          
   4834            pConfPar = (blockConfPar_st*)malloc(sizeof(blockConfPar_st));
   \        0x6   0xF44F 0x707B      MOV      R0,#+1004
   \        0xA   0x.... 0x....      BL       malloc
   \        0xE   0x0005             MOVS     R5,R0
   4835          
   4836            /*             Start to set logic SCU id [0..15]                                                                 */
   4837            pConfPar->idLogicScu = (uint16_t)idLogic;
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0x8028             STRH     R0,[R5, #+0]
   4838            /*             Start to copy eeprom array area                                                                   */
   4839            /*             destination                                  source                           len                 */
   4840            memcpy((uint8_t *)pConfPar->confEepromParamArray, (uint8_t *)getEepromArray(), EEPROM_PARAM_NUM);                             
   \       0x16   0x.... 0x....      BL       getEepromArray
   \       0x1A   0xF05F 0x0944      MOVS     R9,#+68
   \       0x1E   0x9001             STR      R0,[SP, #+4]
   \       0x20   0x1CAE             ADDS     R6,R5,#+2
   \       0x22   0x464A             MOV      R2,R9
   \       0x24   0x9901             LDR      R1,[SP, #+4]
   \       0x26   0x0030             MOVS     R0,R6
   \       0x28   0x.... 0x....      BL       __aeabi_memcpy
   4841            /*             Copy infostation           area                                                                   */
   4842            /*             destination                                  source                           len                 */
   4843            memcpy((uint8_t *)&pConfPar->confInfoStation, (uint8_t *)getStationName(), sizeof (infoStation_t));                             
   \       0x2C   0x.... 0x....      BL       getStationName
   \       0x30   0xF44F 0x7ABE      MOV      R10,#+380
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0xF115 0x0648      ADDS     R6,R5,#+72
   \       0x3A   0x4652             MOV      R2,R10
   \       0x3C   0x9900             LDR      R1,[SP, #+0]
   \       0x3E   0x0030             MOVS     R0,R6
   \       0x40   0x.... 0x....      BL       __aeabi_memcpy
   4844            /*             Copy backup infostation           area                                                            */
   4845            /*                           data origin                         buffer destination                    len       */
   4846            result = ReadFromEeprom (EDATA_BKP_SCU_EE_ADDRESS, (uint8_t *)&pConfPar->confBackupInfoStation, sizeof (infoStation_t));     
   \       0x44   0xF44F 0x72BE      MOV      R2,#+380
   \       0x48   0xF515 0x71E2      ADDS     R1,R5,#+452
   \       0x4C   0xF44F 0x5080      MOV      R0,#+4096
   \       0x50   0x.... 0x....      BL       ReadFromEeprom
   \       0x54   0x0006             MOVS     R6,R0
   4847            /*             Copy product code    area                                                                         */
   4848            /*                          data origin                         buffer destination                    len        */
   4849            result |= ReadFromEeprom (PRD_CODE_EE_ADDRES, (uint8_t *)&pConfPar->confSerialCode, sizeof (pConfPar->confSerialCode));     
   \       0x56   0x2260             MOVS     R2,#+96
   \       0x58   0xF515 0x7150      ADDS     R1,R5,#+832
   \       0x5C   0xF44F 0x50FD      MOV      R0,#+8096
   \       0x60   0x.... 0x....      BL       ReadFromEeprom
   \       0x64   0x0007             MOVS     R7,R0
   \       0x66   0x4337             ORRS     R7,R7,R6
   4850            /*             Copy Serial Number codes  area                                                                    */
   4851            /*                              data origin                         buffer destination                    len    */
   4852            result |= ReadFromEeprom (EDATA_DEFAULT_ID_CODES, (uint8_t *)&pConfPar->confSerialFactoryCode, sizeof (pConfPar->confSerialFactoryCode));     
   \       0x68   0x223C             MOVS     R2,#+60
   \       0x6A   0xF515 0x7168      ADDS     R1,R5,#+928
   \       0x6E   0xF44F 0x6030      MOV      R0,#+2816
   \       0x72   0x.... 0x....      BL       ReadFromEeprom
   \       0x76   0x4680             MOV      R8,R0
   \       0x78   0xEA58 0x0807      ORRS     R8,R8,R7
   4853          
   4854            pConfPar->confRtcBackup[0] =  HAL_RTCEx_BKUPRead((RTC_HandleTypeDef*)getHandleRtc(), BACKUP_EM_MODEL);
   \       0x7C   0x.... 0x....      BL       getHandleRtc
   \       0x80   0x2107             MOVS     R1,#+7
   \       0x82   0x.... 0x....      BL       HAL_RTCEx_BKUPRead
   \       0x86   0xF8C5 0x03DC      STR      R0,[R5, #+988]
   4855            pConfPar->confRtcBackup[1] =  HAL_RTCEx_BKUPRead((RTC_HandleTypeDef*)getHandleRtc(), BACKUP_EM_ENRG_ACT);
   \       0x8A   0x.... 0x....      BL       getHandleRtc
   \       0x8E   0x2108             MOVS     R1,#+8
   \       0x90   0x.... 0x....      BL       HAL_RTCEx_BKUPRead
   \       0x94   0xF8C5 0x03E0      STR      R0,[R5, #+992]
   4856            pConfPar->confRtcBackup[2] =  HAL_RTCEx_BKUPRead((RTC_HandleTypeDef*)getHandleRtc(), BACKUP_HW_INFO);
   \       0x98   0x.... 0x....      BL       getHandleRtc
   \       0x9C   0x2109             MOVS     R1,#+9
   \       0x9E   0x.... 0x....      BL       HAL_RTCEx_BKUPRead
   \       0xA2   0xF8C5 0x03E4      STR      R0,[R5, #+996]
   4857          
   4858            /* set the checksum */
   4859            for (cnt = 0, pConfPar->ckecksumControl = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(blockConfPar_st) - sizeof(pConfPar->ckecksumControl); cnt++)
   \       0xA6   0xF05F 0x0B00      MOVS     R11,#+0
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xF8C5 0x03E8      STR      R0,[R5, #+1000]
   \       0xB0   0x9502             STR      R5,[SP, #+8]
   \                     ??getAndsendAllSlaveParameters_0: (+1)
   \       0xB2   0x4658             MOV      R0,R11
   \       0xB4   0xB280             UXTH     R0,R0
   \       0xB6   0xF5B0 0x7F7A      CMP      R0,#+1000
   \       0xBA   0xD20B             BCS.N    ??getAndsendAllSlaveParameters_1
   4860            {
   4861              pConfPar->ckecksumControl += (uint32_t)pData[cnt];
   \       0xBC   0xF8D5 0x03E8      LDR      R0,[R5, #+1000]
   \       0xC0   0x9902             LDR      R1,[SP, #+8]
   \       0xC2   0x465A             MOV      R2,R11
   \       0xC4   0xB292             UXTH     R2,R2
   \       0xC6   0x5C89             LDRB     R1,[R1, R2]
   \       0xC8   0x1840             ADDS     R0,R0,R1
   \       0xCA   0xF8C5 0x03E8      STR      R0,[R5, #+1000]
   4862            }
   \       0xCE   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \       0xD2   0xE7EE             B.N      ??getAndsendAllSlaveParameters_0
   4863            osDelay(10); // leave 10ms to give the transmitter the time to repositioning in Rx mode
   \                     ??getAndsendAllSlaveParameters_1: (+1)
   \       0xD4   0x200A             MOVS     R0,#+10
   \       0xD6   0x.... 0x....      BL       osDelay
   4864            /* start transmission on UART RS485 to SCU RS485 Bus using DMA */
   4865            setMallocTx485((uint8_t*)pConfPar);
   \       0xDA   0x0028             MOVS     R0,R5
   \       0xDC   0x.... 0x....      BL       setMallocTx485
   4866            txOnRs485Bus((uint8_t*)pConfPar, (uint16_t)sizeof(blockConfPar_st)); 
   \       0xE0   0xF44F 0x717B      MOV      R1,#+1004
   \       0xE4   0x0028             MOVS     R0,R5
   \       0xE6   0x.... 0x....      BL       txOnRs485Bus
   4867          
   4868            return(result);
   \       0xEA   0x4640             MOV      R0,R8
   \       0xEC   0xB2C0             UXTB     R0,R0
   \       0xEE   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   4869          }
   4870          
   4871          /**
   4872          *
   4873          * @brief       get the pointer to configuration parameter area 
   4874          *
   4875          * @param [in]  none    
   4876          *  
   4877          * @retval      areaConfPar_st*: pointer to area for conf 
   4878          *              parameters
   4879          *  
   4880          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4881          areaConfPar_st* getPtrToConfParam (void) 
   4882          {
   4883            return(ptrAreaConfPar);
   \                     getPtrToConfParam: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_14
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
   4884          }
   4885          
   4886          /**
   4887          *
   4888          * @brief       set the pointer to configuration parameter area 
   4889          *
   4890          * @param [in]  uint8_t*: pointer to block area    
   4891          *  
   4892          * @retval      none 
   4893          *  
   4894          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4895          void setPtrToConfParam (uint8_t* ptr) 
   4896          {
   4897            ptrAreaConfPar = (areaConfPar_st*)ptr;
   \                     setPtrToConfParam: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_14
   \        0x2   0x6008             STR      R0,[R1, #+0]
   4898          }
   \        0x4   0x4770             BX       LR
   4899          
   4900          /**
   4901          *
   4902          * @brief       get, from external SPI flash, the status on 
   4903          *              slave configuration parameter area
   4904          *
   4905          * @param [in]  uint16_t: mask for last detected slave     
   4906          *  
   4907          * @retval      none  
   4908          *  
   4909          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4910          static void setInfoEepromSlaveDone(uint16_t lastDetected)
   4911          {
   4912          #ifdef BOARD_REPAIR
   4913            areaConfPar_st*   pConfPar;
   4914            uint8_t*          pData;
   4915            FRESULT           ferr;
   4916            uint16_t          cnt, mask;
   4917            uint32_t          cks;
   4918          
   4919            pConfPar = (areaConfPar_st*)malloc(sizeof(areaConfPar_st));
   4920            sbcSemInfoMng.infoEepromSlaveToDo = (uint16_t)0;
   4921          
   4922            /* read from external SPI flash the info slave eeprom parameters */
   4923            ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)pConfPar, sizeof(areaConfPar_st));
   4924            /* check if the alla data is OK */
   4925            if (ferr == FR_OK)
   4926            {
   4927              for (cnt = 0, cks = 0, pData = (uint8_t*)pConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   4928              {
   4929                cks += pData[cnt];
   4930              }
   4931              if (pConfPar->globalCkecksumControl == cks)
   4932              {
   4933                /* the data is valid and the info on slave eeprom parameters are in the malloc area  */
   4934                for (cnt = 0, mask = (uint16_t)1; cnt < SCU_NUM; cnt++, mask = mask << 1)
   4935                {
   4936                  if (cnt == 0) continue;
   4937                  if (pConfPar->blockConfPar[cnt].idLogicScu != cnt)
   4938                  {
   4939                    /* the info for this slave isn't present so must be request */
   4940                    sbcSemInfoMng.infoEepromSlaveToDo |= mask;
   4941                  }
   4942                }
   4943              }
   4944              else
   4945              {
   4946                /* the SPI flash area is empty so the info eeprom must be request for all slaves detected */
   4947                sbcSemInfoMng.infoEepromSlaveToDo = (uint16_t)0xFFFE;
   4948              }
   4949            }
   4950            free(pConfPar);
   4951          #else
   4952            sbcSemInfoMng.infoEepromSlaveToDo = (uint16_t)0;
   \                     setInfoEepromSlaveDone: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             LDR.N    R2,??DataTable53_5
   \        0x4   0x8491             STRH     R1,[R2, #+36]
   4953          #endif
   4954          }
   \        0x6   0x4770             BX       LR
   4955          
   4956          /**
   4957          *
   4958          * @brief       get and send to slave all previuos eeprom 
   4959          *              parameters stored in SPI flash area
   4960          *
   4961          * @param [in]  uint8_t: slave logic address     
   4962          *  
   4963          * @retval      uint8_t: 0 for no errors   
   4964          *              
   4965          *  
   4966          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   4967          static uint8_t sendEeepromInfoForCloning(uint8_t idLogic)
   4968          {
   \                     sendEeepromInfoForCloning: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   4969            uint16_t          cnt;
   4970            blockConfPar_st*  pConfPar;
   4971            uint8_t*          pData;
   4972            uint32_t          cks;
   4973            FRESULT           ferr;
   4974          
   4975            ptrAreaConfPar = (areaConfPar_st*)malloc(sizeof(areaConfPar_st));
   \        0x6   0x.... 0x....      LDR.W    R10,??DataTable53_14
   \        0xA   0xF643 0x69C4      MOVW     R9,#+16068
   \        0xE   0x4648             MOV      R0,R9
   \       0x10   0x.... 0x....      BL       malloc
   \       0x14   0xF8CA 0x0000      STR      R0,[R10, #+0]
   4976            sbcSemInfoMng.infoEepromSlaveToDo = (uint16_t)0;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x....             LDR.N    R1,??DataTable53_5
   \       0x1C   0x8488             STRH     R0,[R1, #+36]
   4977          
   4978            /* read from external SPI flash the info slave eeprom parameters */
   4979            ferr = (FRESULT)FlashRead(ALL_CONF_PARS_EXT_FLASH_ADDR, (uint8_t*)ptrAreaConfPar, sizeof(areaConfPar_st));
   \       0x1E   0x464A             MOV      R2,R9
   \       0x20   0xF8DA 0x1000      LDR      R1,[R10, #+0]
   \       0x24   0xF45F 0x10A0      MOVS     R0,#+1310720
   \       0x28   0x.... 0x....      BL       FlashRead
   \       0x2C   0x4681             MOV      R9,R0
   4980            /* check if the alla data is OK */
   4981            if (ferr == FR_OK)
   \       0x2E   0x4648             MOV      R0,R9
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD143             BNE.N    ??sendEeepromInfoForCloning_0
   4982            {
   4983              for (cnt = 0, cks = 0, pData = (uint8_t*)ptrAreaConfPar; cnt < sizeof(areaConfPar_st) - sizeof(cks); cnt++)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x0005             MOVS     R5,R0
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x4680             MOV      R8,R0
   \       0x3E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x42   0x0007             MOVS     R7,R0
   \                     ??sendEeepromInfoForCloning_1: (+1)
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0xB280             UXTH     R0,R0
   \       0x48   0xF5B0 0x5F7B      CMP      R0,#+16064
   \       0x4C   0xD206             BCS.N    ??sendEeepromInfoForCloning_2
   4984              {
   4985                cks += pData[cnt];
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0xB280             UXTH     R0,R0
   \       0x52   0x5C38             LDRB     R0,[R7, R0]
   \       0x54   0xEB18 0x0800      ADDS     R8,R8,R0
   4986              }
   \       0x58   0x1C6D             ADDS     R5,R5,#+1
   \       0x5A   0xE7F3             B.N      ??sendEeepromInfoForCloning_1
   4987              if (ptrAreaConfPar->globalCkecksumControl == cks)
   \                     ??sendEeepromInfoForCloning_2: (+1)
   \       0x5C   0x....             LDR.N    R0,??DataTable53_14
   \       0x5E   0x6801             LDR      R1,[R0, #+0]
   \       0x60   0xF511 0x517B      ADDS     R1,R1,#+16064
   \       0x64   0x6809             LDR      R1,[R1, #+0]
   \       0x66   0x4541             CMP      R1,R8
   \       0x68   0xD127             BNE.N    ??sendEeepromInfoForCloning_3
   4988              {
   4989                if (ptrAreaConfPar->blockConfPar[idLogic].idLogicScu == idLogic)
   \       0x6A   0xF44F 0x717B      MOV      R1,#+1004
   \       0x6E   0x6802             LDR      R2,[R0, #+0]
   \       0x70   0x0023             MOVS     R3,R4
   \       0x72   0xB2DB             UXTB     R3,R3
   \       0x74   0x434B             MULS     R3,R1,R3
   \       0x76   0x5AD2             LDRH     R2,[R2, R3]
   \       0x78   0x0023             MOVS     R3,R4
   \       0x7A   0xB2DB             UXTB     R3,R3
   \       0x7C   0xB29B             UXTH     R3,R3
   \       0x7E   0x429A             CMP      R2,R3
   \       0x80   0xD118             BNE.N    ??sendEeepromInfoForCloning_4
   4990                {
   4991                  pConfPar = &ptrAreaConfPar->blockConfPar[idLogic];
   \       0x82   0x6802             LDR      R2,[R0, #+0]
   \       0x84   0x0023             MOVS     R3,R4
   \       0x86   0xB2DB             UXTB     R3,R3
   \       0x88   0xFB01 0xF103      MUL      R1,R1,R3
   \       0x8C   0x4411             ADD      R1,R2,R1
   \       0x8E   0x000E             MOVS     R6,R1
   4992                  /* start transmission on UART RS485 to SCU RS485 Bus using DMA */
   4993                  setMallocTx485((uint8_t*)ptrAreaConfPar);
   \       0x90   0x6800             LDR      R0,[R0, #+0]
   \       0x92   0x.... 0x....      BL       setMallocTx485
   4994                  txOnRs485Bus((uint8_t*)pConfPar, (uint16_t)sizeof(blockConfPar_st)); 
   \       0x96   0xF44F 0x717B      MOV      R1,#+1004
   \       0x9A   0x0030             MOVS     R0,R6
   \       0x9C   0x.... 0x....      BL       txOnRs485Bus
   4995                  tPrintf("Restored eeprom slave %02d info from SPI flash!!\n\r", idLogic + 1);
   \       0xA0   0x0021             MOVS     R1,R4
   \       0xA2   0xB2C9             UXTB     R1,R1
   \       0xA4   0x1C49             ADDS     R1,R1,#+1
   \       0xA6   0x....             LDR.N    R0,??DataTable53_17
   \       0xA8   0x.... 0x....      BL       tPrintf
   4996                  osDelay(100);
   \       0xAC   0x2064             MOVS     R0,#+100
   \       0xAE   0x.... 0x....      BL       osDelay
   \       0xB2   0xE004             B.N      ??sendEeepromInfoForCloning_0
   4997                }
   4998                else
   4999                {
   5000                  ferr = FR_INT_ERR;
   \                     ??sendEeepromInfoForCloning_4: (+1)
   \       0xB4   0x2002             MOVS     R0,#+2
   \       0xB6   0x4681             MOV      R9,R0
   \       0xB8   0xE001             B.N      ??sendEeepromInfoForCloning_0
   5001                }
   5002              }
   5003              else
   5004              {
   5005                ferr = FR_DISK_ERR;
   \                     ??sendEeepromInfoForCloning_3: (+1)
   \       0xBA   0x2001             MOVS     R0,#+1
   \       0xBC   0x4681             MOV      R9,R0
   5006              }
   5007            }
   5008            return((uint8_t)ferr);
   \                     ??sendEeepromInfoForCloning_0: (+1)
   \       0xBE   0x4648             MOV      R0,R9
   \       0xC0   0xB2C0             UXTB     R0,R0
   \       0xC2   0xE8BD 0x87F0      POP      {R4-R10,PC}
   5009          }
   5010          
   5011          /**
   5012          *
   5013          * @brief       get discovery status  
   5014          *
   5015          * @param [in]  none    
   5016          *  
   5017          * @retval      uint32_t: 0 if the discovery phase isn't active 
   5018          *  
   5019          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   5020          uint32_t getDiscoveryStatus (void) 
   5021          {
   5022            return(sbcSemInfoMng.discoveryMask);
   \                     getDiscoveryStatus: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_5
   \        0x2   0xF8D1 0x000A      LDR      R0,[R1, #+10]
   \        0x6   0x4770             BX       LR
   5023          }
   5024          
   5025          /**
   5026          *
   5027          * @brief       get info eeprom for slave  status  
   5028          *
   5029          * @param [in]  none    
   5030          *  
   5031          * @retval      uint16_t: bit mask for slave eeprom info 
   5032          *  
   5033          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   5034          uint16_t getInfoEepromSlaveStatus (void) 
   5035          {
   5036            return(sbcSemInfoMng.infoEepromSlaveToDo);
   \                     getInfoEepromSlaveStatus: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable53_5
   \        0x2   0x8C80             LDRH     R0,[R0, #+36]
   \        0x4   0x4770             BX       LR
   5037          }
   5038          
   5039          /**
   5040          *
   5041          * @brief       set info eeprom for slave  status  
   5042          *
   5043          * @param [in]  uint16_t: bit mask for slave eeprom info    
   5044          *  
   5045          * @retval      none 
   5046          *  
   5047          ****************************************************************/

   \                                 In section .text, align 2, keep-with-next
   5048          void setInfoEepromSlaveStatus (uint16_t logicSlave) 
   5049          {
   5050            uint16_t              maskBit;
   5051          
   5052            maskBit = (uint16_t)sbcSemMaskBit[logicSlave];
   \                     setInfoEepromSlaveStatus: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable53_1
   \        0x2   0x0002             MOVS     R2,R0
   \        0x4   0xB292             UXTH     R2,R2
   \        0x6   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   5053            sbcSemInfoMng.infoEepromSlaveToDo &= (~maskBit);
   \        0xA   0x....             LDR.N    R2,??DataTable53_5
   \        0xC   0x8C93             LDRH     R3,[R2, #+36]
   \        0xE   0x438B             BICS     R3,R3,R1
   \       0x10   0x8493             STRH     R3,[R2, #+36]
   5054          }
   \       0x12   0x4770             BX       LR
   5055          
   5056                                
   5057          
   5058          
   5059          #ifdef MODBUS_TCP_EM_LOVATO
   5060          /**
   5061          *
   5062          * @brief        Ask to master for active power for all the socket   
   5063          *
   5064          * @param [in]   none 
   5065          *
   5066          * @retval       none:  
   5067          *
   5068          ***********************************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   5069          void  readEmValuesFromMaster (void)
   5070          {
   \                     readEmValuesFromMaster: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   5071            uint8_t*                pEnd;
   5072            headerRHR_t*            pMsg;
   5073            uint8_t*                pMallocTx;
   5074            uint16_t                length;
   5075            crcMode_u               crc;
   5076          
   5077            pMallocTx = (uint8_t*)malloc(sizeof(headerRHR_t) + (uint16_t)sizeof(crc)); // remember + 2 for checksum 
   \        0x2   0x2008             MOVS     R0,#+8
   \        0x4   0x.... 0x....      BL       malloc
   \        0x8   0x0005             MOVS     R5,R0
   5078            pMsg = (headerRHR_t*)pMallocTx;
   \        0xA   0x002C             MOVS     R4,R5
   5079            /* the command must be executed    */
   5080            length = (uint16_t)sizeof(headerRHR_t);
   \        0xC   0x2606             MOVS     R6,#+6
   5081            pMsg->unitId = SCU_M_P_ADDR; 
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0x7020             STRB     R0,[R4, #+0]
   5082            pMsg->function = FUNCTION_READ_INPUT_REG;
   \       0x12   0x2004             MOVS     R0,#+4
   \       0x14   0x7060             STRB     R0,[R4, #+1]
   5083            pMsg->regAdd = swapW(ADDR_EM_LOVATO_V_SYS);
   \       0x16   0xF44F 0x60AA      MOV      R0,#+1360
   \       0x1A   0x.... 0x....      BL       swapW
   \       0x1E   0x8060             STRH     R0,[R4, #+2]
   5084            pMsg->numBytes = swapW(sizeof(scuMapRegLovatoEmSim_st) / 2);
   \       0x20   0x2031             MOVS     R0,#+49
   \       0x22   0x.... 0x....      BL       swapW
   \       0x26   0x80A0             STRH     R0,[R4, #+4]
   5085          
   5086            /* now found the CRC message */
   5087            crc.crcW = crcEvaluation ((uint8_t*)pMsg, length);
   \       0x28   0x0031             MOVS     R1,R6
   \       0x2A   0xB289             UXTH     R1,R1
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       crcEvaluation
   \       0x32   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   5088            /* position pEnd pointer on crc field */
   5089            pEnd =  (uint8_t*)((uint32_t)pMsg + (uint32_t)length);
   \       0x36   0xFA14 0xF086      UXTAH    R0,R4,R6
   5090            *pEnd = crc.crcLH_st.crcL;
   \       0x3A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x3E   0x7001             STRB     R1,[R0, #+0]
   5091            pEnd++;
   \       0x40   0x1C47             ADDS     R7,R0,#+1
   5092            *pEnd = crc.crcLH_st.crcH;
   \       0x42   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x46   0x7038             STRB     R0,[R7, #+0]
   5093            length += sizeof(crc.crcW);
   \       0x48   0x1CB6             ADDS     R6,R6,#+2
   5094          
   5095            if (xSemaphoreTake(getScuSinapsiTxUartSemaphoreHandle(), portMAX_DELAY) == pdTRUE)
   \       0x4A   0x.... 0x....      BL       getScuSinapsiTxUartSemaphoreHandle
   \       0x4E   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0x52   0x.... 0x....      BL       xQueueSemaphoreTake
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD107             BNE.N    ??readEmValuesFromMaster_0
   5096            {
   5097              setMallocTx485(pMallocTx);
   \       0x5A   0x0028             MOVS     R0,R5
   \       0x5C   0x.... 0x....      BL       setMallocTx485
   5098              /* start transmission on UART RS485 to SCU RS485 Bus using DMA */
   5099              txOnRs485Bus((uint8_t*)pMsg, (uint16_t)length); 
   \       0x60   0x0031             MOVS     R1,R6
   \       0x62   0xB289             UXTH     R1,R1
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       txOnRs485Bus
   5100            }
   5101          }
   \                     ??readEmValuesFromMaster_0: (+1)
   \       0x6A   0xBDF1             POP      {R0,R4-R7,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     socketPresence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     sbcSemQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x....'....        DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x....'....        DC32     sbcSemTimCallBack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0x....'....        DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x....'....        DC32     packetStatsCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \        0x0   0x....'....        DC32     ptrAreaConfPar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \        0x0   0x....'....        DC32     frameSbcSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x....'....        DC32     pollingSlaveTask_attributes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     pollingSlaveTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     pollingSlaveTaskHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     pollingSlaveMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     headMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     xSbcSemTimers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     sbcSemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     ?_23

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     pScuRoMapReg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x....'....        DC32     sbcSemMaskBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x....'....        DC32     currFrameSbcSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x....'....        DC32     ?_24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     sbcSemQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x....'....        DC32     rs485SemQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     rs485SemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x....'....        DC32     framers485Sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x....'....        DC32     socketPresence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0x....'....        DC32     ?_25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     `HW_CHECKS_ACTUATORS_EEprom_Save::temp`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x....'....        DC32     remoteMngQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     lastCommandSent

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x....'....        DC32     `semUpdateConfig::temp`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     numberOnLcd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x....'....        DC32     pScuRoMapReg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x....'....        DC32     AddrUidStr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x....'....        DC32     AddrEventFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x....'....        DC32     prevState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x....'....        DC32     AddrChargStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x....'....        DC32     nameState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x....'....        DC32     AddrErr1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0x....'....        DC32     AddrErr2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0x....'....        DC32     AddrConnType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0x....'....        DC32     AddrSessId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x....'....        DC32     AddrEm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0x....'....        DC32     AddrMeasure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \        0x0   0x....'....        DC32     sbcSemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \        0x0   0x....'....        DC32     ?_26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     sbcSemMaskBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     socketPresence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     currFrameSbcSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     ?_27

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \        0x0   0x....'....        DC32     ?_28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0x....'....        DC32     pScuTmMapReg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \        0x0   0x....'....        DC32     xSbcSemTimers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \        0x0   0x....'....        DC32     ?_29

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \        0x0   0x....'....        DC32     pollingSlaveQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \        0x0   0x....'....        DC32     ?_30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \        0x0   0x....'....        DC32     pollingSlaveMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \        0x0   0x....'....        DC32     frameSbcSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0x....'....        DC32     sbcSemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \        0x0   0x....'....        DC32     pScuRoMapReg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \        0x0   0x....'....        DC32     ?_31

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_1:
   \        0x0   0x....'....        DC32     ?_32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_2:
   \        0x0   0x....'....        DC32     ?_33

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \        0x0   0x0001'D4C0        DC32     0x1d4c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_1:
   \        0x0   0x....'....        DC32     ?_34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_2:
   \        0x0   0x....'....        DC32     ?_35

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47:
   \        0x0   0x....'....        DC32     numberOnLcd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \        0x0   0x....'....        DC32     socketPresence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_1:
   \        0x0   0x....'....        DC32     sbcSemMaskBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_2:
   \        0x0   0x....'....        DC32     ?_36

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_3:
   \        0x0   0x....'....        DC32     Default_Socket_Presence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_4:
   \        0x0   0x....'....        DC32     ?_37

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_5:
   \        0x0   0x....'....        DC32     sbcSemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_6:
   \        0x0   0x....'....        DC32     remoteMngQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_7:
   \        0x0   0x....'....        DC32     remoteMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_8:
   \        0x0   0x....'....        DC32     xSbcSemTimers

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_9:
   \        0x0   0x....'....        DC32     ?_38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_10:
   \        0x0   0x....'....        DC32     ?_39

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_11:
   \        0x0   0x....'....        DC32     packetStatsCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_12:
   \        0x0   0x....'....        DC32     rs485SemInfoMng

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_13:
   \        0x0   0x....'....        DC32     ?_40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_14:
   \        0x0   0x....'....        DC32     ptrAreaConfPar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_15:
   \        0x0   0x....'....        DC32     ?_41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_16:
   \        0x0   0x....'....        DC32     ?_42

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_17:
   \        0x0   0x....'....        DC32     ?_43

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x20 0x49          DC8 " Initial"
   \              0x6E 0x69    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x20 0x49          DC8 " Idle"
   \              0x64 0x6C    
   \              0x65 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x20 0x50          DC8 " Preparing"
   \              0x72 0x65    
   \              0x70 0x61    
   \              0x72 0x69    
   \              0x6E 0x67    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x20 0x45          DC8 " Ev Connected"
   \              0x76 0x20    
   \              0x43 0x6F    
   \              0x6E 0x6E    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x00
   \        0xE                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x20 0x43          DC8 " Charging"
   \              0x68 0x61    
   \              0x72 0x67    
   \              0x69 0x6E    
   \              0x67 0x00
   \        0xA                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x20 0x53          DC8 " Suspended Ev"
   \              0x75 0x73    
   \              0x70 0x65    
   \              0x6E 0x64    
   \              0x65 0x64    
   \              0x20 0x45    
   \              0x76 0x00
   \        0xE                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x20 0x53          DC8 " Suspended EvSe"
   \              0x75 0x73    
   \              0x70 0x65    
   \              0x6E 0x64    
   \              0x65 0x64    
   \              0x20 0x45    
   \              0x76 0x53    
   \              0x65 0x00

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0x20 0x45          DC8 " End Charge"
   \              0x6E 0x64    
   \              0x20 0x43    
   \              0x68 0x61    
   \              0x72 0x67    
   \              0x65 0x00

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x20 0x46          DC8 " Faulted"
   \              0x61 0x75    
   \              0x6C 0x74    
   \              0x65 0x64    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_9:
   \        0x0   0x20 0x55          DC8 " Unavailable"
   \              0x6E 0x61    
   \              0x76 0x61    
   \              0x69 0x6C    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x20 0x52          DC8 " Reserved"
   \              0x65 0x73    
   \              0x65 0x72    
   \              0x76 0x65    
   \              0x64 0x00
   \        0xA                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_11:
   \        0x0   0x20 0x42          DC8 " Bootloader"
   \              0x6F 0x6F    
   \              0x74 0x6C    
   \              0x6F 0x61    
   \              0x64 0x65    
   \              0x72 0x00

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x53 0x68          DC8 "Shutdown"
   \              0x75 0x74    
   \              0x64 0x6F    
   \              0x77 0x6E    
   \              0x00
   \        0x9                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x20 0x52          DC8 " Rebooting"
   \              0x65 0x62    
   \              0x6F 0x6F    
   \              0x74 0x69    
   \              0x6E 0x67    
   \              0x00
   \        0xB                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0x20 0x53          DC8 " Suspended NoPower"
   \              0x75 0x73    
   \              0x70 0x65    
   \              0x6E 0x64    
   \              0x65 0x64    
   \              0x20 0x4E    
   \              0x6F 0x50    
   \              0x6F 0x77    
   \              0x65 0x72    
   \              0x00
   \       0x13                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x50 0x4F          DC8 "POLLING_SLAVE"
   \              0x4C 0x4C    
   \              0x49 0x4E    
   \              0x47 0x5F    
   \              0x53 0x4C    
   \              0x41 0x56    
   \              0x45 0x00
   \        0xE                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x53 0x55          DC8 "SUSP_REL_TASK"
   \              0x53 0x50    
   \              0x5F 0x52    
   \              0x45 0x4C    
   \              0x5F 0x54    
   \              0x41 0x53    
   \              0x4B 0x00
   \        0xE                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x73 0x62          DC8 "sbcSemQueue"
   \              0x63 0x53    
   \              0x65 0x6D    
   \              0x51 0x75    
   \              0x65 0x75    
   \              0x65 0x00

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x54 0x69          DC8 "TimSbcSem"
   \              0x6D 0x53    
   \              0x62 0x63    
   \              0x53 0x65    
   \              0x6D 0x00
   \        0xA                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x4D 0x61          DC8 "Matrix Initializated\012\015"
   \              0x74 0x72    
   \              0x69 0x78    
   \              0x20 0x49    
   \              0x6E 0x69    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x69 0x7A    
   \              0x61 0x74    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00
   \       0x17                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x53 0x6F          DC8 0x53, 0x6F, 0x63, 0x6B, 0x65, 0x74, 0x20, 0x70
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x70
   \        0x8   0x72 0x65          DC8 0x72, 0x65, 0x73, 0x65, 0x6E, 0x63, 0x65, 0x20
   \              0x73 0x65    
   \              0x6E 0x63    
   \              0x65 0x20
   \       0x10   0x69 0x6E          DC8 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74
   \              0x66 0x6F    
   \              0x72 0x6D    
   \              0x61 0x74
   \       0x18   0x69 0x6F          DC8 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x70, 0x72, 0x6F
   \              0x6E 0x73    
   \              0x20 0x70    
   \              0x72 0x6F
   \       0x20   0x67 0x72          DC8 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x65, 0x64, 0x20
   \              0x61 0x6D    
   \              0x6D 0x65    
   \              0x64 0x20
   \       0x28   0x74 0x6F          DC8 0x74, 0x6F, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75
   \              0x20 0x64    
   \              0x65 0x66    
   \              0x61 0x75
   \       0x30   0x6C 0x74          DC8 0x6C, 0x74, 0x20, 0x0A, 0x0D, 0
   \              0x20 0x0A    
   \              0x0D 0x00
   \       0x36                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x50 0x72          DC8 "Presences detected at reset --> 0x%x\012\015"
   \              0x65 0x73    
   \              0x65 0x6E    
   \              0x63 0x65    
   \              0x73 0x20    
   \              0x64 0x65    
   \              0x74 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x61    
   \              0x74 0x20    
   \              0x72 0x65    
   \              0x73 0x65    
   \              0x74 0x20    
   \              0x2D 0x2D    
   \              0x3E 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0A 0x0D    
   \              0x00
   \       0x27                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x41 0x62          DC8 "Abort: No info received from Addr = %d!\012\015"
   \              0x6F 0x72    
   \              0x74 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x69 0x6E    
   \              0x66 0x6F    
   \              0x20 0x72    
   \              0x65 0x63    
   \              0x65 0x69    
   \              0x76 0x65    
   \              0x64 0x20    
   \              0x66 0x72    
   \              0x6F 0x6D    
   \              0x20 0x41    
   \              0x64 0x64    
   \              0x72 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x21 0x0A    
   \              0x0D 0x00
   \       0x2A                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_23:
   \        0x0   0x50 0x72          DC8 "Presences detected --> 0x%x\012\015"
   \              0x65 0x73    
   \              0x65 0x6E    
   \              0x63 0x65    
   \              0x73 0x20    
   \              0x64 0x65    
   \              0x74 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x2D    
   \              0x2D 0x3E    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x78 0x0A    
   \              0x0D 0x00
   \       0x1E                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_24:
   \        0x0   0x53 0x6F          DC8 "Socket %d Event 0x%X sent!\012\015"
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x25    
   \              0x64 0x20    
   \              0x45 0x76    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x30 0x78    
   \              0x25 0x58    
   \              0x20 0x73    
   \              0x65 0x6E    
   \              0x74 0x21    
   \              0x0A 0x0D    
   \              0x00
   \       0x1D                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_25:
   \        0x0   0x53 0x6F          DC8 "Socket %d retrasmission!\012\015"
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x25    
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x74 0x72    
   \              0x61 0x73    
   \              0x6D 0x69    
   \              0x73 0x73    
   \              0x69 0x6F    
   \              0x6E 0x21    
   \              0x0A 0x0D    
   \              0x00
   \       0x1B                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_26:
   \        0x0   0x53 0x6F          DC8 "Socket %d Reg=0x%X %s Value= 0x%X at %s N=0x%X\012\015"
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x25    
   \              0x64 0x20    
   \              0x52 0x65    
   \              0x67 0x3D    
   \              0x30 0x78    
   \              0x25 0x58    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x56 0x61    
   \              0x6C 0x75    
   \              0x65 0x3D    
   \              0x20 0x30    
   \              0x78 0x25    
   \              0x58 0x20    
   \              0x61 0x74    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x4E 0x3D    
   \              0x30 0x78    
   \              0x25 0x58    
   \              0x0A 0x0D    
   \              0x00
   \       0x31                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_27:
   \        0x0   0x41 0x73          DC8 "Assigned address %d\012\015"
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x65 0x64    
   \              0x20 0x61    
   \              0x64 0x64    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x20 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00
   \       0x16                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_28:
   \        0x0   0x4D 0x61          DC8 "Master unavailable!\012\015"
   \              0x73 0x74    
   \              0x65 0x72    
   \              0x20 0x75    
   \              0x6E 0x61    
   \              0x76 0x61    
   \              0x69 0x6C    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x21 0x0A    
   \              0x0D 0x00
   \       0x16                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_29:
   \        0x0   0x53 0x65          DC8 "Sent upgrade eeprom info slave %02d!!\012\015"
   \              0x6E 0x74    
   \              0x20 0x75    
   \              0x70 0x67    
   \              0x72 0x61    
   \              0x64 0x65    
   \              0x20 0x65    
   \              0x65 0x70    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x69 0x6E    
   \              0x66 0x6F    
   \              0x20 0x73    
   \              0x6C 0x61    
   \              0x76 0x65    
   \              0x20 0x25    
   \              0x30 0x32    
   \              0x64 0x21    
   \              0x21 0x0A    
   \              0x0D 0x00

   \                                 In section .rodata, align 4
   \                     ?_30:
   \        0x0   0x50 0x72          DC8 "Presences Defined\012\015"
   \              0x65 0x73    
   \              0x65 0x6E    
   \              0x63 0x65    
   \              0x73 0x20    
   \              0x44 0x65    
   \              0x66 0x69    
   \              0x6E 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00

   \                                 In section .rodata, align 4
   \                     ?_31:
   \        0x0   0x53 0x43          DC8 "SCU %02d off-line! %s\012\015"
   \              0x55 0x20    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x6F    
   \              0x66 0x66    
   \              0x2D 0x6C    
   \              0x69 0x6E    
   \              0x65 0x21    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x0D 0x00

   \                                 In section .rodata, align 4
   \                     ?_32:
   \        0x0   0x53 0x43          DC8 "SCU %02d off-line! Retry=%d %s\012\015"
   \              0x55 0x20    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x6F    
   \              0x66 0x66    
   \              0x2D 0x6C    
   \              0x69 0x6E    
   \              0x65 0x21    
   \              0x20 0x52    
   \              0x65 0x74    
   \              0x72 0x79    
   \              0x3D 0x25    
   \              0x64 0x20    
   \              0x25 0x73    
   \              0x0A 0x0D    
   \              0x00
   \       0x21                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_33:
   \        0x0   0x53 0x43          DC8 "SCU %02d on-line!! %s\012\015"
   \              0x55 0x20    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x6F    
   \              0x6E 0x2D    
   \              0x6C 0x69    
   \              0x6E 0x65    
   \              0x21 0x21    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x0D 0x00

   \                                 In section .rodata, align 4
   \                     ?_34:
   \        0x0   0x53 0x43          DC8 "SCU id%02d --> FW version %s\012\015"
   \              0x55 0x20    
   \              0x69 0x64    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x2D    
   \              0x2D 0x3E    
   \              0x20 0x46    
   \              0x57 0x20    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x25 0x73    
   \              0x0A 0x0D    
   \              0x00
   \       0x1F                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_35:
   \        0x0   0x41 0x64          DC8 "Address %02d Assigned\012\015"
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x41    
   \              0x73 0x73    
   \              0x69 0x67    
   \              0x6E 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00

   \                                 In section .rodata, align 4
   \                     ?_36:
   \        0x0   0x41 0x73          DC8 "Assigned Physical address %d\012\015"
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x65 0x64    
   \              0x20 0x50    
   \              0x68 0x79    
   \              0x73 0x69    
   \              0x63 0x61    
   \              0x6C 0x20    
   \              0x61 0x64    
   \              0x64 0x72    
   \              0x65 0x73    
   \              0x73 0x20    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00
   \       0x1F                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_37:
   \        0x0   0x50 0x72          DC8 "Presences confirmed --> 0x%x\012\015"
   \              0x65 0x73    
   \              0x65 0x6E    
   \              0x63 0x65    
   \              0x73 0x20    
   \              0x63 0x6F    
   \              0x6E 0x66    
   \              0x69 0x72    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x2D 0x2D    
   \              0x3E 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0A 0x0D    
   \              0x00
   \       0x1F                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_38:
   \        0x0   0x53 0x43          DC8 "SCU %02d on-line! %s\012\015"
   \              0x55 0x20    
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x20 0x6F    
   \              0x6E 0x2D    
   \              0x6C 0x69    
   \              0x6E 0x65    
   \              0x21 0x20    
   \              0x25 0x73    
   \              0x0A 0x0D    
   \              0x00
   \       0x17                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_39:
   \        0x0   0x53 0x6F          DC8 "Socket Id %2d removed!\012\015"
   \              0x63 0x6B    
   \              0x65 0x74    
   \              0x20 0x49    
   \              0x64 0x20    
   \              0x25 0x32    
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x6D 0x6F    
   \              0x76 0x65    
   \              0x64 0x21    
   \              0x0A 0x0D    
   \              0x00
   \       0x19                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_40:
   \        0x0   0x45 0x72          DC8 "Error on Sbc Task! St = %d St = %d\015\012"
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x6F 0x6E    
   \              0x20 0x53    
   \              0x62 0x63    
   \              0x20 0x54    
   \              0x61 0x73    
   \              0x6B 0x21    
   \              0x20 0x53    
   \              0x74 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x20 0x53    
   \              0x74 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x0D 0x0A    
   \              0x00
   \       0x25                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_41:
   \        0x0   0x65 0x65          DC8 "eeprom slave info %2d saved in SPI flash!!\012\015"
   \              0x70 0x72    
   \              0x6F 0x6D    
   \              0x20 0x73    
   \              0x6C 0x61    
   \              0x76 0x65    
   \              0x20 0x69    
   \              0x6E 0x66    
   \              0x6F 0x20    
   \              0x25 0x32    
   \              0x64 0x20    
   \              0x73 0x61    
   \              0x76 0x65    
   \              0x64 0x20    
   \              0x69 0x6E    
   \              0x20 0x53    
   \              0x50 0x49    
   \              0x20 0x66    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x21 0x21    
   \              0x0A 0x0D    
   \              0x00
   \       0x2D                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_42:
   \        0x0   0x45 0x72          DC8 "Error on write eeprom slave info in SPI flash!!\012\015"
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x6F 0x6E    
   \              0x20 0x77    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x20 0x65    
   \              0x65 0x70    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x73 0x6C    
   \              0x61 0x76    
   \              0x65 0x20    
   \              0x69 0x6E    
   \              0x66 0x6F    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x53 0x50    
   \              0x49 0x20    
   \              0x66 0x6C    
   \              0x61 0x73    
   \              0x68 0x21    
   \              0x21 0x0A    
   \              0x0D 0x00
   \       0x32                      DS8 2

   \                                 In section .rodata, align 4
   \                     ?_43:
   \        0x0   0x52 0x65          DC8 0x52, 0x65, 0x73, 0x74, 0x6F, 0x72, 0x65, 0x64
   \              0x73 0x74    
   \              0x6F 0x72    
   \              0x65 0x64
   \        0x8   0x20 0x65          DC8 0x20, 0x65, 0x65, 0x70, 0x72, 0x6F, 0x6D, 0x20
   \              0x65 0x70    
   \              0x72 0x6F    
   \              0x6D 0x20
   \       0x10   0x73 0x6C          DC8 0x73, 0x6C, 0x61, 0x76, 0x65, 0x20, 0x25, 0x30
   \              0x61 0x76    
   \              0x65 0x20    
   \              0x25 0x30
   \       0x18   0x32 0x64          DC8 0x32, 0x64, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x20
   \              0x20 0x69    
   \              0x6E 0x66    
   \              0x6F 0x20
   \       0x20   0x66 0x72          DC8 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x53, 0x50, 0x49
   \              0x6F 0x6D    
   \              0x20 0x53    
   \              0x50 0x49
   \       0x28   0x20 0x66          DC8 0x20, 0x66, 0x6C, 0x61, 0x73, 0x68, 0x21, 0x21
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x21 0x21
   \       0x30   0x0A 0x0D          DC8 0x0A, 0x0D, 0
   \              0x00
   \       0x33                      DS8 1
   5102          #endif
   5103          
   5104          /*************** END OF FILE ******************************************************************************************/
   5105          
   5106          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   Actuators_Mdb_to_Eeprom_Translate
        16   -> EEPROM_Save_Config
        16   -> eeprom_array_set
        16   -> eeprom_param_get
        16   -> getHwChecks2
      16   CONN_ID_Set_New
        16   -> WriteOnEeprom
        16   -> getLogicalMdbAddrSem
      24   HW_CHECKS_ACTUATORS_EEprom_Save
        24   -> Actuators_Mdb_to_Eeprom_Translate
        24   -> EEPROM_Save_Config
        24   -> activeImmediateReset
        24   -> eeprom_param_get
        24   -> getCollaudoRunning
        24   -> getHwActuators
        24   -> getHwChecks1
        24   -> getHwChecks2
      16   HW_PRESENCE_FLAG_EEprom_Save
        16   -> EEPROM_Save_Config
        16   -> eeprom_param_get
        16   -> getHwFlags
      16   Print_Slave_Assigned
        16   -> osDelay
        16   -> tPrintf
      16   Print_Slave_FW_Version
        16   -> getRoMdbRegs
        16   -> osDelay
        16   -> tPrintf
      32   addNode
        32   -> __aeabi_memcpy
        32   -> createNode
       0   allTaskAreOperative
      40   checkAssignNewAddress
        40   -> WriteOnEeprom
        40   -> eeprom_array_set
        40   -> getSktNumInFakeCode
        40   -> tPrintf
        40   -> updateScuModbusAddrr
      32   checkToSendReqAddress
        32   -> getNumSktInProduct
        32   -> getSktNumInFakeCode
        32   -> getTagIdFromPrdSn
        32   -> gsy_connected_set
        32   -> xTimerGenericCommand
       8   createNode
         8   -> malloc
      64   extractSendFirstInList
        64   -> __aeabi_memcpy
        64   -> free
        64   -> getSbcSemQueueHandle
        64   -> xQueueGenericSend
      32   forceSBCreadScu
        32   -> getHmsStr
        32   -> getRoMdbRegs
        32   -> getScuOpMode
        32   -> tPrintf
       0   fromRs485ToSem
      48   getAndsendAllSlaveParameters
        48   -> HAL_RTCEx_BKUPRead
        48   -> ReadFromEeprom
        48   -> __aeabi_memcpy
        48   -> getEepromArray
        48   -> getHandleRtc
        48   -> getStationName
        48   -> malloc
        48   -> osDelay
        48   -> setMallocTx485
        48   -> txOnRs485Bus
       0   getDefSocketInfoPtr
       0   getDiscoveryStatus
      16   getFirstFreeLogicId
        16   -> getScuOpMode
       8   getIdNumberForLcd
         8   -> eeprom_param_get
         8   -> isSemMode
       0   getInfoEepromSlaveStatus
      48   getInfoSocket
        48   -> getRoMdbRegs
        48   -> getRs485SemQueueHandle
        48   -> getRwMdbRegs
        48   -> getTmMdbRegs
        48   -> xQueueGenericSend
       0   getModbusAddrFromDevId
       8   getNumSocketLcd
         8   -> getRwMdbRegs
       0   getPacketStatusNum
       0   getPtrToConfParam
       8   getRemotePmFlag
         8   -> eeprom_param_get
       0   getRs485SemQueueHandle
       0   getSbcSemQueueHandle
       8   getSktNumInFakeCode
         8   -> eeprom_param_get
       0   getSocketDiscovered
      16   getTagIdFromPrdSn
        16   -> crcEvaluation
        16   -> getLogicalMdbAddrSem
        16   -> getRoMdbRegs
        16   -> strlen
       0   isModbusManagerActive
       0   isSlaveWaitToBeOperative
       0   is_socketPresence_Programmed
      56   mngReqAddress
        56   -> getFirstFreeLogicId
        56   -> getRs485SemQueueHandle
        56   -> restartSbcSemTimer
        56   -> xQueueGenericSend
      64   pollingSlaveProcess
        64   -> getBroadcastDownload
        64   -> getHmsStr
        64   -> getNumSocketLcd
        64   -> getRoMdbRegs
        64   -> getRs485SemQueueHandle
        64   -> getScuOpMode
        64   -> getStatusDwnl
        64   -> setChangeRegisterBit
        64   -> tPrintf
        64   -> uartReintialization
        64   -> xQueueGenericSend
      40   pollingSlaveTask
        40   -> pollingSlaveProcess
        40   -> xQueueGenericCreate
        40   -> xQueueReceive
      24   readEmValuesFromMaster
        24   -> crcEvaluation
        24   -> getScuSinapsiTxUartSemaphoreHandle
        24   -> malloc
        24   -> setMallocTx485
        24   -> swapW
        24   -> txOnRs485Bus
        24   -> xQueueSemaphoreTake
      32   readMasterModbusRegister
        32   -> crcEvaluation
        32   -> getScuSinapsiTxUartSemaphoreHandle
        32   -> malloc
        32   -> setMallocTx485
        32   -> swapW
        32   -> txOnRs485Bus
        32   -> xQueueSemaphoreTake
       8   readSocketPresence
         8   -> ReadFromEeprom
      24   remoteMngTask
        24   -> remoteSuspRelProcess
        24   -> xQueueGenericCreate
        24   -> xQueueReceive
      24   remoteSuspRelProcess
        24   -> getMaxTempPowerAc
        24   -> getRemotePmFlag
        24   -> osDelay
        24   -> pmng_sem_power_set
        24   -> send_to_evs
      16   removeSocketFromList
        16   -> WriteOnEeprom
        16   -> activeImmediateResetFromRemove
        16   -> tPrintf
      32   resetChangeRegisterBit
        32   -> getRoMdbRegs
        32   -> gsy_quick_polling_update
       0   resetCommandRemote
      16   resetInOperative
        16   -> tPrintf
        16   -> uartReintialization
       0   resetPacketStatusNum
      24   restartSbcSemTimer
        24   -> xTaskGetTickCount
        24   -> xTimerGenericCommand
      24   restoreFactoryDefaultForAll
        24   -> eraseAllBoardInfoEeprom
        24   -> getRs485SemQueueHandle
        24   -> isSemMasterFz
        24   -> osDelay
        24   -> restoreFactoryDefault
        24   -> xQueueGenericSend
      16   restoreOperativeState
        16   -> resetPowerCurrentValues
        16   -> xQueueGenericSend
      40   rs485SemGestTask
        40   -> rs485SemMsgProcess
        40   -> xQueueGenericCreate
        40   -> xQueueReceive
      40   rs485SemMsgProcess
        40   -> getNumSocketLcd
        40   -> getRoMdbRegs
        40   -> getRwMdbRegs
        40   -> getTmMdbRegs
        40   -> readMasterModbusRegister
        40   -> tPrintf
        40   -> writeMasterModbusRegister
       0   saveAllSlaveParameters
      48   saveSlaveParameters
        48   -> FlashRead
        48   -> FlashWrite
        48   -> __aeabi_memcpy
        48   -> free
        48   -> malloc
        48   -> tPrintf
      48   sbcSemGestTask
        48   -> sbcSemMsgProcess
        48   -> vQueueAddToRegistry
        48   -> xQueueGenericCreate
        48   -> xQueueReceive
        48   -> xTimerCreate
      72   sbcSemMsgProcess
        72   -> Print_Slave_FW_Version
        72   -> WriteOnEeprom
        72   -> __aeabi_memcpy
        72   -> activeImmediateReset
        72   -> addNode
        72   -> checkAssignNewAddress
        72   -> checkToSendReqAddress
        72   -> evs_error_get
        72   -> extractSendFirstInList
        72   -> forceSBCreadScu
        72   -> free
        72   -> fromRs485ToSem
        72   -> getInfoSocket
        72   -> getLogicalMdbAddrSem
        72   -> getPhysicalMdbAddr
        72   -> getRoMdbRegs
        72   -> getRs485SemQueueHandle
        72   -> getScuAddressTypeMode
        72   -> getScuOpMode
        72   -> getStationId
        72   -> getStatusDwnl
        72   -> getTmMdbRegs
        72   -> isSemMasterFz
        72   -> is_socketPresence_Programmed
        72   -> mngReqAddress
        72   -> osDelay
        72   -> osThreadNew
        72   -> reInitSbcUart
        72   -> resetChangeRegisterBit
        72   -> resetPacketStatusNum
        72   -> restartSbcSemTimer
        72   -> restoreFactoryDefault
        72   -> saveAllSlaveParameters
        72   -> semSlaveSendActEnrg
        72   -> semUpdateConfig
        72   -> sendAnswToSem
        72   -> sendEeepromInfoForCloning
        72   -> sendMonMngMsg
        72   -> setChangeRegisterBit
        72   -> setCurrentDateTimeInSem
        72   -> setDevAlias
        72   -> setInfoEepromSlaveDone
        72   -> setParamFromAssignedAddr
        72   -> setScuAddressTypeMode
        72   -> tPrintf
        72   -> toggleHeartLed
        72   -> txRS485Available
        72   -> updateModbusErrorRegisters
        72   -> xQueueGenericSend
        72   -> xTaskGetTickCount
        72   -> xTimerGenericCommand
      64   sbcSemTimCallBack
        64   -> HAL_RTCEx_BKUPRead
        64   -> HAL_RTCEx_BKUPWrite
        64   -> WriteOnEeprom
        64   -> activeImmediateReset
        64   -> eeprom_array_set
        64   -> getAndsendAllSlaveParameters
        64   -> getHandleRtc
        64   -> getLogicalMdbAddrSem
        64   -> getPacketStatusNum
        64   -> getPhysicalMdbAddr
        64   -> getRandomDelay
        64   -> getRemotePmFlag
        64   -> getRs485SemQueueHandle
        64   -> getSbcSemQueueHandle
        64   -> getScuOpMode
        64   -> isSemMasterFz
        64   -> osDelay
        64   -> pvTimerGetTimerID
        64   -> restartSbcSemTimer
        64   -> sendEventToSemMng
        64   -> send_to_eeprom
        64   -> setCurrentDateTimeInSem
        64   -> setPmRemoteSemFlag
        64   -> tPrintf
        64   -> xQueueGenericSend
        64   -> xTaskGetTickCount
        64   -> xTimerGenericCommand
      24   semUpdateConfig
        24   -> CONN_ID_Set_New
        24   -> EEPROM_Save_Config
        24   -> HW_CHECKS_ACTUATORS_EEprom_Save
        24   -> HW_PRESENCE_FLAG_EEprom_Save
        24   -> LANG_Available_Mdb_to_EEprom_Translate
        24   -> LANG_Modbus_to_EEprom_Translate
        24   -> PM_Mdb_to_EEprom_Translate
        24   -> activeImmediateReset
        24   -> evs_reserved_set
        24   -> getAvailableLanguages
        24   -> getChargeByEnergy
        24   -> getChargeByTime
        24   -> getConnectorId
        24   -> getDefaultLanguage
        24   -> getMaxSimplifiedCurrent
        24   -> getMaxTypicalCurrent
        24   -> getOperationMode
        24   -> getPmMenuVisibility
        24   -> isSemMasterFz
        24   -> removeSocketFromList
        24   -> restartSbcSemTimer
        24   -> saveTimeoutRange1
        24   -> send_to_evs
        24   -> setWaitTimeValue
        24   -> xQueueGenericSend
      32   sendEeepromInfoForCloning
        32   -> FlashRead
        32   -> malloc
        32   -> osDelay
        32   -> setMallocTx485
        32   -> tPrintf
        32   -> txOnRs485Bus
      24   setAddressType
        24   -> ReadFromEeprom
        24   -> WriteOnEeprom
        24   -> setScuAddressTypeMode
        24   -> tPrintf
     104   setChangeRegisterBit
       104   -> getHmsStr
       104   -> getNumSocketLcd
       104   -> getRoMdbRegs
       104   -> getRwMdbRegs
       104   -> getScuOpMode
       104   -> isSemMasterFz
       104   -> strcat
       104   -> strcpy
       104   -> tPrintf
      32   setCurrentDateTimeInSem
        32   -> eeprom_param_get
        32   -> getCurrentUnixTime
        32   -> getLogicalMdbAddrSem
        32   -> getRwMdbRegs
        32   -> localtime
        32   -> xTimerGenericCommand
      24   setDevAlias
        24   -> eeprom_param_get
        24   -> fromRs485ToSem
        24   -> getLogicalMdbAddr
        24   -> getPhysicalMdbAddr
        24   -> getRwMdbRegs
        24   -> isSemMode
       0   setInfoEepromSlaveDone
       0   setInfoEepromSlaveStatus
       8   setNewMaxTempPowerSem
         8   -> getMaxTempPowerAc
         8   -> pmng_sem_power_set
       0   setPollingFlag
       0   setPtrToConfParam
      16   setSocketDiscovered
        16   -> WriteOnEeprom
        16   -> tPrintf
      16   setUIDinfoROmap
        16   -> getLogicalMdbAddrSem
        16   -> getRoMdbRegs
        16   -> rfid_uid_get
      24   startSbcSemProcess
        24   -> getPacketStatusNum
        24   -> getPhysicalMdbAddr
        24   -> getSbcSemQueueHandle
        24   -> xQueueGenericSend
       0   txRS485Available
      32   upgradeFwSlaveBroadcast
        32   -> getPacketStatusNum
        32   -> getRwMdbRegs
        32   -> getSbcSemQueueHandle
        32   -> xQueueGenericSend
      32   upgradeModbusHwConfig
        32   -> fromRs485ToSem
        32   -> getPacketStatusNum
        32   -> getPhysicalMdbAddr
        32   -> getSbcSemQueueHandle
        32   -> initModbusRegisters
        32   -> isSemMode
        32   -> xQueueGenericSend
      32   upgradeModbusReg
        32   -> getLogicalMdbAddrSem
        32   -> getPacketStatusNum
        32   -> getSbcSemQueueHandle
        32   -> isSemMode
        32   -> xQueueGenericSend
      40   writeMasterModbusRegister
        40   -> __aeabi_memcpy
        40   -> crcEvaluation
        40   -> getScuSinapsiTxUartSemaphoreHandle
        40   -> malloc
        40   -> setMallocTx485
        40   -> swapW
        40   -> txOnRs485Bus
        40   -> xQueueSemaphoreTake


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable13
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable22
       4  ??DataTable24
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_2
       4  ??DataTable34
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable4
       4  ??DataTable42
       4  ??DataTable45
       4  ??DataTable45_1
       4  ??DataTable45_2
       4  ??DataTable46
       4  ??DataTable46_1
       4  ??DataTable46_2
       4  ??DataTable47
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable53
       4  ??DataTable53_1
       4  ??DataTable53_10
       4  ??DataTable53_11
       4  ??DataTable53_12
       4  ??DataTable53_13
       4  ??DataTable53_14
       4  ??DataTable53_15
       4  ??DataTable53_16
       4  ??DataTable53_17
       4  ??DataTable53_2
       4  ??DataTable53_3
       4  ??DataTable53_4
       4  ??DataTable53_5
       4  ??DataTable53_6
       4  ??DataTable53_7
       4  ??DataTable53_8
       4  ??DataTable53_9
       4  ??DataTable6
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
      12  ?_0
       8  ?_1
      12  ?_10
      12  ?_11
      12  ?_12
      12  ?_13
      20  ?_14
      16  ?_15
      16  ?_16
      12  ?_17
      12  ?_18
      24  ?_19
      12  ?_2
      56  ?_20
      40  ?_21
      44  ?_22
      32  ?_23
      32  ?_24
      28  ?_25
      52  ?_26
      24  ?_27
      24  ?_28
      40  ?_29
      16  ?_3
      20  ?_30
      24  ?_31
      36  ?_32
      24  ?_33
      32  ?_34
      24  ?_35
      32  ?_36
      32  ?_37
      24  ?_38
      28  ?_39
      12  ?_4
      40  ?_40
      48  ?_41
      52  ?_42
      52  ?_43
      16  ?_5
      16  ?_6
      12  ?_7
      12  ?_8
      16  ?_9
     150  Actuators_Mdb_to_Eeprom_Translate
       8  AddrChargStatus
      16  AddrConnType
      16  AddrEm
       8  AddrErr1
       8  AddrErr2
      12  AddrEventFlag
       8  AddrMeasure
      12  AddrSessId
      20  AddrUidStr
      36  CONN_ID_Set_New
      84  Default_Socket_Presence
     170  HW_CHECKS_ACTUATORS_EEprom_Save
     120  HW_PRESENCE_FLAG_EEprom_Save
      50  Print_Slave_Assigned
      62  Print_Slave_FW_Version
      60  addNode
      28  allTaskAreOperative
     242  checkAssignNewAddress
     214  checkToSendReqAddress
      14  createNode
      20  currFrameSbcSem
     140  extractSendFirstInList
     208  forceSBCreadScu
      20  frameSbcSem
      20  framers485Sem
      62  fromRs485ToSem
     242  getAndsendAllSlaveParameters
       6  getDefSocketInfoPtr
       8  getDiscoveryStatus
      62  getFirstFreeLogicId
      48  getIdNumberForLcd
       6  getInfoEepromSlaveStatus
     628  getInfoSocket
      12  getModbusAddrFromDevId
      20  getNumSocketLcd
      14  getPacketStatusNum
       6  getPtrToConfParam
      28  getRemotePmFlag
       8  getRs485SemQueueHandle
       8  getSbcSemQueueHandle
      18  getSktNumInFakeCode
       8  getSocketDiscovered
      44  getTagIdFromPrdSn
       4  headMsg
      18  isModbusManagerActive
      18  isSlaveWaitToBeOperative
      18  is_socketPresence_Programmed
       1  lastCommandSent
     550  mngReqAddress
      60  nameState
       1  numberOnLcd
       4  pScuRoMapReg
       4  pScuTmMapReg
       4  packetStatsCounter
      52  pollingSlaveMng
     732  pollingSlaveProcess
       4  pollingSlaveQueue
     110  pollingSlaveTask
       4  pollingSlaveTaskHandle
      36  pollingSlaveTask_attributes
      32  prevState
       4  ptrAreaConfPar
     108  readEmValuesFromMaster
     116  readMasterModbusRegister
      20  readSocketPresence
       4  remoteMng
       4  remoteMngQueue
      96  remoteMngTask
       4  remoteMngTaskHandle
      36  remoteMngTask_attributes
     332  remoteSuspRelProcess
     102  removeSocketFromList
     662  resetChangeRegisterBit
       2  resetCommandRemote
      36  resetInOperative
      10  resetPacketStatusNum
      66  restartSbcSemTimer
     110  restoreFactoryDefaultForAll
      62  restoreOperativeState
     106  rs485SemGestTask
      24  rs485SemInfoMng
     830  rs485SemMsgProcess
       4  rs485SemQueue
       2  saveAllSlaveParameters
     436  saveSlaveParameters
     262  sbcSemGestTask
      44  sbcSemInfoMng
      64  sbcSemMaskBit
   4'322  sbcSemMsgProcess
       4  sbcSemQueue
   1'224  sbcSemTimCallBack
     832  semUpdateConfig
     198  sendEeepromInfoForCloning
     106  setAddressType
     850  setChangeRegisterBit
     172  setCurrentDateTimeInSem
     126  setDevAlias
       8  setInfoEepromSlaveDone
      20  setInfoEepromSlaveStatus
      20  setNewMaxTempPowerSem
      12  setPollingFlag
       6  setPtrToConfParam
      42  setSocketDiscovered
      78  setUIDinfoROmap
      84  socketPresence
      72  startSbcSemProcess
       8  temp
       8  temp
      18  txRS485Available
     102  upgradeFwSlaveBroadcast
     108  upgradeModbusHwConfig
     108  upgradeModbusReg
     162  writeMasterModbusRegister
      20  xSbcSemTimers

 
    382 bytes in section .bss
     60 bytes in section .data
  1'448 bytes in section .rodata
 16'456 bytes in section .text
 
 16'456 bytes of CODE  memory
  1'448 bytes of CONST memory
    442 bytes of DATA  memory

Errors: none
Warnings: none
